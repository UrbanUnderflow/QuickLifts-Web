"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/recharts";
exports.ids = ["vendor-chunks/recharts"];
exports.modules = {

/***/ "./node_modules/recharts/lib/cartesian/Area.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/Area.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Area = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _max = _interopRequireDefault(__webpack_require__(/*! lodash/max */ \"lodash/max\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isNaN = _interopRequireDefault(__webpack_require__(/*! lodash/isNaN */ \"lodash/isNaN\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _Curve = __webpack_require__(/*! ../shape/Curve */ \"./node_modules/recharts/lib/shape/Curve.js\");\nvar _Dot = __webpack_require__(/*! ../shape/Dot */ \"./node_modules/recharts/lib/shape/Dot.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"./node_modules/recharts/lib/component/LabelList.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"./node_modules/recharts/lib/util/Global.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"layout\",\n    \"type\",\n    \"stroke\",\n    \"connectNulls\",\n    \"isRange\",\n    \"ref\"\n], _excluded2 = [\n    \"key\"\n];\nvar _Area;\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Area\n */ \nvar Area = exports.Area = /*#__PURE__*/ function(_PureComponent) {\n    function Area() {\n        var _this;\n        _classCallCheck(this, Area);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Area, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            isAnimationFinished: true\n        });\n        _defineProperty(_this, \"id\", (0, _DataUtils.uniqueId)(\"recharts-area-\"));\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            var onAnimationEnd = _this.props.onAnimationEnd;\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationEnd)) {\n                onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            var onAnimationStart = _this.props.onAnimationStart;\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationStart)) {\n                onAnimationStart();\n            }\n        });\n        return _this;\n    }\n    _inherits(Area, _PureComponent);\n    return _createClass(Area, [\n        {\n            key: \"renderDots\",\n            value: function renderDots(needClip, clipDot, clipPathId) {\n                var isAnimationActive = this.props.isAnimationActive;\n                var isAnimationFinished = this.state.isAnimationFinished;\n                if (isAnimationActive && !isAnimationFinished) {\n                    return null;\n                }\n                var _this$props = this.props, dot = _this$props.dot, points = _this$props.points, dataKey = _this$props.dataKey;\n                var areaProps = (0, _ReactUtils.filterProps)(this.props, false);\n                var customDotProps = (0, _ReactUtils.filterProps)(dot, true);\n                var dots = points.map(function(entry, i) {\n                    var dotProps = _objectSpread(_objectSpread(_objectSpread({\n                        key: \"dot-\".concat(i),\n                        r: 3\n                    }, areaProps), customDotProps), {}, {\n                        index: i,\n                        cx: entry.x,\n                        cy: entry.y,\n                        dataKey: dataKey,\n                        value: entry.value,\n                        payload: entry.payload,\n                        points: points\n                    });\n                    return Area.renderDotItem(dot, dotProps);\n                });\n                var dotsProps = {\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipDot ? \"\" : \"dots-\").concat(clipPathId, \")\") : null\n                };\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                    className: \"recharts-area-dots\"\n                }, dotsProps), dots);\n            }\n        },\n        {\n            key: \"renderHorizontalRect\",\n            value: function renderHorizontalRect(alpha) {\n                var _this$props2 = this.props, baseLine = _this$props2.baseLine, points = _this$props2.points, strokeWidth = _this$props2.strokeWidth;\n                var startX = points[0].x;\n                var endX = points[points.length - 1].x;\n                var width = alpha * Math.abs(startX - endX);\n                var maxY = (0, _max[\"default\"])(points.map(function(entry) {\n                    return entry.y || 0;\n                }));\n                if ((0, _DataUtils.isNumber)(baseLine) && typeof baseLine === \"number\") {\n                    maxY = Math.max(baseLine, maxY);\n                } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {\n                    maxY = Math.max((0, _max[\"default\"])(baseLine.map(function(entry) {\n                        return entry.y || 0;\n                    })), maxY);\n                }\n                if ((0, _DataUtils.isNumber)(maxY)) {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                        x: startX < endX ? startX : startX - width,\n                        y: 0,\n                        width: width,\n                        height: Math.floor(maxY + (strokeWidth ? parseInt(\"\".concat(strokeWidth), 10) : 1))\n                    });\n                }\n                return null;\n            }\n        },\n        {\n            key: \"renderVerticalRect\",\n            value: function renderVerticalRect(alpha) {\n                var _this$props3 = this.props, baseLine = _this$props3.baseLine, points = _this$props3.points, strokeWidth = _this$props3.strokeWidth;\n                var startY = points[0].y;\n                var endY = points[points.length - 1].y;\n                var height = alpha * Math.abs(startY - endY);\n                var maxX = (0, _max[\"default\"])(points.map(function(entry) {\n                    return entry.x || 0;\n                }));\n                if ((0, _DataUtils.isNumber)(baseLine) && typeof baseLine === \"number\") {\n                    maxX = Math.max(baseLine, maxX);\n                } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {\n                    maxX = Math.max((0, _max[\"default\"])(baseLine.map(function(entry) {\n                        return entry.x || 0;\n                    })), maxX);\n                }\n                if ((0, _DataUtils.isNumber)(maxX)) {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                        x: 0,\n                        y: startY < endY ? startY : startY - height,\n                        width: maxX + (strokeWidth ? parseInt(\"\".concat(strokeWidth), 10) : 1),\n                        height: Math.floor(height)\n                    });\n                }\n                return null;\n            }\n        },\n        {\n            key: \"renderClipRect\",\n            value: function renderClipRect(alpha) {\n                var layout = this.props.layout;\n                if (layout === \"vertical\") {\n                    return this.renderVerticalRect(alpha);\n                }\n                return this.renderHorizontalRect(alpha);\n            }\n        },\n        {\n            key: \"renderAreaStatically\",\n            value: function renderAreaStatically(points, baseLine, needClip, clipPathId) {\n                var _this$props4 = this.props, layout = _this$props4.layout, type = _this$props4.type, stroke = _this$props4.stroke, connectNulls = _this$props4.connectNulls, isRange = _this$props4.isRange, ref = _this$props4.ref, others = _objectWithoutProperties(_this$props4, _excluded);\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : null\n                }, /*#__PURE__*/ _react[\"default\"].createElement(_Curve.Curve, _extends({}, (0, _ReactUtils.filterProps)(others, true), {\n                    points: points,\n                    connectNulls: connectNulls,\n                    type: type,\n                    baseLine: baseLine,\n                    layout: layout,\n                    stroke: \"none\",\n                    className: \"recharts-area-area\"\n                })), stroke !== \"none\" && /*#__PURE__*/ _react[\"default\"].createElement(_Curve.Curve, _extends({}, (0, _ReactUtils.filterProps)(this.props, false), {\n                    className: \"recharts-area-curve\",\n                    layout: layout,\n                    type: type,\n                    connectNulls: connectNulls,\n                    fill: \"none\",\n                    points: points\n                })), stroke !== \"none\" && isRange && /*#__PURE__*/ _react[\"default\"].createElement(_Curve.Curve, _extends({}, (0, _ReactUtils.filterProps)(this.props, false), {\n                    className: \"recharts-area-curve\",\n                    layout: layout,\n                    type: type,\n                    connectNulls: connectNulls,\n                    fill: \"none\",\n                    points: baseLine\n                })));\n            }\n        },\n        {\n            key: \"renderAreaWithAnimation\",\n            value: function renderAreaWithAnimation(needClip, clipPathId) {\n                var _this2 = this;\n                var _this$props5 = this.props, points = _this$props5.points, baseLine = _this$props5.baseLine, isAnimationActive = _this$props5.isAnimationActive, animationBegin = _this$props5.animationBegin, animationDuration = _this$props5.animationDuration, animationEasing = _this$props5.animationEasing, animationId = _this$props5.animationId;\n                var _this$state = this.state, prevPoints = _this$state.prevPoints, prevBaseLine = _this$state.prevBaseLine;\n                // const clipPathId = isNil(id) ? this.id : id;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"area-\".concat(animationId),\n                    onAnimationEnd: this.handleAnimationEnd,\n                    onAnimationStart: this.handleAnimationStart\n                }, function(_ref) {\n                    var t = _ref.t;\n                    if (prevPoints) {\n                        var prevPointsDiffFactor = prevPoints.length / points.length;\n                        // update animtaion\n                        var stepPoints = points.map(function(entry, index) {\n                            var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n                            if (prevPoints[prevPointIndex]) {\n                                var prev = prevPoints[prevPointIndex];\n                                var interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry.x);\n                                var interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry.y);\n                                return _objectSpread(_objectSpread({}, entry), {}, {\n                                    x: interpolatorX(t),\n                                    y: interpolatorY(t)\n                                });\n                            }\n                            return entry;\n                        });\n                        var stepBaseLine;\n                        if ((0, _DataUtils.isNumber)(baseLine) && typeof baseLine === \"number\") {\n                            var interpolator = (0, _DataUtils.interpolateNumber)(prevBaseLine, baseLine);\n                            stepBaseLine = interpolator(t);\n                        } else if ((0, _isNil[\"default\"])(baseLine) || (0, _isNaN[\"default\"])(baseLine)) {\n                            var _interpolator = (0, _DataUtils.interpolateNumber)(prevBaseLine, 0);\n                            stepBaseLine = _interpolator(t);\n                        } else {\n                            stepBaseLine = baseLine.map(function(entry, index) {\n                                var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n                                if (prevBaseLine[prevPointIndex]) {\n                                    var prev = prevBaseLine[prevPointIndex];\n                                    var interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry.x);\n                                    var interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry.y);\n                                    return _objectSpread(_objectSpread({}, entry), {}, {\n                                        x: interpolatorX(t),\n                                        y: interpolatorY(t)\n                                    });\n                                }\n                                return entry;\n                            });\n                        }\n                        return _this2.renderAreaStatically(stepPoints, stepBaseLine, needClip, clipPathId);\n                    }\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, null, /*#__PURE__*/ _react[\"default\"].createElement(\"defs\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                        id: \"animationClipPath-\".concat(clipPathId)\n                    }, _this2.renderClipRect(t))), /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                        clipPath: \"url(#animationClipPath-\".concat(clipPathId, \")\")\n                    }, _this2.renderAreaStatically(points, baseLine, needClip, clipPathId)));\n                });\n            }\n        },\n        {\n            key: \"renderArea\",\n            value: function renderArea(needClip, clipPathId) {\n                var _this$props6 = this.props, points = _this$props6.points, baseLine = _this$props6.baseLine, isAnimationActive = _this$props6.isAnimationActive;\n                var _this$state2 = this.state, prevPoints = _this$state2.prevPoints, prevBaseLine = _this$state2.prevBaseLine, totalLength = _this$state2.totalLength;\n                if (isAnimationActive && points && points.length && (!prevPoints && totalLength > 0 || !(0, _isEqual[\"default\"])(prevPoints, points) || !(0, _isEqual[\"default\"])(prevBaseLine, baseLine))) {\n                    return this.renderAreaWithAnimation(needClip, clipPathId);\n                }\n                return this.renderAreaStatically(points, baseLine, needClip, clipPathId);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _filterProps;\n                var _this$props7 = this.props, hide = _this$props7.hide, dot = _this$props7.dot, points = _this$props7.points, className = _this$props7.className, top = _this$props7.top, left = _this$props7.left, xAxis = _this$props7.xAxis, yAxis = _this$props7.yAxis, width = _this$props7.width, height = _this$props7.height, isAnimationActive = _this$props7.isAnimationActive, id = _this$props7.id;\n                if (hide || !points || !points.length) {\n                    return null;\n                }\n                var isAnimationFinished = this.state.isAnimationFinished;\n                var hasSinglePoint = points.length === 1;\n                var layerClass = (0, _clsx[\"default\"])(\"recharts-area\", className);\n                var needClipX = xAxis && xAxis.allowDataOverflow;\n                var needClipY = yAxis && yAxis.allowDataOverflow;\n                var needClip = needClipX || needClipY;\n                var clipPathId = (0, _isNil[\"default\"])(id) ? this.id : id;\n                var _ref2 = (_filterProps = (0, _ReactUtils.filterProps)(dot, false)) !== null && _filterProps !== void 0 ? _filterProps : {\n                    r: 3,\n                    strokeWidth: 2\n                }, _ref2$r = _ref2.r, r = _ref2$r === void 0 ? 3 : _ref2$r, _ref2$strokeWidth = _ref2.strokeWidth, strokeWidth = _ref2$strokeWidth === void 0 ? 2 : _ref2$strokeWidth;\n                var _ref3 = (0, _ReactUtils.hasClipDot)(dot) ? dot : {}, _ref3$clipDot = _ref3.clipDot, clipDot = _ref3$clipDot === void 0 ? true : _ref3$clipDot;\n                var dotSize = r * 2 + strokeWidth;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass\n                }, needClipX || needClipY ? /*#__PURE__*/ _react[\"default\"].createElement(\"defs\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                    id: \"clipPath-\".concat(clipPathId)\n                }, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    x: needClipX ? left : left - width / 2,\n                    y: needClipY ? top : top - height / 2,\n                    width: needClipX ? width : width * 2,\n                    height: needClipY ? height : height * 2\n                })), !clipDot && /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                    id: \"clipPath-dots-\".concat(clipPathId)\n                }, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    x: left - dotSize / 2,\n                    y: top - dotSize / 2,\n                    width: width + dotSize,\n                    height: height + dotSize\n                }))) : null, !hasSinglePoint ? this.renderArea(needClip, clipPathId) : null, (dot || hasSinglePoint) && this.renderDots(needClip, clipDot, clipPathId), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, points));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curPoints: nextProps.points,\n                        curBaseLine: nextProps.baseLine,\n                        prevPoints: prevState.curPoints,\n                        prevBaseLine: prevState.curBaseLine\n                    };\n                }\n                if (nextProps.points !== prevState.curPoints || nextProps.baseLine !== prevState.curBaseLine) {\n                    return {\n                        curPoints: nextProps.points,\n                        curBaseLine: nextProps.baseLine\n                    };\n                }\n                return null;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_Area = Area;\n_defineProperty(Area, \"displayName\", \"Area\");\n_defineProperty(Area, \"defaultProps\", {\n    stroke: \"#3182bd\",\n    fill: \"#3182bd\",\n    fillOpacity: 0.6,\n    xAxisId: 0,\n    yAxisId: 0,\n    legendType: \"line\",\n    connectNulls: false,\n    // points of area\n    points: [],\n    dot: false,\n    activeDot: true,\n    hide: false,\n    isAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 0,\n    animationDuration: 1500,\n    animationEasing: \"ease\"\n});\n_defineProperty(Area, \"getBaseValue\", function(props, item, xAxis, yAxis) {\n    var layout = props.layout, chartBaseValue = props.baseValue;\n    var itemBaseValue = item.props.baseValue;\n    // The baseValue can be defined both on the AreaChart as well as on the Area.\n    // The value for the item takes precedence.\n    var baseValue = itemBaseValue !== null && itemBaseValue !== void 0 ? itemBaseValue : chartBaseValue;\n    if ((0, _DataUtils.isNumber)(baseValue) && typeof baseValue === \"number\") {\n        return baseValue;\n    }\n    var numericAxis = layout === \"horizontal\" ? yAxis : xAxis;\n    var domain = numericAxis.scale.domain();\n    if (numericAxis.type === \"number\") {\n        var domainMax = Math.max(domain[0], domain[1]);\n        var domainMin = Math.min(domain[0], domain[1]);\n        if (baseValue === \"dataMin\") {\n            return domainMin;\n        }\n        if (baseValue === \"dataMax\") {\n            return domainMax;\n        }\n        return domainMax < 0 ? domainMax : Math.max(Math.min(domain[0], domain[1]), 0);\n    }\n    if (baseValue === \"dataMin\") {\n        return domain[0];\n    }\n    if (baseValue === \"dataMax\") {\n        return domain[1];\n    }\n    return domain[0];\n});\n_defineProperty(Area, \"getComposedData\", function(_ref4) {\n    var props = _ref4.props, item = _ref4.item, xAxis = _ref4.xAxis, yAxis = _ref4.yAxis, xAxisTicks = _ref4.xAxisTicks, yAxisTicks = _ref4.yAxisTicks, bandSize = _ref4.bandSize, dataKey = _ref4.dataKey, stackedData = _ref4.stackedData, dataStartIndex = _ref4.dataStartIndex, displayedData = _ref4.displayedData, offset = _ref4.offset;\n    var layout = props.layout;\n    var hasStack = stackedData && stackedData.length;\n    var baseValue = _Area.getBaseValue(props, item, xAxis, yAxis);\n    var isHorizontalLayout = layout === \"horizontal\";\n    var isRange = false;\n    var points = displayedData.map(function(entry, index) {\n        var value;\n        if (hasStack) {\n            value = stackedData[dataStartIndex + index];\n        } else {\n            value = (0, _ChartUtils.getValueByDataKey)(entry, dataKey);\n            if (!Array.isArray(value)) {\n                value = [\n                    baseValue,\n                    value\n                ];\n            } else {\n                isRange = true;\n            }\n        }\n        var isBreakPoint = value[1] == null || hasStack && (0, _ChartUtils.getValueByDataKey)(entry, dataKey) == null;\n        if (isHorizontalLayout) {\n            return {\n                x: (0, _ChartUtils.getCateCoordinateOfLine)({\n                    axis: xAxis,\n                    ticks: xAxisTicks,\n                    bandSize: bandSize,\n                    entry: entry,\n                    index: index\n                }),\n                y: isBreakPoint ? null : yAxis.scale(value[1]),\n                value: value,\n                payload: entry\n            };\n        }\n        return {\n            x: isBreakPoint ? null : xAxis.scale(value[1]),\n            y: (0, _ChartUtils.getCateCoordinateOfLine)({\n                axis: yAxis,\n                ticks: yAxisTicks,\n                bandSize: bandSize,\n                entry: entry,\n                index: index\n            }),\n            value: value,\n            payload: entry\n        };\n    });\n    var baseLine;\n    if (hasStack || isRange) {\n        baseLine = points.map(function(entry) {\n            var x = Array.isArray(entry.value) ? entry.value[0] : null;\n            if (isHorizontalLayout) {\n                return {\n                    x: entry.x,\n                    y: x != null && entry.y != null ? yAxis.scale(x) : null\n                };\n            }\n            return {\n                x: x != null ? xAxis.scale(x) : null,\n                y: entry.y\n            };\n        });\n    } else {\n        baseLine = isHorizontalLayout ? yAxis.scale(baseValue) : xAxis.scale(baseValue);\n    }\n    return _objectSpread({\n        points: points,\n        baseLine: baseLine,\n        layout: layout,\n        isRange: isRange\n    }, offset);\n});\n_defineProperty(Area, \"renderDotItem\", function(option, props) {\n    var dotItem;\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n        dotItem = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n    } else if ((0, _isFunction[\"default\"])(option)) {\n        dotItem = option(props);\n    } else {\n        var className = (0, _clsx[\"default\"])(\"recharts-area-dot\", typeof option !== \"boolean\" ? option.className : \"\");\n        var key = props.key, rest = _objectWithoutProperties(props, _excluded2);\n        dotItem = /*#__PURE__*/ _react[\"default\"].createElement(_Dot.Dot, _extends({}, rest, {\n            key: key,\n            className: className\n        }));\n    }\n    return dotItem;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9BcmVhLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxZQUFZLEdBQUcsS0FBSztBQUNwQixJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLFFBQVFDLHVCQUF1QkYsbUJBQU9BLENBQUMsa0JBQU07QUFDakQsSUFBSUcsZUFBZUQsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUNoRSxJQUFJSSxjQUFjRix1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJSyxPQUFPSCx1QkFBdUJGLG1CQUFPQSxDQUFDLDhCQUFZO0FBQ3RELElBQUlNLFNBQVNKLHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDMUQsSUFBSU8sU0FBU0wsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJUSxXQUFXTix1QkFBdUJGLG1CQUFPQSxDQUFDLHNDQUFnQjtBQUM5RCxJQUFJUyxTQUFTVCxtQkFBT0EsQ0FBQyxrRUFBZ0I7QUFDckMsSUFBSVUsT0FBT1YsbUJBQU9BLENBQUMsOERBQWM7QUFDakMsSUFBSVcsU0FBU1gsbUJBQU9BLENBQUMsMEVBQW9CO0FBQ3pDLElBQUlZLGFBQWFaLG1CQUFPQSxDQUFDLGtGQUF3QjtBQUNqRCxJQUFJYSxVQUFVYixtQkFBT0EsQ0FBQyxrRUFBZ0I7QUFDdEMsSUFBSWMsYUFBYWQsbUJBQU9BLENBQUMsd0VBQW1CO0FBQzVDLElBQUllLGNBQWNmLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJZ0IsY0FBY2hCLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJaUIsWUFBWTtJQUFDO0lBQVU7SUFBUTtJQUFVO0lBQWdCO0lBQVc7Q0FBTSxFQUM1RUMsYUFBYTtJQUFDO0NBQU07QUFDdEIsSUFBSUM7QUFDSixTQUFTakIsdUJB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V0E7UUFDYjtJQUNGO0lBQ0EsT0FBT29JO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9BcmVhLmpzPzJmY2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkFyZWEgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xudmFyIF9yZWFjdFNtb290aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LXNtb290aFwiKSk7XG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XG52YXIgX21heCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9tYXhcIikpO1xudmFyIF9pc05pbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc05pbFwiKSk7XG52YXIgX2lzTmFOID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzTmFOXCIpKTtcbnZhciBfaXNFcXVhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0VxdWFsXCIpKTtcbnZhciBfQ3VydmUgPSByZXF1aXJlKFwiLi4vc2hhcGUvQ3VydmVcIik7XG52YXIgX0RvdCA9IHJlcXVpcmUoXCIuLi9zaGFwZS9Eb3RcIik7XG52YXIgX0xheWVyID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9MYXllclwiKTtcbnZhciBfTGFiZWxMaXN0ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbExpc3RcIik7XG52YXIgX0dsb2JhbCA9IHJlcXVpcmUoXCIuLi91dGlsL0dsb2JhbFwiKTtcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xudmFyIF9DaGFydFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQ2hhcnRVdGlsc1wiKTtcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XG52YXIgX2V4Y2x1ZGVkID0gW1wibGF5b3V0XCIsIFwidHlwZVwiLCBcInN0cm9rZVwiLCBcImNvbm5lY3ROdWxsc1wiLCBcImlzUmFuZ2VcIiwgXCJyZWZcIl0sXG4gIF9leGNsdWRlZDIgPSBbXCJrZXlcIl07XG52YXIgX0FyZWE7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxuICogQGZpbGVPdmVydmlldyBBcmVhXG4gKi9cbnZhciBBcmVhID0gZXhwb3J0cy5BcmVhID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBmdW5jdGlvbiBBcmVhKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXJlYSk7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgQXJlYSwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwic3RhdGVcIiwge1xuICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogdHJ1ZVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpZFwiLCAoMCwgX0RhdGFVdGlscy51bmlxdWVJZCkoJ3JlY2hhcnRzLWFyZWEtJykpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25FbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9uQW5pbWF0aW9uRW5kID0gX3RoaXMucHJvcHMub25BbmltYXRpb25FbmQ7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9uQW5pbWF0aW9uRW5kKSkge1xuICAgICAgICBvbkFuaW1hdGlvbkVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25TdGFydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb25BbmltYXRpb25TdGFydCA9IF90aGlzLnByb3BzLm9uQW5pbWF0aW9uU3RhcnQ7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvbkFuaW1hdGlvblN0YXJ0KSkge1xuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhBcmVhLCBfUHVyZUNvbXBvbmVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQXJlYSwgW3tcbiAgICBrZXk6IFwicmVuZGVyRG90c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJEb3RzKG5lZWRDbGlwLCBjbGlwRG90LCBjbGlwUGF0aElkKSB7XG4gICAgICB2YXIgaXNBbmltYXRpb25BY3RpdmUgPSB0aGlzLnByb3BzLmlzQW5pbWF0aW9uQWN0aXZlO1xuICAgICAgdmFyIGlzQW5pbWF0aW9uRmluaXNoZWQgPSB0aGlzLnN0YXRlLmlzQW5pbWF0aW9uRmluaXNoZWQ7XG4gICAgICBpZiAoaXNBbmltYXRpb25BY3RpdmUgJiYgIWlzQW5pbWF0aW9uRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBkb3QgPSBfdGhpcyRwcm9wcy5kb3QsXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzLnBvaW50cyxcbiAgICAgICAgZGF0YUtleSA9IF90aGlzJHByb3BzLmRhdGFLZXk7XG4gICAgICB2YXIgYXJlYVByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aGlzLnByb3BzLCBmYWxzZSk7XG4gICAgICB2YXIgY3VzdG9tRG90UHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKGRvdCwgdHJ1ZSk7XG4gICAgICB2YXIgZG90cyA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gICAgICAgIHZhciBkb3RQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICBrZXk6IFwiZG90LVwiLmNvbmNhdChpKSxcbiAgICAgICAgICByOiAzXG4gICAgICAgIH0sIGFyZWFQcm9wcyksIGN1c3RvbURvdFByb3BzKSwge30sIHtcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBjeDogZW50cnkueCxcbiAgICAgICAgICBjeTogZW50cnkueSxcbiAgICAgICAgICBkYXRhS2V5OiBkYXRhS2V5LFxuICAgICAgICAgIHZhbHVlOiBlbnRyeS52YWx1ZSxcbiAgICAgICAgICBwYXlsb2FkOiBlbnRyeS5wYXlsb2FkLFxuICAgICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQXJlYS5yZW5kZXJEb3RJdGVtKGRvdCwgZG90UHJvcHMpO1xuICAgICAgfSk7XG4gICAgICB2YXIgZG90c1Byb3BzID0ge1xuICAgICAgICBjbGlwUGF0aDogbmVlZENsaXAgPyBcInVybCgjY2xpcFBhdGgtXCIuY29uY2F0KGNsaXBEb3QgPyAnJyA6ICdkb3RzLScpLmNvbmNhdChjbGlwUGF0aElkLCBcIilcIikgOiBudWxsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1hcmVhLWRvdHNcIlxuICAgICAgfSwgZG90c1Byb3BzKSwgZG90cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckhvcml6b250YWxSZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckhvcml6b250YWxSZWN0KGFscGhhKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYmFzZUxpbmUgPSBfdGhpcyRwcm9wczIuYmFzZUxpbmUsXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzMi5wb2ludHMsXG4gICAgICAgIHN0cm9rZVdpZHRoID0gX3RoaXMkcHJvcHMyLnN0cm9rZVdpZHRoO1xuICAgICAgdmFyIHN0YXJ0WCA9IHBvaW50c1swXS54O1xuICAgICAgdmFyIGVuZFggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLng7XG4gICAgICB2YXIgd2lkdGggPSBhbHBoYSAqIE1hdGguYWJzKHN0YXJ0WCAtIGVuZFgpO1xuICAgICAgdmFyIG1heFkgPSAoMCwgX21heFtcImRlZmF1bHRcIl0pKHBvaW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBlbnRyeS55IHx8IDA7XG4gICAgICB9KSk7XG4gICAgICBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGJhc2VMaW5lKSAmJiB0eXBlb2YgYmFzZUxpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG1heFkgPSBNYXRoLm1heChiYXNlTGluZSwgbWF4WSk7XG4gICAgICB9IGVsc2UgaWYgKGJhc2VMaW5lICYmIEFycmF5LmlzQXJyYXkoYmFzZUxpbmUpICYmIGJhc2VMaW5lLmxlbmd0aCkge1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgoKDAsIF9tYXhbXCJkZWZhdWx0XCJdKShiYXNlTGluZS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgcmV0dXJuIGVudHJ5LnkgfHwgMDtcbiAgICAgICAgfSkpLCBtYXhZKTtcbiAgICAgIH1cbiAgICAgIGlmICgoMCwgX0RhdGFVdGlscy5pc051bWJlcikobWF4WSkpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICAgICAgICB4OiBzdGFydFggPCBlbmRYID8gc3RhcnRYIDogc3RhcnRYIC0gd2lkdGgsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLmZsb29yKG1heFkgKyAoc3Ryb2tlV2lkdGggPyBwYXJzZUludChcIlwiLmNvbmNhdChzdHJva2VXaWR0aCksIDEwKSA6IDEpKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJWZXJ0aWNhbFJlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVmVydGljYWxSZWN0KGFscGhhKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYmFzZUxpbmUgPSBfdGhpcyRwcm9wczMuYmFzZUxpbmUsXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzMy5wb2ludHMsXG4gICAgICAgIHN0cm9rZVdpZHRoID0gX3RoaXMkcHJvcHMzLnN0cm9rZVdpZHRoO1xuICAgICAgdmFyIHN0YXJ0WSA9IHBvaW50c1swXS55O1xuICAgICAgdmFyIGVuZFkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLnk7XG4gICAgICB2YXIgaGVpZ2h0ID0gYWxwaGEgKiBNYXRoLmFicyhzdGFydFkgLSBlbmRZKTtcbiAgICAgIHZhciBtYXhYID0gKDAsIF9tYXhbXCJkZWZhdWx0XCJdKShwb2ludHMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICByZXR1cm4gZW50cnkueCB8fCAwO1xuICAgICAgfSkpO1xuICAgICAgaWYgKCgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShiYXNlTGluZSkgJiYgdHlwZW9mIGJhc2VMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgoYmFzZUxpbmUsIG1heFgpO1xuICAgICAgfSBlbHNlIGlmIChiYXNlTGluZSAmJiBBcnJheS5pc0FycmF5KGJhc2VMaW5lKSAmJiBiYXNlTGluZS5sZW5ndGgpIHtcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KCgwLCBfbWF4W1wiZGVmYXVsdFwiXSkoYmFzZUxpbmUubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHJldHVybiBlbnRyeS54IHx8IDA7XG4gICAgICAgIH0pKSwgbWF4WCk7XG4gICAgICB9XG4gICAgICBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKG1heFgpKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiBzdGFydFkgPCBlbmRZID8gc3RhcnRZIDogc3RhcnRZIC0gaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBtYXhYICsgKHN0cm9rZVdpZHRoID8gcGFyc2VJbnQoXCJcIi5jb25jYXQoc3Ryb2tlV2lkdGgpLCAxMCkgOiAxKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGguZmxvb3IoaGVpZ2h0KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJDbGlwUmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDbGlwUmVjdChhbHBoYSkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMucHJvcHMubGF5b3V0O1xuICAgICAgaWYgKGxheW91dCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJWZXJ0aWNhbFJlY3QoYWxwaGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVySG9yaXpvbnRhbFJlY3QoYWxwaGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJBcmVhU3RhdGljYWxseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJBcmVhU3RhdGljYWxseShwb2ludHMsIGJhc2VMaW5lLCBuZWVkQ2xpcCwgY2xpcFBhdGhJZCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgIGxheW91dCA9IF90aGlzJHByb3BzNC5sYXlvdXQsXG4gICAgICAgIHR5cGUgPSBfdGhpcyRwcm9wczQudHlwZSxcbiAgICAgICAgc3Ryb2tlID0gX3RoaXMkcHJvcHM0LnN0cm9rZSxcbiAgICAgICAgY29ubmVjdE51bGxzID0gX3RoaXMkcHJvcHM0LmNvbm5lY3ROdWxscyxcbiAgICAgICAgaXNSYW5nZSA9IF90aGlzJHByb3BzNC5pc1JhbmdlLFxuICAgICAgICByZWYgPSBfdGhpcyRwcm9wczQucmVmLFxuICAgICAgICBvdGhlcnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHM0LCBfZXhjbHVkZWQpO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XG4gICAgICAgIGNsaXBQYXRoOiBuZWVkQ2xpcCA/IFwidXJsKCNjbGlwUGF0aC1cIi5jb25jYXQoY2xpcFBhdGhJZCwgXCIpXCIpIDogbnVsbFxuICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfQ3VydmUuQ3VydmUsIF9leHRlbmRzKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKG90aGVycywgdHJ1ZSksIHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgIGNvbm5lY3ROdWxsczogY29ubmVjdE51bGxzLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBiYXNlTGluZTogYmFzZUxpbmUsXG4gICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtYXJlYS1hcmVhXCJcbiAgICAgIH0pKSwgc3Ryb2tlICE9PSAnbm9uZScgJiYgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfQ3VydmUuQ3VydmUsIF9leHRlbmRzKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIGZhbHNlKSwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtYXJlYS1jdXJ2ZVwiLFxuICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgY29ubmVjdE51bGxzOiBjb25uZWN0TnVsbHMsXG4gICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgfSkpLCBzdHJva2UgIT09ICdub25lJyAmJiBpc1JhbmdlICYmIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0N1cnZlLkN1cnZlLCBfZXh0ZW5kcyh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aGlzLnByb3BzLCBmYWxzZSksIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWFyZWEtY3VydmVcIixcbiAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGNvbm5lY3ROdWxsczogY29ubmVjdE51bGxzLFxuICAgICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgICAgcG9pbnRzOiBiYXNlTGluZVxuICAgICAgfSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQXJlYVdpdGhBbmltYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQXJlYVdpdGhBbmltYXRpb24obmVlZENsaXAsIGNsaXBQYXRoSWQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzNS5wb2ludHMsXG4gICAgICAgIGJhc2VMaW5lID0gX3RoaXMkcHJvcHM1LmJhc2VMaW5lLFxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzNS5pc0FuaW1hdGlvbkFjdGl2ZSxcbiAgICAgICAgYW5pbWF0aW9uQmVnaW4gPSBfdGhpcyRwcm9wczUuYW5pbWF0aW9uQmVnaW4sXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uID0gX3RoaXMkcHJvcHM1LmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICBhbmltYXRpb25FYXNpbmcgPSBfdGhpcyRwcm9wczUuYW5pbWF0aW9uRWFzaW5nLFxuICAgICAgICBhbmltYXRpb25JZCA9IF90aGlzJHByb3BzNS5hbmltYXRpb25JZDtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSA9IHRoaXMuc3RhdGUsXG4gICAgICAgIHByZXZQb2ludHMgPSBfdGhpcyRzdGF0ZS5wcmV2UG9pbnRzLFxuICAgICAgICBwcmV2QmFzZUxpbmUgPSBfdGhpcyRzdGF0ZS5wcmV2QmFzZUxpbmU7XG4gICAgICAvLyBjb25zdCBjbGlwUGF0aElkID0gaXNOaWwoaWQpID8gdGhpcy5pZCA6IGlkO1xuXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfcmVhY3RTbW9vdGhbXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgIGJlZ2luOiBhbmltYXRpb25CZWdpbixcbiAgICAgICAgZHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICBpc0FjdGl2ZTogaXNBbmltYXRpb25BY3RpdmUsXG4gICAgICAgIGVhc2luZzogYW5pbWF0aW9uRWFzaW5nLFxuICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgdDogMFxuICAgICAgICB9LFxuICAgICAgICB0bzoge1xuICAgICAgICAgIHQ6IDFcbiAgICAgICAgfSxcbiAgICAgICAga2V5OiBcImFyZWEtXCIuY29uY2F0KGFuaW1hdGlvbklkKSxcbiAgICAgICAgb25BbmltYXRpb25FbmQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uRW5kLFxuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0OiB0aGlzLmhhbmRsZUFuaW1hdGlvblN0YXJ0XG4gICAgICB9LCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgdCA9IF9yZWYudDtcbiAgICAgICAgaWYgKHByZXZQb2ludHMpIHtcbiAgICAgICAgICB2YXIgcHJldlBvaW50c0RpZmZGYWN0b3IgPSBwcmV2UG9pbnRzLmxlbmd0aCAvIHBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgLy8gdXBkYXRlIGFuaW10YWlvblxuICAgICAgICAgIHZhciBzdGVwUG9pbnRzID0gcG9pbnRzLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcHJldlBvaW50SW5kZXggPSBNYXRoLmZsb29yKGluZGV4ICogcHJldlBvaW50c0RpZmZGYWN0b3IpO1xuICAgICAgICAgICAgaWYgKHByZXZQb2ludHNbcHJldlBvaW50SW5kZXhdKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2ID0gcHJldlBvaW50c1twcmV2UG9pbnRJbmRleF07XG4gICAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JYID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXYueCwgZW50cnkueCk7XG4gICAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JZID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXYueSwgZW50cnkueSk7XG4gICAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcbiAgICAgICAgICAgICAgICB4OiBpbnRlcnBvbGF0b3JYKHQpLFxuICAgICAgICAgICAgICAgIHk6IGludGVycG9sYXRvclkodClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN0ZXBCYXNlTGluZTtcbiAgICAgICAgICBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGJhc2VMaW5lKSAmJiB0eXBlb2YgYmFzZUxpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXZCYXNlTGluZSwgYmFzZUxpbmUpO1xuICAgICAgICAgICAgc3RlcEJhc2VMaW5lID0gaW50ZXJwb2xhdG9yKHQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGJhc2VMaW5lKSB8fCAoMCwgX2lzTmFOW1wiZGVmYXVsdFwiXSkoYmFzZUxpbmUpKSB7XG4gICAgICAgICAgICB2YXIgX2ludGVycG9sYXRvciA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2QmFzZUxpbmUsIDApO1xuICAgICAgICAgICAgc3RlcEJhc2VMaW5lID0gX2ludGVycG9sYXRvcih0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RlcEJhc2VMaW5lID0gYmFzZUxpbmUubWFwKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZQb2ludEluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAqIHByZXZQb2ludHNEaWZmRmFjdG9yKTtcbiAgICAgICAgICAgICAgaWYgKHByZXZCYXNlTGluZVtwcmV2UG9pbnRJbmRleF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHByZXZCYXNlTGluZVtwcmV2UG9pbnRJbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIGludGVycG9sYXRvclggPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi54LCBlbnRyeS54KTtcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yWSA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2LnksIGVudHJ5LnkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcbiAgICAgICAgICAgICAgICAgIHg6IGludGVycG9sYXRvclgodCksXG4gICAgICAgICAgICAgICAgICB5OiBpbnRlcnBvbGF0b3JZKHQpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfdGhpczIucmVuZGVyQXJlYVN0YXRpY2FsbHkoc3RlcFBvaW50cywgc3RlcEJhc2VMaW5lLCBuZWVkQ2xpcCwgY2xpcFBhdGhJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwge1xuICAgICAgICAgIGlkOiBcImFuaW1hdGlvbkNsaXBQYXRoLVwiLmNvbmNhdChjbGlwUGF0aElkKVxuICAgICAgICB9LCBfdGhpczIucmVuZGVyQ2xpcFJlY3QodCkpKSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcbiAgICAgICAgICBjbGlwUGF0aDogXCJ1cmwoI2FuaW1hdGlvbkNsaXBQYXRoLVwiLmNvbmNhdChjbGlwUGF0aElkLCBcIilcIilcbiAgICAgICAgfSwgX3RoaXMyLnJlbmRlckFyZWFTdGF0aWNhbGx5KHBvaW50cywgYmFzZUxpbmUsIG5lZWRDbGlwLCBjbGlwUGF0aElkKSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckFyZWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQXJlYShuZWVkQ2xpcCwgY2xpcFBhdGhJZCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNiA9IHRoaXMucHJvcHMsXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzNi5wb2ludHMsXG4gICAgICAgIGJhc2VMaW5lID0gX3RoaXMkcHJvcHM2LmJhc2VMaW5lLFxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzNi5pc0FuaW1hdGlvbkFjdGl2ZTtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZTIgPSB0aGlzLnN0YXRlLFxuICAgICAgICBwcmV2UG9pbnRzID0gX3RoaXMkc3RhdGUyLnByZXZQb2ludHMsXG4gICAgICAgIHByZXZCYXNlTGluZSA9IF90aGlzJHN0YXRlMi5wcmV2QmFzZUxpbmUsXG4gICAgICAgIHRvdGFsTGVuZ3RoID0gX3RoaXMkc3RhdGUyLnRvdGFsTGVuZ3RoO1xuICAgICAgaWYgKGlzQW5pbWF0aW9uQWN0aXZlICYmIHBvaW50cyAmJiBwb2ludHMubGVuZ3RoICYmICghcHJldlBvaW50cyAmJiB0b3RhbExlbmd0aCA+IDAgfHwgISgwLCBfaXNFcXVhbFtcImRlZmF1bHRcIl0pKHByZXZQb2ludHMsIHBvaW50cykgfHwgISgwLCBfaXNFcXVhbFtcImRlZmF1bHRcIl0pKHByZXZCYXNlTGluZSwgYmFzZUxpbmUpKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJBcmVhV2l0aEFuaW1hdGlvbihuZWVkQ2xpcCwgY2xpcFBhdGhJZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJBcmVhU3RhdGljYWxseShwb2ludHMsIGJhc2VMaW5lLCBuZWVkQ2xpcCwgY2xpcFBhdGhJZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX2ZpbHRlclByb3BzO1xuICAgICAgdmFyIF90aGlzJHByb3BzNyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGhpZGUgPSBfdGhpcyRwcm9wczcuaGlkZSxcbiAgICAgICAgZG90ID0gX3RoaXMkcHJvcHM3LmRvdCxcbiAgICAgICAgcG9pbnRzID0gX3RoaXMkcHJvcHM3LnBvaW50cyxcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHM3LmNsYXNzTmFtZSxcbiAgICAgICAgdG9wID0gX3RoaXMkcHJvcHM3LnRvcCxcbiAgICAgICAgbGVmdCA9IF90aGlzJHByb3BzNy5sZWZ0LFxuICAgICAgICB4QXhpcyA9IF90aGlzJHByb3BzNy54QXhpcyxcbiAgICAgICAgeUF4aXMgPSBfdGhpcyRwcm9wczcueUF4aXMsXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM3LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczcuaGVpZ2h0LFxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzNy5pc0FuaW1hdGlvbkFjdGl2ZSxcbiAgICAgICAgaWQgPSBfdGhpcyRwcm9wczcuaWQ7XG4gICAgICBpZiAoaGlkZSB8fCAhcG9pbnRzIHx8ICFwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGlzQW5pbWF0aW9uRmluaXNoZWQgPSB0aGlzLnN0YXRlLmlzQW5pbWF0aW9uRmluaXNoZWQ7XG4gICAgICB2YXIgaGFzU2luZ2xlUG9pbnQgPSBwb2ludHMubGVuZ3RoID09PSAxO1xuICAgICAgdmFyIGxheWVyQ2xhc3MgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtYXJlYScsIGNsYXNzTmFtZSk7XG4gICAgICB2YXIgbmVlZENsaXBYID0geEF4aXMgJiYgeEF4aXMuYWxsb3dEYXRhT3ZlcmZsb3c7XG4gICAgICB2YXIgbmVlZENsaXBZID0geUF4aXMgJiYgeUF4aXMuYWxsb3dEYXRhT3ZlcmZsb3c7XG4gICAgICB2YXIgbmVlZENsaXAgPSBuZWVkQ2xpcFggfHwgbmVlZENsaXBZO1xuICAgICAgdmFyIGNsaXBQYXRoSWQgPSAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoaWQpID8gdGhpcy5pZCA6IGlkO1xuICAgICAgdmFyIF9yZWYyID0gKF9maWx0ZXJQcm9wcyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykoZG90LCBmYWxzZSkpICE9PSBudWxsICYmIF9maWx0ZXJQcm9wcyAhPT0gdm9pZCAwID8gX2ZpbHRlclByb3BzIDoge1xuICAgICAgICAgIHI6IDMsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDJcbiAgICAgICAgfSxcbiAgICAgICAgX3JlZjIkciA9IF9yZWYyLnIsXG4gICAgICAgIHIgPSBfcmVmMiRyID09PSB2b2lkIDAgPyAzIDogX3JlZjIkcixcbiAgICAgICAgX3JlZjIkc3Ryb2tlV2lkdGggPSBfcmVmMi5zdHJva2VXaWR0aCxcbiAgICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmMiRzdHJva2VXaWR0aCA9PT0gdm9pZCAwID8gMiA6IF9yZWYyJHN0cm9rZVdpZHRoO1xuICAgICAgdmFyIF9yZWYzID0gKDAsIF9SZWFjdFV0aWxzLmhhc0NsaXBEb3QpKGRvdCkgPyBkb3QgOiB7fSxcbiAgICAgICAgX3JlZjMkY2xpcERvdCA9IF9yZWYzLmNsaXBEb3QsXG4gICAgICAgIGNsaXBEb3QgPSBfcmVmMyRjbGlwRG90ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjMkY2xpcERvdDtcbiAgICAgIHZhciBkb3RTaXplID0gciAqIDIgKyBzdHJva2VXaWR0aDtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xuICAgICAgICBjbGFzc05hbWU6IGxheWVyQ2xhc3NcbiAgICAgIH0sIG5lZWRDbGlwWCB8fCBuZWVkQ2xpcFkgPyAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwge1xuICAgICAgICBpZDogXCJjbGlwUGF0aC1cIi5jb25jYXQoY2xpcFBhdGhJZClcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICAgICAgeDogbmVlZENsaXBYID8gbGVmdCA6IGxlZnQgLSB3aWR0aCAvIDIsXG4gICAgICAgIHk6IG5lZWRDbGlwWSA/IHRvcCA6IHRvcCAtIGhlaWdodCAvIDIsXG4gICAgICAgIHdpZHRoOiBuZWVkQ2xpcFggPyB3aWR0aCA6IHdpZHRoICogMixcbiAgICAgICAgaGVpZ2h0OiBuZWVkQ2xpcFkgPyBoZWlnaHQgOiBoZWlnaHQgKiAyXG4gICAgICB9KSksICFjbGlwRG90ICYmIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiLCB7XG4gICAgICAgIGlkOiBcImNsaXBQYXRoLWRvdHMtXCIuY29uY2F0KGNsaXBQYXRoSWQpXG4gICAgICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgICAgIHg6IGxlZnQgLSBkb3RTaXplIC8gMixcbiAgICAgICAgeTogdG9wIC0gZG90U2l6ZSAvIDIsXG4gICAgICAgIHdpZHRoOiB3aWR0aCArIGRvdFNpemUsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgZG90U2l6ZVxuICAgICAgfSkpKSA6IG51bGwsICFoYXNTaW5nbGVQb2ludCA/IHRoaXMucmVuZGVyQXJlYShuZWVkQ2xpcCwgY2xpcFBhdGhJZCkgOiBudWxsLCAoZG90IHx8IGhhc1NpbmdsZVBvaW50KSAmJiB0aGlzLnJlbmRlckRvdHMobmVlZENsaXAsIGNsaXBEb3QsIGNsaXBQYXRoSWQpLCAoIWlzQW5pbWF0aW9uQWN0aXZlIHx8IGlzQW5pbWF0aW9uRmluaXNoZWQpICYmIF9MYWJlbExpc3QuTGFiZWxMaXN0LnJlbmRlckNhbGxCeVBhcmVudCh0aGlzLnByb3BzLCBwb2ludHMpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmFuaW1hdGlvbklkICE9PSBwcmV2U3RhdGUucHJldkFuaW1hdGlvbklkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJldkFuaW1hdGlvbklkOiBuZXh0UHJvcHMuYW5pbWF0aW9uSWQsXG4gICAgICAgICAgY3VyUG9pbnRzOiBuZXh0UHJvcHMucG9pbnRzLFxuICAgICAgICAgIGN1ckJhc2VMaW5lOiBuZXh0UHJvcHMuYmFzZUxpbmUsXG4gICAgICAgICAgcHJldlBvaW50czogcHJldlN0YXRlLmN1clBvaW50cyxcbiAgICAgICAgICBwcmV2QmFzZUxpbmU6IHByZXZTdGF0ZS5jdXJCYXNlTGluZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKG5leHRQcm9wcy5wb2ludHMgIT09IHByZXZTdGF0ZS5jdXJQb2ludHMgfHwgbmV4dFByb3BzLmJhc2VMaW5lICE9PSBwcmV2U3RhdGUuY3VyQmFzZUxpbmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjdXJQb2ludHM6IG5leHRQcm9wcy5wb2ludHMsXG4gICAgICAgICAgY3VyQmFzZUxpbmU6IG5leHRQcm9wcy5iYXNlTGluZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XSk7XG59KF9yZWFjdC5QdXJlQ29tcG9uZW50KTtcbl9BcmVhID0gQXJlYTtcbl9kZWZpbmVQcm9wZXJ0eShBcmVhLCBcImRpc3BsYXlOYW1lXCIsICdBcmVhJyk7XG5fZGVmaW5lUHJvcGVydHkoQXJlYSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBzdHJva2U6ICcjMzE4MmJkJyxcbiAgZmlsbDogJyMzMTgyYmQnLFxuICBmaWxsT3BhY2l0eTogMC42LFxuICB4QXhpc0lkOiAwLFxuICB5QXhpc0lkOiAwLFxuICBsZWdlbmRUeXBlOiAnbGluZScsXG4gIGNvbm5lY3ROdWxsczogZmFsc2UsXG4gIC8vIHBvaW50cyBvZiBhcmVhXG4gIHBvaW50czogW10sXG4gIGRvdDogZmFsc2UsXG4gIGFjdGl2ZURvdDogdHJ1ZSxcbiAgaGlkZTogZmFsc2UsXG4gIGlzQW5pbWF0aW9uQWN0aXZlOiAhX0dsb2JhbC5HbG9iYWwuaXNTc3IsXG4gIGFuaW1hdGlvbkJlZ2luOiAwLFxuICBhbmltYXRpb25EdXJhdGlvbjogMTUwMCxcbiAgYW5pbWF0aW9uRWFzaW5nOiAnZWFzZSdcbn0pO1xuX2RlZmluZVByb3BlcnR5KEFyZWEsIFwiZ2V0QmFzZVZhbHVlXCIsIGZ1bmN0aW9uIChwcm9wcywgaXRlbSwgeEF4aXMsIHlBeGlzKSB7XG4gIHZhciBsYXlvdXQgPSBwcm9wcy5sYXlvdXQsXG4gICAgY2hhcnRCYXNlVmFsdWUgPSBwcm9wcy5iYXNlVmFsdWU7XG4gIHZhciBpdGVtQmFzZVZhbHVlID0gaXRlbS5wcm9wcy5iYXNlVmFsdWU7XG5cbiAgLy8gVGhlIGJhc2VWYWx1ZSBjYW4gYmUgZGVmaW5lZCBib3RoIG9uIHRoZSBBcmVhQ2hhcnQgYXMgd2VsbCBhcyBvbiB0aGUgQXJlYS5cbiAgLy8gVGhlIHZhbHVlIGZvciB0aGUgaXRlbSB0YWtlcyBwcmVjZWRlbmNlLlxuICB2YXIgYmFzZVZhbHVlID0gaXRlbUJhc2VWYWx1ZSAhPT0gbnVsbCAmJiBpdGVtQmFzZVZhbHVlICE9PSB2b2lkIDAgPyBpdGVtQmFzZVZhbHVlIDogY2hhcnRCYXNlVmFsdWU7XG4gIGlmICgoMCwgX0RhdGFVdGlscy5pc051bWJlcikoYmFzZVZhbHVlKSAmJiB0eXBlb2YgYmFzZVZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBiYXNlVmFsdWU7XG4gIH1cbiAgdmFyIG51bWVyaWNBeGlzID0gbGF5b3V0ID09PSAnaG9yaXpvbnRhbCcgPyB5QXhpcyA6IHhBeGlzO1xuICB2YXIgZG9tYWluID0gbnVtZXJpY0F4aXMuc2NhbGUuZG9tYWluKCk7XG4gIGlmIChudW1lcmljQXhpcy50eXBlID09PSAnbnVtYmVyJykge1xuICAgIHZhciBkb21haW5NYXggPSBNYXRoLm1heChkb21haW5bMF0sIGRvbWFpblsxXSk7XG4gICAgdmFyIGRvbWFpbk1pbiA9IE1hdGgubWluKGRvbWFpblswXSwgZG9tYWluWzFdKTtcbiAgICBpZiAoYmFzZVZhbHVlID09PSAnZGF0YU1pbicpIHtcbiAgICAgIHJldHVybiBkb21haW5NaW47XG4gICAgfVxuICAgIGlmIChiYXNlVmFsdWUgPT09ICdkYXRhTWF4Jykge1xuICAgICAgcmV0dXJuIGRvbWFpbk1heDtcbiAgICB9XG4gICAgcmV0dXJuIGRvbWFpbk1heCA8IDAgPyBkb21haW5NYXggOiBNYXRoLm1heChNYXRoLm1pbihkb21haW5bMF0sIGRvbWFpblsxXSksIDApO1xuICB9XG4gIGlmIChiYXNlVmFsdWUgPT09ICdkYXRhTWluJykge1xuICAgIHJldHVybiBkb21haW5bMF07XG4gIH1cbiAgaWYgKGJhc2VWYWx1ZSA9PT0gJ2RhdGFNYXgnKSB7XG4gICAgcmV0dXJuIGRvbWFpblsxXTtcbiAgfVxuICByZXR1cm4gZG9tYWluWzBdO1xufSk7XG5fZGVmaW5lUHJvcGVydHkoQXJlYSwgXCJnZXRDb21wb3NlZERhdGFcIiwgZnVuY3Rpb24gKF9yZWY0KSB7XG4gIHZhciBwcm9wcyA9IF9yZWY0LnByb3BzLFxuICAgIGl0ZW0gPSBfcmVmNC5pdGVtLFxuICAgIHhBeGlzID0gX3JlZjQueEF4aXMsXG4gICAgeUF4aXMgPSBfcmVmNC55QXhpcyxcbiAgICB4QXhpc1RpY2tzID0gX3JlZjQueEF4aXNUaWNrcyxcbiAgICB5QXhpc1RpY2tzID0gX3JlZjQueUF4aXNUaWNrcyxcbiAgICBiYW5kU2l6ZSA9IF9yZWY0LmJhbmRTaXplLFxuICAgIGRhdGFLZXkgPSBfcmVmNC5kYXRhS2V5LFxuICAgIHN0YWNrZWREYXRhID0gX3JlZjQuc3RhY2tlZERhdGEsXG4gICAgZGF0YVN0YXJ0SW5kZXggPSBfcmVmNC5kYXRhU3RhcnRJbmRleCxcbiAgICBkaXNwbGF5ZWREYXRhID0gX3JlZjQuZGlzcGxheWVkRGF0YSxcbiAgICBvZmZzZXQgPSBfcmVmNC5vZmZzZXQ7XG4gIHZhciBsYXlvdXQgPSBwcm9wcy5sYXlvdXQ7XG4gIHZhciBoYXNTdGFjayA9IHN0YWNrZWREYXRhICYmIHN0YWNrZWREYXRhLmxlbmd0aDtcbiAgdmFyIGJhc2VWYWx1ZSA9IF9BcmVhLmdldEJhc2VWYWx1ZShwcm9wcywgaXRlbSwgeEF4aXMsIHlBeGlzKTtcbiAgdmFyIGlzSG9yaXpvbnRhbExheW91dCA9IGxheW91dCA9PT0gJ2hvcml6b250YWwnO1xuICB2YXIgaXNSYW5nZSA9IGZhbHNlO1xuICB2YXIgcG9pbnRzID0gZGlzcGxheWVkRGF0YS5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAoaGFzU3RhY2spIHtcbiAgICAgIHZhbHVlID0gc3RhY2tlZERhdGFbZGF0YVN0YXJ0SW5kZXggKyBpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgZGF0YUtleSk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gW2Jhc2VWYWx1ZSwgdmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNSYW5nZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpc0JyZWFrUG9pbnQgPSB2YWx1ZVsxXSA9PSBudWxsIHx8IGhhc1N0YWNrICYmICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkoZW50cnksIGRhdGFLZXkpID09IG51bGw7XG4gICAgaWYgKGlzSG9yaXpvbnRhbExheW91dCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKDAsIF9DaGFydFV0aWxzLmdldENhdGVDb29yZGluYXRlT2ZMaW5lKSh7XG4gICAgICAgICAgYXhpczogeEF4aXMsXG4gICAgICAgICAgdGlja3M6IHhBeGlzVGlja3MsXG4gICAgICAgICAgYmFuZFNpemU6IGJhbmRTaXplLFxuICAgICAgICAgIGVudHJ5OiBlbnRyeSxcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfSksXG4gICAgICAgIHk6IGlzQnJlYWtQb2ludCA/IG51bGwgOiB5QXhpcy5zY2FsZSh2YWx1ZVsxXSksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgcGF5bG9hZDogZW50cnlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4OiBpc0JyZWFrUG9pbnQgPyBudWxsIDogeEF4aXMuc2NhbGUodmFsdWVbMV0pLFxuICAgICAgeTogKDAsIF9DaGFydFV0aWxzLmdldENhdGVDb29yZGluYXRlT2ZMaW5lKSh7XG4gICAgICAgIGF4aXM6IHlBeGlzLFxuICAgICAgICB0aWNrczogeUF4aXNUaWNrcyxcbiAgICAgICAgYmFuZFNpemU6IGJhbmRTaXplLFxuICAgICAgICBlbnRyeTogZW50cnksXG4gICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgfSksXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBwYXlsb2FkOiBlbnRyeVxuICAgIH07XG4gIH0pO1xuICB2YXIgYmFzZUxpbmU7XG4gIGlmIChoYXNTdGFjayB8fCBpc1JhbmdlKSB7XG4gICAgYmFzZUxpbmUgPSBwb2ludHMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgdmFyIHggPSBBcnJheS5pc0FycmF5KGVudHJ5LnZhbHVlKSA/IGVudHJ5LnZhbHVlWzBdIDogbnVsbDtcbiAgICAgIGlmIChpc0hvcml6b250YWxMYXlvdXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBlbnRyeS54LFxuICAgICAgICAgIHk6IHggIT0gbnVsbCAmJiBlbnRyeS55ICE9IG51bGwgPyB5QXhpcy5zY2FsZSh4KSA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggIT0gbnVsbCA/IHhBeGlzLnNjYWxlKHgpIDogbnVsbCxcbiAgICAgICAgeTogZW50cnkueVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBiYXNlTGluZSA9IGlzSG9yaXpvbnRhbExheW91dCA/IHlBeGlzLnNjYWxlKGJhc2VWYWx1ZSkgOiB4QXhpcy5zY2FsZShiYXNlVmFsdWUpO1xuICB9XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICBiYXNlTGluZTogYmFzZUxpbmUsXG4gICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgaXNSYW5nZTogaXNSYW5nZVxuICB9LCBvZmZzZXQpO1xufSk7XG5fZGVmaW5lUHJvcGVydHkoQXJlYSwgXCJyZW5kZXJEb3RJdGVtXCIsIGZ1bmN0aW9uIChvcHRpb24sIHByb3BzKSB7XG4gIHZhciBkb3RJdGVtO1xuICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KG9wdGlvbikpIHtcbiAgICBkb3RJdGVtID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KG9wdGlvbiwgcHJvcHMpO1xuICB9IGVsc2UgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9wdGlvbikpIHtcbiAgICBkb3RJdGVtID0gb3B0aW9uKHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLWFyZWEtZG90JywgdHlwZW9mIG9wdGlvbiAhPT0gJ2Jvb2xlYW4nID8gb3B0aW9uLmNsYXNzTmFtZSA6ICcnKTtcbiAgICB2YXIga2V5ID0gcHJvcHMua2V5LFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkMik7XG4gICAgZG90SXRlbSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0RvdC5Eb3QsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiBkb3RJdGVtO1xufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXJlYSIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9jbHN4IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9yZWFjdFNtb290aCIsIl9pc0Z1bmN0aW9uIiwiX21heCIsIl9pc05pbCIsIl9pc05hTiIsIl9pc0VxdWFsIiwiX0N1cnZlIiwiX0RvdCIsIl9MYXllciIsIl9MYWJlbExpc3QiLCJfR2xvYmFsIiwiX0RhdGFVdGlscyIsIl9DaGFydFV0aWxzIiwiX1JlYWN0VXRpbHMiLCJfZXhjbHVkZWQiLCJfZXhjbHVkZWQyIiwiX0FyZWEiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2UiLCJleGNsdWRlZCIsInRhcmdldCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwia2V5IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImxlbmd0aCIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsImFyZ3VtZW50cyIsImFwcGx5Iiwib3duS2V5cyIsImtleXMiLCJmaWx0ZXIiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiX1B1cmVDb21wb25lbnQiLCJfdGhpcyIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiY29uY2F0IiwiaXNBbmltYXRpb25GaW5pc2hlZCIsInVuaXF1ZUlkIiwib25BbmltYXRpb25FbmQiLCJzZXRTdGF0ZSIsIm9uQW5pbWF0aW9uU3RhcnQiLCJyZW5kZXJEb3RzIiwibmVlZENsaXAiLCJjbGlwRG90IiwiY2xpcFBhdGhJZCIsImlzQW5pbWF0aW9uQWN0aXZlIiwic3RhdGUiLCJfdGhpcyRwcm9wcyIsImRvdCIsInBvaW50cyIsImRhdGFLZXkiLCJhcmVhUHJvcHMiLCJmaWx0ZXJQcm9wcyIsImN1c3RvbURvdFByb3BzIiwiZG90cyIsIm1hcCIsImVudHJ5IiwiZG90UHJvcHMiLCJpbmRleCIsImN4IiwieCIsImN5IiwieSIsInBheWxvYWQiLCJyZW5kZXJEb3RJdGVtIiwiZG90c1Byb3BzIiwiY2xpcFBhdGgiLCJjcmVhdGVFbGVtZW50IiwiTGF5ZXIiLCJjbGFzc05hbWUiLCJyZW5kZXJIb3Jpem9udGFsUmVjdCIsImFscGhhIiwiX3RoaXMkcHJvcHMyIiwiYmFzZUxpbmUiLCJzdHJva2VXaWR0aCIsInN0YXJ0WCIsImVuZFgiLCJ3aWR0aCIsIk1hdGgiLCJhYnMiLCJtYXhZIiwiaXNOdW1iZXIiLCJtYXgiLCJpc0FycmF5IiwiaGVpZ2h0IiwiZmxvb3IiLCJwYXJzZUludCIsInJlbmRlclZlcnRpY2FsUmVjdCIsIl90aGlzJHByb3BzMyIsInN0YXJ0WSIsImVuZFkiLCJtYXhYIiwicmVuZGVyQ2xpcFJlY3QiLCJsYXlvdXQiLCJyZW5kZXJBcmVhU3RhdGljYWxseSIsIl90aGlzJHByb3BzNCIsInR5cGUiLCJzdHJva2UiLCJjb25uZWN0TnVsbHMiLCJpc1JhbmdlIiwicmVmIiwib3RoZXJzIiwiQ3VydmUiLCJmaWxsIiwicmVuZGVyQXJlYVdpdGhBbmltYXRpb24iLCJfdGhpczIiLCJfdGhpcyRwcm9wczUiLCJhbmltYXRpb25CZWdpbiIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRWFzaW5nIiwiYW5pbWF0aW9uSWQiLCJfdGhpcyRzdGF0ZSIsInByZXZQb2ludHMiLCJwcmV2QmFzZUxpbmUiLCJiZWdpbiIsImR1cmF0aW9uIiwiaXNBY3RpdmUiLCJlYXNpbmciLCJmcm9tIiwidG8iLCJoYW5kbGVBbmltYXRpb25FbmQiLCJoYW5kbGVBbmltYXRpb25TdGFydCIsIl9yZWYiLCJwcmV2UG9pbnRzRGlmZkZhY3RvciIsInN0ZXBQb2ludHMiLCJwcmV2UG9pbnRJbmRleCIsInByZXYiLCJpbnRlcnBvbGF0b3JYIiwiaW50ZXJwb2xhdGVOdW1iZXIiLCJpbnRlcnBvbGF0b3JZIiwic3RlcEJhc2VMaW5lIiwiaW50ZXJwb2xhdG9yIiwiX2ludGVycG9sYXRvciIsImlkIiwicmVuZGVyQXJlYSIsIl90aGlzJHByb3BzNiIsIl90aGlzJHN0YXRlMiIsInRvdGFsTGVuZ3RoIiwicmVuZGVyIiwiX2ZpbHRlclByb3BzIiwiX3RoaXMkcHJvcHM3IiwiaGlkZSIsInRvcCIsImxlZnQiLCJ4QXhpcyIsInlBeGlzIiwiaGFzU2luZ2xlUG9pbnQiLCJsYXllckNsYXNzIiwibmVlZENsaXBYIiwiYWxsb3dEYXRhT3ZlcmZsb3ciLCJuZWVkQ2xpcFkiLCJfcmVmMiIsIl9yZWYyJHIiLCJfcmVmMiRzdHJva2VXaWR0aCIsIl9yZWYzIiwiaGFzQ2xpcERvdCIsIl9yZWYzJGNsaXBEb3QiLCJkb3RTaXplIiwiTGFiZWxMaXN0IiwicmVuZGVyQ2FsbEJ5UGFyZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibmV4dFByb3BzIiwicHJldlN0YXRlIiwicHJldkFuaW1hdGlvbklkIiwiY3VyUG9pbnRzIiwiY3VyQmFzZUxpbmUiLCJQdXJlQ29tcG9uZW50IiwiZmlsbE9wYWNpdHkiLCJ4QXhpc0lkIiwieUF4aXNJZCIsImxlZ2VuZFR5cGUiLCJhY3RpdmVEb3QiLCJHbG9iYWwiLCJpc1NzciIsIml0ZW0iLCJjaGFydEJhc2VWYWx1ZSIsImJhc2VWYWx1ZSIsIml0ZW1CYXNlVmFsdWUiLCJudW1lcmljQXhpcyIsImRvbWFpbiIsInNjYWxlIiwiZG9tYWluTWF4IiwiZG9tYWluTWluIiwibWluIiwiX3JlZjQiLCJ4QXhpc1RpY2tzIiwieUF4aXNUaWNrcyIsImJhbmRTaXplIiwic3RhY2tlZERhdGEiLCJkYXRhU3RhcnRJbmRleCIsImRpc3BsYXllZERhdGEiLCJvZmZzZXQiLCJoYXNTdGFjayIsImdldEJhc2VWYWx1ZSIsImlzSG9yaXpvbnRhbExheW91dCIsImdldFZhbHVlQnlEYXRhS2V5IiwiaXNCcmVha1BvaW50IiwiZ2V0Q2F0ZUNvb3JkaW5hdGVPZkxpbmUiLCJheGlzIiwidGlja3MiLCJvcHRpb24iLCJkb3RJdGVtIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJyZXN0IiwiRG90Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/Area.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/cartesian/Bar.js":
/*!****************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/Bar.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Bar = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _ErrorBar = __webpack_require__(/*! ./ErrorBar */ \"./node_modules/recharts/lib/cartesian/ErrorBar.js\");\nvar _Cell = __webpack_require__(/*! ../component/Cell */ \"./node_modules/recharts/lib/component/Cell.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"./node_modules/recharts/lib/component/LabelList.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"./node_modules/recharts/lib/util/Global.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"./node_modules/recharts/lib/util/types.js\");\nvar _BarUtils = __webpack_require__(/*! ../util/BarUtils */ \"./node_modules/recharts/lib/util/BarUtils.js\");\nvar _excluded = [\n    \"value\",\n    \"background\"\n];\nvar _Bar;\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Render a group of bar\n */ \nvar Bar = exports.Bar = /*#__PURE__*/ function(_PureComponent) {\n    function Bar() {\n        var _this;\n        _classCallCheck(this, Bar);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Bar, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            isAnimationFinished: false\n        });\n        _defineProperty(_this, \"id\", (0, _DataUtils.uniqueId)(\"recharts-bar-\"));\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            var onAnimationEnd = _this.props.onAnimationEnd;\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if (onAnimationEnd) {\n                onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            var onAnimationStart = _this.props.onAnimationStart;\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if (onAnimationStart) {\n                onAnimationStart();\n            }\n        });\n        return _this;\n    }\n    _inherits(Bar, _PureComponent);\n    return _createClass(Bar, [\n        {\n            key: \"renderRectanglesStatically\",\n            value: function renderRectanglesStatically(data) {\n                var _this2 = this;\n                var _this$props = this.props, shape = _this$props.shape, dataKey = _this$props.dataKey, activeIndex = _this$props.activeIndex, activeBar = _this$props.activeBar;\n                var baseProps = (0, _ReactUtils.filterProps)(this.props, false);\n                return data && data.map(function(entry, i) {\n                    var isActive = i === activeIndex;\n                    var option = isActive ? activeBar : shape;\n                    var props = _objectSpread(_objectSpread(_objectSpread({}, baseProps), entry), {}, {\n                        isActive: isActive,\n                        option: option,\n                        index: i,\n                        dataKey: dataKey,\n                        onAnimationStart: _this2.handleAnimationStart,\n                        onAnimationEnd: _this2.handleAnimationEnd\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        className: \"recharts-bar-rectangle\"\n                    }, (0, _types.adaptEventsOfChild)(_this2.props, entry, i), {\n                        key: \"rectangle-\".concat(entry === null || entry === void 0 ? void 0 : entry.x, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.y, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.value)\n                    }), /*#__PURE__*/ _react[\"default\"].createElement(_BarUtils.BarRectangle, props));\n                });\n            }\n        },\n        {\n            key: \"renderRectanglesWithAnimation\",\n            value: function renderRectanglesWithAnimation() {\n                var _this3 = this;\n                var _this$props2 = this.props, data = _this$props2.data, layout = _this$props2.layout, isAnimationActive = _this$props2.isAnimationActive, animationBegin = _this$props2.animationBegin, animationDuration = _this$props2.animationDuration, animationEasing = _this$props2.animationEasing, animationId = _this$props2.animationId;\n                var prevData = this.state.prevData;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"bar-\".concat(animationId),\n                    onAnimationEnd: this.handleAnimationEnd,\n                    onAnimationStart: this.handleAnimationStart\n                }, function(_ref) {\n                    var t = _ref.t;\n                    var stepData = data.map(function(entry, index) {\n                        var prev = prevData && prevData[index];\n                        if (prev) {\n                            var interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry.x);\n                            var interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry.y);\n                            var interpolatorWidth = (0, _DataUtils.interpolateNumber)(prev.width, entry.width);\n                            var interpolatorHeight = (0, _DataUtils.interpolateNumber)(prev.height, entry.height);\n                            return _objectSpread(_objectSpread({}, entry), {}, {\n                                x: interpolatorX(t),\n                                y: interpolatorY(t),\n                                width: interpolatorWidth(t),\n                                height: interpolatorHeight(t)\n                            });\n                        }\n                        if (layout === \"horizontal\") {\n                            var _interpolatorHeight = (0, _DataUtils.interpolateNumber)(0, entry.height);\n                            var h = _interpolatorHeight(t);\n                            return _objectSpread(_objectSpread({}, entry), {}, {\n                                y: entry.y + entry.height - h,\n                                height: h\n                            });\n                        }\n                        var interpolator = (0, _DataUtils.interpolateNumber)(0, entry.width);\n                        var w = interpolator(t);\n                        return _objectSpread(_objectSpread({}, entry), {}, {\n                            width: w\n                        });\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, null, _this3.renderRectanglesStatically(stepData));\n                });\n            }\n        },\n        {\n            key: \"renderRectangles\",\n            value: function renderRectangles() {\n                var _this$props3 = this.props, data = _this$props3.data, isAnimationActive = _this$props3.isAnimationActive;\n                var prevData = this.state.prevData;\n                if (isAnimationActive && data && data.length && (!prevData || !(0, _isEqual[\"default\"])(prevData, data))) {\n                    return this.renderRectanglesWithAnimation();\n                }\n                return this.renderRectanglesStatically(data);\n            }\n        },\n        {\n            key: \"renderBackground\",\n            value: function renderBackground() {\n                var _this4 = this;\n                var _this$props4 = this.props, data = _this$props4.data, dataKey = _this$props4.dataKey, activeIndex = _this$props4.activeIndex;\n                var backgroundProps = (0, _ReactUtils.filterProps)(this.props.background, false);\n                return data.map(function(entry, i) {\n                    var value = entry.value, background = entry.background, rest = _objectWithoutProperties(entry, _excluded);\n                    if (!background) {\n                        return null;\n                    }\n                    var props = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, rest), {}, {\n                        fill: \"#eee\"\n                    }, background), backgroundProps), (0, _types.adaptEventsOfChild)(_this4.props, entry, i)), {}, {\n                        onAnimationStart: _this4.handleAnimationStart,\n                        onAnimationEnd: _this4.handleAnimationEnd,\n                        dataKey: dataKey,\n                        index: i,\n                        className: \"recharts-bar-background-rectangle\"\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_BarUtils.BarRectangle, _extends({\n                        key: \"background-bar-\".concat(i),\n                        option: _this4.props.background,\n                        isActive: i === activeIndex\n                    }, props));\n                });\n            }\n        },\n        {\n            key: \"renderErrorBar\",\n            value: function renderErrorBar(needClip, clipPathId) {\n                if (this.props.isAnimationActive && !this.state.isAnimationFinished) {\n                    return null;\n                }\n                var _this$props5 = this.props, data = _this$props5.data, xAxis = _this$props5.xAxis, yAxis = _this$props5.yAxis, layout = _this$props5.layout, children = _this$props5.children;\n                var errorBarItems = (0, _ReactUtils.findAllByType)(children, _ErrorBar.ErrorBar);\n                if (!errorBarItems) {\n                    return null;\n                }\n                var offset = layout === \"vertical\" ? data[0].height / 2 : data[0].width / 2;\n                var dataPointFormatter = function dataPointFormatter(dataPoint, dataKey) {\n                    /**\n         * if the value coming from `getComposedData` is an array then this is a stacked bar chart.\n         * arr[1] represents end value of the bar since the data is in the form of [startValue, endValue].\n         * */ var value = Array.isArray(dataPoint.value) ? dataPoint.value[1] : dataPoint.value;\n                    return {\n                        x: dataPoint.x,\n                        y: dataPoint.y,\n                        value: value,\n                        errorVal: (0, _ChartUtils.getValueByDataKey)(dataPoint, dataKey)\n                    };\n                };\n                var errorBarProps = {\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : null\n                };\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, errorBarProps, errorBarItems.map(function(item) {\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(item, {\n                        key: \"error-bar-\".concat(clipPathId, \"-\").concat(item.props.dataKey),\n                        data: data,\n                        xAxis: xAxis,\n                        yAxis: yAxis,\n                        layout: layout,\n                        offset: offset,\n                        dataPointFormatter: dataPointFormatter\n                    });\n                }));\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props6 = this.props, hide = _this$props6.hide, data = _this$props6.data, className = _this$props6.className, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, left = _this$props6.left, top = _this$props6.top, width = _this$props6.width, height = _this$props6.height, isAnimationActive = _this$props6.isAnimationActive, background = _this$props6.background, id = _this$props6.id;\n                if (hide || !data || !data.length) {\n                    return null;\n                }\n                var isAnimationFinished = this.state.isAnimationFinished;\n                var layerClass = (0, _clsx[\"default\"])(\"recharts-bar\", className);\n                var needClipX = xAxis && xAxis.allowDataOverflow;\n                var needClipY = yAxis && yAxis.allowDataOverflow;\n                var needClip = needClipX || needClipY;\n                var clipPathId = (0, _isNil[\"default\"])(id) ? this.id : id;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass\n                }, needClipX || needClipY ? /*#__PURE__*/ _react[\"default\"].createElement(\"defs\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                    id: \"clipPath-\".concat(clipPathId)\n                }, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    x: needClipX ? left : left - width / 2,\n                    y: needClipY ? top : top - height / 2,\n                    width: needClipX ? width : width * 2,\n                    height: needClipY ? height : height * 2\n                }))) : null, /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-bar-rectangles\",\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : null\n                }, background ? this.renderBackground() : null, this.renderRectangles()), this.renderErrorBar(needClip, clipPathId), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, data));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curData: nextProps.data,\n                        prevData: prevState.curData\n                    };\n                }\n                if (nextProps.data !== prevState.curData) {\n                    return {\n                        curData: nextProps.data\n                    };\n                }\n                return null;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_Bar = Bar;\n_defineProperty(Bar, \"displayName\", \"Bar\");\n_defineProperty(Bar, \"defaultProps\", {\n    xAxisId: 0,\n    yAxisId: 0,\n    legendType: \"rect\",\n    minPointSize: 0,\n    hide: false,\n    data: [],\n    layout: \"vertical\",\n    activeBar: false,\n    isAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 0,\n    animationDuration: 400,\n    animationEasing: \"ease\"\n});\n/**\n * Compose the data of each group\n * @param {Object} props Props for the component\n * @param {Object} item        An instance of Bar\n * @param {Array} barPosition  The offset and size of each bar\n * @param {Object} xAxis       The configuration of x-axis\n * @param {Object} yAxis       The configuration of y-axis\n * @param {Array} stackedData  The stacked data of a bar item\n * @return{Array} Composed data\n */ _defineProperty(Bar, \"getComposedData\", function(_ref2) {\n    var props = _ref2.props, item = _ref2.item, barPosition = _ref2.barPosition, bandSize = _ref2.bandSize, xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, stackedData = _ref2.stackedData, dataStartIndex = _ref2.dataStartIndex, displayedData = _ref2.displayedData, offset = _ref2.offset;\n    var pos = (0, _ChartUtils.findPositionOfBar)(barPosition, item);\n    if (!pos) {\n        return null;\n    }\n    var layout = props.layout;\n    var itemDefaultProps = item.type.defaultProps;\n    var itemProps = itemDefaultProps !== undefined ? _objectSpread(_objectSpread({}, itemDefaultProps), item.props) : item.props;\n    var dataKey = itemProps.dataKey, children = itemProps.children, minPointSizeProp = itemProps.minPointSize;\n    var numericAxis = layout === \"horizontal\" ? yAxis : xAxis;\n    var stackedDomain = stackedData ? numericAxis.scale.domain() : null;\n    var baseValue = (0, _ChartUtils.getBaseValueOfBar)({\n        numericAxis: numericAxis\n    });\n    var cells = (0, _ReactUtils.findAllByType)(children, _Cell.Cell);\n    var rects = displayedData.map(function(entry, index) {\n        var value, x, y, width, height, background;\n        if (stackedData) {\n            value = (0, _ChartUtils.truncateByDomain)(stackedData[dataStartIndex + index], stackedDomain);\n        } else {\n            value = (0, _ChartUtils.getValueByDataKey)(entry, dataKey);\n            if (!Array.isArray(value)) {\n                value = [\n                    baseValue,\n                    value\n                ];\n            }\n        }\n        var minPointSize = (0, _BarUtils.minPointSizeCallback)(minPointSizeProp, _Bar.defaultProps.minPointSize)(value[1], index);\n        if (layout === \"horizontal\") {\n            var _ref4;\n            var _ref3 = [\n                yAxis.scale(value[0]),\n                yAxis.scale(value[1])\n            ], baseValueScale = _ref3[0], currentValueScale = _ref3[1];\n            x = (0, _ChartUtils.getCateCoordinateOfBar)({\n                axis: xAxis,\n                ticks: xAxisTicks,\n                bandSize: bandSize,\n                offset: pos.offset,\n                entry: entry,\n                index: index\n            });\n            y = (_ref4 = currentValueScale !== null && currentValueScale !== void 0 ? currentValueScale : baseValueScale) !== null && _ref4 !== void 0 ? _ref4 : undefined;\n            width = pos.size;\n            var computedHeight = baseValueScale - currentValueScale;\n            height = Number.isNaN(computedHeight) ? 0 : computedHeight;\n            background = {\n                x: x,\n                y: yAxis.y,\n                width: width,\n                height: yAxis.height\n            };\n            if (Math.abs(minPointSize) > 0 && Math.abs(height) < Math.abs(minPointSize)) {\n                var delta = (0, _DataUtils.mathSign)(height || minPointSize) * (Math.abs(minPointSize) - Math.abs(height));\n                y -= delta;\n                height += delta;\n            }\n        } else {\n            var _ref5 = [\n                xAxis.scale(value[0]),\n                xAxis.scale(value[1])\n            ], _baseValueScale = _ref5[0], _currentValueScale = _ref5[1];\n            x = _baseValueScale;\n            y = (0, _ChartUtils.getCateCoordinateOfBar)({\n                axis: yAxis,\n                ticks: yAxisTicks,\n                bandSize: bandSize,\n                offset: pos.offset,\n                entry: entry,\n                index: index\n            });\n            width = _currentValueScale - _baseValueScale;\n            height = pos.size;\n            background = {\n                x: xAxis.x,\n                y: y,\n                width: xAxis.width,\n                height: height\n            };\n            if (Math.abs(minPointSize) > 0 && Math.abs(width) < Math.abs(minPointSize)) {\n                var _delta = (0, _DataUtils.mathSign)(width || minPointSize) * (Math.abs(minPointSize) - Math.abs(width));\n                width += _delta;\n            }\n        }\n        return _objectSpread(_objectSpread(_objectSpread({}, entry), {}, {\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            value: stackedData ? value : value[1],\n            payload: entry,\n            background: background\n        }, cells && cells[index] && cells[index].props), {}, {\n            tooltipPayload: [\n                (0, _ChartUtils.getTooltipItem)(item, entry)\n            ],\n            tooltipPosition: {\n                x: x + width / 2,\n                y: y + height / 2\n            }\n        });\n    });\n    return _objectSpread({\n        data: rects,\n        layout: layout\n    }, offset);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9CYXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELFdBQVcsR0FBRyxLQUFLO0FBQ25CLElBQUlHLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsUUFBUUMsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQkFBTTtBQUNqRCxJQUFJRyxlQUFlRCx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQ2hFLElBQUlJLFdBQVdGLHVCQUF1QkYsbUJBQU9BLENBQUMsc0NBQWdCO0FBQzlELElBQUlLLFNBQVNILHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDMUQsSUFBSU0sU0FBU04sbUJBQU9BLENBQUMsMEVBQW9CO0FBQ3pDLElBQUlPLFlBQVlQLG1CQUFPQSxDQUFDLHFFQUFZO0FBQ3BDLElBQUlRLFFBQVFSLG1CQUFPQSxDQUFDLHdFQUFtQjtBQUN2QyxJQUFJUyxhQUFhVCxtQkFBT0EsQ0FBQyxrRkFBd0I7QUFDakQsSUFBSVUsYUFBYVYsbUJBQU9BLENBQUMsd0VBQW1CO0FBQzVDLElBQUlXLGNBQWNYLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJWSxVQUFVWixtQkFBT0EsQ0FBQyxrRUFBZ0I7QUFDdEMsSUFBSWEsY0FBY2IsbUJBQU9BLENBQUMsMEVBQW9CO0FBQzlDLElBQUljLFNBQVNkLG1CQUFPQSxDQUFDLGdFQUFlO0FBQ3BDLElBQUllLFlBQVlmLG1CQUFPQSxDQUFDLHNFQUFrQjtBQUMxQyxJQUFJZ0IsWUFBWTtJQUFDO0lBQVM7Q0FBYTtBQUN2QyxJQUFJQztBQUNKLFNBQVNmLHVCQUF1QmdCLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UseUJBQXlCQyxDQUFDO0lBQUksSUFBSSxj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LENBQUN6QyxnQkFBZ0J3QyxLQUFLQyxHQUFHLENBQUNsRyxNQUFLO2dCQUN2R0EsU0FBU3dHO1lBQ1g7UUFDRjtRQUNBLE9BQU81TSxjQUFjQSxjQUFjQSxjQUFjLENBQUMsR0FBR2dFLFFBQVEsQ0FBQyxHQUFHO1lBQy9EVSxHQUFHQTtZQUNIQyxHQUFHQTtZQUNIeUIsT0FBT0E7WUFDUEUsUUFBUUE7WUFDUnpLLE9BQU93TyxjQUFjeE8sUUFBUUEsS0FBSyxDQUFDLEVBQUU7WUFDckNnUixTQUFTN0k7WUFDVGlELFlBQVlBO1FBQ2QsR0FBR3FFLFNBQVNBLEtBQUssQ0FBQ25ILE1BQU0sSUFBSW1ILEtBQUssQ0FBQ25ILE1BQU0sQ0FBQ3pELEtBQUssR0FBRyxDQUFDLEdBQUc7WUFDbkRvTSxnQkFBZ0I7Z0JBQUUsSUFBR2hRLFlBQVlpUSxjQUFjLEVBQUV6RSxNQUFNdEU7YUFBTztZQUM5RGdKLGlCQUFpQjtnQkFDZnRJLEdBQUdBLElBQUkwQixRQUFRO2dCQUNmekIsR0FBR0EsSUFBSTJCLFNBQVM7WUFDbEI7UUFDRjtJQUNGO0lBQ0EsT0FBT3RHLGNBQWM7UUFDbkJzRCxNQUFNa0k7UUFDTnhHLFFBQVFBO0lBQ1YsR0FBRzhDO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9CYXIuanM/MjQzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQmFyID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfcmVhY3RTbW9vdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1zbW9vdGhcIikpO1xudmFyIF9pc0VxdWFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRXF1YWxcIikpO1xudmFyIF9pc05pbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc05pbFwiKSk7XG52YXIgX0xheWVyID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9MYXllclwiKTtcbnZhciBfRXJyb3JCYXIgPSByZXF1aXJlKFwiLi9FcnJvckJhclwiKTtcbnZhciBfQ2VsbCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvQ2VsbFwiKTtcbnZhciBfTGFiZWxMaXN0ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbExpc3RcIik7XG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XG52YXIgX0dsb2JhbCA9IHJlcXVpcmUoXCIuLi91dGlsL0dsb2JhbFwiKTtcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4uL3V0aWwvdHlwZXNcIik7XG52YXIgX0JhclV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQmFyVXRpbHNcIik7XG52YXIgX2V4Y2x1ZGVkID0gW1widmFsdWVcIiwgXCJiYWNrZ3JvdW5kXCJdO1xudmFyIF9CYXI7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxuICogQGZpbGVPdmVydmlldyBSZW5kZXIgYSBncm91cCBvZiBiYXJcbiAqL1xudmFyIEJhciA9IGV4cG9ydHMuQmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBmdW5jdGlvbiBCYXIoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXIpO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIEJhciwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwic3RhdGVcIiwge1xuICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogZmFsc2VcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaWRcIiwgKDAsIF9EYXRhVXRpbHMudW5pcXVlSWQpKCdyZWNoYXJ0cy1iYXItJykpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25FbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9uQW5pbWF0aW9uRW5kID0gX3RoaXMucHJvcHMub25BbmltYXRpb25FbmQ7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKG9uQW5pbWF0aW9uRW5kKSB7XG4gICAgICAgIG9uQW5pbWF0aW9uRW5kKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZUFuaW1hdGlvblN0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvbkFuaW1hdGlvblN0YXJ0ID0gX3RoaXMucHJvcHMub25BbmltYXRpb25TdGFydDtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgaWYgKG9uQW5pbWF0aW9uU3RhcnQpIHtcbiAgICAgICAgb25BbmltYXRpb25TdGFydCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoQmFyLCBfUHVyZUNvbXBvbmVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQmFyLCBbe1xuICAgIGtleTogXCJyZW5kZXJSZWN0YW5nbGVzU3RhdGljYWxseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJSZWN0YW5nbGVzU3RhdGljYWxseShkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHNoYXBlID0gX3RoaXMkcHJvcHMuc2hhcGUsXG4gICAgICAgIGRhdGFLZXkgPSBfdGhpcyRwcm9wcy5kYXRhS2V5LFxuICAgICAgICBhY3RpdmVJbmRleCA9IF90aGlzJHByb3BzLmFjdGl2ZUluZGV4LFxuICAgICAgICBhY3RpdmVCYXIgPSBfdGhpcyRwcm9wcy5hY3RpdmVCYXI7XG4gICAgICB2YXIgYmFzZVByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aGlzLnByb3BzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gZGF0YSAmJiBkYXRhLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgICAgICAgdmFyIGlzQWN0aXZlID0gaSA9PT0gYWN0aXZlSW5kZXg7XG4gICAgICAgIHZhciBvcHRpb24gPSBpc0FjdGl2ZSA/IGFjdGl2ZUJhciA6IHNoYXBlO1xuICAgICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYmFzZVByb3BzKSwgZW50cnkpLCB7fSwge1xuICAgICAgICAgIGlzQWN0aXZlOiBpc0FjdGl2ZSxcbiAgICAgICAgICBvcHRpb246IG9wdGlvbixcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBkYXRhS2V5OiBkYXRhS2V5LFxuICAgICAgICAgIG9uQW5pbWF0aW9uU3RhcnQ6IF90aGlzMi5oYW5kbGVBbmltYXRpb25TdGFydCxcbiAgICAgICAgICBvbkFuaW1hdGlvbkVuZDogX3RoaXMyLmhhbmRsZUFuaW1hdGlvbkVuZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWJhci1yZWN0YW5nbGVcIlxuICAgICAgICB9LCAoMCwgX3R5cGVzLmFkYXB0RXZlbnRzT2ZDaGlsZCkoX3RoaXMyLnByb3BzLCBlbnRyeSwgaSksIHtcbiAgICAgICAgICBrZXk6IFwicmVjdGFuZ2xlLVwiLmNvbmNhdChlbnRyeSA9PT0gbnVsbCB8fCBlbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW50cnkueCwgXCItXCIpLmNvbmNhdChlbnRyeSA9PT0gbnVsbCB8fCBlbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW50cnkueSwgXCItXCIpLmNvbmNhdChlbnRyeSA9PT0gbnVsbCB8fCBlbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW50cnkudmFsdWUpXG4gICAgICAgIH0pLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9CYXJVdGlscy5CYXJSZWN0YW5nbGUsIHByb3BzKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyUmVjdGFuZ2xlc1dpdGhBbmltYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyUmVjdGFuZ2xlc1dpdGhBbmltYXRpb24oKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHMyLmRhdGEsXG4gICAgICAgIGxheW91dCA9IF90aGlzJHByb3BzMi5sYXlvdXQsXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHMyLmlzQW5pbWF0aW9uQWN0aXZlLFxuICAgICAgICBhbmltYXRpb25CZWdpbiA9IF90aGlzJHByb3BzMi5hbmltYXRpb25CZWdpbixcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb24gPSBfdGhpcyRwcm9wczIuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZyA9IF90aGlzJHByb3BzMi5hbmltYXRpb25FYXNpbmcsXG4gICAgICAgIGFuaW1hdGlvbklkID0gX3RoaXMkcHJvcHMyLmFuaW1hdGlvbklkO1xuICAgICAgdmFyIHByZXZEYXRhID0gdGhpcy5zdGF0ZS5wcmV2RGF0YTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9yZWFjdFNtb290aFtcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgYmVnaW46IGFuaW1hdGlvbkJlZ2luLFxuICAgICAgICBkdXJhdGlvbjogYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgIGlzQWN0aXZlOiBpc0FuaW1hdGlvbkFjdGl2ZSxcbiAgICAgICAgZWFzaW5nOiBhbmltYXRpb25FYXNpbmcsXG4gICAgICAgIGZyb206IHtcbiAgICAgICAgICB0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHRvOiB7XG4gICAgICAgICAgdDogMVxuICAgICAgICB9LFxuICAgICAgICBrZXk6IFwiYmFyLVwiLmNvbmNhdChhbmltYXRpb25JZCksXG4gICAgICAgIG9uQW5pbWF0aW9uRW5kOiB0aGlzLmhhbmRsZUFuaW1hdGlvbkVuZCxcbiAgICAgICAgb25BbmltYXRpb25TdGFydDogdGhpcy5oYW5kbGVBbmltYXRpb25TdGFydFxuICAgICAgfSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHQgPSBfcmVmLnQ7XG4gICAgICAgIHZhciBzdGVwRGF0YSA9IGRhdGEubWFwKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgcHJldiA9IHByZXZEYXRhICYmIHByZXZEYXRhW2luZGV4XTtcbiAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgdmFyIGludGVycG9sYXRvclggPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi54LCBlbnRyeS54KTtcbiAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JZID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXYueSwgZW50cnkueSk7XG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yV2lkdGggPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi53aWR0aCwgZW50cnkud2lkdGgpO1xuICAgICAgICAgICAgdmFyIGludGVycG9sYXRvckhlaWdodCA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2LmhlaWdodCwgZW50cnkuaGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcbiAgICAgICAgICAgICAgeDogaW50ZXJwb2xhdG9yWCh0KSxcbiAgICAgICAgICAgICAgeTogaW50ZXJwb2xhdG9yWSh0KSxcbiAgICAgICAgICAgICAgd2lkdGg6IGludGVycG9sYXRvcldpZHRoKHQpLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGludGVycG9sYXRvckhlaWdodCh0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsYXlvdXQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdmFyIF9pbnRlcnBvbGF0b3JIZWlnaHQgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikoMCwgZW50cnkuaGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciBoID0gX2ludGVycG9sYXRvckhlaWdodCh0KTtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcbiAgICAgICAgICAgICAgeTogZW50cnkueSArIGVudHJ5LmhlaWdodCAtIGgsXG4gICAgICAgICAgICAgIGhlaWdodDogaFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3IgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikoMCwgZW50cnkud2lkdGgpO1xuICAgICAgICAgIHZhciB3ID0gaW50ZXJwb2xhdG9yKHQpO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcbiAgICAgICAgICAgIHdpZHRoOiB3XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIG51bGwsIF90aGlzMy5yZW5kZXJSZWN0YW5nbGVzU3RhdGljYWxseShzdGVwRGF0YSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclJlY3RhbmdsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyUmVjdGFuZ2xlcygpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHMzLmRhdGEsXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHMzLmlzQW5pbWF0aW9uQWN0aXZlO1xuICAgICAgdmFyIHByZXZEYXRhID0gdGhpcy5zdGF0ZS5wcmV2RGF0YTtcbiAgICAgIGlmIChpc0FuaW1hdGlvbkFjdGl2ZSAmJiBkYXRhICYmIGRhdGEubGVuZ3RoICYmICghcHJldkRhdGEgfHwgISgwLCBfaXNFcXVhbFtcImRlZmF1bHRcIl0pKHByZXZEYXRhLCBkYXRhKSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUmVjdGFuZ2xlc1dpdGhBbmltYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclJlY3RhbmdsZXNTdGF0aWNhbGx5KGRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJCYWNrZ3JvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckJhY2tncm91bmQoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHM0LmRhdGEsXG4gICAgICAgIGRhdGFLZXkgPSBfdGhpcyRwcm9wczQuZGF0YUtleSxcbiAgICAgICAgYWN0aXZlSW5kZXggPSBfdGhpcyRwcm9wczQuYWN0aXZlSW5kZXg7XG4gICAgICB2YXIgYmFja2dyb3VuZFByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aGlzLnByb3BzLmJhY2tncm91bmQsIGZhbHNlKTtcbiAgICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZW50cnkudmFsdWUsXG4gICAgICAgICAgYmFja2dyb3VuZCA9IGVudHJ5LmJhY2tncm91bmQsXG4gICAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhlbnRyeSwgX2V4Y2x1ZGVkKTtcbiAgICAgICAgaWYgKCFiYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXN0KSwge30sIHtcbiAgICAgICAgICBmaWxsOiAnI2VlZSdcbiAgICAgICAgfSwgYmFja2dyb3VuZCksIGJhY2tncm91bmRQcm9wcyksICgwLCBfdHlwZXMuYWRhcHRFdmVudHNPZkNoaWxkKShfdGhpczQucHJvcHMsIGVudHJ5LCBpKSksIHt9LCB7XG4gICAgICAgICAgb25BbmltYXRpb25TdGFydDogX3RoaXM0LmhhbmRsZUFuaW1hdGlvblN0YXJ0LFxuICAgICAgICAgIG9uQW5pbWF0aW9uRW5kOiBfdGhpczQuaGFuZGxlQW5pbWF0aW9uRW5kLFxuICAgICAgICAgIGRhdGFLZXk6IGRhdGFLZXksXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgY2xhc3NOYW1lOiAncmVjaGFydHMtYmFyLWJhY2tncm91bmQtcmVjdGFuZ2xlJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0JhclV0aWxzLkJhclJlY3RhbmdsZSwgX2V4dGVuZHMoe1xuICAgICAgICAgIGtleTogXCJiYWNrZ3JvdW5kLWJhci1cIi5jb25jYXQoaSksXG4gICAgICAgICAgb3B0aW9uOiBfdGhpczQucHJvcHMuYmFja2dyb3VuZCxcbiAgICAgICAgICBpc0FjdGl2ZTogaSA9PT0gYWN0aXZlSW5kZXhcbiAgICAgICAgfSwgcHJvcHMpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJFcnJvckJhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJFcnJvckJhcihuZWVkQ2xpcCwgY2xpcFBhdGhJZCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMuaXNBbmltYXRpb25BY3RpdmUgJiYgIXRoaXMuc3RhdGUuaXNBbmltYXRpb25GaW5pc2hlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBfdGhpcyRwcm9wczUgPSB0aGlzLnByb3BzLFxuICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHM1LmRhdGEsXG4gICAgICAgIHhBeGlzID0gX3RoaXMkcHJvcHM1LnhBeGlzLFxuICAgICAgICB5QXhpcyA9IF90aGlzJHByb3BzNS55QXhpcyxcbiAgICAgICAgbGF5b3V0ID0gX3RoaXMkcHJvcHM1LmxheW91dCxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczUuY2hpbGRyZW47XG4gICAgICB2YXIgZXJyb3JCYXJJdGVtcyA9ICgwLCBfUmVhY3RVdGlscy5maW5kQWxsQnlUeXBlKShjaGlsZHJlbiwgX0Vycm9yQmFyLkVycm9yQmFyKTtcbiAgICAgIGlmICghZXJyb3JCYXJJdGVtcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSBsYXlvdXQgPT09ICd2ZXJ0aWNhbCcgPyBkYXRhWzBdLmhlaWdodCAvIDIgOiBkYXRhWzBdLndpZHRoIC8gMjtcbiAgICAgIHZhciBkYXRhUG9pbnRGb3JtYXR0ZXIgPSBmdW5jdGlvbiBkYXRhUG9pbnRGb3JtYXR0ZXIoZGF0YVBvaW50LCBkYXRhS2V5KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpZiB0aGUgdmFsdWUgY29taW5nIGZyb20gYGdldENvbXBvc2VkRGF0YWAgaXMgYW4gYXJyYXkgdGhlbiB0aGlzIGlzIGEgc3RhY2tlZCBiYXIgY2hhcnQuXG4gICAgICAgICAqIGFyclsxXSByZXByZXNlbnRzIGVuZCB2YWx1ZSBvZiB0aGUgYmFyIHNpbmNlIHRoZSBkYXRhIGlzIGluIHRoZSBmb3JtIG9mIFtzdGFydFZhbHVlLCBlbmRWYWx1ZV0uXG4gICAgICAgICAqICovXG4gICAgICAgIHZhciB2YWx1ZSA9IEFycmF5LmlzQXJyYXkoZGF0YVBvaW50LnZhbHVlKSA/IGRhdGFQb2ludC52YWx1ZVsxXSA6IGRhdGFQb2ludC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBkYXRhUG9pbnQueCxcbiAgICAgICAgICB5OiBkYXRhUG9pbnQueSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgZXJyb3JWYWw6ICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkoZGF0YVBvaW50LCBkYXRhS2V5KVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHZhciBlcnJvckJhclByb3BzID0ge1xuICAgICAgICBjbGlwUGF0aDogbmVlZENsaXAgPyBcInVybCgjY2xpcFBhdGgtXCIuY29uY2F0KGNsaXBQYXRoSWQsIFwiKVwiKSA6IG51bGxcbiAgICAgIH07XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIGVycm9yQmFyUHJvcHMsIGVycm9yQmFySXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQoaXRlbSwge1xuICAgICAgICAgIGtleTogXCJlcnJvci1iYXItXCIuY29uY2F0KGNsaXBQYXRoSWQsIFwiLVwiKS5jb25jYXQoaXRlbS5wcm9wcy5kYXRhS2V5KSxcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIHhBeGlzOiB4QXhpcyxcbiAgICAgICAgICB5QXhpczogeUF4aXMsXG4gICAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgZGF0YVBvaW50Rm9ybWF0dGVyOiBkYXRhUG9pbnRGb3JtYXR0ZXJcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM2ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgaGlkZSA9IF90aGlzJHByb3BzNi5oaWRlLFxuICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHM2LmRhdGEsXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzNi5jbGFzc05hbWUsXG4gICAgICAgIHhBeGlzID0gX3RoaXMkcHJvcHM2LnhBeGlzLFxuICAgICAgICB5QXhpcyA9IF90aGlzJHByb3BzNi55QXhpcyxcbiAgICAgICAgbGVmdCA9IF90aGlzJHByb3BzNi5sZWZ0LFxuICAgICAgICB0b3AgPSBfdGhpcyRwcm9wczYudG9wLFxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM2LmhlaWdodCxcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczYuaXNBbmltYXRpb25BY3RpdmUsXG4gICAgICAgIGJhY2tncm91bmQgPSBfdGhpcyRwcm9wczYuYmFja2dyb3VuZCxcbiAgICAgICAgaWQgPSBfdGhpcyRwcm9wczYuaWQ7XG4gICAgICBpZiAoaGlkZSB8fCAhZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgaXNBbmltYXRpb25GaW5pc2hlZCA9IHRoaXMuc3RhdGUuaXNBbmltYXRpb25GaW5pc2hlZDtcbiAgICAgIHZhciBsYXllckNsYXNzID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLWJhcicsIGNsYXNzTmFtZSk7XG4gICAgICB2YXIgbmVlZENsaXBYID0geEF4aXMgJiYgeEF4aXMuYWxsb3dEYXRhT3ZlcmZsb3c7XG4gICAgICB2YXIgbmVlZENsaXBZID0geUF4aXMgJiYgeUF4aXMuYWxsb3dEYXRhT3ZlcmZsb3c7XG4gICAgICB2YXIgbmVlZENsaXAgPSBuZWVkQ2xpcFggfHwgbmVlZENsaXBZO1xuICAgICAgdmFyIGNsaXBQYXRoSWQgPSAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoaWQpID8gdGhpcy5pZCA6IGlkO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XG4gICAgICAgIGNsYXNzTmFtZTogbGF5ZXJDbGFzc1xuICAgICAgfSwgbmVlZENsaXBYIHx8IG5lZWRDbGlwWSA/IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIsIG51bGwsIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiLCB7XG4gICAgICAgIGlkOiBcImNsaXBQYXRoLVwiLmNvbmNhdChjbGlwUGF0aElkKVxuICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAgICB4OiBuZWVkQ2xpcFggPyBsZWZ0IDogbGVmdCAtIHdpZHRoIC8gMixcbiAgICAgICAgeTogbmVlZENsaXBZID8gdG9wIDogdG9wIC0gaGVpZ2h0IC8gMixcbiAgICAgICAgd2lkdGg6IG5lZWRDbGlwWCA/IHdpZHRoIDogd2lkdGggKiAyLFxuICAgICAgICBoZWlnaHQ6IG5lZWRDbGlwWSA/IGhlaWdodCA6IGhlaWdodCAqIDJcbiAgICAgIH0pKSkgOiBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtYmFyLXJlY3RhbmdsZXNcIixcbiAgICAgICAgY2xpcFBhdGg6IG5lZWRDbGlwID8gXCJ1cmwoI2NsaXBQYXRoLVwiLmNvbmNhdChjbGlwUGF0aElkLCBcIilcIikgOiBudWxsXG4gICAgICB9LCBiYWNrZ3JvdW5kID8gdGhpcy5yZW5kZXJCYWNrZ3JvdW5kKCkgOiBudWxsLCB0aGlzLnJlbmRlclJlY3RhbmdsZXMoKSksIHRoaXMucmVuZGVyRXJyb3JCYXIobmVlZENsaXAsIGNsaXBQYXRoSWQpLCAoIWlzQW5pbWF0aW9uQWN0aXZlIHx8IGlzQW5pbWF0aW9uRmluaXNoZWQpICYmIF9MYWJlbExpc3QuTGFiZWxMaXN0LnJlbmRlckNhbGxCeVBhcmVudCh0aGlzLnByb3BzLCBkYXRhKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgaWYgKG5leHRQcm9wcy5hbmltYXRpb25JZCAhPT0gcHJldlN0YXRlLnByZXZBbmltYXRpb25JZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByZXZBbmltYXRpb25JZDogbmV4dFByb3BzLmFuaW1hdGlvbklkLFxuICAgICAgICAgIGN1ckRhdGE6IG5leHRQcm9wcy5kYXRhLFxuICAgICAgICAgIHByZXZEYXRhOiBwcmV2U3RhdGUuY3VyRGF0YVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKG5leHRQcm9wcy5kYXRhICE9PSBwcmV2U3RhdGUuY3VyRGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGN1ckRhdGE6IG5leHRQcm9wcy5kYXRhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcbn0oX3JlYWN0LlB1cmVDb21wb25lbnQpO1xuX0JhciA9IEJhcjtcbl9kZWZpbmVQcm9wZXJ0eShCYXIsIFwiZGlzcGxheU5hbWVcIiwgJ0JhcicpO1xuX2RlZmluZVByb3BlcnR5KEJhciwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICB4QXhpc0lkOiAwLFxuICB5QXhpc0lkOiAwLFxuICBsZWdlbmRUeXBlOiAncmVjdCcsXG4gIG1pblBvaW50U2l6ZTogMCxcbiAgaGlkZTogZmFsc2UsXG4gIGRhdGE6IFtdLFxuICBsYXlvdXQ6ICd2ZXJ0aWNhbCcsXG4gIGFjdGl2ZUJhcjogZmFsc2UsXG4gIGlzQW5pbWF0aW9uQWN0aXZlOiAhX0dsb2JhbC5HbG9iYWwuaXNTc3IsXG4gIGFuaW1hdGlvbkJlZ2luOiAwLFxuICBhbmltYXRpb25EdXJhdGlvbjogNDAwLFxuICBhbmltYXRpb25FYXNpbmc6ICdlYXNlJ1xufSk7XG4vKipcbiAqIENvbXBvc2UgdGhlIGRhdGEgb2YgZWFjaCBncm91cFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFByb3BzIGZvciB0aGUgY29tcG9uZW50XG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbSAgICAgICAgQW4gaW5zdGFuY2Ugb2YgQmFyXG4gKiBAcGFyYW0ge0FycmF5fSBiYXJQb3NpdGlvbiAgVGhlIG9mZnNldCBhbmQgc2l6ZSBvZiBlYWNoIGJhclxuICogQHBhcmFtIHtPYmplY3R9IHhBeGlzICAgICAgIFRoZSBjb25maWd1cmF0aW9uIG9mIHgtYXhpc1xuICogQHBhcmFtIHtPYmplY3R9IHlBeGlzICAgICAgIFRoZSBjb25maWd1cmF0aW9uIG9mIHktYXhpc1xuICogQHBhcmFtIHtBcnJheX0gc3RhY2tlZERhdGEgIFRoZSBzdGFja2VkIGRhdGEgb2YgYSBiYXIgaXRlbVxuICogQHJldHVybntBcnJheX0gQ29tcG9zZWQgZGF0YVxuICovXG5fZGVmaW5lUHJvcGVydHkoQmFyLCBcImdldENvbXBvc2VkRGF0YVwiLCBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgdmFyIHByb3BzID0gX3JlZjIucHJvcHMsXG4gICAgaXRlbSA9IF9yZWYyLml0ZW0sXG4gICAgYmFyUG9zaXRpb24gPSBfcmVmMi5iYXJQb3NpdGlvbixcbiAgICBiYW5kU2l6ZSA9IF9yZWYyLmJhbmRTaXplLFxuICAgIHhBeGlzID0gX3JlZjIueEF4aXMsXG4gICAgeUF4aXMgPSBfcmVmMi55QXhpcyxcbiAgICB4QXhpc1RpY2tzID0gX3JlZjIueEF4aXNUaWNrcyxcbiAgICB5QXhpc1RpY2tzID0gX3JlZjIueUF4aXNUaWNrcyxcbiAgICBzdGFja2VkRGF0YSA9IF9yZWYyLnN0YWNrZWREYXRhLFxuICAgIGRhdGFTdGFydEluZGV4ID0gX3JlZjIuZGF0YVN0YXJ0SW5kZXgsXG4gICAgZGlzcGxheWVkRGF0YSA9IF9yZWYyLmRpc3BsYXllZERhdGEsXG4gICAgb2Zmc2V0ID0gX3JlZjIub2Zmc2V0O1xuICB2YXIgcG9zID0gKDAsIF9DaGFydFV0aWxzLmZpbmRQb3NpdGlvbk9mQmFyKShiYXJQb3NpdGlvbiwgaXRlbSk7XG4gIGlmICghcG9zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGxheW91dCA9IHByb3BzLmxheW91dDtcbiAgdmFyIGl0ZW1EZWZhdWx0UHJvcHMgPSBpdGVtLnR5cGUuZGVmYXVsdFByb3BzO1xuICB2YXIgaXRlbVByb3BzID0gaXRlbURlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBpdGVtRGVmYXVsdFByb3BzKSwgaXRlbS5wcm9wcykgOiBpdGVtLnByb3BzO1xuICB2YXIgZGF0YUtleSA9IGl0ZW1Qcm9wcy5kYXRhS2V5LFxuICAgIGNoaWxkcmVuID0gaXRlbVByb3BzLmNoaWxkcmVuLFxuICAgIG1pblBvaW50U2l6ZVByb3AgPSBpdGVtUHJvcHMubWluUG9pbnRTaXplO1xuICB2YXIgbnVtZXJpY0F4aXMgPSBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IHlBeGlzIDogeEF4aXM7XG4gIHZhciBzdGFja2VkRG9tYWluID0gc3RhY2tlZERhdGEgPyBudW1lcmljQXhpcy5zY2FsZS5kb21haW4oKSA6IG51bGw7XG4gIHZhciBiYXNlVmFsdWUgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0QmFzZVZhbHVlT2ZCYXIpKHtcbiAgICBudW1lcmljQXhpczogbnVtZXJpY0F4aXNcbiAgfSk7XG4gIHZhciBjZWxscyA9ICgwLCBfUmVhY3RVdGlscy5maW5kQWxsQnlUeXBlKShjaGlsZHJlbiwgX0NlbGwuQ2VsbCk7XG4gIHZhciByZWN0cyA9IGRpc3BsYXllZERhdGEubWFwKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcbiAgICB2YXIgdmFsdWUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJhY2tncm91bmQ7XG4gICAgaWYgKHN0YWNrZWREYXRhKSB7XG4gICAgICB2YWx1ZSA9ICgwLCBfQ2hhcnRVdGlscy50cnVuY2F0ZUJ5RG9tYWluKShzdGFja2VkRGF0YVtkYXRhU3RhcnRJbmRleCArIGluZGV4XSwgc3RhY2tlZERvbWFpbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgZGF0YUtleSk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gW2Jhc2VWYWx1ZSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWluUG9pbnRTaXplID0gKDAsIF9CYXJVdGlscy5taW5Qb2ludFNpemVDYWxsYmFjaykobWluUG9pbnRTaXplUHJvcCwgX0Jhci5kZWZhdWx0UHJvcHMubWluUG9pbnRTaXplKSh2YWx1ZVsxXSwgaW5kZXgpO1xuICAgIGlmIChsYXlvdXQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgdmFyIF9yZWY0O1xuICAgICAgdmFyIF9yZWYzID0gW3lBeGlzLnNjYWxlKHZhbHVlWzBdKSwgeUF4aXMuc2NhbGUodmFsdWVbMV0pXSxcbiAgICAgICAgYmFzZVZhbHVlU2NhbGUgPSBfcmVmM1swXSxcbiAgICAgICAgY3VycmVudFZhbHVlU2NhbGUgPSBfcmVmM1sxXTtcbiAgICAgIHggPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0Q2F0ZUNvb3JkaW5hdGVPZkJhcikoe1xuICAgICAgICBheGlzOiB4QXhpcyxcbiAgICAgICAgdGlja3M6IHhBeGlzVGlja3MsXG4gICAgICAgIGJhbmRTaXplOiBiYW5kU2l6ZSxcbiAgICAgICAgb2Zmc2V0OiBwb3Mub2Zmc2V0LFxuICAgICAgICBlbnRyeTogZW50cnksXG4gICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgfSk7XG4gICAgICB5ID0gKF9yZWY0ID0gY3VycmVudFZhbHVlU2NhbGUgIT09IG51bGwgJiYgY3VycmVudFZhbHVlU2NhbGUgIT09IHZvaWQgMCA/IGN1cnJlbnRWYWx1ZVNjYWxlIDogYmFzZVZhbHVlU2NhbGUpICE9PSBudWxsICYmIF9yZWY0ICE9PSB2b2lkIDAgPyBfcmVmNCA6IHVuZGVmaW5lZDtcbiAgICAgIHdpZHRoID0gcG9zLnNpemU7XG4gICAgICB2YXIgY29tcHV0ZWRIZWlnaHQgPSBiYXNlVmFsdWVTY2FsZSAtIGN1cnJlbnRWYWx1ZVNjYWxlO1xuICAgICAgaGVpZ2h0ID0gTnVtYmVyLmlzTmFOKGNvbXB1dGVkSGVpZ2h0KSA/IDAgOiBjb21wdXRlZEhlaWdodDtcbiAgICAgIGJhY2tncm91bmQgPSB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlBeGlzLnksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB5QXhpcy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBpZiAoTWF0aC5hYnMobWluUG9pbnRTaXplKSA+IDAgJiYgTWF0aC5hYnMoaGVpZ2h0KSA8IE1hdGguYWJzKG1pblBvaW50U2l6ZSkpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gKDAsIF9EYXRhVXRpbHMubWF0aFNpZ24pKGhlaWdodCB8fCBtaW5Qb2ludFNpemUpICogKE1hdGguYWJzKG1pblBvaW50U2l6ZSkgLSBNYXRoLmFicyhoZWlnaHQpKTtcbiAgICAgICAgeSAtPSBkZWx0YTtcbiAgICAgICAgaGVpZ2h0ICs9IGRlbHRhO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3JlZjUgPSBbeEF4aXMuc2NhbGUodmFsdWVbMF0pLCB4QXhpcy5zY2FsZSh2YWx1ZVsxXSldLFxuICAgICAgICBfYmFzZVZhbHVlU2NhbGUgPSBfcmVmNVswXSxcbiAgICAgICAgX2N1cnJlbnRWYWx1ZVNjYWxlID0gX3JlZjVbMV07XG4gICAgICB4ID0gX2Jhc2VWYWx1ZVNjYWxlO1xuICAgICAgeSA9ICgwLCBfQ2hhcnRVdGlscy5nZXRDYXRlQ29vcmRpbmF0ZU9mQmFyKSh7XG4gICAgICAgIGF4aXM6IHlBeGlzLFxuICAgICAgICB0aWNrczogeUF4aXNUaWNrcyxcbiAgICAgICAgYmFuZFNpemU6IGJhbmRTaXplLFxuICAgICAgICBvZmZzZXQ6IHBvcy5vZmZzZXQsXG4gICAgICAgIGVudHJ5OiBlbnRyeSxcbiAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICB9KTtcbiAgICAgIHdpZHRoID0gX2N1cnJlbnRWYWx1ZVNjYWxlIC0gX2Jhc2VWYWx1ZVNjYWxlO1xuICAgICAgaGVpZ2h0ID0gcG9zLnNpemU7XG4gICAgICBiYWNrZ3JvdW5kID0ge1xuICAgICAgICB4OiB4QXhpcy54LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogeEF4aXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgICAgaWYgKE1hdGguYWJzKG1pblBvaW50U2l6ZSkgPiAwICYmIE1hdGguYWJzKHdpZHRoKSA8IE1hdGguYWJzKG1pblBvaW50U2l6ZSkpIHtcbiAgICAgICAgdmFyIF9kZWx0YSA9ICgwLCBfRGF0YVV0aWxzLm1hdGhTaWduKSh3aWR0aCB8fCBtaW5Qb2ludFNpemUpICogKE1hdGguYWJzKG1pblBvaW50U2l6ZSkgLSBNYXRoLmFicyh3aWR0aCkpO1xuICAgICAgICB3aWR0aCArPSBfZGVsdGE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHZhbHVlOiBzdGFja2VkRGF0YSA/IHZhbHVlIDogdmFsdWVbMV0sXG4gICAgICBwYXlsb2FkOiBlbnRyeSxcbiAgICAgIGJhY2tncm91bmQ6IGJhY2tncm91bmRcbiAgICB9LCBjZWxscyAmJiBjZWxsc1tpbmRleF0gJiYgY2VsbHNbaW5kZXhdLnByb3BzKSwge30sIHtcbiAgICAgIHRvb2x0aXBQYXlsb2FkOiBbKDAsIF9DaGFydFV0aWxzLmdldFRvb2x0aXBJdGVtKShpdGVtLCBlbnRyeSldLFxuICAgICAgdG9vbHRpcFBvc2l0aW9uOiB7XG4gICAgICAgIHg6IHggKyB3aWR0aCAvIDIsXG4gICAgICAgIHk6IHkgKyBoZWlnaHQgLyAyXG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgZGF0YTogcmVjdHMsXG4gICAgbGF5b3V0OiBsYXlvdXRcbiAgfSwgb2Zmc2V0KTtcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJhciIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9jbHN4IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9yZWFjdFNtb290aCIsIl9pc0VxdWFsIiwiX2lzTmlsIiwiX0xheWVyIiwiX0Vycm9yQmFyIiwiX0NlbGwiLCJfTGFiZWxMaXN0IiwiX0RhdGFVdGlscyIsIl9SZWFjdFV0aWxzIiwiX0dsb2JhbCIsIl9DaGFydFV0aWxzIiwiX3R5cGVzIiwiX0JhclV0aWxzIiwiX2V4Y2x1ZGVkIiwiX0JhciIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZSIsImV4Y2x1ZGVkIiwidGFyZ2V0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJrZXkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwibGVuZ3RoIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJvd25LZXlzIiwia2V5cyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJfUHVyZUNvbXBvbmVudCIsIl90aGlzIiwiX2xlbiIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJjb25jYXQiLCJpc0FuaW1hdGlvbkZpbmlzaGVkIiwidW5pcXVlSWQiLCJvbkFuaW1hdGlvbkVuZCIsInNldFN0YXRlIiwib25BbmltYXRpb25TdGFydCIsInJlbmRlclJlY3RhbmdsZXNTdGF0aWNhbGx5IiwiZGF0YSIsIl90aGlzMiIsIl90aGlzJHByb3BzIiwic2hhcGUiLCJkYXRhS2V5IiwiYWN0aXZlSW5kZXgiLCJhY3RpdmVCYXIiLCJiYXNlUHJvcHMiLCJmaWx0ZXJQcm9wcyIsIm1hcCIsImVudHJ5IiwiaXNBY3RpdmUiLCJvcHRpb24iLCJpbmRleCIsImhhbmRsZUFuaW1hdGlvblN0YXJ0IiwiaGFuZGxlQW5pbWF0aW9uRW5kIiwiY3JlYXRlRWxlbWVudCIsIkxheWVyIiwiY2xhc3NOYW1lIiwiYWRhcHRFdmVudHNPZkNoaWxkIiwieCIsInkiLCJCYXJSZWN0YW5nbGUiLCJyZW5kZXJSZWN0YW5nbGVzV2l0aEFuaW1hdGlvbiIsIl90aGlzMyIsIl90aGlzJHByb3BzMiIsImxheW91dCIsImlzQW5pbWF0aW9uQWN0aXZlIiwiYW5pbWF0aW9uQmVnaW4iLCJhbmltYXRpb25EdXJhdGlvbiIsImFuaW1hdGlvbkVhc2luZyIsImFuaW1hdGlvbklkIiwicHJldkRhdGEiLCJzdGF0ZSIsImJlZ2luIiwiZHVyYXRpb24iLCJlYXNpbmciLCJmcm9tIiwidG8iLCJfcmVmIiwic3RlcERhdGEiLCJwcmV2IiwiaW50ZXJwb2xhdG9yWCIsImludGVycG9sYXRlTnVtYmVyIiwiaW50ZXJwb2xhdG9yWSIsImludGVycG9sYXRvcldpZHRoIiwid2lkdGgiLCJpbnRlcnBvbGF0b3JIZWlnaHQiLCJoZWlnaHQiLCJfaW50ZXJwb2xhdG9ySGVpZ2h0IiwiaCIsImludGVycG9sYXRvciIsInciLCJyZW5kZXJSZWN0YW5nbGVzIiwiX3RoaXMkcHJvcHMzIiwicmVuZGVyQmFja2dyb3VuZCIsIl90aGlzNCIsIl90aGlzJHByb3BzNCIsImJhY2tncm91bmRQcm9wcyIsImJhY2tncm91bmQiLCJyZXN0IiwiZmlsbCIsInJlbmRlckVycm9yQmFyIiwibmVlZENsaXAiLCJjbGlwUGF0aElkIiwiX3RoaXMkcHJvcHM1IiwieEF4aXMiLCJ5QXhpcyIsImNoaWxkcmVuIiwiZXJyb3JCYXJJdGVtcyIsImZpbmRBbGxCeVR5cGUiLCJFcnJvckJhciIsIm9mZnNldCIsImRhdGFQb2ludEZvcm1hdHRlciIsImRhdGFQb2ludCIsImlzQXJyYXkiLCJlcnJvclZhbCIsImdldFZhbHVlQnlEYXRhS2V5IiwiZXJyb3JCYXJQcm9wcyIsImNsaXBQYXRoIiwiaXRlbSIsImNsb25lRWxlbWVudCIsInJlbmRlciIsIl90aGlzJHByb3BzNiIsImhpZGUiLCJsZWZ0IiwidG9wIiwiaWQiLCJsYXllckNsYXNzIiwibmVlZENsaXBYIiwiYWxsb3dEYXRhT3ZlcmZsb3ciLCJuZWVkQ2xpcFkiLCJMYWJlbExpc3QiLCJyZW5kZXJDYWxsQnlQYXJlbnQiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJuZXh0UHJvcHMiLCJwcmV2U3RhdGUiLCJwcmV2QW5pbWF0aW9uSWQiLCJjdXJEYXRhIiwiUHVyZUNvbXBvbmVudCIsInhBeGlzSWQiLCJ5QXhpc0lkIiwibGVnZW5kVHlwZSIsIm1pblBvaW50U2l6ZSIsIkdsb2JhbCIsImlzU3NyIiwiX3JlZjIiLCJiYXJQb3NpdGlvbiIsImJhbmRTaXplIiwieEF4aXNUaWNrcyIsInlBeGlzVGlja3MiLCJzdGFja2VkRGF0YSIsImRhdGFTdGFydEluZGV4IiwiZGlzcGxheWVkRGF0YSIsInBvcyIsImZpbmRQb3NpdGlvbk9mQmFyIiwiaXRlbURlZmF1bHRQcm9wcyIsInR5cGUiLCJkZWZhdWx0UHJvcHMiLCJpdGVtUHJvcHMiLCJ1bmRlZmluZWQiLCJtaW5Qb2ludFNpemVQcm9wIiwibnVtZXJpY0F4aXMiLCJzdGFja2VkRG9tYWluIiwic2NhbGUiLCJkb21haW4iLCJiYXNlVmFsdWUiLCJnZXRCYXNlVmFsdWVPZkJhciIsImNlbGxzIiwiQ2VsbCIsInJlY3RzIiwidHJ1bmNhdGVCeURvbWFpbiIsIm1pblBvaW50U2l6ZUNhbGxiYWNrIiwiX3JlZjQiLCJfcmVmMyIsImJhc2VWYWx1ZVNjYWxlIiwiY3VycmVudFZhbHVlU2NhbGUiLCJnZXRDYXRlQ29vcmRpbmF0ZU9mQmFyIiwiYXhpcyIsInRpY2tzIiwic2l6ZSIsImNvbXB1dGVkSGVpZ2h0IiwiaXNOYU4iLCJNYXRoIiwiYWJzIiwiZGVsdGEiLCJtYXRoU2lnbiIsIl9yZWY1IiwiX2Jhc2VWYWx1ZVNjYWxlIiwiX2N1cnJlbnRWYWx1ZVNjYWxlIiwiX2RlbHRhIiwicGF5bG9hZCIsInRvb2x0aXBQYXlsb2FkIiwiZ2V0VG9vbHRpcEl0ZW0iLCJ0b29sdGlwUG9zaXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/Bar.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/cartesian/Brush.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/Brush.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Brush = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _d3Scale = __webpack_require__(/*! victory-vendor/d3-scale */ \"victory-vendor/d3-scale\");\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _range = _interopRequireDefault(__webpack_require__(/*! lodash/range */ \"lodash/range\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _Text = __webpack_require__(/*! ../component/Text */ \"./node_modules/recharts/lib/component/Text.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _CssPrefixUtils = __webpack_require__(/*! ../util/CssPrefixUtils */ \"./node_modules/recharts/lib/util/CssPrefixUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Brush\n */ \nvar createScale = function createScale(_ref) {\n    var data = _ref.data, startIndex = _ref.startIndex, endIndex = _ref.endIndex, x = _ref.x, width = _ref.width, travellerWidth = _ref.travellerWidth;\n    if (!data || !data.length) {\n        return {};\n    }\n    var len = data.length;\n    var scale = (0, _d3Scale.scalePoint)().domain((0, _range[\"default\"])(0, len)).range([\n        x,\n        x + width - travellerWidth\n    ]);\n    var scaleValues = scale.domain().map(function(entry) {\n        return scale(entry);\n    });\n    return {\n        isTextActive: false,\n        isSlideMoving: false,\n        isTravellerMoving: false,\n        isTravellerFocused: false,\n        startX: scale(startIndex),\n        endX: scale(endIndex),\n        scale: scale,\n        scaleValues: scaleValues\n    };\n};\nvar isTouch = function isTouch(e) {\n    return e.changedTouches && !!e.changedTouches.length;\n};\nvar Brush = exports.Brush = /*#__PURE__*/ function(_PureComponent) {\n    function Brush(props) {\n        var _this;\n        _classCallCheck(this, Brush);\n        _this = _callSuper(this, Brush, [\n            props\n        ]);\n        _defineProperty(_this, \"handleDrag\", function(e) {\n            if (_this.leaveTimer) {\n                clearTimeout(_this.leaveTimer);\n                _this.leaveTimer = null;\n            }\n            if (_this.state.isTravellerMoving) {\n                _this.handleTravellerMove(e);\n            } else if (_this.state.isSlideMoving) {\n                _this.handleSlideDrag(e);\n            }\n        });\n        _defineProperty(_this, \"handleTouchMove\", function(e) {\n            if (e.changedTouches != null && e.changedTouches.length > 0) {\n                _this.handleDrag(e.changedTouches[0]);\n            }\n        });\n        _defineProperty(_this, \"handleDragEnd\", function() {\n            _this.setState({\n                isTravellerMoving: false,\n                isSlideMoving: false\n            }, function() {\n                var _this$props = _this.props, endIndex = _this$props.endIndex, onDragEnd = _this$props.onDragEnd, startIndex = _this$props.startIndex;\n                onDragEnd === null || onDragEnd === void 0 || onDragEnd({\n                    endIndex: endIndex,\n                    startIndex: startIndex\n                });\n            });\n            _this.detachDragEndListener();\n        });\n        _defineProperty(_this, \"handleLeaveWrapper\", function() {\n            if (_this.state.isTravellerMoving || _this.state.isSlideMoving) {\n                _this.leaveTimer = window.setTimeout(_this.handleDragEnd, _this.props.leaveTimeOut);\n            }\n        });\n        _defineProperty(_this, \"handleEnterSlideOrTraveller\", function() {\n            _this.setState({\n                isTextActive: true\n            });\n        });\n        _defineProperty(_this, \"handleLeaveSlideOrTraveller\", function() {\n            _this.setState({\n                isTextActive: false\n            });\n        });\n        _defineProperty(_this, \"handleSlideDragStart\", function(e) {\n            var event = isTouch(e) ? e.changedTouches[0] : e;\n            _this.setState({\n                isTravellerMoving: false,\n                isSlideMoving: true,\n                slideMoveStartX: event.pageX\n            });\n            _this.attachDragEndListener();\n        });\n        _this.travellerDragStartHandlers = {\n            startX: _this.handleTravellerDragStart.bind(_this, \"startX\"),\n            endX: _this.handleTravellerDragStart.bind(_this, \"endX\")\n        };\n        _this.state = {};\n        return _this;\n    }\n    _inherits(Brush, _PureComponent);\n    return _createClass(Brush, [\n        {\n            key: \"componentWillUnmount\",\n            value: function componentWillUnmount() {\n                if (this.leaveTimer) {\n                    clearTimeout(this.leaveTimer);\n                    this.leaveTimer = null;\n                }\n                this.detachDragEndListener();\n            }\n        },\n        {\n            key: \"getIndex\",\n            value: function getIndex(_ref2) {\n                var startX = _ref2.startX, endX = _ref2.endX;\n                var scaleValues = this.state.scaleValues;\n                var _this$props2 = this.props, gap = _this$props2.gap, data = _this$props2.data;\n                var lastIndex = data.length - 1;\n                var min = Math.min(startX, endX);\n                var max = Math.max(startX, endX);\n                var minIndex = Brush.getIndexInRange(scaleValues, min);\n                var maxIndex = Brush.getIndexInRange(scaleValues, max);\n                return {\n                    startIndex: minIndex - minIndex % gap,\n                    endIndex: maxIndex === lastIndex ? lastIndex : maxIndex - maxIndex % gap\n                };\n            }\n        },\n        {\n            key: \"getTextOfTick\",\n            value: function getTextOfTick(index) {\n                var _this$props3 = this.props, data = _this$props3.data, tickFormatter = _this$props3.tickFormatter, dataKey = _this$props3.dataKey;\n                var text = (0, _ChartUtils.getValueByDataKey)(data[index], dataKey, index);\n                return (0, _isFunction[\"default\"])(tickFormatter) ? tickFormatter(text, index) : text;\n            }\n        },\n        {\n            key: \"attachDragEndListener\",\n            value: function attachDragEndListener() {\n                window.addEventListener(\"mouseup\", this.handleDragEnd, true);\n                window.addEventListener(\"touchend\", this.handleDragEnd, true);\n                window.addEventListener(\"mousemove\", this.handleDrag, true);\n            }\n        },\n        {\n            key: \"detachDragEndListener\",\n            value: function detachDragEndListener() {\n                window.removeEventListener(\"mouseup\", this.handleDragEnd, true);\n                window.removeEventListener(\"touchend\", this.handleDragEnd, true);\n                window.removeEventListener(\"mousemove\", this.handleDrag, true);\n            }\n        },\n        {\n            key: \"handleSlideDrag\",\n            value: function handleSlideDrag(e) {\n                var _this$state = this.state, slideMoveStartX = _this$state.slideMoveStartX, startX = _this$state.startX, endX = _this$state.endX;\n                var _this$props4 = this.props, x = _this$props4.x, width = _this$props4.width, travellerWidth = _this$props4.travellerWidth, startIndex = _this$props4.startIndex, endIndex = _this$props4.endIndex, onChange = _this$props4.onChange;\n                var delta = e.pageX - slideMoveStartX;\n                if (delta > 0) {\n                    delta = Math.min(delta, x + width - travellerWidth - endX, x + width - travellerWidth - startX);\n                } else if (delta < 0) {\n                    delta = Math.max(delta, x - startX, x - endX);\n                }\n                var newIndex = this.getIndex({\n                    startX: startX + delta,\n                    endX: endX + delta\n                });\n                if ((newIndex.startIndex !== startIndex || newIndex.endIndex !== endIndex) && onChange) {\n                    onChange(newIndex);\n                }\n                this.setState({\n                    startX: startX + delta,\n                    endX: endX + delta,\n                    slideMoveStartX: e.pageX\n                });\n            }\n        },\n        {\n            key: \"handleTravellerDragStart\",\n            value: function handleTravellerDragStart(id, e) {\n                var event = isTouch(e) ? e.changedTouches[0] : e;\n                this.setState({\n                    isSlideMoving: false,\n                    isTravellerMoving: true,\n                    movingTravellerId: id,\n                    brushMoveStartX: event.pageX\n                });\n                this.attachDragEndListener();\n            }\n        },\n        {\n            key: \"handleTravellerMove\",\n            value: function handleTravellerMove(e) {\n                var _this$state2 = this.state, brushMoveStartX = _this$state2.brushMoveStartX, movingTravellerId = _this$state2.movingTravellerId, endX = _this$state2.endX, startX = _this$state2.startX;\n                var prevValue = this.state[movingTravellerId];\n                var _this$props5 = this.props, x = _this$props5.x, width = _this$props5.width, travellerWidth = _this$props5.travellerWidth, onChange = _this$props5.onChange, gap = _this$props5.gap, data = _this$props5.data;\n                var params = {\n                    startX: this.state.startX,\n                    endX: this.state.endX\n                };\n                var delta = e.pageX - brushMoveStartX;\n                if (delta > 0) {\n                    delta = Math.min(delta, x + width - travellerWidth - prevValue);\n                } else if (delta < 0) {\n                    delta = Math.max(delta, x - prevValue);\n                }\n                params[movingTravellerId] = prevValue + delta;\n                var newIndex = this.getIndex(params);\n                var startIndex = newIndex.startIndex, endIndex = newIndex.endIndex;\n                var isFullGap = function isFullGap() {\n                    var lastIndex = data.length - 1;\n                    if (movingTravellerId === \"startX\" && (endX > startX ? startIndex % gap === 0 : endIndex % gap === 0) || endX < startX && endIndex === lastIndex || movingTravellerId === \"endX\" && (endX > startX ? endIndex % gap === 0 : startIndex % gap === 0) || endX > startX && endIndex === lastIndex) {\n                        return true;\n                    }\n                    return false;\n                };\n                this.setState(_defineProperty(_defineProperty({}, movingTravellerId, prevValue + delta), \"brushMoveStartX\", e.pageX), function() {\n                    if (onChange) {\n                        if (isFullGap()) {\n                            onChange(newIndex);\n                        }\n                    }\n                });\n            }\n        },\n        {\n            key: \"handleTravellerMoveKeyboard\",\n            value: function handleTravellerMoveKeyboard(direction, id) {\n                var _this2 = this;\n                // scaleValues are a list of coordinates. For example: [65, 250, 435, 620, 805, 990].\n                var _this$state3 = this.state, scaleValues = _this$state3.scaleValues, startX = _this$state3.startX, endX = _this$state3.endX;\n                // currentScaleValue refers to which coordinate the current traveller should be placed at.\n                var currentScaleValue = this.state[id];\n                var currentIndex = scaleValues.indexOf(currentScaleValue);\n                if (currentIndex === -1) {\n                    return;\n                }\n                var newIndex = currentIndex + direction;\n                if (newIndex === -1 || newIndex >= scaleValues.length) {\n                    return;\n                }\n                var newScaleValue = scaleValues[newIndex];\n                // Prevent travellers from being on top of each other or overlapping\n                if (id === \"startX\" && newScaleValue >= endX || id === \"endX\" && newScaleValue <= startX) {\n                    return;\n                }\n                this.setState(_defineProperty({}, id, newScaleValue), function() {\n                    _this2.props.onChange(_this2.getIndex({\n                        startX: _this2.state.startX,\n                        endX: _this2.state.endX\n                    }));\n                });\n            }\n        },\n        {\n            key: \"renderBackground\",\n            value: function renderBackground() {\n                var _this$props6 = this.props, x = _this$props6.x, y = _this$props6.y, width = _this$props6.width, height = _this$props6.height, fill = _this$props6.fill, stroke = _this$props6.stroke;\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    stroke: stroke,\n                    fill: fill,\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }\n        },\n        {\n            key: \"renderPanorama\",\n            value: function renderPanorama() {\n                var _this$props7 = this.props, x = _this$props7.x, y = _this$props7.y, width = _this$props7.width, height = _this$props7.height, data = _this$props7.data, children = _this$props7.children, padding = _this$props7.padding;\n                var chartElement = _react.Children.only(children);\n                if (!chartElement) {\n                    return null;\n                }\n                return /*#__PURE__*/ _react[\"default\"].cloneElement(chartElement, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height,\n                    margin: padding,\n                    compact: true,\n                    data: data\n                });\n            }\n        },\n        {\n            key: \"renderTravellerLayer\",\n            value: function renderTravellerLayer(travellerX, id) {\n                var _data$startIndex, _data$endIndex, _this3 = this;\n                var _this$props8 = this.props, y = _this$props8.y, travellerWidth = _this$props8.travellerWidth, height = _this$props8.height, traveller = _this$props8.traveller, ariaLabel = _this$props8.ariaLabel, data = _this$props8.data, startIndex = _this$props8.startIndex, endIndex = _this$props8.endIndex;\n                var x = Math.max(travellerX, this.props.x);\n                var travellerProps = _objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(this.props, false)), {}, {\n                    x: x,\n                    y: y,\n                    width: travellerWidth,\n                    height: height\n                });\n                var ariaLabelBrush = ariaLabel || \"Min value: \".concat((_data$startIndex = data[startIndex]) === null || _data$startIndex === void 0 ? void 0 : _data$startIndex.name, \", Max value: \").concat((_data$endIndex = data[endIndex]) === null || _data$endIndex === void 0 ? void 0 : _data$endIndex.name);\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    tabIndex: 0,\n                    role: \"slider\",\n                    \"aria-label\": ariaLabelBrush,\n                    \"aria-valuenow\": travellerX,\n                    className: \"recharts-brush-traveller\",\n                    onMouseEnter: this.handleEnterSlideOrTraveller,\n                    onMouseLeave: this.handleLeaveSlideOrTraveller,\n                    onMouseDown: this.travellerDragStartHandlers[id],\n                    onTouchStart: this.travellerDragStartHandlers[id],\n                    onKeyDown: function onKeyDown(e) {\n                        if (![\n                            \"ArrowLeft\",\n                            \"ArrowRight\"\n                        ].includes(e.key)) {\n                            return;\n                        }\n                        e.preventDefault();\n                        e.stopPropagation();\n                        _this3.handleTravellerMoveKeyboard(e.key === \"ArrowRight\" ? 1 : -1, id);\n                    },\n                    onFocus: function onFocus() {\n                        _this3.setState({\n                            isTravellerFocused: true\n                        });\n                    },\n                    onBlur: function onBlur() {\n                        _this3.setState({\n                            isTravellerFocused: false\n                        });\n                    },\n                    style: {\n                        cursor: \"col-resize\"\n                    }\n                }, Brush.renderTraveller(traveller, travellerProps));\n            }\n        },\n        {\n            key: \"renderSlide\",\n            value: function renderSlide(startX, endX) {\n                var _this$props9 = this.props, y = _this$props9.y, height = _this$props9.height, stroke = _this$props9.stroke, travellerWidth = _this$props9.travellerWidth;\n                var x = Math.min(startX, endX) + travellerWidth;\n                var width = Math.max(Math.abs(endX - startX) - travellerWidth, 0);\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    className: \"recharts-brush-slide\",\n                    onMouseEnter: this.handleEnterSlideOrTraveller,\n                    onMouseLeave: this.handleLeaveSlideOrTraveller,\n                    onMouseDown: this.handleSlideDragStart,\n                    onTouchStart: this.handleSlideDragStart,\n                    style: {\n                        cursor: \"move\"\n                    },\n                    stroke: \"none\",\n                    fill: stroke,\n                    fillOpacity: 0.2,\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }\n        },\n        {\n            key: \"renderText\",\n            value: function renderText() {\n                var _this$props10 = this.props, startIndex = _this$props10.startIndex, endIndex = _this$props10.endIndex, y = _this$props10.y, height = _this$props10.height, travellerWidth = _this$props10.travellerWidth, stroke = _this$props10.stroke;\n                var _this$state4 = this.state, startX = _this$state4.startX, endX = _this$state4.endX;\n                var offset = 5;\n                var attrs = {\n                    pointerEvents: \"none\",\n                    fill: stroke\n                };\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-brush-texts\"\n                }, /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({\n                    textAnchor: \"end\",\n                    verticalAnchor: \"middle\",\n                    x: Math.min(startX, endX) - offset,\n                    y: y + height / 2\n                }, attrs), this.getTextOfTick(startIndex)), /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({\n                    textAnchor: \"start\",\n                    verticalAnchor: \"middle\",\n                    x: Math.max(startX, endX) + travellerWidth + offset,\n                    y: y + height / 2\n                }, attrs), this.getTextOfTick(endIndex)));\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props11 = this.props, data = _this$props11.data, className = _this$props11.className, children = _this$props11.children, x = _this$props11.x, y = _this$props11.y, width = _this$props11.width, height = _this$props11.height, alwaysShowText = _this$props11.alwaysShowText;\n                var _this$state5 = this.state, startX = _this$state5.startX, endX = _this$state5.endX, isTextActive = _this$state5.isTextActive, isSlideMoving = _this$state5.isSlideMoving, isTravellerMoving = _this$state5.isTravellerMoving, isTravellerFocused = _this$state5.isTravellerFocused;\n                if (!data || !data.length || !(0, _DataUtils.isNumber)(x) || !(0, _DataUtils.isNumber)(y) || !(0, _DataUtils.isNumber)(width) || !(0, _DataUtils.isNumber)(height) || width <= 0 || height <= 0) {\n                    return null;\n                }\n                var layerClass = (0, _clsx[\"default\"])(\"recharts-brush\", className);\n                var isPanoramic = _react[\"default\"].Children.count(children) === 1;\n                var style = (0, _CssPrefixUtils.generatePrefixStyle)(\"userSelect\", \"none\");\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass,\n                    onMouseLeave: this.handleLeaveWrapper,\n                    onTouchMove: this.handleTouchMove,\n                    style: style\n                }, this.renderBackground(), isPanoramic && this.renderPanorama(), this.renderSlide(startX, endX), this.renderTravellerLayer(startX, \"startX\"), this.renderTravellerLayer(endX, \"endX\"), (isTextActive || isSlideMoving || isTravellerMoving || isTravellerFocused || alwaysShowText) && this.renderText());\n            }\n        }\n    ], [\n        {\n            key: \"renderDefaultTraveller\",\n            value: function renderDefaultTraveller(props) {\n                var x = props.x, y = props.y, width = props.width, height = props.height, stroke = props.stroke;\n                var lineY = Math.floor(y + height / 2) - 1;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_react[\"default\"].Fragment, null, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height,\n                    fill: stroke,\n                    stroke: \"none\"\n                }), /*#__PURE__*/ _react[\"default\"].createElement(\"line\", {\n                    x1: x + 1,\n                    y1: lineY,\n                    x2: x + width - 1,\n                    y2: lineY,\n                    fill: \"none\",\n                    stroke: \"#fff\"\n                }), /*#__PURE__*/ _react[\"default\"].createElement(\"line\", {\n                    x1: x + 1,\n                    y1: lineY + 2,\n                    x2: x + width - 1,\n                    y2: lineY + 2,\n                    fill: \"none\",\n                    stroke: \"#fff\"\n                }));\n            }\n        },\n        {\n            key: \"renderTraveller\",\n            value: function renderTraveller(option, props) {\n                var rectangle;\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    rectangle = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                } else if ((0, _isFunction[\"default\"])(option)) {\n                    rectangle = option(props);\n                } else {\n                    rectangle = Brush.renderDefaultTraveller(props);\n                }\n                return rectangle;\n            }\n        },\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                var data = nextProps.data, width = nextProps.width, x = nextProps.x, travellerWidth = nextProps.travellerWidth, updateId = nextProps.updateId, startIndex = nextProps.startIndex, endIndex = nextProps.endIndex;\n                if (data !== prevState.prevData || updateId !== prevState.prevUpdateId) {\n                    return _objectSpread({\n                        prevData: data,\n                        prevTravellerWidth: travellerWidth,\n                        prevUpdateId: updateId,\n                        prevX: x,\n                        prevWidth: width\n                    }, data && data.length ? createScale({\n                        data: data,\n                        width: width,\n                        x: x,\n                        travellerWidth: travellerWidth,\n                        startIndex: startIndex,\n                        endIndex: endIndex\n                    }) : {\n                        scale: null,\n                        scaleValues: null\n                    });\n                }\n                if (prevState.scale && (width !== prevState.prevWidth || x !== prevState.prevX || travellerWidth !== prevState.prevTravellerWidth)) {\n                    prevState.scale.range([\n                        x,\n                        x + width - travellerWidth\n                    ]);\n                    var scaleValues = prevState.scale.domain().map(function(entry) {\n                        return prevState.scale(entry);\n                    });\n                    return {\n                        prevData: data,\n                        prevTravellerWidth: travellerWidth,\n                        prevUpdateId: updateId,\n                        prevX: x,\n                        prevWidth: width,\n                        startX: prevState.scale(nextProps.startIndex),\n                        endX: prevState.scale(nextProps.endIndex),\n                        scaleValues: scaleValues\n                    };\n                }\n                return null;\n            }\n        },\n        {\n            key: \"getIndexInRange\",\n            value: function getIndexInRange(valueRange, x) {\n                var len = valueRange.length;\n                var start = 0;\n                var end = len - 1;\n                while(end - start > 1){\n                    var middle = Math.floor((start + end) / 2);\n                    if (valueRange[middle] > x) {\n                        end = middle;\n                    } else {\n                        start = middle;\n                    }\n                }\n                return x >= valueRange[end] ? end : start;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(Brush, \"displayName\", \"Brush\");\n_defineProperty(Brush, \"defaultProps\", {\n    height: 40,\n    travellerWidth: 5,\n    gap: 1,\n    fill: \"#fff\",\n    stroke: \"#666\",\n    padding: {\n        top: 1,\n        right: 1,\n        bottom: 1,\n        left: 1\n    },\n    leaveTimeOut: 1000,\n    alwaysShowText: false\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9CcnVzaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsYUFBYSxHQUFHLEtBQUs7QUFDckIsSUFBSUcsU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyxRQUFRQyx1QkFBdUJGLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlHLFdBQVdILG1CQUFPQSxDQUFDLHdEQUF5QjtBQUNoRCxJQUFJSSxjQUFjRix1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJSyxTQUFTSCx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlNLFNBQVNOLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJTyxRQUFRUCxtQkFBT0EsQ0FBQyx3RUFBbUI7QUFDdkMsSUFBSVEsY0FBY1IsbUJBQU9BLENBQUMsMEVBQW9CO0FBQzlDLElBQUlTLGFBQWFULG1CQUFPQSxDQUFDLHdFQUFtQjtBQUM1QyxJQUFJVSxrQkFBa0JWLG1CQUFPQSxDQUFDLGtGQUF3QjtBQUN0RCxJQUFJVyxjQUFjWCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsU0FBU0UsdUJBQXVCVSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLHlCQUF5QkMsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLE9BQU87SUFBTSxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx5QkFBeUJDLENBQUM7UUFBSSxPQUFPQSxJQUFJRyxJQUFJRDtJQUFHLEdBQUdGO0FBQUk7QUFDbk8sU0FBU2hCLHdCQUF3QmdCLENBQUMsRUFBRUUsQ0FBQztJQUFJLElBQUksQ0FBQ0Es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TCxNQUFNO2dCQUNoQixNQUFPaUwsTUFBTUQsUUFBUSxFQUFHO29CQUN0QixJQUFJRSxTQUFTckksS0FBS2dILEtBQUssQ0FBQyxDQUFDbUIsUUFBUUMsR0FBRSxJQUFLO29CQUN4QyxJQUFJRixVQUFVLENBQUNHLE9BQU8sR0FBR3JMLEdBQUc7d0JBQzFCb0wsTUFBTUM7b0JBQ1IsT0FBTzt3QkFDTEYsUUFBUUU7b0JBQ1Y7Z0JBQ0Y7Z0JBQ0EsT0FBT3JMLEtBQUtrTCxVQUFVLENBQUNFLElBQUksR0FBR0EsTUFBTUQ7WUFDdEM7UUFDRjtLQUFFO0FBQ0osRUFBRXRSLE9BQU95UixhQUFhO0FBQ3RCbE8sZ0JBQWdCeEQsT0FBTyxlQUFlO0FBQ3RDd0QsZ0JBQWdCeEQsT0FBTyxnQkFBZ0I7SUFDckMwTCxRQUFRO0lBQ1JwRixnQkFBZ0I7SUFDaEIyQyxLQUFLO0lBQ0wwQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkssU0FBUztRQUNQMEYsS0FBSztRQUNMQyxPQUFPO1FBQ1BDLFFBQVE7UUFDUkMsTUFBTTtJQUNSO0lBQ0F4SixjQUFjO0lBQ2RrSCxnQkFBZ0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9CcnVzaC5qcz83MGQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5CcnVzaCA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX2QzU2NhbGUgPSByZXF1aXJlKFwidmljdG9yeS12ZW5kb3IvZDMtc2NhbGVcIik7XG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XG52YXIgX3JhbmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3JhbmdlXCIpKTtcbnZhciBfTGF5ZXIgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0xheWVyXCIpO1xudmFyIF9UZXh0ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9UZXh0XCIpO1xudmFyIF9DaGFydFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQ2hhcnRVdGlsc1wiKTtcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xudmFyIF9Dc3NQcmVmaXhVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0Nzc1ByZWZpeFV0aWxzXCIpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKipcbiAqIEBmaWxlT3ZlcnZpZXcgQnJ1c2hcbiAqL1xudmFyIGNyZWF0ZVNjYWxlID0gZnVuY3Rpb24gY3JlYXRlU2NhbGUoX3JlZikge1xuICB2YXIgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICBzdGFydEluZGV4ID0gX3JlZi5zdGFydEluZGV4LFxuICAgIGVuZEluZGV4ID0gX3JlZi5lbmRJbmRleCxcbiAgICB4ID0gX3JlZi54LFxuICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICB0cmF2ZWxsZXJXaWR0aCA9IF9yZWYudHJhdmVsbGVyV2lkdGg7XG4gIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuICB2YXIgc2NhbGUgPSAoMCwgX2QzU2NhbGUuc2NhbGVQb2ludCkoKS5kb21haW4oKDAsIF9yYW5nZVtcImRlZmF1bHRcIl0pKDAsIGxlbikpLnJhbmdlKFt4LCB4ICsgd2lkdGggLSB0cmF2ZWxsZXJXaWR0aF0pO1xuICB2YXIgc2NhbGVWYWx1ZXMgPSBzY2FsZS5kb21haW4oKS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHNjYWxlKGVudHJ5KTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgaXNUZXh0QWN0aXZlOiBmYWxzZSxcbiAgICBpc1NsaWRlTW92aW5nOiBmYWxzZSxcbiAgICBpc1RyYXZlbGxlck1vdmluZzogZmFsc2UsXG4gICAgaXNUcmF2ZWxsZXJGb2N1c2VkOiBmYWxzZSxcbiAgICBzdGFydFg6IHNjYWxlKHN0YXJ0SW5kZXgpLFxuICAgIGVuZFg6IHNjYWxlKGVuZEluZGV4KSxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgc2NhbGVWYWx1ZXM6IHNjYWxlVmFsdWVzXG4gIH07XG59O1xudmFyIGlzVG91Y2ggPSBmdW5jdGlvbiBpc1RvdWNoKGUpIHtcbiAgcmV0dXJuIGUuY2hhbmdlZFRvdWNoZXMgJiYgISFlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aDtcbn07XG52YXIgQnJ1c2ggPSBleHBvcnRzLkJydXNoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBmdW5jdGlvbiBCcnVzaChwcm9wcykge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJ1c2gpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBCcnVzaCwgW3Byb3BzXSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZURyYWdcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChfdGhpcy5sZWF2ZVRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5sZWF2ZVRpbWVyKTtcbiAgICAgICAgX3RoaXMubGVhdmVUaW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMuc3RhdGUuaXNUcmF2ZWxsZXJNb3ZpbmcpIHtcbiAgICAgICAgX3RoaXMuaGFuZGxlVHJhdmVsbGVyTW92ZShlKTtcbiAgICAgIH0gZWxzZSBpZiAoX3RoaXMuc3RhdGUuaXNTbGlkZU1vdmluZykge1xuICAgICAgICBfdGhpcy5oYW5kbGVTbGlkZURyYWcoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZVRvdWNoTW92ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUuY2hhbmdlZFRvdWNoZXMgIT0gbnVsbCAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgX3RoaXMuaGFuZGxlRHJhZyhlLmNoYW5nZWRUb3VjaGVzWzBdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlRHJhZ0VuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzVHJhdmVsbGVyTW92aW5nOiBmYWxzZSxcbiAgICAgICAgaXNTbGlkZU1vdmluZzogZmFsc2VcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgZW5kSW5kZXggPSBfdGhpcyRwcm9wcy5lbmRJbmRleCxcbiAgICAgICAgICBvbkRyYWdFbmQgPSBfdGhpcyRwcm9wcy5vbkRyYWdFbmQsXG4gICAgICAgICAgc3RhcnRJbmRleCA9IF90aGlzJHByb3BzLnN0YXJ0SW5kZXg7XG4gICAgICAgIG9uRHJhZ0VuZCA9PT0gbnVsbCB8fCBvbkRyYWdFbmQgPT09IHZvaWQgMCB8fCBvbkRyYWdFbmQoe1xuICAgICAgICAgIGVuZEluZGV4OiBlbmRJbmRleCxcbiAgICAgICAgICBzdGFydEluZGV4OiBzdGFydEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBfdGhpcy5kZXRhY2hEcmFnRW5kTGlzdGVuZXIoKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlTGVhdmVXcmFwcGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5zdGF0ZS5pc1RyYXZlbGxlck1vdmluZyB8fCBfdGhpcy5zdGF0ZS5pc1NsaWRlTW92aW5nKSB7XG4gICAgICAgIF90aGlzLmxlYXZlVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChfdGhpcy5oYW5kbGVEcmFnRW5kLCBfdGhpcy5wcm9wcy5sZWF2ZVRpbWVPdXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVFbnRlclNsaWRlT3JUcmF2ZWxsZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc1RleHRBY3RpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVMZWF2ZVNsaWRlT3JUcmF2ZWxsZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc1RleHRBY3RpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlU2xpZGVEcmFnU3RhcnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBldmVudCA9IGlzVG91Y2goZSkgPyBlLmNoYW5nZWRUb3VjaGVzWzBdIDogZTtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNUcmF2ZWxsZXJNb3Zpbmc6IGZhbHNlLFxuICAgICAgICBpc1NsaWRlTW92aW5nOiB0cnVlLFxuICAgICAgICBzbGlkZU1vdmVTdGFydFg6IGV2ZW50LnBhZ2VYXG4gICAgICB9KTtcbiAgICAgIF90aGlzLmF0dGFjaERyYWdFbmRMaXN0ZW5lcigpO1xuICAgIH0pO1xuICAgIF90aGlzLnRyYXZlbGxlckRyYWdTdGFydEhhbmRsZXJzID0ge1xuICAgICAgc3RhcnRYOiBfdGhpcy5oYW5kbGVUcmF2ZWxsZXJEcmFnU3RhcnQuYmluZChfdGhpcywgJ3N0YXJ0WCcpLFxuICAgICAgZW5kWDogX3RoaXMuaGFuZGxlVHJhdmVsbGVyRHJhZ1N0YXJ0LmJpbmQoX3RoaXMsICdlbmRYJylcbiAgICB9O1xuICAgIF90aGlzLnN0YXRlID0ge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhCcnVzaCwgX1B1cmVDb21wb25lbnQpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEJydXNoLCBbe1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLmxlYXZlVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubGVhdmVUaW1lcik7XG4gICAgICAgIHRoaXMubGVhdmVUaW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmRldGFjaERyYWdFbmRMaXN0ZW5lcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmRleChfcmVmMikge1xuICAgICAgdmFyIHN0YXJ0WCA9IF9yZWYyLnN0YXJ0WCxcbiAgICAgICAgZW5kWCA9IF9yZWYyLmVuZFg7XG4gICAgICB2YXIgc2NhbGVWYWx1ZXMgPSB0aGlzLnN0YXRlLnNjYWxlVmFsdWVzO1xuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIGdhcCA9IF90aGlzJHByb3BzMi5nYXAsXG4gICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wczIuZGF0YTtcbiAgICAgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgbWluID0gTWF0aC5taW4oc3RhcnRYLCBlbmRYKTtcbiAgICAgIHZhciBtYXggPSBNYXRoLm1heChzdGFydFgsIGVuZFgpO1xuICAgICAgdmFyIG1pbkluZGV4ID0gQnJ1c2guZ2V0SW5kZXhJblJhbmdlKHNjYWxlVmFsdWVzLCBtaW4pO1xuICAgICAgdmFyIG1heEluZGV4ID0gQnJ1c2guZ2V0SW5kZXhJblJhbmdlKHNjYWxlVmFsdWVzLCBtYXgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRJbmRleDogbWluSW5kZXggLSBtaW5JbmRleCAlIGdhcCxcbiAgICAgICAgZW5kSW5kZXg6IG1heEluZGV4ID09PSBsYXN0SW5kZXggPyBsYXN0SW5kZXggOiBtYXhJbmRleCAtIG1heEluZGV4ICUgZ2FwXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUZXh0T2ZUaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRleHRPZlRpY2soaW5kZXgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHMzLmRhdGEsXG4gICAgICAgIHRpY2tGb3JtYXR0ZXIgPSBfdGhpcyRwcm9wczMudGlja0Zvcm1hdHRlcixcbiAgICAgICAgZGF0YUtleSA9IF90aGlzJHByb3BzMy5kYXRhS2V5O1xuICAgICAgdmFyIHRleHQgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0VmFsdWVCeURhdGFLZXkpKGRhdGFbaW5kZXhdLCBkYXRhS2V5LCBpbmRleCk7XG4gICAgICByZXR1cm4gKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkodGlja0Zvcm1hdHRlcikgPyB0aWNrRm9ybWF0dGVyKHRleHQsIGluZGV4KSA6IHRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF0dGFjaERyYWdFbmRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hEcmFnRW5kTGlzdGVuZXIoKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCwgdHJ1ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQsIHRydWUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlRHJhZywgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRldGFjaERyYWdFbmRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hEcmFnRW5kTGlzdGVuZXIoKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCwgdHJ1ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQsIHRydWUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlRHJhZywgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVNsaWRlRHJhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVTbGlkZURyYWcoZSkge1xuICAgICAgdmFyIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgc2xpZGVNb3ZlU3RhcnRYID0gX3RoaXMkc3RhdGUuc2xpZGVNb3ZlU3RhcnRYLFxuICAgICAgICBzdGFydFggPSBfdGhpcyRzdGF0ZS5zdGFydFgsXG4gICAgICAgIGVuZFggPSBfdGhpcyRzdGF0ZS5lbmRYO1xuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgIHggPSBfdGhpcyRwcm9wczQueCxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczQud2lkdGgsXG4gICAgICAgIHRyYXZlbGxlcldpZHRoID0gX3RoaXMkcHJvcHM0LnRyYXZlbGxlcldpZHRoLFxuICAgICAgICBzdGFydEluZGV4ID0gX3RoaXMkcHJvcHM0LnN0YXJ0SW5kZXgsXG4gICAgICAgIGVuZEluZGV4ID0gX3RoaXMkcHJvcHM0LmVuZEluZGV4LFxuICAgICAgICBvbkNoYW5nZSA9IF90aGlzJHByb3BzNC5vbkNoYW5nZTtcbiAgICAgIHZhciBkZWx0YSA9IGUucGFnZVggLSBzbGlkZU1vdmVTdGFydFg7XG4gICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgIGRlbHRhID0gTWF0aC5taW4oZGVsdGEsIHggKyB3aWR0aCAtIHRyYXZlbGxlcldpZHRoIC0gZW5kWCwgeCArIHdpZHRoIC0gdHJhdmVsbGVyV2lkdGggLSBzdGFydFgpO1xuICAgICAgfSBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgZGVsdGEgPSBNYXRoLm1heChkZWx0YSwgeCAtIHN0YXJ0WCwgeCAtIGVuZFgpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0luZGV4ID0gdGhpcy5nZXRJbmRleCh7XG4gICAgICAgIHN0YXJ0WDogc3RhcnRYICsgZGVsdGEsXG4gICAgICAgIGVuZFg6IGVuZFggKyBkZWx0YVxuICAgICAgfSk7XG4gICAgICBpZiAoKG5ld0luZGV4LnN0YXJ0SW5kZXggIT09IHN0YXJ0SW5kZXggfHwgbmV3SW5kZXguZW5kSW5kZXggIT09IGVuZEluZGV4KSAmJiBvbkNoYW5nZSkge1xuICAgICAgICBvbkNoYW5nZShuZXdJbmRleCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc3RhcnRYOiBzdGFydFggKyBkZWx0YSxcbiAgICAgICAgZW5kWDogZW5kWCArIGRlbHRhLFxuICAgICAgICBzbGlkZU1vdmVTdGFydFg6IGUucGFnZVhcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVUcmF2ZWxsZXJEcmFnU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVHJhdmVsbGVyRHJhZ1N0YXJ0KGlkLCBlKSB7XG4gICAgICB2YXIgZXZlbnQgPSBpc1RvdWNoKGUpID8gZS5jaGFuZ2VkVG91Y2hlc1swXSA6IGU7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNTbGlkZU1vdmluZzogZmFsc2UsXG4gICAgICAgIGlzVHJhdmVsbGVyTW92aW5nOiB0cnVlLFxuICAgICAgICBtb3ZpbmdUcmF2ZWxsZXJJZDogaWQsXG4gICAgICAgIGJydXNoTW92ZVN0YXJ0WDogZXZlbnQucGFnZVhcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hdHRhY2hEcmFnRW5kTGlzdGVuZXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlVHJhdmVsbGVyTW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUcmF2ZWxsZXJNb3ZlKGUpIHtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZTIgPSB0aGlzLnN0YXRlLFxuICAgICAgICBicnVzaE1vdmVTdGFydFggPSBfdGhpcyRzdGF0ZTIuYnJ1c2hNb3ZlU3RhcnRYLFxuICAgICAgICBtb3ZpbmdUcmF2ZWxsZXJJZCA9IF90aGlzJHN0YXRlMi5tb3ZpbmdUcmF2ZWxsZXJJZCxcbiAgICAgICAgZW5kWCA9IF90aGlzJHN0YXRlMi5lbmRYLFxuICAgICAgICBzdGFydFggPSBfdGhpcyRzdGF0ZTIuc3RhcnRYO1xuICAgICAgdmFyIHByZXZWYWx1ZSA9IHRoaXMuc3RhdGVbbW92aW5nVHJhdmVsbGVySWRdO1xuICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXG4gICAgICAgIHggPSBfdGhpcyRwcm9wczUueCxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczUud2lkdGgsXG4gICAgICAgIHRyYXZlbGxlcldpZHRoID0gX3RoaXMkcHJvcHM1LnRyYXZlbGxlcldpZHRoLFxuICAgICAgICBvbkNoYW5nZSA9IF90aGlzJHByb3BzNS5vbkNoYW5nZSxcbiAgICAgICAgZ2FwID0gX3RoaXMkcHJvcHM1LmdhcCxcbiAgICAgICAgZGF0YSA9IF90aGlzJHByb3BzNS5kYXRhO1xuICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgc3RhcnRYOiB0aGlzLnN0YXRlLnN0YXJ0WCxcbiAgICAgICAgZW5kWDogdGhpcy5zdGF0ZS5lbmRYXG4gICAgICB9O1xuICAgICAgdmFyIGRlbHRhID0gZS5wYWdlWCAtIGJydXNoTW92ZVN0YXJ0WDtcbiAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgZGVsdGEgPSBNYXRoLm1pbihkZWx0YSwgeCArIHdpZHRoIC0gdHJhdmVsbGVyV2lkdGggLSBwcmV2VmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgZGVsdGEgPSBNYXRoLm1heChkZWx0YSwgeCAtIHByZXZWYWx1ZSk7XG4gICAgICB9XG4gICAgICBwYXJhbXNbbW92aW5nVHJhdmVsbGVySWRdID0gcHJldlZhbHVlICsgZGVsdGE7XG4gICAgICB2YXIgbmV3SW5kZXggPSB0aGlzLmdldEluZGV4KHBhcmFtcyk7XG4gICAgICB2YXIgc3RhcnRJbmRleCA9IG5ld0luZGV4LnN0YXJ0SW5kZXgsXG4gICAgICAgIGVuZEluZGV4ID0gbmV3SW5kZXguZW5kSW5kZXg7XG4gICAgICB2YXIgaXNGdWxsR2FwID0gZnVuY3Rpb24gaXNGdWxsR2FwKCkge1xuICAgICAgICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobW92aW5nVHJhdmVsbGVySWQgPT09ICdzdGFydFgnICYmIChlbmRYID4gc3RhcnRYID8gc3RhcnRJbmRleCAlIGdhcCA9PT0gMCA6IGVuZEluZGV4ICUgZ2FwID09PSAwKSB8fCBlbmRYIDwgc3RhcnRYICYmIGVuZEluZGV4ID09PSBsYXN0SW5kZXggfHwgbW92aW5nVHJhdmVsbGVySWQgPT09ICdlbmRYJyAmJiAoZW5kWCA+IHN0YXJ0WCA/IGVuZEluZGV4ICUgZ2FwID09PSAwIDogc3RhcnRJbmRleCAlIGdhcCA9PT0gMCkgfHwgZW5kWCA+IHN0YXJ0WCAmJiBlbmRJbmRleCA9PT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eSh7fSwgbW92aW5nVHJhdmVsbGVySWQsIHByZXZWYWx1ZSArIGRlbHRhKSwgXCJicnVzaE1vdmVTdGFydFhcIiwgZS5wYWdlWCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICAgICAgaWYgKGlzRnVsbEdhcCgpKSB7XG4gICAgICAgICAgICBvbkNoYW5nZShuZXdJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlVHJhdmVsbGVyTW92ZUtleWJvYXJkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVRyYXZlbGxlck1vdmVLZXlib2FyZChkaXJlY3Rpb24sIGlkKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIC8vIHNjYWxlVmFsdWVzIGFyZSBhIGxpc3Qgb2YgY29vcmRpbmF0ZXMuIEZvciBleGFtcGxlOiBbNjUsIDI1MCwgNDM1LCA2MjAsIDgwNSwgOTkwXS5cbiAgICAgIHZhciBfdGhpcyRzdGF0ZTMgPSB0aGlzLnN0YXRlLFxuICAgICAgICBzY2FsZVZhbHVlcyA9IF90aGlzJHN0YXRlMy5zY2FsZVZhbHVlcyxcbiAgICAgICAgc3RhcnRYID0gX3RoaXMkc3RhdGUzLnN0YXJ0WCxcbiAgICAgICAgZW5kWCA9IF90aGlzJHN0YXRlMy5lbmRYO1xuICAgICAgLy8gY3VycmVudFNjYWxlVmFsdWUgcmVmZXJzIHRvIHdoaWNoIGNvb3JkaW5hdGUgdGhlIGN1cnJlbnQgdHJhdmVsbGVyIHNob3VsZCBiZSBwbGFjZWQgYXQuXG4gICAgICB2YXIgY3VycmVudFNjYWxlVmFsdWUgPSB0aGlzLnN0YXRlW2lkXTtcbiAgICAgIHZhciBjdXJyZW50SW5kZXggPSBzY2FsZVZhbHVlcy5pbmRleE9mKGN1cnJlbnRTY2FsZVZhbHVlKTtcbiAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdJbmRleCA9IGN1cnJlbnRJbmRleCArIGRpcmVjdGlvbjtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gLTEgfHwgbmV3SW5kZXggPj0gc2NhbGVWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTY2FsZVZhbHVlID0gc2NhbGVWYWx1ZXNbbmV3SW5kZXhdO1xuXG4gICAgICAvLyBQcmV2ZW50IHRyYXZlbGxlcnMgZnJvbSBiZWluZyBvbiB0b3Agb2YgZWFjaCBvdGhlciBvciBvdmVybGFwcGluZ1xuICAgICAgaWYgKGlkID09PSAnc3RhcnRYJyAmJiBuZXdTY2FsZVZhbHVlID49IGVuZFggfHwgaWQgPT09ICdlbmRYJyAmJiBuZXdTY2FsZVZhbHVlIDw9IHN0YXJ0WCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKF9kZWZpbmVQcm9wZXJ0eSh7fSwgaWQsIG5ld1NjYWxlVmFsdWUpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5wcm9wcy5vbkNoYW5nZShfdGhpczIuZ2V0SW5kZXgoe1xuICAgICAgICAgIHN0YXJ0WDogX3RoaXMyLnN0YXRlLnN0YXJ0WCxcbiAgICAgICAgICBlbmRYOiBfdGhpczIuc3RhdGUuZW5kWFxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQmFja2dyb3VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJCYWNrZ3JvdW5kKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNiA9IHRoaXMucHJvcHMsXG4gICAgICAgIHggPSBfdGhpcyRwcm9wczYueCxcbiAgICAgICAgeSA9IF90aGlzJHByb3BzNi55LFxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM2LmhlaWdodCxcbiAgICAgICAgZmlsbCA9IF90aGlzJHByb3BzNi5maWxsLFxuICAgICAgICBzdHJva2UgPSBfdGhpcyRwcm9wczYuc3Ryb2tlO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJQYW5vcmFtYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJQYW5vcmFtYSgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczcgPSB0aGlzLnByb3BzLFxuICAgICAgICB4ID0gX3RoaXMkcHJvcHM3LngsXG4gICAgICAgIHkgPSBfdGhpcyRwcm9wczcueSxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczcud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzNy5oZWlnaHQsXG4gICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wczcuZGF0YSxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczcuY2hpbGRyZW4sXG4gICAgICAgIHBhZGRpbmcgPSBfdGhpcyRwcm9wczcucGFkZGluZztcbiAgICAgIHZhciBjaGFydEVsZW1lbnQgPSBfcmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICBpZiAoIWNoYXJ0RWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQoY2hhcnRFbGVtZW50LCB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIG1hcmdpbjogcGFkZGluZyxcbiAgICAgICAgY29tcGFjdDogdHJ1ZSxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclRyYXZlbGxlckxheWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRyYXZlbGxlckxheWVyKHRyYXZlbGxlclgsIGlkKSB7XG4gICAgICB2YXIgX2RhdGEkc3RhcnRJbmRleCxcbiAgICAgICAgX2RhdGEkZW5kSW5kZXgsXG4gICAgICAgIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM4ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgeSA9IF90aGlzJHByb3BzOC55LFxuICAgICAgICB0cmF2ZWxsZXJXaWR0aCA9IF90aGlzJHByb3BzOC50cmF2ZWxsZXJXaWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM4LmhlaWdodCxcbiAgICAgICAgdHJhdmVsbGVyID0gX3RoaXMkcHJvcHM4LnRyYXZlbGxlcixcbiAgICAgICAgYXJpYUxhYmVsID0gX3RoaXMkcHJvcHM4LmFyaWFMYWJlbCxcbiAgICAgICAgZGF0YSA9IF90aGlzJHByb3BzOC5kYXRhLFxuICAgICAgICBzdGFydEluZGV4ID0gX3RoaXMkcHJvcHM4LnN0YXJ0SW5kZXgsXG4gICAgICAgIGVuZEluZGV4ID0gX3RoaXMkcHJvcHM4LmVuZEluZGV4O1xuICAgICAgdmFyIHggPSBNYXRoLm1heCh0cmF2ZWxsZXJYLCB0aGlzLnByb3BzLngpO1xuICAgICAgdmFyIHRyYXZlbGxlclByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIGZhbHNlKSksIHt9LCB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiB0cmF2ZWxsZXJXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0pO1xuICAgICAgdmFyIGFyaWFMYWJlbEJydXNoID0gYXJpYUxhYmVsIHx8IFwiTWluIHZhbHVlOiBcIi5jb25jYXQoKF9kYXRhJHN0YXJ0SW5kZXggPSBkYXRhW3N0YXJ0SW5kZXhdKSA9PT0gbnVsbCB8fCBfZGF0YSRzdGFydEluZGV4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGF0YSRzdGFydEluZGV4Lm5hbWUsIFwiLCBNYXggdmFsdWU6IFwiKS5jb25jYXQoKF9kYXRhJGVuZEluZGV4ID0gZGF0YVtlbmRJbmRleF0pID09PSBudWxsIHx8IF9kYXRhJGVuZEluZGV4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGF0YSRlbmRJbmRleC5uYW1lKTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xuICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgcm9sZTogXCJzbGlkZXJcIixcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbEJydXNoLFxuICAgICAgICBcImFyaWEtdmFsdWVub3dcIjogdHJhdmVsbGVyWCxcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWJydXNoLXRyYXZlbGxlclwiLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IHRoaXMuaGFuZGxlRW50ZXJTbGlkZU9yVHJhdmVsbGVyLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IHRoaXMuaGFuZGxlTGVhdmVTbGlkZU9yVHJhdmVsbGVyLFxuICAgICAgICBvbk1vdXNlRG93bjogdGhpcy50cmF2ZWxsZXJEcmFnU3RhcnRIYW5kbGVyc1tpZF0sXG4gICAgICAgIG9uVG91Y2hTdGFydDogdGhpcy50cmF2ZWxsZXJEcmFnU3RhcnRIYW5kbGVyc1tpZF0sXG4gICAgICAgIG9uS2V5RG93bjogZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICAgICAgICBpZiAoIVsnQXJyb3dMZWZ0JywgJ0Fycm93UmlnaHQnXS5pbmNsdWRlcyhlLmtleSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgX3RoaXMzLmhhbmRsZVRyYXZlbGxlck1vdmVLZXlib2FyZChlLmtleSA9PT0gJ0Fycm93UmlnaHQnID8gMSA6IC0xLCBpZCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRm9jdXM6IGZ1bmN0aW9uIG9uRm9jdXMoKSB7XG4gICAgICAgICAgX3RoaXMzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGlzVHJhdmVsbGVyRm9jdXNlZDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgICAgICBfdGhpczMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaXNUcmF2ZWxsZXJGb2N1c2VkOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGN1cnNvcjogJ2NvbC1yZXNpemUnXG4gICAgICAgIH1cbiAgICAgIH0sIEJydXNoLnJlbmRlclRyYXZlbGxlcih0cmF2ZWxsZXIsIHRyYXZlbGxlclByb3BzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclNsaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclNsaWRlKHN0YXJ0WCwgZW5kWCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzOSA9IHRoaXMucHJvcHMsXG4gICAgICAgIHkgPSBfdGhpcyRwcm9wczkueSxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM5LmhlaWdodCxcbiAgICAgICAgc3Ryb2tlID0gX3RoaXMkcHJvcHM5LnN0cm9rZSxcbiAgICAgICAgdHJhdmVsbGVyV2lkdGggPSBfdGhpcyRwcm9wczkudHJhdmVsbGVyV2lkdGg7XG4gICAgICB2YXIgeCA9IE1hdGgubWluKHN0YXJ0WCwgZW5kWCkgKyB0cmF2ZWxsZXJXaWR0aDtcbiAgICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KE1hdGguYWJzKGVuZFggLSBzdGFydFgpIC0gdHJhdmVsbGVyV2lkdGgsIDApO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWJydXNoLXNsaWRlXCIsXG4gICAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5oYW5kbGVFbnRlclNsaWRlT3JUcmF2ZWxsZXIsXG4gICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5oYW5kbGVMZWF2ZVNsaWRlT3JUcmF2ZWxsZXIsXG4gICAgICAgIG9uTW91c2VEb3duOiB0aGlzLmhhbmRsZVNsaWRlRHJhZ1N0YXJ0LFxuICAgICAgICBvblRvdWNoU3RhcnQ6IHRoaXMuaGFuZGxlU2xpZGVEcmFnU3RhcnQsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgY3Vyc29yOiAnbW92ZSdcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiBcIm5vbmVcIixcbiAgICAgICAgZmlsbDogc3Ryb2tlLFxuICAgICAgICBmaWxsT3BhY2l0eTogMC4yLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJUZXh0KCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMTAgPSB0aGlzLnByb3BzLFxuICAgICAgICBzdGFydEluZGV4ID0gX3RoaXMkcHJvcHMxMC5zdGFydEluZGV4LFxuICAgICAgICBlbmRJbmRleCA9IF90aGlzJHByb3BzMTAuZW5kSW5kZXgsXG4gICAgICAgIHkgPSBfdGhpcyRwcm9wczEwLnksXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzMTAuaGVpZ2h0LFxuICAgICAgICB0cmF2ZWxsZXJXaWR0aCA9IF90aGlzJHByb3BzMTAudHJhdmVsbGVyV2lkdGgsXG4gICAgICAgIHN0cm9rZSA9IF90aGlzJHByb3BzMTAuc3Ryb2tlO1xuICAgICAgdmFyIF90aGlzJHN0YXRlNCA9IHRoaXMuc3RhdGUsXG4gICAgICAgIHN0YXJ0WCA9IF90aGlzJHN0YXRlNC5zdGFydFgsXG4gICAgICAgIGVuZFggPSBfdGhpcyRzdGF0ZTQuZW5kWDtcbiAgICAgIHZhciBvZmZzZXQgPSA1O1xuICAgICAgdmFyIGF0dHJzID0ge1xuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgIGZpbGw6IHN0cm9rZVxuICAgICAgfTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtYnJ1c2gtdGV4dHNcIlxuICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfVGV4dC5UZXh0LCBfZXh0ZW5kcyh7XG4gICAgICAgIHRleHRBbmNob3I6IFwiZW5kXCIsXG4gICAgICAgIHZlcnRpY2FsQW5jaG9yOiBcIm1pZGRsZVwiLFxuICAgICAgICB4OiBNYXRoLm1pbihzdGFydFgsIGVuZFgpIC0gb2Zmc2V0LFxuICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMlxuICAgICAgfSwgYXR0cnMpLCB0aGlzLmdldFRleHRPZlRpY2soc3RhcnRJbmRleCkpLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9UZXh0LlRleHQsIF9leHRlbmRzKHtcbiAgICAgICAgdGV4dEFuY2hvcjogXCJzdGFydFwiLFxuICAgICAgICB2ZXJ0aWNhbEFuY2hvcjogXCJtaWRkbGVcIixcbiAgICAgICAgeDogTWF0aC5tYXgoc3RhcnRYLCBlbmRYKSArIHRyYXZlbGxlcldpZHRoICsgb2Zmc2V0LFxuICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMlxuICAgICAgfSwgYXR0cnMpLCB0aGlzLmdldFRleHRPZlRpY2soZW5kSW5kZXgpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMxMSA9IHRoaXMucHJvcHMsXG4gICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wczExLmRhdGEsXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzMTEuY2xhc3NOYW1lLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzMTEuY2hpbGRyZW4sXG4gICAgICAgIHggPSBfdGhpcyRwcm9wczExLngsXG4gICAgICAgIHkgPSBfdGhpcyRwcm9wczExLnksXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHMxMS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHMxMS5oZWlnaHQsXG4gICAgICAgIGFsd2F5c1Nob3dUZXh0ID0gX3RoaXMkcHJvcHMxMS5hbHdheXNTaG93VGV4dDtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZTUgPSB0aGlzLnN0YXRlLFxuICAgICAgICBzdGFydFggPSBfdGhpcyRzdGF0ZTUuc3RhcnRYLFxuICAgICAgICBlbmRYID0gX3RoaXMkc3RhdGU1LmVuZFgsXG4gICAgICAgIGlzVGV4dEFjdGl2ZSA9IF90aGlzJHN0YXRlNS5pc1RleHRBY3RpdmUsXG4gICAgICAgIGlzU2xpZGVNb3ZpbmcgPSBfdGhpcyRzdGF0ZTUuaXNTbGlkZU1vdmluZyxcbiAgICAgICAgaXNUcmF2ZWxsZXJNb3ZpbmcgPSBfdGhpcyRzdGF0ZTUuaXNUcmF2ZWxsZXJNb3ZpbmcsXG4gICAgICAgIGlzVHJhdmVsbGVyRm9jdXNlZCA9IF90aGlzJHN0YXRlNS5pc1RyYXZlbGxlckZvY3VzZWQ7XG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICEoMCwgX0RhdGFVdGlscy5pc051bWJlcikoeCkgfHwgISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh5KSB8fCAhKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHdpZHRoKSB8fCAhKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGhlaWdodCkgfHwgd2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBsYXllckNsYXNzID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLWJydXNoJywgY2xhc3NOYW1lKTtcbiAgICAgIHZhciBpc1Bhbm9yYW1pYyA9IF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pID09PSAxO1xuICAgICAgdmFyIHN0eWxlID0gKDAsIF9Dc3NQcmVmaXhVdGlscy5nZW5lcmF0ZVByZWZpeFN0eWxlKSgndXNlclNlbGVjdCcsICdub25lJyk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBsYXllckNsYXNzLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IHRoaXMuaGFuZGxlTGVhdmVXcmFwcGVyLFxuICAgICAgICBvblRvdWNoTW92ZTogdGhpcy5oYW5kbGVUb3VjaE1vdmUsXG4gICAgICAgIHN0eWxlOiBzdHlsZVxuICAgICAgfSwgdGhpcy5yZW5kZXJCYWNrZ3JvdW5kKCksIGlzUGFub3JhbWljICYmIHRoaXMucmVuZGVyUGFub3JhbWEoKSwgdGhpcy5yZW5kZXJTbGlkZShzdGFydFgsIGVuZFgpLCB0aGlzLnJlbmRlclRyYXZlbGxlckxheWVyKHN0YXJ0WCwgJ3N0YXJ0WCcpLCB0aGlzLnJlbmRlclRyYXZlbGxlckxheWVyKGVuZFgsICdlbmRYJyksIChpc1RleHRBY3RpdmUgfHwgaXNTbGlkZU1vdmluZyB8fCBpc1RyYXZlbGxlck1vdmluZyB8fCBpc1RyYXZlbGxlckZvY3VzZWQgfHwgYWx3YXlzU2hvd1RleHQpICYmIHRoaXMucmVuZGVyVGV4dCgpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJyZW5kZXJEZWZhdWx0VHJhdmVsbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckRlZmF1bHRUcmF2ZWxsZXIocHJvcHMpIHtcbiAgICAgIHZhciB4ID0gcHJvcHMueCxcbiAgICAgICAgeSA9IHByb3BzLnksXG4gICAgICAgIHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcbiAgICAgICAgc3Ryb2tlID0gcHJvcHMuc3Ryb2tlO1xuICAgICAgdmFyIGxpbmVZID0gTWF0aC5mbG9vcih5ICsgaGVpZ2h0IC8gMikgLSAxO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JlYWN0W1wiZGVmYXVsdFwiXS5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBmaWxsOiBzdHJva2UsXG4gICAgICAgIHN0cm9rZTogXCJub25lXCJcbiAgICAgIH0pLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7XG4gICAgICAgIHgxOiB4ICsgMSxcbiAgICAgICAgeTE6IGxpbmVZLFxuICAgICAgICB4MjogeCArIHdpZHRoIC0gMSxcbiAgICAgICAgeTI6IGxpbmVZLFxuICAgICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgICAgc3Ryb2tlOiBcIiNmZmZcIlxuICAgICAgfSksIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHtcbiAgICAgICAgeDE6IHggKyAxLFxuICAgICAgICB5MTogbGluZVkgKyAyLFxuICAgICAgICB4MjogeCArIHdpZHRoIC0gMSxcbiAgICAgICAgeTI6IGxpbmVZICsgMixcbiAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICAgIHN0cm9rZTogXCIjZmZmXCJcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyVHJhdmVsbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRyYXZlbGxlcihvcHRpb24sIHByb3BzKSB7XG4gICAgICB2YXIgcmVjdGFuZ2xlO1xuICAgICAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChvcHRpb24pKSB7XG4gICAgICAgIHJlY3RhbmdsZSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChvcHRpb24sIHByb3BzKTtcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob3B0aW9uKSkge1xuICAgICAgICByZWN0YW5nbGUgPSBvcHRpb24ocHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjdGFuZ2xlID0gQnJ1c2gucmVuZGVyRGVmYXVsdFRyYXZlbGxlcihwcm9wcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICB2YXIgZGF0YSA9IG5leHRQcm9wcy5kYXRhLFxuICAgICAgICB3aWR0aCA9IG5leHRQcm9wcy53aWR0aCxcbiAgICAgICAgeCA9IG5leHRQcm9wcy54LFxuICAgICAgICB0cmF2ZWxsZXJXaWR0aCA9IG5leHRQcm9wcy50cmF2ZWxsZXJXaWR0aCxcbiAgICAgICAgdXBkYXRlSWQgPSBuZXh0UHJvcHMudXBkYXRlSWQsXG4gICAgICAgIHN0YXJ0SW5kZXggPSBuZXh0UHJvcHMuc3RhcnRJbmRleCxcbiAgICAgICAgZW5kSW5kZXggPSBuZXh0UHJvcHMuZW5kSW5kZXg7XG4gICAgICBpZiAoZGF0YSAhPT0gcHJldlN0YXRlLnByZXZEYXRhIHx8IHVwZGF0ZUlkICE9PSBwcmV2U3RhdGUucHJldlVwZGF0ZUlkKSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICBwcmV2RGF0YTogZGF0YSxcbiAgICAgICAgICBwcmV2VHJhdmVsbGVyV2lkdGg6IHRyYXZlbGxlcldpZHRoLFxuICAgICAgICAgIHByZXZVcGRhdGVJZDogdXBkYXRlSWQsXG4gICAgICAgICAgcHJldlg6IHgsXG4gICAgICAgICAgcHJldldpZHRoOiB3aWR0aFxuICAgICAgICB9LCBkYXRhICYmIGRhdGEubGVuZ3RoID8gY3JlYXRlU2NhbGUoe1xuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgdHJhdmVsbGVyV2lkdGg6IHRyYXZlbGxlcldpZHRoLFxuICAgICAgICAgIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG4gICAgICAgICAgZW5kSW5kZXg6IGVuZEluZGV4XG4gICAgICAgIH0pIDoge1xuICAgICAgICAgIHNjYWxlOiBudWxsLFxuICAgICAgICAgIHNjYWxlVmFsdWVzOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZTdGF0ZS5zY2FsZSAmJiAod2lkdGggIT09IHByZXZTdGF0ZS5wcmV2V2lkdGggfHwgeCAhPT0gcHJldlN0YXRlLnByZXZYIHx8IHRyYXZlbGxlcldpZHRoICE9PSBwcmV2U3RhdGUucHJldlRyYXZlbGxlcldpZHRoKSkge1xuICAgICAgICBwcmV2U3RhdGUuc2NhbGUucmFuZ2UoW3gsIHggKyB3aWR0aCAtIHRyYXZlbGxlcldpZHRoXSk7XG4gICAgICAgIHZhciBzY2FsZVZhbHVlcyA9IHByZXZTdGF0ZS5zY2FsZS5kb21haW4oKS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZTdGF0ZS5zY2FsZShlbnRyeSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByZXZEYXRhOiBkYXRhLFxuICAgICAgICAgIHByZXZUcmF2ZWxsZXJXaWR0aDogdHJhdmVsbGVyV2lkdGgsXG4gICAgICAgICAgcHJldlVwZGF0ZUlkOiB1cGRhdGVJZCxcbiAgICAgICAgICBwcmV2WDogeCxcbiAgICAgICAgICBwcmV2V2lkdGg6IHdpZHRoLFxuICAgICAgICAgIHN0YXJ0WDogcHJldlN0YXRlLnNjYWxlKG5leHRQcm9wcy5zdGFydEluZGV4KSxcbiAgICAgICAgICBlbmRYOiBwcmV2U3RhdGUuc2NhbGUobmV4dFByb3BzLmVuZEluZGV4KSxcbiAgICAgICAgICBzY2FsZVZhbHVlczogc2NhbGVWYWx1ZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRJbmRleEluUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5kZXhJblJhbmdlKHZhbHVlUmFuZ2UsIHgpIHtcbiAgICAgIHZhciBsZW4gPSB2YWx1ZVJhbmdlLmxlbmd0aDtcbiAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICB2YXIgZW5kID0gbGVuIC0gMTtcbiAgICAgIHdoaWxlIChlbmQgLSBzdGFydCA+IDEpIHtcbiAgICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgICAgICBpZiAodmFsdWVSYW5nZVttaWRkbGVdID4geCkge1xuICAgICAgICAgIGVuZCA9IG1pZGRsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydCA9IG1pZGRsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHggPj0gdmFsdWVSYW5nZVtlbmRdID8gZW5kIDogc3RhcnQ7XG4gICAgfVxuICB9XSk7XG59KF9yZWFjdC5QdXJlQ29tcG9uZW50KTtcbl9kZWZpbmVQcm9wZXJ0eShCcnVzaCwgXCJkaXNwbGF5TmFtZVwiLCAnQnJ1c2gnKTtcbl9kZWZpbmVQcm9wZXJ0eShCcnVzaCwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBoZWlnaHQ6IDQwLFxuICB0cmF2ZWxsZXJXaWR0aDogNSxcbiAgZ2FwOiAxLFxuICBmaWxsOiAnI2ZmZicsXG4gIHN0cm9rZTogJyM2NjYnLFxuICBwYWRkaW5nOiB7XG4gICAgdG9wOiAxLFxuICAgIHJpZ2h0OiAxLFxuICAgIGJvdHRvbTogMSxcbiAgICBsZWZ0OiAxXG4gIH0sXG4gIGxlYXZlVGltZU91dDogMTAwMCxcbiAgYWx3YXlzU2hvd1RleHQ6IGZhbHNlXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCcnVzaCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9jbHN4IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9kM1NjYWxlIiwiX2lzRnVuY3Rpb24iLCJfcmFuZ2UiLCJfTGF5ZXIiLCJfVGV4dCIsIl9DaGFydFV0aWxzIiwiX0RhdGFVdGlscyIsIl9Dc3NQcmVmaXhVdGlscyIsIl9SZWFjdFV0aWxzIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfdHlwZW9mIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaSIsInNldCIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiYXBwbHkiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJjcmVhdGVTY2FsZSIsIl9yZWYiLCJkYXRhIiwic3RhcnRJbmRleCIsImVuZEluZGV4IiwieCIsIndpZHRoIiwidHJhdmVsbGVyV2lkdGgiLCJsZW4iLCJzY2FsZSIsInNjYWxlUG9pbnQiLCJkb21haW4iLCJyYW5nZSIsInNjYWxlVmFsdWVzIiwibWFwIiwiZW50cnkiLCJpc1RleHRBY3RpdmUiLCJpc1NsaWRlTW92aW5nIiwiaXNUcmF2ZWxsZXJNb3ZpbmciLCJpc1RyYXZlbGxlckZvY3VzZWQiLCJzdGFydFgiLCJlbmRYIiwiaXNUb3VjaCIsImNoYW5nZWRUb3VjaGVzIiwiX1B1cmVDb21wb25lbnQiLCJfdGhpcyIsImxlYXZlVGltZXIiLCJjbGVhclRpbWVvdXQiLCJzdGF0ZSIsImhhbmRsZVRyYXZlbGxlck1vdmUiLCJoYW5kbGVTbGlkZURyYWciLCJoYW5kbGVEcmFnIiwic2V0U3RhdGUiLCJfdGhpcyRwcm9wcyIsIm9uRHJhZ0VuZCIsImRldGFjaERyYWdFbmRMaXN0ZW5lciIsIndpbmRvdyIsInNldFRpbWVvdXQiLCJoYW5kbGVEcmFnRW5kIiwibGVhdmVUaW1lT3V0IiwiZXZlbnQiLCJzbGlkZU1vdmVTdGFydFgiLCJwYWdlWCIsImF0dGFjaERyYWdFbmRMaXN0ZW5lciIsInRyYXZlbGxlckRyYWdTdGFydEhhbmRsZXJzIiwiaGFuZGxlVHJhdmVsbGVyRHJhZ1N0YXJ0IiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJnZXRJbmRleCIsIl9yZWYyIiwiX3RoaXMkcHJvcHMyIiwiZ2FwIiwibGFzdEluZGV4IiwibWluIiwiTWF0aCIsIm1heCIsIm1pbkluZGV4IiwiZ2V0SW5kZXhJblJhbmdlIiwibWF4SW5kZXgiLCJnZXRUZXh0T2ZUaWNrIiwiaW5kZXgiLCJfdGhpcyRwcm9wczMiLCJ0aWNrRm9ybWF0dGVyIiwiZGF0YUtleSIsInRleHQiLCJnZXRWYWx1ZUJ5RGF0YUtleSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiX3RoaXMkc3RhdGUiLCJfdGhpcyRwcm9wczQiLCJvbkNoYW5nZSIsImRlbHRhIiwibmV3SW5kZXgiLCJpZCIsIm1vdmluZ1RyYXZlbGxlcklkIiwiYnJ1c2hNb3ZlU3RhcnRYIiwiX3RoaXMkc3RhdGUyIiwicHJldlZhbHVlIiwiX3RoaXMkcHJvcHM1IiwicGFyYW1zIiwiaXNGdWxsR2FwIiwiaGFuZGxlVHJhdmVsbGVyTW92ZUtleWJvYXJkIiwiZGlyZWN0aW9uIiwiX3RoaXMyIiwiX3RoaXMkc3RhdGUzIiwiY3VycmVudFNjYWxlVmFsdWUiLCJjdXJyZW50SW5kZXgiLCJpbmRleE9mIiwibmV3U2NhbGVWYWx1ZSIsInJlbmRlckJhY2tncm91bmQiLCJfdGhpcyRwcm9wczYiLCJ5IiwiaGVpZ2h0IiwiZmlsbCIsInN0cm9rZSIsImNyZWF0ZUVsZW1lbnQiLCJyZW5kZXJQYW5vcmFtYSIsIl90aGlzJHByb3BzNyIsImNoaWxkcmVuIiwicGFkZGluZyIsImNoYXJ0RWxlbWVudCIsIkNoaWxkcmVuIiwib25seSIsImNsb25lRWxlbWVudCIsIm1hcmdpbiIsImNvbXBhY3QiLCJyZW5kZXJUcmF2ZWxsZXJMYXllciIsInRyYXZlbGxlclgiLCJfZGF0YSRzdGFydEluZGV4IiwiX2RhdGEkZW5kSW5kZXgiLCJfdGhpczMiLCJfdGhpcyRwcm9wczgiLCJ0cmF2ZWxsZXIiLCJhcmlhTGFiZWwiLCJ0cmF2ZWxsZXJQcm9wcyIsImZpbHRlclByb3BzIiwiYXJpYUxhYmVsQnJ1c2giLCJjb25jYXQiLCJuYW1lIiwiTGF5ZXIiLCJ0YWJJbmRleCIsInJvbGUiLCJjbGFzc05hbWUiLCJvbk1vdXNlRW50ZXIiLCJoYW5kbGVFbnRlclNsaWRlT3JUcmF2ZWxsZXIiLCJvbk1vdXNlTGVhdmUiLCJoYW5kbGVMZWF2ZVNsaWRlT3JUcmF2ZWxsZXIiLCJvbk1vdXNlRG93biIsIm9uVG91Y2hTdGFydCIsIm9uS2V5RG93biIsImluY2x1ZGVzIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJvbkZvY3VzIiwib25CbHVyIiwic3R5bGUiLCJjdXJzb3IiLCJyZW5kZXJUcmF2ZWxsZXIiLCJyZW5kZXJTbGlkZSIsIl90aGlzJHByb3BzOSIsImFicyIsImhhbmRsZVNsaWRlRHJhZ1N0YXJ0IiwiZmlsbE9wYWNpdHkiLCJyZW5kZXJUZXh0IiwiX3RoaXMkcHJvcHMxMCIsIl90aGlzJHN0YXRlNCIsIm9mZnNldCIsImF0dHJzIiwicG9pbnRlckV2ZW50cyIsIlRleHQiLCJ0ZXh0QW5jaG9yIiwidmVydGljYWxBbmNob3IiLCJyZW5kZXIiLCJfdGhpcyRwcm9wczExIiwiYWx3YXlzU2hvd1RleHQiLCJfdGhpcyRzdGF0ZTUiLCJpc051bWJlciIsImxheWVyQ2xhc3MiLCJpc1Bhbm9yYW1pYyIsImNvdW50IiwiZ2VuZXJhdGVQcmVmaXhTdHlsZSIsImhhbmRsZUxlYXZlV3JhcHBlciIsIm9uVG91Y2hNb3ZlIiwiaGFuZGxlVG91Y2hNb3ZlIiwicmVuZGVyRGVmYXVsdFRyYXZlbGxlciIsImxpbmVZIiwiZmxvb3IiLCJGcmFnbWVudCIsIngxIiwieTEiLCJ4MiIsInkyIiwib3B0aW9uIiwicmVjdGFuZ2xlIiwiaXNWYWxpZEVsZW1lbnQiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJuZXh0UHJvcHMiLCJwcmV2U3RhdGUiLCJ1cGRhdGVJZCIsInByZXZEYXRhIiwicHJldlVwZGF0ZUlkIiwicHJldlRyYXZlbGxlcldpZHRoIiwicHJldlgiLCJwcmV2V2lkdGgiLCJ2YWx1ZVJhbmdlIiwic3RhcnQiLCJlbmQiLCJtaWRkbGUiLCJQdXJlQ29tcG9uZW50IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/Brush.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/cartesian/CartesianAxis.js":
/*!**************************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/CartesianAxis.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CartesianAxis = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _ShallowEqual = __webpack_require__(/*! ../util/ShallowEqual */ \"./node_modules/recharts/lib/util/ShallowEqual.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _Text = __webpack_require__(/*! ../component/Text */ \"./node_modules/recharts/lib/component/Text.js\");\nvar _Label = __webpack_require__(/*! ../component/Label */ \"./node_modules/recharts/lib/component/Label.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"./node_modules/recharts/lib/util/types.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _getTicks = __webpack_require__(/*! ./getTicks */ \"./node_modules/recharts/lib/cartesian/getTicks.js\");\nvar _excluded = [\n    \"viewBox\"\n], _excluded2 = [\n    \"viewBox\"\n], _excluded3 = [\n    \"ticks\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Cartesian Axis\n */ \n/** The orientation of the axis in correspondence to the chart */ /** A unit to be appended to a value */ /** The formatter function of tick */ var CartesianAxis = exports.CartesianAxis = /*#__PURE__*/ function(_Component) {\n    function CartesianAxis(props) {\n        var _this;\n        _classCallCheck(this, CartesianAxis);\n        _this = _callSuper(this, CartesianAxis, [\n            props\n        ]);\n        _this.state = {\n            fontSize: \"\",\n            letterSpacing: \"\"\n        };\n        return _this;\n    }\n    _inherits(CartesianAxis, _Component);\n    return _createClass(CartesianAxis, [\n        {\n            key: \"shouldComponentUpdate\",\n            value: function shouldComponentUpdate(_ref, nextState) {\n                var viewBox = _ref.viewBox, restProps = _objectWithoutProperties(_ref, _excluded);\n                // props.viewBox is sometimes generated every time -\n                // check that specially as object equality is likely to fail\n                var _this$props = this.props, viewBoxOld = _this$props.viewBox, restPropsOld = _objectWithoutProperties(_this$props, _excluded2);\n                return !(0, _ShallowEqual.shallowEqual)(viewBox, viewBoxOld) || !(0, _ShallowEqual.shallowEqual)(restProps, restPropsOld) || !(0, _ShallowEqual.shallowEqual)(nextState, this.state);\n            }\n        },\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                var htmlLayer = this.layerReference;\n                if (!htmlLayer) return;\n                var tick = htmlLayer.getElementsByClassName(\"recharts-cartesian-axis-tick-value\")[0];\n                if (tick) {\n                    this.setState({\n                        fontSize: window.getComputedStyle(tick).fontSize,\n                        letterSpacing: window.getComputedStyle(tick).letterSpacing\n                    });\n                }\n            }\n        },\n        {\n            key: \"getTickLineCoord\",\n            value: function getTickLineCoord(data) {\n                var _this$props2 = this.props, x = _this$props2.x, y = _this$props2.y, width = _this$props2.width, height = _this$props2.height, orientation = _this$props2.orientation, tickSize = _this$props2.tickSize, mirror = _this$props2.mirror, tickMargin = _this$props2.tickMargin;\n                var x1, x2, y1, y2, tx, ty;\n                var sign = mirror ? -1 : 1;\n                var finalTickSize = data.tickSize || tickSize;\n                var tickCoord = (0, _DataUtils.isNumber)(data.tickCoord) ? data.tickCoord : data.coordinate;\n                switch(orientation){\n                    case \"top\":\n                        x1 = x2 = data.coordinate;\n                        y2 = y + +!mirror * height;\n                        y1 = y2 - sign * finalTickSize;\n                        ty = y1 - sign * tickMargin;\n                        tx = tickCoord;\n                        break;\n                    case \"left\":\n                        y1 = y2 = data.coordinate;\n                        x2 = x + +!mirror * width;\n                        x1 = x2 - sign * finalTickSize;\n                        tx = x1 - sign * tickMargin;\n                        ty = tickCoord;\n                        break;\n                    case \"right\":\n                        y1 = y2 = data.coordinate;\n                        x2 = x + +mirror * width;\n                        x1 = x2 + sign * finalTickSize;\n                        tx = x1 + sign * tickMargin;\n                        ty = tickCoord;\n                        break;\n                    default:\n                        x1 = x2 = data.coordinate;\n                        y2 = y + +mirror * height;\n                        y1 = y2 + sign * finalTickSize;\n                        ty = y1 + sign * tickMargin;\n                        tx = tickCoord;\n                        break;\n                }\n                return {\n                    line: {\n                        x1: x1,\n                        y1: y1,\n                        x2: x2,\n                        y2: y2\n                    },\n                    tick: {\n                        x: tx,\n                        y: ty\n                    }\n                };\n            }\n        },\n        {\n            key: \"getTickTextAnchor\",\n            value: function getTickTextAnchor() {\n                var _this$props3 = this.props, orientation = _this$props3.orientation, mirror = _this$props3.mirror;\n                var textAnchor;\n                switch(orientation){\n                    case \"left\":\n                        textAnchor = mirror ? \"start\" : \"end\";\n                        break;\n                    case \"right\":\n                        textAnchor = mirror ? \"end\" : \"start\";\n                        break;\n                    default:\n                        textAnchor = \"middle\";\n                        break;\n                }\n                return textAnchor;\n            }\n        },\n        {\n            key: \"getTickVerticalAnchor\",\n            value: function getTickVerticalAnchor() {\n                var _this$props4 = this.props, orientation = _this$props4.orientation, mirror = _this$props4.mirror;\n                var verticalAnchor = \"end\";\n                switch(orientation){\n                    case \"left\":\n                    case \"right\":\n                        verticalAnchor = \"middle\";\n                        break;\n                    case \"top\":\n                        verticalAnchor = mirror ? \"start\" : \"end\";\n                        break;\n                    default:\n                        verticalAnchor = mirror ? \"end\" : \"start\";\n                        break;\n                }\n                return verticalAnchor;\n            }\n        },\n        {\n            key: \"renderAxisLine\",\n            value: function renderAxisLine() {\n                var _this$props5 = this.props, x = _this$props5.x, y = _this$props5.y, width = _this$props5.width, height = _this$props5.height, orientation = _this$props5.orientation, mirror = _this$props5.mirror, axisLine = _this$props5.axisLine;\n                var props = _objectSpread(_objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(this.props, false)), (0, _ReactUtils.filterProps)(axisLine, false)), {}, {\n                    fill: \"none\"\n                });\n                if (orientation === \"top\" || orientation === \"bottom\") {\n                    var needHeight = +(orientation === \"top\" && !mirror || orientation === \"bottom\" && mirror);\n                    props = _objectSpread(_objectSpread({}, props), {}, {\n                        x1: x,\n                        y1: y + needHeight * height,\n                        x2: x + width,\n                        y2: y + needHeight * height\n                    });\n                } else {\n                    var needWidth = +(orientation === \"left\" && !mirror || orientation === \"right\" && mirror);\n                    props = _objectSpread(_objectSpread({}, props), {}, {\n                        x1: x + needWidth * width,\n                        y1: y,\n                        x2: x + needWidth * width,\n                        y2: y + height\n                    });\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({}, props, {\n                    className: (0, _clsx[\"default\"])(\"recharts-cartesian-axis-line\", (0, _get[\"default\"])(axisLine, \"className\"))\n                }));\n            }\n        },\n        {\n            key: \"renderTicks\",\n            value: /**\n     * render the ticks\n     * @param {Array} ticks The ticks to actually render (overrides what was passed in props)\n     * @param {string} fontSize Fontsize to consider for tick spacing\n     * @param {string} letterSpacing Letterspacing to consider for tick spacing\n     * @return {ReactComponent} renderedTicks\n     */ function renderTicks(ticks, fontSize, letterSpacing) {\n                var _this2 = this;\n                var _this$props6 = this.props, tickLine = _this$props6.tickLine, stroke = _this$props6.stroke, tick = _this$props6.tick, tickFormatter = _this$props6.tickFormatter, unit = _this$props6.unit;\n                var finalTicks = (0, _getTicks.getTicks)(_objectSpread(_objectSpread({}, this.props), {}, {\n                    ticks: ticks\n                }), fontSize, letterSpacing);\n                var textAnchor = this.getTickTextAnchor();\n                var verticalAnchor = this.getTickVerticalAnchor();\n                var axisProps = (0, _ReactUtils.filterProps)(this.props, false);\n                var customTickProps = (0, _ReactUtils.filterProps)(tick, false);\n                var tickLineProps = _objectSpread(_objectSpread({}, axisProps), {}, {\n                    fill: \"none\"\n                }, (0, _ReactUtils.filterProps)(tickLine, false));\n                var items = finalTicks.map(function(entry, i) {\n                    var _this2$getTickLineCoo = _this2.getTickLineCoord(entry), lineCoord = _this2$getTickLineCoo.line, tickCoord = _this2$getTickLineCoo.tick;\n                    var tickProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread({\n                        textAnchor: textAnchor,\n                        verticalAnchor: verticalAnchor\n                    }, axisProps), {}, {\n                        stroke: \"none\",\n                        fill: stroke\n                    }, customTickProps), tickCoord), {}, {\n                        index: i,\n                        payload: entry,\n                        visibleTicksCount: finalTicks.length,\n                        tickFormatter: tickFormatter\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        className: \"recharts-cartesian-axis-tick\",\n                        key: \"tick-\".concat(entry.value, \"-\").concat(entry.coordinate, \"-\").concat(entry.tickCoord)\n                    }, (0, _types.adaptEventsOfChild)(_this2.props, entry, i)), tickLine && /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({}, tickLineProps, lineCoord, {\n                        className: (0, _clsx[\"default\"])(\"recharts-cartesian-axis-tick-line\", (0, _get[\"default\"])(tickLine, \"className\"))\n                    })), tick && CartesianAxis.renderTickItem(tick, tickProps, \"\".concat((0, _isFunction[\"default\"])(tickFormatter) ? tickFormatter(entry.value, i) : entry.value).concat(unit || \"\")));\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n                    className: \"recharts-cartesian-axis-ticks\"\n                }, items);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this3 = this;\n                var _this$props7 = this.props, axisLine = _this$props7.axisLine, width = _this$props7.width, height = _this$props7.height, ticksGenerator = _this$props7.ticksGenerator, className = _this$props7.className, hide = _this$props7.hide;\n                if (hide) {\n                    return null;\n                }\n                var _this$props8 = this.props, ticks = _this$props8.ticks, noTicksProps = _objectWithoutProperties(_this$props8, _excluded3);\n                var finalTicks = ticks;\n                if ((0, _isFunction[\"default\"])(ticksGenerator)) {\n                    finalTicks = ticks && ticks.length > 0 ? ticksGenerator(this.props) : ticksGenerator(noTicksProps);\n                }\n                if (width <= 0 || height <= 0 || !finalTicks || !finalTicks.length) {\n                    return null;\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: (0, _clsx[\"default\"])(\"recharts-cartesian-axis\", className),\n                    ref: function ref(_ref2) {\n                        _this3.layerReference = _ref2;\n                    }\n                }, axisLine && this.renderAxisLine(), this.renderTicks(finalTicks, this.state.fontSize, this.state.letterSpacing), _Label.Label.renderCallByParent(this.props));\n            }\n        }\n    ], [\n        {\n            key: \"renderTickItem\",\n            value: function renderTickItem(option, props, value) {\n                var tickItem;\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    tickItem = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                } else if ((0, _isFunction[\"default\"])(option)) {\n                    tickItem = option(props);\n                } else {\n                    tickItem = /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({}, props, {\n                        className: \"recharts-cartesian-axis-tick-value\"\n                    }), value);\n                }\n                return tickItem;\n            }\n        }\n    ]);\n}(_react.Component);\n_defineProperty(CartesianAxis, \"displayName\", \"CartesianAxis\");\n_defineProperty(CartesianAxis, \"defaultProps\", {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    viewBox: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n    },\n    // The orientation of axis\n    orientation: \"bottom\",\n    // The ticks\n    ticks: [],\n    stroke: \"#666\",\n    tickLine: true,\n    axisLine: true,\n    tick: true,\n    mirror: false,\n    minTickGap: 5,\n    // The width or height of tick\n    tickSize: 6,\n    tickMargin: 2,\n    interval: \"preserveEnd\"\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9DYXJ0ZXNpYW5BeGlzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxxQkFBcUIsR0FBRyxLQUFLO0FBQzdCLElBQUlHLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsY0FBY0MsdUJBQXVCRixtQkFBT0EsQ0FBQyw0Q0FBbUI7QUFDcEUsSUFBSUcsT0FBT0QsdUJBQXVCRixtQkFBT0EsQ0FBQyw4QkFBWTtBQUN0RCxJQUFJSSxRQUFRRix1QkFBdUJGLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlLLGdCQUFnQkwsbUJBQU9BLENBQUMsOEVBQXNCO0FBQ2xELElBQUlNLFNBQVNOLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJTyxRQUFRUCxtQkFBT0EsQ0FBQyx3RUFBbUI7QUFDdkMsSUFBSVEsU0FBU1IsbUJBQU9BLENBQUMsMEVBQW9CO0FBQ3pDLElBQUlTLGFBQWFULG1CQUFPQSxDQUFDLHdFQUFtQjtBQUM1QyxJQUFJVSxTQUFTVixtQkFBT0EsQ0FBQyxnRUFBZTtBQUNwQyxJQUFJVyxjQUFjWCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSVksWUFBWVosbUJBQU9BLENBQUMscUVBQVk7QUFDcEMsSUFBSWEsWUFBWTtJQUFDO0NBQVUsRUFDekJDLGFBQWE7SUFBQztDQUFVLEVBQ3hCQyxhQUFhO0lBQUM7Q0FBUTtBQUN4QixTQUFTYix1QkFBdUJjLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UseUJBQXlCQyxDQUFDO0lBQUksSUFBSSxjQUFjLE9BQU9DLFNBQVMsT0FBTztJQUFNLElBQUlDLElBQUksSUFBSUQsV0FBV0UsSUFBSSxJQUFJRjtJQUFXLE9BQU8sQ0FBQ0YsMkJB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QVcsR0FBRTFNLE1BQU0sQ0FBQyxVQUFVLENBQUMyTSxjQUFjLENBQUNGLFNBQVM7b0JBQzFEQyxXQUFXLFdBQVcsR0FBRTFNLE1BQU0sQ0FBQyxVQUFVLENBQUM0TSxZQUFZLENBQUNILFFBQVFoSTtnQkFDakUsT0FBTyxJQUFJLENBQUMsR0FBR3RFLFdBQVcsQ0FBQyxVQUFVLEVBQUVzTSxTQUFTO29CQUM5Q0MsV0FBV0QsT0FBT2hJO2dCQUNwQixPQUFPO29CQUNMaUksV0FBVyxXQUFXLEdBQUUxTSxNQUFNLENBQUMsVUFBVSxDQUFDa0ssYUFBYSxDQUFDekosTUFBTW9NLElBQUksRUFBRW5LLFNBQVMsQ0FBQyxHQUFHK0IsT0FBTzt3QkFDdEYwRixXQUFXO29CQUNiLElBQUlySztnQkFDTjtnQkFDQSxPQUFPNE07WUFDVDtRQUNGO0tBQUU7QUFDSixFQUFFMU0sT0FBTzhNLFNBQVM7QUFDbEJuSixnQkFBZ0I1RCxlQUFlLGVBQWU7QUFDOUM0RCxnQkFBZ0I1RCxlQUFlLGdCQUFnQjtJQUM3Q2tJLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUnBCLFNBQVM7UUFDUGlCLEdBQUc7UUFDSEMsR0FBRztRQUNIQyxPQUFPO1FBQ1BDLFFBQVE7SUFDVjtJQUNBLDBCQUEwQjtJQUMxQkMsYUFBYTtJQUNiLFlBQVk7SUFDWmdDLE9BQU8sRUFBRTtJQUNUSSxRQUFRO0lBQ1JELFVBQVU7SUFDVlgsVUFBVTtJQUNWcEMsTUFBTTtJQUNOYyxRQUFRO0lBQ1J3RSxZQUFZO0lBQ1osOEJBQThCO0lBQzlCekUsVUFBVTtJQUNWRSxZQUFZO0lBQ1p3RSxVQUFVO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9DYXJ0ZXNpYW5BeGlzLmpzPzg1MzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNhcnRlc2lhbkF4aXMgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcbnZhciBfZ2V0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2dldFwiKSk7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfU2hhbGxvd0VxdWFsID0gcmVxdWlyZShcIi4uL3V0aWwvU2hhbGxvd0VxdWFsXCIpO1xudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XG52YXIgX1RleHQgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L1RleHRcIik7XG52YXIgX0xhYmVsID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbFwiKTtcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi91dGlsL3R5cGVzXCIpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcbnZhciBfZ2V0VGlja3MgPSByZXF1aXJlKFwiLi9nZXRUaWNrc1wiKTtcbnZhciBfZXhjbHVkZWQgPSBbXCJ2aWV3Qm94XCJdLFxuICBfZXhjbHVkZWQyID0gW1widmlld0JveFwiXSxcbiAgX2V4Y2x1ZGVkMyA9IFtcInRpY2tzXCJdO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKipcbiAqIEBmaWxlT3ZlcnZpZXcgQ2FydGVzaWFuIEF4aXNcbiAqL1xuLyoqIFRoZSBvcmllbnRhdGlvbiBvZiB0aGUgYXhpcyBpbiBjb3JyZXNwb25kZW5jZSB0byB0aGUgY2hhcnQgKi9cbi8qKiBBIHVuaXQgdG8gYmUgYXBwZW5kZWQgdG8gYSB2YWx1ZSAqL1xuLyoqIFRoZSBmb3JtYXR0ZXIgZnVuY3Rpb24gb2YgdGljayAqL1xudmFyIENhcnRlc2lhbkF4aXMgPSBleHBvcnRzLkNhcnRlc2lhbkF4aXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgZnVuY3Rpb24gQ2FydGVzaWFuQXhpcyhwcm9wcykge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FydGVzaWFuQXhpcyk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIENhcnRlc2lhbkF4aXMsIFtwcm9wc10pO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgZm9udFNpemU6ICcnLFxuICAgICAgbGV0dGVyU3BhY2luZzogJydcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoQ2FydGVzaWFuQXhpcywgX0NvbXBvbmVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ2FydGVzaWFuQXhpcywgW3tcbiAgICBrZXk6IFwic2hvdWxkQ29tcG9uZW50VXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShfcmVmLCBuZXh0U3RhdGUpIHtcbiAgICAgIHZhciB2aWV3Qm94ID0gX3JlZi52aWV3Qm94LFxuICAgICAgICByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkKTtcbiAgICAgIC8vIHByb3BzLnZpZXdCb3ggaXMgc29tZXRpbWVzIGdlbmVyYXRlZCBldmVyeSB0aW1lIC1cbiAgICAgIC8vIGNoZWNrIHRoYXQgc3BlY2lhbGx5IGFzIG9iamVjdCBlcXVhbGl0eSBpcyBsaWtlbHkgdG8gZmFpbFxuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgdmlld0JveE9sZCA9IF90aGlzJHByb3BzLnZpZXdCb3gsXG4gICAgICAgIHJlc3RQcm9wc09sZCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRwcm9wcywgX2V4Y2x1ZGVkMik7XG4gICAgICByZXR1cm4gISgwLCBfU2hhbGxvd0VxdWFsLnNoYWxsb3dFcXVhbCkodmlld0JveCwgdmlld0JveE9sZCkgfHwgISgwLCBfU2hhbGxvd0VxdWFsLnNoYWxsb3dFcXVhbCkocmVzdFByb3BzLCByZXN0UHJvcHNPbGQpIHx8ICEoMCwgX1NoYWxsb3dFcXVhbC5zaGFsbG93RXF1YWwpKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIGh0bWxMYXllciA9IHRoaXMubGF5ZXJSZWZlcmVuY2U7XG4gICAgICBpZiAoIWh0bWxMYXllcikgcmV0dXJuO1xuICAgICAgdmFyIHRpY2sgPSBodG1sTGF5ZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncmVjaGFydHMtY2FydGVzaWFuLWF4aXMtdGljay12YWx1ZScpWzBdO1xuICAgICAgaWYgKHRpY2spIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgZm9udFNpemU6IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRpY2spLmZvbnRTaXplLFxuICAgICAgICAgIGxldHRlclNwYWNpbmc6IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRpY2spLmxldHRlclNwYWNpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb29yZGluYXRlcyBvZiBlbmRwb2ludHMgaW4gdGlja3NcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgb2YgYSBzaW1wbGUgdGlja1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gKHgxLCB5MSk6IFRoZSBjb29yZGluYXRlIG9mIGVuZHBvaW50IGNsb3NlIHRvIHRpY2sgdGV4dFxuICAgICAqICAoeDIsIHkyKTogVGhlIGNvb3JkaW5hdGUgb2YgZW5kcG9pbnQgY2xvc2UgdG8gYXhpc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFRpY2tMaW5lQ29vcmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGlja0xpbmVDb29yZChkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgeCA9IF90aGlzJHByb3BzMi54LFxuICAgICAgICB5ID0gX3RoaXMkcHJvcHMyLnksXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHMyLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczIuaGVpZ2h0LFxuICAgICAgICBvcmllbnRhdGlvbiA9IF90aGlzJHByb3BzMi5vcmllbnRhdGlvbixcbiAgICAgICAgdGlja1NpemUgPSBfdGhpcyRwcm9wczIudGlja1NpemUsXG4gICAgICAgIG1pcnJvciA9IF90aGlzJHByb3BzMi5taXJyb3IsXG4gICAgICAgIHRpY2tNYXJnaW4gPSBfdGhpcyRwcm9wczIudGlja01hcmdpbjtcbiAgICAgIHZhciB4MSwgeDIsIHkxLCB5MiwgdHgsIHR5O1xuICAgICAgdmFyIHNpZ24gPSBtaXJyb3IgPyAtMSA6IDE7XG4gICAgICB2YXIgZmluYWxUaWNrU2l6ZSA9IGRhdGEudGlja1NpemUgfHwgdGlja1NpemU7XG4gICAgICB2YXIgdGlja0Nvb3JkID0gKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGRhdGEudGlja0Nvb3JkKSA/IGRhdGEudGlja0Nvb3JkIDogZGF0YS5jb29yZGluYXRlO1xuICAgICAgc3dpdGNoIChvcmllbnRhdGlvbikge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIHgxID0geDIgPSBkYXRhLmNvb3JkaW5hdGU7XG4gICAgICAgICAgeTIgPSB5ICsgKyFtaXJyb3IgKiBoZWlnaHQ7XG4gICAgICAgICAgeTEgPSB5MiAtIHNpZ24gKiBmaW5hbFRpY2tTaXplO1xuICAgICAgICAgIHR5ID0geTEgLSBzaWduICogdGlja01hcmdpbjtcbiAgICAgICAgICB0eCA9IHRpY2tDb29yZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgeTEgPSB5MiA9IGRhdGEuY29vcmRpbmF0ZTtcbiAgICAgICAgICB4MiA9IHggKyArIW1pcnJvciAqIHdpZHRoO1xuICAgICAgICAgIHgxID0geDIgLSBzaWduICogZmluYWxUaWNrU2l6ZTtcbiAgICAgICAgICB0eCA9IHgxIC0gc2lnbiAqIHRpY2tNYXJnaW47XG4gICAgICAgICAgdHkgPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICB5MSA9IHkyID0gZGF0YS5jb29yZGluYXRlO1xuICAgICAgICAgIHgyID0geCArICttaXJyb3IgKiB3aWR0aDtcbiAgICAgICAgICB4MSA9IHgyICsgc2lnbiAqIGZpbmFsVGlja1NpemU7XG4gICAgICAgICAgdHggPSB4MSArIHNpZ24gKiB0aWNrTWFyZ2luO1xuICAgICAgICAgIHR5ID0gdGlja0Nvb3JkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHgxID0geDIgPSBkYXRhLmNvb3JkaW5hdGU7XG4gICAgICAgICAgeTIgPSB5ICsgK21pcnJvciAqIGhlaWdodDtcbiAgICAgICAgICB5MSA9IHkyICsgc2lnbiAqIGZpbmFsVGlja1NpemU7XG4gICAgICAgICAgdHkgPSB5MSArIHNpZ24gKiB0aWNrTWFyZ2luO1xuICAgICAgICAgIHR4ID0gdGlja0Nvb3JkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZToge1xuICAgICAgICAgIHgxOiB4MSxcbiAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgIHkyOiB5MlxuICAgICAgICB9LFxuICAgICAgICB0aWNrOiB7XG4gICAgICAgICAgeDogdHgsXG4gICAgICAgICAgeTogdHlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGlja1RleHRBbmNob3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGlja1RleHRBbmNob3IoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgb3JpZW50YXRpb24gPSBfdGhpcyRwcm9wczMub3JpZW50YXRpb24sXG4gICAgICAgIG1pcnJvciA9IF90aGlzJHByb3BzMy5taXJyb3I7XG4gICAgICB2YXIgdGV4dEFuY2hvcjtcbiAgICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgdGV4dEFuY2hvciA9IG1pcnJvciA/ICdzdGFydCcgOiAnZW5kJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHRleHRBbmNob3IgPSBtaXJyb3IgPyAnZW5kJyA6ICdzdGFydCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHRBbmNob3I7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRpY2tWZXJ0aWNhbEFuY2hvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaWNrVmVydGljYWxBbmNob3IoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgb3JpZW50YXRpb24gPSBfdGhpcyRwcm9wczQub3JpZW50YXRpb24sXG4gICAgICAgIG1pcnJvciA9IF90aGlzJHByb3BzNC5taXJyb3I7XG4gICAgICB2YXIgdmVydGljYWxBbmNob3IgPSAnZW5kJztcbiAgICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICB2ZXJ0aWNhbEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIHZlcnRpY2FsQW5jaG9yID0gbWlycm9yID8gJ3N0YXJ0JyA6ICdlbmQnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZlcnRpY2FsQW5jaG9yID0gbWlycm9yID8gJ2VuZCcgOiAnc3RhcnQnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZlcnRpY2FsQW5jaG9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJBeGlzTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJBeGlzTGluZSgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczUgPSB0aGlzLnByb3BzLFxuICAgICAgICB4ID0gX3RoaXMkcHJvcHM1LngsXG4gICAgICAgIHkgPSBfdGhpcyRwcm9wczUueSxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczUud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzNS5oZWlnaHQsXG4gICAgICAgIG9yaWVudGF0aW9uID0gX3RoaXMkcHJvcHM1Lm9yaWVudGF0aW9uLFxuICAgICAgICBtaXJyb3IgPSBfdGhpcyRwcm9wczUubWlycm9yLFxuICAgICAgICBheGlzTGluZSA9IF90aGlzJHByb3BzNS5heGlzTGluZTtcbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIGZhbHNlKSksICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykoYXhpc0xpbmUsIGZhbHNlKSksIHt9LCB7XG4gICAgICAgIGZpbGw6ICdub25lJ1xuICAgICAgfSk7XG4gICAgICBpZiAob3JpZW50YXRpb24gPT09ICd0b3AnIHx8IG9yaWVudGF0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICB2YXIgbmVlZEhlaWdodCA9ICsob3JpZW50YXRpb24gPT09ICd0b3AnICYmICFtaXJyb3IgfHwgb3JpZW50YXRpb24gPT09ICdib3R0b20nICYmIG1pcnJvcik7XG4gICAgICAgIHByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgICAgICAgeDE6IHgsXG4gICAgICAgICAgeTE6IHkgKyBuZWVkSGVpZ2h0ICogaGVpZ2h0LFxuICAgICAgICAgIHgyOiB4ICsgd2lkdGgsXG4gICAgICAgICAgeTI6IHkgKyBuZWVkSGVpZ2h0ICogaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5lZWRXaWR0aCA9ICsob3JpZW50YXRpb24gPT09ICdsZWZ0JyAmJiAhbWlycm9yIHx8IG9yaWVudGF0aW9uID09PSAncmlnaHQnICYmIG1pcnJvcik7XG4gICAgICAgIHByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgICAgICAgeDE6IHggKyBuZWVkV2lkdGggKiB3aWR0aCxcbiAgICAgICAgICB5MTogeSxcbiAgICAgICAgICB4MjogeCArIG5lZWRXaWR0aCAqIHdpZHRoLFxuICAgICAgICAgIHkyOiB5ICsgaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1jYXJ0ZXNpYW4tYXhpcy1saW5lJywgKDAsIF9nZXRbXCJkZWZhdWx0XCJdKShheGlzTGluZSwgJ2NsYXNzTmFtZScpKVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJUaWNrc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIHJlbmRlciB0aGUgdGlja3NcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0aWNrcyBUaGUgdGlja3MgdG8gYWN0dWFsbHkgcmVuZGVyIChvdmVycmlkZXMgd2hhdCB3YXMgcGFzc2VkIGluIHByb3BzKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb250U2l6ZSBGb250c2l6ZSB0byBjb25zaWRlciBmb3IgdGljayBzcGFjaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlclNwYWNpbmcgTGV0dGVyc3BhY2luZyB0byBjb25zaWRlciBmb3IgdGljayBzcGFjaW5nXG4gICAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IHJlbmRlcmVkVGlja3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW5kZXJUaWNrcyh0aWNrcywgZm9udFNpemUsIGxldHRlclNwYWNpbmcpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIF90aGlzJHByb3BzNiA9IHRoaXMucHJvcHMsXG4gICAgICAgIHRpY2tMaW5lID0gX3RoaXMkcHJvcHM2LnRpY2tMaW5lLFxuICAgICAgICBzdHJva2UgPSBfdGhpcyRwcm9wczYuc3Ryb2tlLFxuICAgICAgICB0aWNrID0gX3RoaXMkcHJvcHM2LnRpY2ssXG4gICAgICAgIHRpY2tGb3JtYXR0ZXIgPSBfdGhpcyRwcm9wczYudGlja0Zvcm1hdHRlcixcbiAgICAgICAgdW5pdCA9IF90aGlzJHByb3BzNi51bml0O1xuICAgICAgdmFyIGZpbmFsVGlja3MgPSAoMCwgX2dldFRpY2tzLmdldFRpY2tzKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMucHJvcHMpLCB7fSwge1xuICAgICAgICB0aWNrczogdGlja3NcbiAgICAgIH0pLCBmb250U2l6ZSwgbGV0dGVyU3BhY2luZyk7XG4gICAgICB2YXIgdGV4dEFuY2hvciA9IHRoaXMuZ2V0VGlja1RleHRBbmNob3IoKTtcbiAgICAgIHZhciB2ZXJ0aWNhbEFuY2hvciA9IHRoaXMuZ2V0VGlja1ZlcnRpY2FsQW5jaG9yKCk7XG4gICAgICB2YXIgYXhpc1Byb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aGlzLnByb3BzLCBmYWxzZSk7XG4gICAgICB2YXIgY3VzdG9tVGlja1Byb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aWNrLCBmYWxzZSk7XG4gICAgICB2YXIgdGlja0xpbmVQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYXhpc1Byb3BzKSwge30sIHtcbiAgICAgICAgZmlsbDogJ25vbmUnXG4gICAgICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRpY2tMaW5lLCBmYWxzZSkpO1xuICAgICAgdmFyIGl0ZW1zID0gZmluYWxUaWNrcy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gICAgICAgIHZhciBfdGhpczIkZ2V0VGlja0xpbmVDb28gPSBfdGhpczIuZ2V0VGlja0xpbmVDb29yZChlbnRyeSksXG4gICAgICAgICAgbGluZUNvb3JkID0gX3RoaXMyJGdldFRpY2tMaW5lQ29vLmxpbmUsXG4gICAgICAgICAgdGlja0Nvb3JkID0gX3RoaXMyJGdldFRpY2tMaW5lQ29vLnRpY2s7XG4gICAgICAgIHZhciB0aWNrUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yLFxuICAgICAgICAgIHZlcnRpY2FsQW5jaG9yOiB2ZXJ0aWNhbEFuY2hvclxuICAgICAgICB9LCBheGlzUHJvcHMpLCB7fSwge1xuICAgICAgICAgIHN0cm9rZTogJ25vbmUnLFxuICAgICAgICAgIGZpbGw6IHN0cm9rZVxuICAgICAgICB9LCBjdXN0b21UaWNrUHJvcHMpLCB0aWNrQ29vcmQpLCB7fSwge1xuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHBheWxvYWQ6IGVudHJ5LFxuICAgICAgICAgIHZpc2libGVUaWNrc0NvdW50OiBmaW5hbFRpY2tzLmxlbmd0aCxcbiAgICAgICAgICB0aWNrRm9ybWF0dGVyOiB0aWNrRm9ybWF0dGVyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIF9leHRlbmRzKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtY2FydGVzaWFuLWF4aXMtdGlja1wiLFxuICAgICAgICAgIGtleTogXCJ0aWNrLVwiLmNvbmNhdChlbnRyeS52YWx1ZSwgXCItXCIpLmNvbmNhdChlbnRyeS5jb29yZGluYXRlLCBcIi1cIikuY29uY2F0KGVudHJ5LnRpY2tDb29yZClcbiAgICAgICAgfSwgKDAsIF90eXBlcy5hZGFwdEV2ZW50c09mQ2hpbGQpKF90aGlzMi5wcm9wcywgZW50cnksIGkpKSwgdGlja0xpbmUgJiYgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImxpbmVcIiwgX2V4dGVuZHMoe30sIHRpY2tMaW5lUHJvcHMsIGxpbmVDb29yZCwge1xuICAgICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLWNhcnRlc2lhbi1heGlzLXRpY2stbGluZScsICgwLCBfZ2V0W1wiZGVmYXVsdFwiXSkodGlja0xpbmUsICdjbGFzc05hbWUnKSlcbiAgICAgICAgfSkpLCB0aWNrICYmIENhcnRlc2lhbkF4aXMucmVuZGVyVGlja0l0ZW0odGljaywgdGlja1Byb3BzLCBcIlwiLmNvbmNhdCgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKSh0aWNrRm9ybWF0dGVyKSA/IHRpY2tGb3JtYXR0ZXIoZW50cnkudmFsdWUsIGkpIDogZW50cnkudmFsdWUpLmNvbmNhdCh1bml0IHx8ICcnKSkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtY2FydGVzaWFuLWF4aXMtdGlja3NcIlxuICAgICAgfSwgaXRlbXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM3ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYXhpc0xpbmUgPSBfdGhpcyRwcm9wczcuYXhpc0xpbmUsXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM3LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczcuaGVpZ2h0LFxuICAgICAgICB0aWNrc0dlbmVyYXRvciA9IF90aGlzJHByb3BzNy50aWNrc0dlbmVyYXRvcixcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHM3LmNsYXNzTmFtZSxcbiAgICAgICAgaGlkZSA9IF90aGlzJHByb3BzNy5oaWRlO1xuICAgICAgaWYgKGhpZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgX3RoaXMkcHJvcHM4ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgdGlja3MgPSBfdGhpcyRwcm9wczgudGlja3MsXG4gICAgICAgIG5vVGlja3NQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRwcm9wczgsIF9leGNsdWRlZDMpO1xuICAgICAgdmFyIGZpbmFsVGlja3MgPSB0aWNrcztcbiAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKSh0aWNrc0dlbmVyYXRvcikpIHtcbiAgICAgICAgZmluYWxUaWNrcyA9IHRpY2tzICYmIHRpY2tzLmxlbmd0aCA+IDAgPyB0aWNrc0dlbmVyYXRvcih0aGlzLnByb3BzKSA6IHRpY2tzR2VuZXJhdG9yKG5vVGlja3NQcm9wcyk7XG4gICAgICB9XG4gICAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCB8fCAhZmluYWxUaWNrcyB8fCAhZmluYWxUaWNrcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtY2FydGVzaWFuLWF4aXMnLCBjbGFzc05hbWUpLFxuICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihfcmVmMikge1xuICAgICAgICAgIF90aGlzMy5sYXllclJlZmVyZW5jZSA9IF9yZWYyO1xuICAgICAgICB9XG4gICAgICB9LCBheGlzTGluZSAmJiB0aGlzLnJlbmRlckF4aXNMaW5lKCksIHRoaXMucmVuZGVyVGlja3MoZmluYWxUaWNrcywgdGhpcy5zdGF0ZS5mb250U2l6ZSwgdGhpcy5zdGF0ZS5sZXR0ZXJTcGFjaW5nKSwgX0xhYmVsLkxhYmVsLnJlbmRlckNhbGxCeVBhcmVudCh0aGlzLnByb3BzKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicmVuZGVyVGlja0l0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVGlja0l0ZW0ob3B0aW9uLCBwcm9wcywgdmFsdWUpIHtcbiAgICAgIHZhciB0aWNrSXRlbTtcbiAgICAgIGlmICggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQob3B0aW9uKSkge1xuICAgICAgICB0aWNrSXRlbSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChvcHRpb24sIHByb3BzKTtcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob3B0aW9uKSkge1xuICAgICAgICB0aWNrSXRlbSA9IG9wdGlvbihwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWNrSXRlbSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1RleHQuVGV4dCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWNhcnRlc2lhbi1heGlzLXRpY2stdmFsdWVcIlxuICAgICAgICB9KSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpY2tJdGVtO1xuICAgIH1cbiAgfV0pO1xufShfcmVhY3QuQ29tcG9uZW50KTtcbl9kZWZpbmVQcm9wZXJ0eShDYXJ0ZXNpYW5BeGlzLCBcImRpc3BsYXlOYW1lXCIsICdDYXJ0ZXNpYW5BeGlzJyk7XG5fZGVmaW5lUHJvcGVydHkoQ2FydGVzaWFuQXhpcywgXCJkZWZhdWx0UHJvcHNcIiwge1xuICB4OiAwLFxuICB5OiAwLFxuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwLFxuICB2aWV3Qm94OiB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9LFxuICAvLyBUaGUgb3JpZW50YXRpb24gb2YgYXhpc1xuICBvcmllbnRhdGlvbjogJ2JvdHRvbScsXG4gIC8vIFRoZSB0aWNrc1xuICB0aWNrczogW10sXG4gIHN0cm9rZTogJyM2NjYnLFxuICB0aWNrTGluZTogdHJ1ZSxcbiAgYXhpc0xpbmU6IHRydWUsXG4gIHRpY2s6IHRydWUsXG4gIG1pcnJvcjogZmFsc2UsXG4gIG1pblRpY2tHYXA6IDUsXG4gIC8vIFRoZSB3aWR0aCBvciBoZWlnaHQgb2YgdGlja1xuICB0aWNrU2l6ZTogNixcbiAgdGlja01hcmdpbjogMixcbiAgaW50ZXJ2YWw6ICdwcmVzZXJ2ZUVuZCdcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNhcnRlc2lhbkF4aXMiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfaXNGdW5jdGlvbiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfZ2V0IiwiX2Nsc3giLCJfU2hhbGxvd0VxdWFsIiwiX0xheWVyIiwiX1RleHQiLCJfTGFiZWwiLCJfRGF0YVV0aWxzIiwiX3R5cGVzIiwiX1JlYWN0VXRpbHMiLCJfZ2V0VGlja3MiLCJfZXhjbHVkZWQiLCJfZXhjbHVkZWQyIiwiX2V4Y2x1ZGVkMyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImFwcGx5Iiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJfQ29tcG9uZW50IiwiX3RoaXMiLCJzdGF0ZSIsImZvbnRTaXplIiwibGV0dGVyU3BhY2luZyIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsIl9yZWYiLCJuZXh0U3RhdGUiLCJ2aWV3Qm94IiwicmVzdFByb3BzIiwiX3RoaXMkcHJvcHMiLCJ2aWV3Qm94T2xkIiwicmVzdFByb3BzT2xkIiwic2hhbGxvd0VxdWFsIiwiY29tcG9uZW50RGlkTW91bnQiLCJodG1sTGF5ZXIiLCJsYXllclJlZmVyZW5jZSIsInRpY2siLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwic2V0U3RhdGUiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0VGlja0xpbmVDb29yZCIsImRhdGEiLCJfdGhpcyRwcm9wczIiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0Iiwib3JpZW50YXRpb24iLCJ0aWNrU2l6ZSIsIm1pcnJvciIsInRpY2tNYXJnaW4iLCJ4MSIsIngyIiwieTEiLCJ5MiIsInR4IiwidHkiLCJzaWduIiwiZmluYWxUaWNrU2l6ZSIsInRpY2tDb29yZCIsImlzTnVtYmVyIiwiY29vcmRpbmF0ZSIsImxpbmUiLCJnZXRUaWNrVGV4dEFuY2hvciIsIl90aGlzJHByb3BzMyIsInRleHRBbmNob3IiLCJnZXRUaWNrVmVydGljYWxBbmNob3IiLCJfdGhpcyRwcm9wczQiLCJ2ZXJ0aWNhbEFuY2hvciIsInJlbmRlckF4aXNMaW5lIiwiX3RoaXMkcHJvcHM1IiwiYXhpc0xpbmUiLCJmaWx0ZXJQcm9wcyIsImZpbGwiLCJuZWVkSGVpZ2h0IiwibmVlZFdpZHRoIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsInJlbmRlclRpY2tzIiwidGlja3MiLCJfdGhpczIiLCJfdGhpcyRwcm9wczYiLCJ0aWNrTGluZSIsInN0cm9rZSIsInRpY2tGb3JtYXR0ZXIiLCJ1bml0IiwiZmluYWxUaWNrcyIsImdldFRpY2tzIiwiYXhpc1Byb3BzIiwiY3VzdG9tVGlja1Byb3BzIiwidGlja0xpbmVQcm9wcyIsIml0ZW1zIiwibWFwIiwiZW50cnkiLCJfdGhpczIkZ2V0VGlja0xpbmVDb28iLCJsaW5lQ29vcmQiLCJ0aWNrUHJvcHMiLCJpbmRleCIsInBheWxvYWQiLCJ2aXNpYmxlVGlja3NDb3VudCIsIkxheWVyIiwiY29uY2F0IiwiYWRhcHRFdmVudHNPZkNoaWxkIiwicmVuZGVyVGlja0l0ZW0iLCJyZW5kZXIiLCJfdGhpczMiLCJfdGhpcyRwcm9wczciLCJ0aWNrc0dlbmVyYXRvciIsImhpZGUiLCJfdGhpcyRwcm9wczgiLCJub1RpY2tzUHJvcHMiLCJyZWYiLCJfcmVmMiIsIkxhYmVsIiwicmVuZGVyQ2FsbEJ5UGFyZW50Iiwib3B0aW9uIiwidGlja0l0ZW0iLCJpc1ZhbGlkRWxlbWVudCIsImNsb25lRWxlbWVudCIsIlRleHQiLCJDb21wb25lbnQiLCJtaW5UaWNrR2FwIiwiaW50ZXJ2YWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/CartesianAxis.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/cartesian/CartesianGrid.js":
/*!**************************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/CartesianGrid.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CartesianGrid = CartesianGrid;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"./node_modules/recharts/lib/util/LogUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _getTicks = __webpack_require__(/*! ./getTicks */ \"./node_modules/recharts/lib/cartesian/getTicks.js\");\nvar _CartesianAxis = __webpack_require__(/*! ./CartesianAxis */ \"./node_modules/recharts/lib/cartesian/CartesianAxis.js\");\nvar _chartLayoutContext = __webpack_require__(/*! ../context/chartLayoutContext */ \"./node_modules/recharts/lib/context/chartLayoutContext.js\");\nvar _excluded = [\n    \"x1\",\n    \"y1\",\n    \"x2\",\n    \"y2\",\n    \"key\"\n], _excluded2 = [\n    \"offset\"\n];\n/**\n * @fileOverview Cartesian Grid\n */ function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n/**\n * The <CartesianGrid horizontal\n */ var Background = function Background(props) {\n    var fill = props.fill;\n    if (!fill || fill === \"none\") {\n        return null;\n    }\n    var fillOpacity = props.fillOpacity, x = props.x, y = props.y, width = props.width, height = props.height, ry = props.ry;\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n        x: x,\n        y: y,\n        ry: ry,\n        width: width,\n        height: height,\n        stroke: \"none\",\n        fill: fill,\n        fillOpacity: fillOpacity,\n        className: \"recharts-cartesian-grid-bg\"\n    });\n};\nfunction renderLineItem(option, props) {\n    var lineItem;\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n        // @ts-expect-error typescript does not see the props type when cloning an element\n        lineItem = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n    } else if ((0, _isFunction[\"default\"])(option)) {\n        lineItem = option(props);\n    } else {\n        var x1 = props.x1, y1 = props.y1, x2 = props.x2, y2 = props.y2, key = props.key, others = _objectWithoutProperties(props, _excluded);\n        var _filterProps = (0, _ReactUtils.filterProps)(others, false), __ = _filterProps.offset, restOfFilteredProps = _objectWithoutProperties(_filterProps, _excluded2);\n        lineItem = /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({}, restOfFilteredProps, {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2,\n            fill: \"none\",\n            key: key\n        }));\n    }\n    return lineItem;\n}\nfunction HorizontalGridLines(props) {\n    var x = props.x, width = props.width, _props$horizontal = props.horizontal, horizontal = _props$horizontal === void 0 ? true : _props$horizontal, horizontalPoints = props.horizontalPoints;\n    if (!horizontal || !horizontalPoints || !horizontalPoints.length) {\n        return null;\n    }\n    var items = horizontalPoints.map(function(entry, i) {\n        var lineItemProps = _objectSpread(_objectSpread({}, props), {}, {\n            x1: x,\n            y1: entry,\n            x2: x + width,\n            y2: entry,\n            key: \"line-\".concat(i),\n            index: i\n        });\n        return renderLineItem(horizontal, lineItemProps);\n    });\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-cartesian-grid-horizontal\"\n    }, items);\n}\nfunction VerticalGridLines(props) {\n    var y = props.y, height = props.height, _props$vertical = props.vertical, vertical = _props$vertical === void 0 ? true : _props$vertical, verticalPoints = props.verticalPoints;\n    if (!vertical || !verticalPoints || !verticalPoints.length) {\n        return null;\n    }\n    var items = verticalPoints.map(function(entry, i) {\n        var lineItemProps = _objectSpread(_objectSpread({}, props), {}, {\n            x1: entry,\n            y1: y,\n            x2: entry,\n            y2: y + height,\n            key: \"line-\".concat(i),\n            index: i\n        });\n        return renderLineItem(vertical, lineItemProps);\n    });\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-cartesian-grid-vertical\"\n    }, items);\n}\nfunction HorizontalStripes(props) {\n    var horizontalFill = props.horizontalFill, fillOpacity = props.fillOpacity, x = props.x, y = props.y, width = props.width, height = props.height, horizontalPoints = props.horizontalPoints, _props$horizontal2 = props.horizontal, horizontal = _props$horizontal2 === void 0 ? true : _props$horizontal2;\n    if (!horizontal || !horizontalFill || !horizontalFill.length) {\n        return null;\n    }\n    // Why =y -y? I was trying to find any difference that this makes, with floating point numbers and edge cases but ... nothing.\n    var roundedSortedHorizontalPoints = horizontalPoints.map(function(e) {\n        return Math.round(e + y - y);\n    }).sort(function(a, b) {\n        return a - b;\n    });\n    // Why is this condition `!==` instead of `<=` ?\n    if (y !== roundedSortedHorizontalPoints[0]) {\n        roundedSortedHorizontalPoints.unshift(0);\n    }\n    var items = roundedSortedHorizontalPoints.map(function(entry, i) {\n        // Why do we strip only the last stripe if it is invisible, and not all invisible stripes?\n        var lastStripe = !roundedSortedHorizontalPoints[i + 1];\n        var lineHeight = lastStripe ? y + height - entry : roundedSortedHorizontalPoints[i + 1] - entry;\n        if (lineHeight <= 0) {\n            return null;\n        }\n        var colorIndex = i % horizontalFill.length;\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n            key: \"react-\".concat(i) // eslint-disable-line react/no-array-index-key\n            ,\n            y: entry,\n            x: x,\n            height: lineHeight,\n            width: width,\n            stroke: \"none\",\n            fill: horizontalFill[colorIndex],\n            fillOpacity: fillOpacity,\n            className: \"recharts-cartesian-grid-bg\"\n        });\n    });\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-cartesian-gridstripes-horizontal\"\n    }, items);\n}\nfunction VerticalStripes(props) {\n    var _props$vertical2 = props.vertical, vertical = _props$vertical2 === void 0 ? true : _props$vertical2, verticalFill = props.verticalFill, fillOpacity = props.fillOpacity, x = props.x, y = props.y, width = props.width, height = props.height, verticalPoints = props.verticalPoints;\n    if (!vertical || !verticalFill || !verticalFill.length) {\n        return null;\n    }\n    var roundedSortedVerticalPoints = verticalPoints.map(function(e) {\n        return Math.round(e + x - x);\n    }).sort(function(a, b) {\n        return a - b;\n    });\n    if (x !== roundedSortedVerticalPoints[0]) {\n        roundedSortedVerticalPoints.unshift(0);\n    }\n    var items = roundedSortedVerticalPoints.map(function(entry, i) {\n        var lastStripe = !roundedSortedVerticalPoints[i + 1];\n        var lineWidth = lastStripe ? x + width - entry : roundedSortedVerticalPoints[i + 1] - entry;\n        if (lineWidth <= 0) {\n            return null;\n        }\n        var colorIndex = i % verticalFill.length;\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n            key: \"react-\".concat(i) // eslint-disable-line react/no-array-index-key\n            ,\n            x: entry,\n            y: y,\n            width: lineWidth,\n            height: height,\n            stroke: \"none\",\n            fill: verticalFill[colorIndex],\n            fillOpacity: fillOpacity,\n            className: \"recharts-cartesian-grid-bg\"\n        });\n    });\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-cartesian-gridstripes-vertical\"\n    }, items);\n}\nvar defaultVerticalCoordinatesGenerator = function defaultVerticalCoordinatesGenerator(_ref, syncWithTicks) {\n    var xAxis = _ref.xAxis, width = _ref.width, height = _ref.height, offset = _ref.offset;\n    return (0, _ChartUtils.getCoordinatesOfGrid)((0, _getTicks.getTicks)(_objectSpread(_objectSpread(_objectSpread({}, _CartesianAxis.CartesianAxis.defaultProps), xAxis), {}, {\n        ticks: (0, _ChartUtils.getTicksOfAxis)(xAxis, true),\n        viewBox: {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n        }\n    })), offset.left, offset.left + offset.width, syncWithTicks);\n};\nvar defaultHorizontalCoordinatesGenerator = function defaultHorizontalCoordinatesGenerator(_ref2, syncWithTicks) {\n    var yAxis = _ref2.yAxis, width = _ref2.width, height = _ref2.height, offset = _ref2.offset;\n    return (0, _ChartUtils.getCoordinatesOfGrid)((0, _getTicks.getTicks)(_objectSpread(_objectSpread(_objectSpread({}, _CartesianAxis.CartesianAxis.defaultProps), yAxis), {}, {\n        ticks: (0, _ChartUtils.getTicksOfAxis)(yAxis, true),\n        viewBox: {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n        }\n    })), offset.top, offset.top + offset.height, syncWithTicks);\n};\nvar defaultProps = {\n    horizontal: true,\n    vertical: true,\n    // The ordinates of horizontal grid lines\n    horizontalPoints: [],\n    // The abscissas of vertical grid lines\n    verticalPoints: [],\n    stroke: \"#ccc\",\n    fill: \"none\",\n    // The fill of colors of grid lines\n    verticalFill: [],\n    horizontalFill: []\n};\nfunction CartesianGrid(props) {\n    var _props$stroke, _props$fill, _props$horizontal3, _props$horizontalFill, _props$vertical3, _props$verticalFill;\n    var chartWidth = (0, _chartLayoutContext.useChartWidth)();\n    var chartHeight = (0, _chartLayoutContext.useChartHeight)();\n    var offset = (0, _chartLayoutContext.useOffset)();\n    var propsIncludingDefaults = _objectSpread(_objectSpread({}, props), {}, {\n        stroke: (_props$stroke = props.stroke) !== null && _props$stroke !== void 0 ? _props$stroke : defaultProps.stroke,\n        fill: (_props$fill = props.fill) !== null && _props$fill !== void 0 ? _props$fill : defaultProps.fill,\n        horizontal: (_props$horizontal3 = props.horizontal) !== null && _props$horizontal3 !== void 0 ? _props$horizontal3 : defaultProps.horizontal,\n        horizontalFill: (_props$horizontalFill = props.horizontalFill) !== null && _props$horizontalFill !== void 0 ? _props$horizontalFill : defaultProps.horizontalFill,\n        vertical: (_props$vertical3 = props.vertical) !== null && _props$vertical3 !== void 0 ? _props$vertical3 : defaultProps.vertical,\n        verticalFill: (_props$verticalFill = props.verticalFill) !== null && _props$verticalFill !== void 0 ? _props$verticalFill : defaultProps.verticalFill,\n        x: (0, _DataUtils.isNumber)(props.x) ? props.x : offset.left,\n        y: (0, _DataUtils.isNumber)(props.y) ? props.y : offset.top,\n        width: (0, _DataUtils.isNumber)(props.width) ? props.width : offset.width,\n        height: (0, _DataUtils.isNumber)(props.height) ? props.height : offset.height\n    });\n    var x = propsIncludingDefaults.x, y = propsIncludingDefaults.y, width = propsIncludingDefaults.width, height = propsIncludingDefaults.height, syncWithTicks = propsIncludingDefaults.syncWithTicks, horizontalValues = propsIncludingDefaults.horizontalValues, verticalValues = propsIncludingDefaults.verticalValues;\n    // @ts-expect-error the scale prop is mixed up - we need to untagle this at some point\n    var xAxis = (0, _chartLayoutContext.useArbitraryXAxis)();\n    // @ts-expect-error the scale prop is mixed up - we need to untagle this at some point\n    var yAxis = (0, _chartLayoutContext.useYAxisWithFiniteDomainOrRandom)();\n    if (!(0, _DataUtils.isNumber)(width) || width <= 0 || !(0, _DataUtils.isNumber)(height) || height <= 0 || !(0, _DataUtils.isNumber)(x) || x !== +x || !(0, _DataUtils.isNumber)(y) || y !== +y) {\n        return null;\n    }\n    /*\n   * verticalCoordinatesGenerator and horizontalCoordinatesGenerator are defined\n   * outside of the propsIncludingDefaults because they were never part of the original props\n   * and they were never passed as a prop down to horizontal/vertical custom elements.\n   * If we add these two to propsIncludingDefaults then we are changing public API.\n   * Not a bad thing per se but also not necessary.\n   */ var verticalCoordinatesGenerator = propsIncludingDefaults.verticalCoordinatesGenerator || defaultVerticalCoordinatesGenerator;\n    var horizontalCoordinatesGenerator = propsIncludingDefaults.horizontalCoordinatesGenerator || defaultHorizontalCoordinatesGenerator;\n    var horizontalPoints = propsIncludingDefaults.horizontalPoints, verticalPoints = propsIncludingDefaults.verticalPoints;\n    // No horizontal points are specified\n    if ((!horizontalPoints || !horizontalPoints.length) && (0, _isFunction[\"default\"])(horizontalCoordinatesGenerator)) {\n        var isHorizontalValues = horizontalValues && horizontalValues.length;\n        var generatorResult = horizontalCoordinatesGenerator({\n            yAxis: yAxis ? _objectSpread(_objectSpread({}, yAxis), {}, {\n                ticks: isHorizontalValues ? horizontalValues : yAxis.ticks\n            }) : undefined,\n            width: chartWidth,\n            height: chartHeight,\n            offset: offset\n        }, isHorizontalValues ? true : syncWithTicks);\n        (0, _LogUtils.warn)(Array.isArray(generatorResult), \"horizontalCoordinatesGenerator should return Array but instead it returned [\".concat(_typeof(generatorResult), \"]\"));\n        if (Array.isArray(generatorResult)) {\n            horizontalPoints = generatorResult;\n        }\n    }\n    // No vertical points are specified\n    if ((!verticalPoints || !verticalPoints.length) && (0, _isFunction[\"default\"])(verticalCoordinatesGenerator)) {\n        var isVerticalValues = verticalValues && verticalValues.length;\n        var _generatorResult = verticalCoordinatesGenerator({\n            xAxis: xAxis ? _objectSpread(_objectSpread({}, xAxis), {}, {\n                ticks: isVerticalValues ? verticalValues : xAxis.ticks\n            }) : undefined,\n            width: chartWidth,\n            height: chartHeight,\n            offset: offset\n        }, isVerticalValues ? true : syncWithTicks);\n        (0, _LogUtils.warn)(Array.isArray(_generatorResult), \"verticalCoordinatesGenerator should return Array but instead it returned [\".concat(_typeof(_generatorResult), \"]\"));\n        if (Array.isArray(_generatorResult)) {\n            verticalPoints = _generatorResult;\n        }\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-cartesian-grid\"\n    }, /*#__PURE__*/ _react[\"default\"].createElement(Background, {\n        fill: propsIncludingDefaults.fill,\n        fillOpacity: propsIncludingDefaults.fillOpacity,\n        x: propsIncludingDefaults.x,\n        y: propsIncludingDefaults.y,\n        width: propsIncludingDefaults.width,\n        height: propsIncludingDefaults.height,\n        ry: propsIncludingDefaults.ry\n    }), /*#__PURE__*/ _react[\"default\"].createElement(HorizontalGridLines, _extends({}, propsIncludingDefaults, {\n        offset: offset,\n        horizontalPoints: horizontalPoints,\n        xAxis: xAxis,\n        yAxis: yAxis\n    })), /*#__PURE__*/ _react[\"default\"].createElement(VerticalGridLines, _extends({}, propsIncludingDefaults, {\n        offset: offset,\n        verticalPoints: verticalPoints,\n        xAxis: xAxis,\n        yAxis: yAxis\n    })), /*#__PURE__*/ _react[\"default\"].createElement(HorizontalStripes, _extends({}, propsIncludingDefaults, {\n        horizontalPoints: horizontalPoints\n    })), /*#__PURE__*/ _react[\"default\"].createElement(VerticalStripes, _extends({}, propsIncludingDefaults, {\n        verticalPoints: verticalPoints\n    })));\n}\nCartesianGrid.displayName = \"CartesianGrid\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9DYXJ0ZXNpYW5HcmlkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxxQkFBcUIsR0FBR0U7QUFDeEIsSUFBSUMsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxjQUFjRix1QkFBdUJDLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJRSxZQUFZRixtQkFBT0EsQ0FBQyxzRUFBa0I7QUFDMUMsSUFBSUcsYUFBYUgsbUJBQU9BLENBQUMsd0VBQW1CO0FBQzVDLElBQUlJLGNBQWNKLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJSyxjQUFjTCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSU0sWUFBWU4sbUJBQU9BLENBQUMscUVBQVk7QUFDcEMsSUFBSU8saUJBQWlCUCxtQkFBT0EsQ0FBQywrRUFBaUI7QUFDOUMsSUFBSVEsc0JBQXNCUixtQkFBT0EsQ0FBQyxnR0FBK0I7QUFDakUsSUFBSVMsWUFBWTtJQUFDO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FBTSxFQUM3Q0MsYUFBYTtJQUFDO0NBQVM7QUFDekI7O0NBRUMsR0FDRCxTQUFTWCx1QkFBdUJZLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxH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ckNDLElBQUk4RSx1QkFBdUI5RSxFQUFFO0lBQy9CLElBQUksV0FBVyxHQUFFdEUsTUFBTSxDQUFDLFVBQVUsQ0FBQ3VFLGFBQWEsQ0FBQ2tCLHFCQUFxQnZDLFNBQVMsQ0FBQyxHQUFHa0csd0JBQXdCO1FBQ3pHN0QsUUFBUUE7UUFDUkssa0JBQWtCQTtRQUNsQmdDLE9BQU9BO1FBQ1BXLE9BQU9BO0lBQ1QsS0FBSyxXQUFXLEdBQUV2SSxNQUFNLENBQUMsVUFBVSxDQUFDdUUsYUFBYSxDQUFDNEIsbUJBQW1CakQsU0FBUyxDQUFDLEdBQUdrRyx3QkFBd0I7UUFDeEc3RCxRQUFRQTtRQUNSZSxnQkFBZ0JBO1FBQ2hCc0IsT0FBT0E7UUFDUFcsT0FBT0E7SUFDVCxLQUFLLFdBQVcsR0FBRXZJLE1BQU0sQ0FBQyxVQUFVLENBQUN1RSxhQUFhLENBQUNnQyxtQkFBbUJyRCxTQUFTLENBQUMsR0FBR2tHLHdCQUF3QjtRQUN4R3hELGtCQUFrQkE7SUFDcEIsS0FBSyxXQUFXLEdBQUU1RixNQUFNLENBQUMsVUFBVSxDQUFDdUUsYUFBYSxDQUFDNkMsaUJBQWlCbEUsU0FBUyxDQUFDLEdBQUdrRyx3QkFBd0I7UUFDdEc5QyxnQkFBZ0JBO0lBQ2xCO0FBQ0Y7QUFDQXZHLGNBQWNxSyxXQUFXLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9DYXJ0ZXNpYW5HcmlkLmpzPzU0MzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNhcnRlc2lhbkdyaWQgPSBDYXJ0ZXNpYW5HcmlkO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcbnZhciBfTG9nVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Mb2dVdGlsc1wiKTtcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XG52YXIgX2dldFRpY2tzID0gcmVxdWlyZShcIi4vZ2V0VGlja3NcIik7XG52YXIgX0NhcnRlc2lhbkF4aXMgPSByZXF1aXJlKFwiLi9DYXJ0ZXNpYW5BeGlzXCIpO1xudmFyIF9jaGFydExheW91dENvbnRleHQgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jaGFydExheW91dENvbnRleHRcIik7XG52YXIgX2V4Y2x1ZGVkID0gW1wieDFcIiwgXCJ5MVwiLCBcIngyXCIsIFwieTJcIiwgXCJrZXlcIl0sXG4gIF9leGNsdWRlZDIgPSBbXCJvZmZzZXRcIl07XG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgQ2FydGVzaWFuIEdyaWRcbiAqL1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuLyoqXG4gKiBUaGUgPENhcnRlc2lhbkdyaWQgaG9yaXpvbnRhbFxuICovXG5cbnZhciBCYWNrZ3JvdW5kID0gZnVuY3Rpb24gQmFja2dyb3VuZChwcm9wcykge1xuICB2YXIgZmlsbCA9IHByb3BzLmZpbGw7XG4gIGlmICghZmlsbCB8fCBmaWxsID09PSAnbm9uZScpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgZmlsbE9wYWNpdHkgPSBwcm9wcy5maWxsT3BhY2l0eSxcbiAgICB4ID0gcHJvcHMueCxcbiAgICB5ID0gcHJvcHMueSxcbiAgICB3aWR0aCA9IHByb3BzLndpZHRoLFxuICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcbiAgICByeSA9IHByb3BzLnJ5O1xuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICByeTogcnksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHN0cm9rZTogXCJub25lXCIsXG4gICAgZmlsbDogZmlsbCxcbiAgICBmaWxsT3BhY2l0eTogZmlsbE9wYWNpdHksXG4gICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWNhcnRlc2lhbi1ncmlkLWJnXCJcbiAgfSk7XG59O1xuZnVuY3Rpb24gcmVuZGVyTGluZUl0ZW0ob3B0aW9uLCBwcm9wcykge1xuICB2YXIgbGluZUl0ZW07XG4gIGlmICggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQob3B0aW9uKSkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdHlwZXNjcmlwdCBkb2VzIG5vdCBzZWUgdGhlIHByb3BzIHR5cGUgd2hlbiBjbG9uaW5nIGFuIGVsZW1lbnRcbiAgICBsaW5lSXRlbSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChvcHRpb24sIHByb3BzKTtcbiAgfSBlbHNlIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvcHRpb24pKSB7XG4gICAgbGluZUl0ZW0gPSBvcHRpb24ocHJvcHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciB4MSA9IHByb3BzLngxLFxuICAgICAgeTEgPSBwcm9wcy55MSxcbiAgICAgIHgyID0gcHJvcHMueDIsXG4gICAgICB5MiA9IHByb3BzLnkyLFxuICAgICAga2V5ID0gcHJvcHMua2V5LFxuICAgICAgb3RoZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xuICAgIHZhciBfZmlsdGVyUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKG90aGVycywgZmFsc2UpLFxuICAgICAgX18gPSBfZmlsdGVyUHJvcHMub2Zmc2V0LFxuICAgICAgcmVzdE9mRmlsdGVyZWRQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfZmlsdGVyUHJvcHMsIF9leGNsdWRlZDIpO1xuICAgIGxpbmVJdGVtID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImxpbmVcIiwgX2V4dGVuZHMoe30sIHJlc3RPZkZpbHRlcmVkUHJvcHMsIHtcbiAgICAgIHgxOiB4MSxcbiAgICAgIHkxOiB5MSxcbiAgICAgIHgyOiB4MixcbiAgICAgIHkyOiB5MixcbiAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAga2V5OiBrZXlcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIGxpbmVJdGVtO1xufVxuZnVuY3Rpb24gSG9yaXpvbnRhbEdyaWRMaW5lcyhwcm9wcykge1xuICB2YXIgeCA9IHByb3BzLngsXG4gICAgd2lkdGggPSBwcm9wcy53aWR0aCxcbiAgICBfcHJvcHMkaG9yaXpvbnRhbCA9IHByb3BzLmhvcml6b250YWwsXG4gICAgaG9yaXpvbnRhbCA9IF9wcm9wcyRob3Jpem9udGFsID09PSB2b2lkIDAgPyB0cnVlIDogX3Byb3BzJGhvcml6b250YWwsXG4gICAgaG9yaXpvbnRhbFBvaW50cyA9IHByb3BzLmhvcml6b250YWxQb2ludHM7XG4gIGlmICghaG9yaXpvbnRhbCB8fCAhaG9yaXpvbnRhbFBvaW50cyB8fCAhaG9yaXpvbnRhbFBvaW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgaXRlbXMgPSBob3Jpem9udGFsUG9pbnRzLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgICB2YXIgbGluZUl0ZW1Qcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgeDE6IHgsXG4gICAgICB5MTogZW50cnksXG4gICAgICB4MjogeCArIHdpZHRoLFxuICAgICAgeTI6IGVudHJ5LFxuICAgICAga2V5OiBcImxpbmUtXCIuY29uY2F0KGkpLFxuICAgICAgaW5kZXg6IGlcbiAgICB9KTtcbiAgICByZXR1cm4gcmVuZGVyTGluZUl0ZW0oaG9yaXpvbnRhbCwgbGluZUl0ZW1Qcm9wcyk7XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1jYXJ0ZXNpYW4tZ3JpZC1ob3Jpem9udGFsXCJcbiAgfSwgaXRlbXMpO1xufVxuZnVuY3Rpb24gVmVydGljYWxHcmlkTGluZXMocHJvcHMpIHtcbiAgdmFyIHkgPSBwcm9wcy55LFxuICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcbiAgICBfcHJvcHMkdmVydGljYWwgPSBwcm9wcy52ZXJ0aWNhbCxcbiAgICB2ZXJ0aWNhbCA9IF9wcm9wcyR2ZXJ0aWNhbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9wcm9wcyR2ZXJ0aWNhbCxcbiAgICB2ZXJ0aWNhbFBvaW50cyA9IHByb3BzLnZlcnRpY2FsUG9pbnRzO1xuICBpZiAoIXZlcnRpY2FsIHx8ICF2ZXJ0aWNhbFBvaW50cyB8fCAhdmVydGljYWxQb2ludHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGl0ZW1zID0gdmVydGljYWxQb2ludHMubWFwKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xuICAgIHZhciBsaW5lSXRlbVByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgICB4MTogZW50cnksXG4gICAgICB5MTogeSxcbiAgICAgIHgyOiBlbnRyeSxcbiAgICAgIHkyOiB5ICsgaGVpZ2h0LFxuICAgICAga2V5OiBcImxpbmUtXCIuY29uY2F0KGkpLFxuICAgICAgaW5kZXg6IGlcbiAgICB9KTtcbiAgICByZXR1cm4gcmVuZGVyTGluZUl0ZW0odmVydGljYWwsIGxpbmVJdGVtUHJvcHMpO1xuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtY2FydGVzaWFuLWdyaWQtdmVydGljYWxcIlxuICB9LCBpdGVtcyk7XG59XG5mdW5jdGlvbiBIb3Jpem9udGFsU3RyaXBlcyhwcm9wcykge1xuICB2YXIgaG9yaXpvbnRhbEZpbGwgPSBwcm9wcy5ob3Jpem9udGFsRmlsbCxcbiAgICBmaWxsT3BhY2l0eSA9IHByb3BzLmZpbGxPcGFjaXR5LFxuICAgIHggPSBwcm9wcy54LFxuICAgIHkgPSBwcm9wcy55LFxuICAgIHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxuICAgIGhvcml6b250YWxQb2ludHMgPSBwcm9wcy5ob3Jpem9udGFsUG9pbnRzLFxuICAgIF9wcm9wcyRob3Jpem9udGFsMiA9IHByb3BzLmhvcml6b250YWwsXG4gICAgaG9yaXpvbnRhbCA9IF9wcm9wcyRob3Jpem9udGFsMiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9wcm9wcyRob3Jpem9udGFsMjtcbiAgaWYgKCFob3Jpem9udGFsIHx8ICFob3Jpem9udGFsRmlsbCB8fCAhaG9yaXpvbnRhbEZpbGwubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBXaHkgPXkgLXk/IEkgd2FzIHRyeWluZyB0byBmaW5kIGFueSBkaWZmZXJlbmNlIHRoYXQgdGhpcyBtYWtlcywgd2l0aCBmbG9hdGluZyBwb2ludCBudW1iZXJzIGFuZCBlZGdlIGNhc2VzIGJ1dCAuLi4gbm90aGluZy5cbiAgdmFyIHJvdW5kZWRTb3J0ZWRIb3Jpem9udGFsUG9pbnRzID0gaG9yaXpvbnRhbFBvaW50cy5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChlICsgeSAtIHkpO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xuICB9KTtcbiAgLy8gV2h5IGlzIHRoaXMgY29uZGl0aW9uIGAhPT1gIGluc3RlYWQgb2YgYDw9YCA/XG4gIGlmICh5ICE9PSByb3VuZGVkU29ydGVkSG9yaXpvbnRhbFBvaW50c1swXSkge1xuICAgIHJvdW5kZWRTb3J0ZWRIb3Jpem9udGFsUG9pbnRzLnVuc2hpZnQoMCk7XG4gIH1cbiAgdmFyIGl0ZW1zID0gcm91bmRlZFNvcnRlZEhvcml6b250YWxQb2ludHMubWFwKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xuICAgIC8vIFdoeSBkbyB3ZSBzdHJpcCBvbmx5IHRoZSBsYXN0IHN0cmlwZSBpZiBpdCBpcyBpbnZpc2libGUsIGFuZCBub3QgYWxsIGludmlzaWJsZSBzdHJpcGVzP1xuICAgIHZhciBsYXN0U3RyaXBlID0gIXJvdW5kZWRTb3J0ZWRIb3Jpem9udGFsUG9pbnRzW2kgKyAxXTtcbiAgICB2YXIgbGluZUhlaWdodCA9IGxhc3RTdHJpcGUgPyB5ICsgaGVpZ2h0IC0gZW50cnkgOiByb3VuZGVkU29ydGVkSG9yaXpvbnRhbFBvaW50c1tpICsgMV0gLSBlbnRyeTtcbiAgICBpZiAobGluZUhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNvbG9ySW5kZXggPSBpICUgaG9yaXpvbnRhbEZpbGwubGVuZ3RoO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgICBrZXk6IFwicmVhY3QtXCIuY29uY2F0KGkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICAsXG4gICAgICB5OiBlbnRyeSxcbiAgICAgIHg6IHgsXG4gICAgICBoZWlnaHQ6IGxpbmVIZWlnaHQsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgICAgZmlsbDogaG9yaXpvbnRhbEZpbGxbY29sb3JJbmRleF0sXG4gICAgICBmaWxsT3BhY2l0eTogZmlsbE9wYWNpdHksXG4gICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtY2FydGVzaWFuLWdyaWQtYmdcIlxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtY2FydGVzaWFuLWdyaWRzdHJpcGVzLWhvcml6b250YWxcIlxuICB9LCBpdGVtcyk7XG59XG5mdW5jdGlvbiBWZXJ0aWNhbFN0cmlwZXMocHJvcHMpIHtcbiAgdmFyIF9wcm9wcyR2ZXJ0aWNhbDIgPSBwcm9wcy52ZXJ0aWNhbCxcbiAgICB2ZXJ0aWNhbCA9IF9wcm9wcyR2ZXJ0aWNhbDIgPT09IHZvaWQgMCA/IHRydWUgOiBfcHJvcHMkdmVydGljYWwyLFxuICAgIHZlcnRpY2FsRmlsbCA9IHByb3BzLnZlcnRpY2FsRmlsbCxcbiAgICBmaWxsT3BhY2l0eSA9IHByb3BzLmZpbGxPcGFjaXR5LFxuICAgIHggPSBwcm9wcy54LFxuICAgIHkgPSBwcm9wcy55LFxuICAgIHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxuICAgIHZlcnRpY2FsUG9pbnRzID0gcHJvcHMudmVydGljYWxQb2ludHM7XG4gIGlmICghdmVydGljYWwgfHwgIXZlcnRpY2FsRmlsbCB8fCAhdmVydGljYWxGaWxsLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByb3VuZGVkU29ydGVkVmVydGljYWxQb2ludHMgPSB2ZXJ0aWNhbFBvaW50cy5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChlICsgeCAtIHgpO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xuICB9KTtcbiAgaWYgKHggIT09IHJvdW5kZWRTb3J0ZWRWZXJ0aWNhbFBvaW50c1swXSkge1xuICAgIHJvdW5kZWRTb3J0ZWRWZXJ0aWNhbFBvaW50cy51bnNoaWZ0KDApO1xuICB9XG4gIHZhciBpdGVtcyA9IHJvdW5kZWRTb3J0ZWRWZXJ0aWNhbFBvaW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gICAgdmFyIGxhc3RTdHJpcGUgPSAhcm91bmRlZFNvcnRlZFZlcnRpY2FsUG9pbnRzW2kgKyAxXTtcbiAgICB2YXIgbGluZVdpZHRoID0gbGFzdFN0cmlwZSA/IHggKyB3aWR0aCAtIGVudHJ5IDogcm91bmRlZFNvcnRlZFZlcnRpY2FsUG9pbnRzW2kgKyAxXSAtIGVudHJ5O1xuICAgIGlmIChsaW5lV2lkdGggPD0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjb2xvckluZGV4ID0gaSAlIHZlcnRpY2FsRmlsbC5sZW5ndGg7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICAgIGtleTogXCJyZWFjdC1cIi5jb25jYXQoaSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcbiAgICAgICxcbiAgICAgIHg6IGVudHJ5LFxuICAgICAgeTogeSxcbiAgICAgIHdpZHRoOiBsaW5lV2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHN0cm9rZTogXCJub25lXCIsXG4gICAgICBmaWxsOiB2ZXJ0aWNhbEZpbGxbY29sb3JJbmRleF0sXG4gICAgICBmaWxsT3BhY2l0eTogZmlsbE9wYWNpdHksXG4gICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtY2FydGVzaWFuLWdyaWQtYmdcIlxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtY2FydGVzaWFuLWdyaWRzdHJpcGVzLXZlcnRpY2FsXCJcbiAgfSwgaXRlbXMpO1xufVxudmFyIGRlZmF1bHRWZXJ0aWNhbENvb3JkaW5hdGVzR2VuZXJhdG9yID0gZnVuY3Rpb24gZGVmYXVsdFZlcnRpY2FsQ29vcmRpbmF0ZXNHZW5lcmF0b3IoX3JlZiwgc3luY1dpdGhUaWNrcykge1xuICB2YXIgeEF4aXMgPSBfcmVmLnhBeGlzLFxuICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICBoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICBvZmZzZXQgPSBfcmVmLm9mZnNldDtcbiAgcmV0dXJuICgwLCBfQ2hhcnRVdGlscy5nZXRDb29yZGluYXRlc09mR3JpZCkoKDAsIF9nZXRUaWNrcy5nZXRUaWNrcykoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF9DYXJ0ZXNpYW5BeGlzLkNhcnRlc2lhbkF4aXMuZGVmYXVsdFByb3BzKSwgeEF4aXMpLCB7fSwge1xuICAgIHRpY2tzOiAoMCwgX0NoYXJ0VXRpbHMuZ2V0VGlja3NPZkF4aXMpKHhBeGlzLCB0cnVlKSxcbiAgICB2aWV3Qm94OiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfVxuICB9KSksIG9mZnNldC5sZWZ0LCBvZmZzZXQubGVmdCArIG9mZnNldC53aWR0aCwgc3luY1dpdGhUaWNrcyk7XG59O1xudmFyIGRlZmF1bHRIb3Jpem9udGFsQ29vcmRpbmF0ZXNHZW5lcmF0b3IgPSBmdW5jdGlvbiBkZWZhdWx0SG9yaXpvbnRhbENvb3JkaW5hdGVzR2VuZXJhdG9yKF9yZWYyLCBzeW5jV2l0aFRpY2tzKSB7XG4gIHZhciB5QXhpcyA9IF9yZWYyLnlBeGlzLFxuICAgIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0LFxuICAgIG9mZnNldCA9IF9yZWYyLm9mZnNldDtcbiAgcmV0dXJuICgwLCBfQ2hhcnRVdGlscy5nZXRDb29yZGluYXRlc09mR3JpZCkoKDAsIF9nZXRUaWNrcy5nZXRUaWNrcykoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF9DYXJ0ZXNpYW5BeGlzLkNhcnRlc2lhbkF4aXMuZGVmYXVsdFByb3BzKSwgeUF4aXMpLCB7fSwge1xuICAgIHRpY2tzOiAoMCwgX0NoYXJ0VXRpbHMuZ2V0VGlja3NPZkF4aXMpKHlBeGlzLCB0cnVlKSxcbiAgICB2aWV3Qm94OiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfVxuICB9KSksIG9mZnNldC50b3AsIG9mZnNldC50b3AgKyBvZmZzZXQuaGVpZ2h0LCBzeW5jV2l0aFRpY2tzKTtcbn07XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBob3Jpem9udGFsOiB0cnVlLFxuICB2ZXJ0aWNhbDogdHJ1ZSxcbiAgLy8gVGhlIG9yZGluYXRlcyBvZiBob3Jpem9udGFsIGdyaWQgbGluZXNcbiAgaG9yaXpvbnRhbFBvaW50czogW10sXG4gIC8vIFRoZSBhYnNjaXNzYXMgb2YgdmVydGljYWwgZ3JpZCBsaW5lc1xuICB2ZXJ0aWNhbFBvaW50czogW10sXG4gIHN0cm9rZTogJyNjY2MnLFxuICBmaWxsOiAnbm9uZScsXG4gIC8vIFRoZSBmaWxsIG9mIGNvbG9ycyBvZiBncmlkIGxpbmVzXG4gIHZlcnRpY2FsRmlsbDogW10sXG4gIGhvcml6b250YWxGaWxsOiBbXVxufTtcbmZ1bmN0aW9uIENhcnRlc2lhbkdyaWQocHJvcHMpIHtcbiAgdmFyIF9wcm9wcyRzdHJva2UsIF9wcm9wcyRmaWxsLCBfcHJvcHMkaG9yaXpvbnRhbDMsIF9wcm9wcyRob3Jpem9udGFsRmlsbCwgX3Byb3BzJHZlcnRpY2FsMywgX3Byb3BzJHZlcnRpY2FsRmlsbDtcbiAgdmFyIGNoYXJ0V2lkdGggPSAoMCwgX2NoYXJ0TGF5b3V0Q29udGV4dC51c2VDaGFydFdpZHRoKSgpO1xuICB2YXIgY2hhcnRIZWlnaHQgPSAoMCwgX2NoYXJ0TGF5b3V0Q29udGV4dC51c2VDaGFydEhlaWdodCkoKTtcbiAgdmFyIG9mZnNldCA9ICgwLCBfY2hhcnRMYXlvdXRDb250ZXh0LnVzZU9mZnNldCkoKTtcbiAgdmFyIHByb3BzSW5jbHVkaW5nRGVmYXVsdHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICBzdHJva2U6IChfcHJvcHMkc3Ryb2tlID0gcHJvcHMuc3Ryb2tlKSAhPT0gbnVsbCAmJiBfcHJvcHMkc3Ryb2tlICE9PSB2b2lkIDAgPyBfcHJvcHMkc3Ryb2tlIDogZGVmYXVsdFByb3BzLnN0cm9rZSxcbiAgICBmaWxsOiAoX3Byb3BzJGZpbGwgPSBwcm9wcy5maWxsKSAhPT0gbnVsbCAmJiBfcHJvcHMkZmlsbCAhPT0gdm9pZCAwID8gX3Byb3BzJGZpbGwgOiBkZWZhdWx0UHJvcHMuZmlsbCxcbiAgICBob3Jpem9udGFsOiAoX3Byb3BzJGhvcml6b250YWwzID0gcHJvcHMuaG9yaXpvbnRhbCkgIT09IG51bGwgJiYgX3Byb3BzJGhvcml6b250YWwzICE9PSB2b2lkIDAgPyBfcHJvcHMkaG9yaXpvbnRhbDMgOiBkZWZhdWx0UHJvcHMuaG9yaXpvbnRhbCxcbiAgICBob3Jpem9udGFsRmlsbDogKF9wcm9wcyRob3Jpem9udGFsRmlsbCA9IHByb3BzLmhvcml6b250YWxGaWxsKSAhPT0gbnVsbCAmJiBfcHJvcHMkaG9yaXpvbnRhbEZpbGwgIT09IHZvaWQgMCA/IF9wcm9wcyRob3Jpem9udGFsRmlsbCA6IGRlZmF1bHRQcm9wcy5ob3Jpem9udGFsRmlsbCxcbiAgICB2ZXJ0aWNhbDogKF9wcm9wcyR2ZXJ0aWNhbDMgPSBwcm9wcy52ZXJ0aWNhbCkgIT09IG51bGwgJiYgX3Byb3BzJHZlcnRpY2FsMyAhPT0gdm9pZCAwID8gX3Byb3BzJHZlcnRpY2FsMyA6IGRlZmF1bHRQcm9wcy52ZXJ0aWNhbCxcbiAgICB2ZXJ0aWNhbEZpbGw6IChfcHJvcHMkdmVydGljYWxGaWxsID0gcHJvcHMudmVydGljYWxGaWxsKSAhPT0gbnVsbCAmJiBfcHJvcHMkdmVydGljYWxGaWxsICE9PSB2b2lkIDAgPyBfcHJvcHMkdmVydGljYWxGaWxsIDogZGVmYXVsdFByb3BzLnZlcnRpY2FsRmlsbCxcbiAgICB4OiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikocHJvcHMueCkgPyBwcm9wcy54IDogb2Zmc2V0LmxlZnQsXG4gICAgeTogKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHByb3BzLnkpID8gcHJvcHMueSA6IG9mZnNldC50b3AsXG4gICAgd2lkdGg6ICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShwcm9wcy53aWR0aCkgPyBwcm9wcy53aWR0aCA6IG9mZnNldC53aWR0aCxcbiAgICBoZWlnaHQ6ICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShwcm9wcy5oZWlnaHQpID8gcHJvcHMuaGVpZ2h0IDogb2Zmc2V0LmhlaWdodFxuICB9KTtcbiAgdmFyIHggPSBwcm9wc0luY2x1ZGluZ0RlZmF1bHRzLngsXG4gICAgeSA9IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMueSxcbiAgICB3aWR0aCA9IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMud2lkdGgsXG4gICAgaGVpZ2h0ID0gcHJvcHNJbmNsdWRpbmdEZWZhdWx0cy5oZWlnaHQsXG4gICAgc3luY1dpdGhUaWNrcyA9IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMuc3luY1dpdGhUaWNrcyxcbiAgICBob3Jpem9udGFsVmFsdWVzID0gcHJvcHNJbmNsdWRpbmdEZWZhdWx0cy5ob3Jpem9udGFsVmFsdWVzLFxuICAgIHZlcnRpY2FsVmFsdWVzID0gcHJvcHNJbmNsdWRpbmdEZWZhdWx0cy52ZXJ0aWNhbFZhbHVlcztcblxuICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSBzY2FsZSBwcm9wIGlzIG1peGVkIHVwIC0gd2UgbmVlZCB0byB1bnRhZ2xlIHRoaXMgYXQgc29tZSBwb2ludFxuICB2YXIgeEF4aXMgPSAoMCwgX2NoYXJ0TGF5b3V0Q29udGV4dC51c2VBcmJpdHJhcnlYQXhpcykoKTtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGUgc2NhbGUgcHJvcCBpcyBtaXhlZCB1cCAtIHdlIG5lZWQgdG8gdW50YWdsZSB0aGlzIGF0IHNvbWUgcG9pbnRcbiAgdmFyIHlBeGlzID0gKDAsIF9jaGFydExheW91dENvbnRleHQudXNlWUF4aXNXaXRoRmluaXRlRG9tYWluT3JSYW5kb20pKCk7XG4gIGlmICghKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHdpZHRoKSB8fCB3aWR0aCA8PSAwIHx8ICEoMCwgX0RhdGFVdGlscy5pc051bWJlcikoaGVpZ2h0KSB8fCBoZWlnaHQgPD0gMCB8fCAhKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHgpIHx8IHggIT09ICt4IHx8ICEoMCwgX0RhdGFVdGlscy5pc051bWJlcikoeSkgfHwgeSAhPT0gK3kpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qXG4gICAqIHZlcnRpY2FsQ29vcmRpbmF0ZXNHZW5lcmF0b3IgYW5kIGhvcml6b250YWxDb29yZGluYXRlc0dlbmVyYXRvciBhcmUgZGVmaW5lZFxuICAgKiBvdXRzaWRlIG9mIHRoZSBwcm9wc0luY2x1ZGluZ0RlZmF1bHRzIGJlY2F1c2UgdGhleSB3ZXJlIG5ldmVyIHBhcnQgb2YgdGhlIG9yaWdpbmFsIHByb3BzXG4gICAqIGFuZCB0aGV5IHdlcmUgbmV2ZXIgcGFzc2VkIGFzIGEgcHJvcCBkb3duIHRvIGhvcml6b250YWwvdmVydGljYWwgY3VzdG9tIGVsZW1lbnRzLlxuICAgKiBJZiB3ZSBhZGQgdGhlc2UgdHdvIHRvIHByb3BzSW5jbHVkaW5nRGVmYXVsdHMgdGhlbiB3ZSBhcmUgY2hhbmdpbmcgcHVibGljIEFQSS5cbiAgICogTm90IGEgYmFkIHRoaW5nIHBlciBzZSBidXQgYWxzbyBub3QgbmVjZXNzYXJ5LlxuICAgKi9cbiAgdmFyIHZlcnRpY2FsQ29vcmRpbmF0ZXNHZW5lcmF0b3IgPSBwcm9wc0luY2x1ZGluZ0RlZmF1bHRzLnZlcnRpY2FsQ29vcmRpbmF0ZXNHZW5lcmF0b3IgfHwgZGVmYXVsdFZlcnRpY2FsQ29vcmRpbmF0ZXNHZW5lcmF0b3I7XG4gIHZhciBob3Jpem9udGFsQ29vcmRpbmF0ZXNHZW5lcmF0b3IgPSBwcm9wc0luY2x1ZGluZ0RlZmF1bHRzLmhvcml6b250YWxDb29yZGluYXRlc0dlbmVyYXRvciB8fCBkZWZhdWx0SG9yaXpvbnRhbENvb3JkaW5hdGVzR2VuZXJhdG9yO1xuICB2YXIgaG9yaXpvbnRhbFBvaW50cyA9IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMuaG9yaXpvbnRhbFBvaW50cyxcbiAgICB2ZXJ0aWNhbFBvaW50cyA9IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMudmVydGljYWxQb2ludHM7XG5cbiAgLy8gTm8gaG9yaXpvbnRhbCBwb2ludHMgYXJlIHNwZWNpZmllZFxuICBpZiAoKCFob3Jpem9udGFsUG9pbnRzIHx8ICFob3Jpem9udGFsUG9pbnRzLmxlbmd0aCkgJiYgKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkoaG9yaXpvbnRhbENvb3JkaW5hdGVzR2VuZXJhdG9yKSkge1xuICAgIHZhciBpc0hvcml6b250YWxWYWx1ZXMgPSBob3Jpem9udGFsVmFsdWVzICYmIGhvcml6b250YWxWYWx1ZXMubGVuZ3RoO1xuICAgIHZhciBnZW5lcmF0b3JSZXN1bHQgPSBob3Jpem9udGFsQ29vcmRpbmF0ZXNHZW5lcmF0b3Ioe1xuICAgICAgeUF4aXM6IHlBeGlzID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB5QXhpcyksIHt9LCB7XG4gICAgICAgIHRpY2tzOiBpc0hvcml6b250YWxWYWx1ZXMgPyBob3Jpem9udGFsVmFsdWVzIDogeUF4aXMudGlja3NcbiAgICAgIH0pIDogdW5kZWZpbmVkLFxuICAgICAgd2lkdGg6IGNoYXJ0V2lkdGgsXG4gICAgICBoZWlnaHQ6IGNoYXJ0SGVpZ2h0LFxuICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICB9LCBpc0hvcml6b250YWxWYWx1ZXMgPyB0cnVlIDogc3luY1dpdGhUaWNrcyk7XG4gICAgKDAsIF9Mb2dVdGlscy53YXJuKShBcnJheS5pc0FycmF5KGdlbmVyYXRvclJlc3VsdCksIFwiaG9yaXpvbnRhbENvb3JkaW5hdGVzR2VuZXJhdG9yIHNob3VsZCByZXR1cm4gQXJyYXkgYnV0IGluc3RlYWQgaXQgcmV0dXJuZWQgW1wiLmNvbmNhdChfdHlwZW9mKGdlbmVyYXRvclJlc3VsdCksIFwiXVwiKSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZ2VuZXJhdG9yUmVzdWx0KSkge1xuICAgICAgaG9yaXpvbnRhbFBvaW50cyA9IGdlbmVyYXRvclJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAvLyBObyB2ZXJ0aWNhbCBwb2ludHMgYXJlIHNwZWNpZmllZFxuICBpZiAoKCF2ZXJ0aWNhbFBvaW50cyB8fCAhdmVydGljYWxQb2ludHMubGVuZ3RoKSAmJiAoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKSh2ZXJ0aWNhbENvb3JkaW5hdGVzR2VuZXJhdG9yKSkge1xuICAgIHZhciBpc1ZlcnRpY2FsVmFsdWVzID0gdmVydGljYWxWYWx1ZXMgJiYgdmVydGljYWxWYWx1ZXMubGVuZ3RoO1xuICAgIHZhciBfZ2VuZXJhdG9yUmVzdWx0ID0gdmVydGljYWxDb29yZGluYXRlc0dlbmVyYXRvcih7XG4gICAgICB4QXhpczogeEF4aXMgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHhBeGlzKSwge30sIHtcbiAgICAgICAgdGlja3M6IGlzVmVydGljYWxWYWx1ZXMgPyB2ZXJ0aWNhbFZhbHVlcyA6IHhBeGlzLnRpY2tzXG4gICAgICB9KSA6IHVuZGVmaW5lZCxcbiAgICAgIHdpZHRoOiBjaGFydFdpZHRoLFxuICAgICAgaGVpZ2h0OiBjaGFydEhlaWdodCxcbiAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgfSwgaXNWZXJ0aWNhbFZhbHVlcyA/IHRydWUgOiBzeW5jV2l0aFRpY2tzKTtcbiAgICAoMCwgX0xvZ1V0aWxzLndhcm4pKEFycmF5LmlzQXJyYXkoX2dlbmVyYXRvclJlc3VsdCksIFwidmVydGljYWxDb29yZGluYXRlc0dlbmVyYXRvciBzaG91bGQgcmV0dXJuIEFycmF5IGJ1dCBpbnN0ZWFkIGl0IHJldHVybmVkIFtcIi5jb25jYXQoX3R5cGVvZihfZ2VuZXJhdG9yUmVzdWx0KSwgXCJdXCIpKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShfZ2VuZXJhdG9yUmVzdWx0KSkge1xuICAgICAgdmVydGljYWxQb2ludHMgPSBfZ2VuZXJhdG9yUmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1jYXJ0ZXNpYW4tZ3JpZFwiXG4gIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQmFja2dyb3VuZCwge1xuICAgIGZpbGw6IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMuZmlsbCxcbiAgICBmaWxsT3BhY2l0eTogcHJvcHNJbmNsdWRpbmdEZWZhdWx0cy5maWxsT3BhY2l0eSxcbiAgICB4OiBwcm9wc0luY2x1ZGluZ0RlZmF1bHRzLngsXG4gICAgeTogcHJvcHNJbmNsdWRpbmdEZWZhdWx0cy55LFxuICAgIHdpZHRoOiBwcm9wc0luY2x1ZGluZ0RlZmF1bHRzLndpZHRoLFxuICAgIGhlaWdodDogcHJvcHNJbmNsdWRpbmdEZWZhdWx0cy5oZWlnaHQsXG4gICAgcnk6IHByb3BzSW5jbHVkaW5nRGVmYXVsdHMucnlcbiAgfSksIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoSG9yaXpvbnRhbEdyaWRMaW5lcywgX2V4dGVuZHMoe30sIHByb3BzSW5jbHVkaW5nRGVmYXVsdHMsIHtcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBob3Jpem9udGFsUG9pbnRzOiBob3Jpem9udGFsUG9pbnRzLFxuICAgIHhBeGlzOiB4QXhpcyxcbiAgICB5QXhpczogeUF4aXNcbiAgfSkpLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFZlcnRpY2FsR3JpZExpbmVzLCBfZXh0ZW5kcyh7fSwgcHJvcHNJbmNsdWRpbmdEZWZhdWx0cywge1xuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIHZlcnRpY2FsUG9pbnRzOiB2ZXJ0aWNhbFBvaW50cyxcbiAgICB4QXhpczogeEF4aXMsXG4gICAgeUF4aXM6IHlBeGlzXG4gIH0pKSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChIb3Jpem9udGFsU3RyaXBlcywgX2V4dGVuZHMoe30sIHByb3BzSW5jbHVkaW5nRGVmYXVsdHMsIHtcbiAgICBob3Jpem9udGFsUG9pbnRzOiBob3Jpem9udGFsUG9pbnRzXG4gIH0pKSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChWZXJ0aWNhbFN0cmlwZXMsIF9leHRlbmRzKHt9LCBwcm9wc0luY2x1ZGluZ0RlZmF1bHRzLCB7XG4gICAgdmVydGljYWxQb2ludHM6IHZlcnRpY2FsUG9pbnRzXG4gIH0pKSk7XG59XG5DYXJ0ZXNpYW5HcmlkLmRpc3BsYXlOYW1lID0gJ0NhcnRlc2lhbkdyaWQnOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNhcnRlc2lhbkdyaWQiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9pc0Z1bmN0aW9uIiwiX0xvZ1V0aWxzIiwiX0RhdGFVdGlscyIsIl9SZWFjdFV0aWxzIiwiX0NoYXJ0VXRpbHMiLCJfZ2V0VGlja3MiLCJfQ2FydGVzaWFuQXhpcyIsIl9jaGFydExheW91dENvbnRleHQiLCJfZXhjbHVkZWQiLCJfZXhjbHVkZWQyIiwib2JqIiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIm93bktleXMiLCJlIiwiciIsInQiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJrZXkiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiaSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsInNvdXJjZSIsImhhc093blByb3BlcnR5IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJCYWNrZ3JvdW5kIiwicHJvcHMiLCJmaWxsIiwiZmlsbE9wYWNpdHkiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0IiwicnkiLCJjcmVhdGVFbGVtZW50Iiwic3Ryb2tlIiwiY2xhc3NOYW1lIiwicmVuZGVyTGluZUl0ZW0iLCJvcHRpb24iLCJsaW5lSXRlbSIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwieDEiLCJ5MSIsIngyIiwieTIiLCJvdGhlcnMiLCJfZmlsdGVyUHJvcHMiLCJmaWx0ZXJQcm9wcyIsIl9fIiwib2Zmc2V0IiwicmVzdE9mRmlsdGVyZWRQcm9wcyIsIkhvcml6b250YWxHcmlkTGluZXMiLCJfcHJvcHMkaG9yaXpvbnRhbCIsImhvcml6b250YWwiLCJob3Jpem9udGFsUG9pbnRzIiwiaXRlbXMiLCJtYXAiLCJlbnRyeSIsImxpbmVJdGVtUHJvcHMiLCJjb25jYXQiLCJpbmRleCIsIlZlcnRpY2FsR3JpZExpbmVzIiwiX3Byb3BzJHZlcnRpY2FsIiwidmVydGljYWwiLCJ2ZXJ0aWNhbFBvaW50cyIsIkhvcml6b250YWxTdHJpcGVzIiwiaG9yaXpvbnRhbEZpbGwiLCJfcHJvcHMkaG9yaXpvbnRhbDIiLCJyb3VuZGVkU29ydGVkSG9yaXpvbnRhbFBvaW50cyIsIk1hdGgiLCJyb3VuZCIsInNvcnQiLCJhIiwiYiIsInVuc2hpZnQiLCJsYXN0U3RyaXBlIiwibGluZUhlaWdodCIsImNvbG9ySW5kZXgiLCJWZXJ0aWNhbFN0cmlwZXMiLCJfcHJvcHMkdmVydGljYWwyIiwidmVydGljYWxGaWxsIiwicm91bmRlZFNvcnRlZFZlcnRpY2FsUG9pbnRzIiwibGluZVdpZHRoIiwiZGVmYXVsdFZlcnRpY2FsQ29vcmRpbmF0ZXNHZW5lcmF0b3IiLCJfcmVmIiwic3luY1dpdGhUaWNrcyIsInhBeGlzIiwiZ2V0Q29vcmRpbmF0ZXNPZkdyaWQiLCJnZXRUaWNrcyIsIkNhcnRlc2lhbkF4aXMiLCJkZWZhdWx0UHJvcHMiLCJ0aWNrcyIsImdldFRpY2tzT2ZBeGlzIiwidmlld0JveCIsImxlZnQiLCJkZWZhdWx0SG9yaXpvbnRhbENvb3JkaW5hdGVzR2VuZXJhdG9yIiwiX3JlZjIiLCJ5QXhpcyIsInRvcCIsIl9wcm9wcyRzdHJva2UiLCJfcHJvcHMkZmlsbCIsIl9wcm9wcyRob3Jpem9udGFsMyIsIl9wcm9wcyRob3Jpem9udGFsRmlsbCIsIl9wcm9wcyR2ZXJ0aWNhbDMiLCJfcHJvcHMkdmVydGljYWxGaWxsIiwiY2hhcnRXaWR0aCIsInVzZUNoYXJ0V2lkdGgiLCJjaGFydEhlaWdodCIsInVzZUNoYXJ0SGVpZ2h0IiwidXNlT2Zmc2V0IiwicHJvcHNJbmNsdWRpbmdEZWZhdWx0cyIsImlzTnVtYmVyIiwiaG9yaXpvbnRhbFZhbHVlcyIsInZlcnRpY2FsVmFsdWVzIiwidXNlQXJiaXRyYXJ5WEF4aXMiLCJ1c2VZQXhpc1dpdGhGaW5pdGVEb21haW5PclJhbmRvbSIsInZlcnRpY2FsQ29vcmRpbmF0ZXNHZW5lcmF0b3IiLCJob3Jpem9udGFsQ29vcmRpbmF0ZXNHZW5lcmF0b3IiLCJpc0hvcml6b250YWxWYWx1ZXMiLCJnZW5lcmF0b3JSZXN1bHQiLCJ1bmRlZmluZWQiLCJ3YXJuIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNWZXJ0aWNhbFZhbHVlcyIsIl9nZW5lcmF0b3JSZXN1bHQiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/CartesianGrid.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/cartesian/ErrorBar.js":
/*!*********************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/ErrorBar.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ErrorBar = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _tinyInvariant = _interopRequireDefault(__webpack_require__(/*! tiny-invariant */ \"tiny-invariant\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"offset\",\n    \"layout\",\n    \"width\",\n    \"dataKey\",\n    \"data\",\n    \"dataPointFormatter\",\n    \"xAxis\",\n    \"yAxis\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Render a group of error bar\n */ \n// eslint-disable-next-line react/prefer-stateless-function -- requires static defaultProps\nvar ErrorBar = exports.ErrorBar = /*#__PURE__*/ function(_React$Component) {\n    function ErrorBar() {\n        _classCallCheck(this, ErrorBar);\n        return _callSuper(this, ErrorBar, arguments);\n    }\n    _inherits(ErrorBar, _React$Component);\n    return _createClass(ErrorBar, [\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props = this.props, offset = _this$props.offset, layout = _this$props.layout, width = _this$props.width, dataKey = _this$props.dataKey, data = _this$props.data, dataPointFormatter = _this$props.dataPointFormatter, xAxis = _this$props.xAxis, yAxis = _this$props.yAxis, others = _objectWithoutProperties(_this$props, _excluded);\n                var svgProps = (0, _ReactUtils.filterProps)(others, false);\n                !!(this.props.direction === \"x\" && xAxis.type !== \"number\") ?  true ? (0, _tinyInvariant[\"default\"])(false, 'ErrorBar requires Axis type property to be \"number\".') : 0 : void 0;\n                var errorBars = data.map(function(entry) {\n                    var _dataPointFormatter = dataPointFormatter(entry, dataKey), x = _dataPointFormatter.x, y = _dataPointFormatter.y, value = _dataPointFormatter.value, errorVal = _dataPointFormatter.errorVal;\n                    if (!errorVal) {\n                        return null;\n                    }\n                    var lineCoordinates = [];\n                    var lowBound, highBound;\n                    if (Array.isArray(errorVal)) {\n                        var _errorVal = _slicedToArray(errorVal, 2);\n                        lowBound = _errorVal[0];\n                        highBound = _errorVal[1];\n                    } else {\n                        lowBound = highBound = errorVal;\n                    }\n                    if (layout === \"vertical\") {\n                        // error bar for horizontal charts, the y is fixed, x is a range value\n                        var scale = xAxis.scale;\n                        var yMid = y + offset;\n                        var yMin = yMid + width;\n                        var yMax = yMid - width;\n                        var xMin = scale(value - lowBound);\n                        var xMax = scale(value + highBound);\n                        // the right line of |--|\n                        lineCoordinates.push({\n                            x1: xMax,\n                            y1: yMin,\n                            x2: xMax,\n                            y2: yMax\n                        });\n                        // the middle line of |--|\n                        lineCoordinates.push({\n                            x1: xMin,\n                            y1: yMid,\n                            x2: xMax,\n                            y2: yMid\n                        });\n                        // the left line of |--|\n                        lineCoordinates.push({\n                            x1: xMin,\n                            y1: yMin,\n                            x2: xMin,\n                            y2: yMax\n                        });\n                    } else if (layout === \"horizontal\") {\n                        // error bar for horizontal charts, the x is fixed, y is a range value\n                        var _scale = yAxis.scale;\n                        var xMid = x + offset;\n                        var _xMin = xMid - width;\n                        var _xMax = xMid + width;\n                        var _yMin = _scale(value - lowBound);\n                        var _yMax = _scale(value + highBound);\n                        // the top line\n                        lineCoordinates.push({\n                            x1: _xMin,\n                            y1: _yMax,\n                            x2: _xMax,\n                            y2: _yMax\n                        });\n                        // the middle line\n                        lineCoordinates.push({\n                            x1: xMid,\n                            y1: _yMin,\n                            x2: xMid,\n                            y2: _yMax\n                        });\n                        // the bottom line\n                        lineCoordinates.push({\n                            x1: _xMin,\n                            y1: _yMin,\n                            x2: _xMax,\n                            y2: _yMin\n                        });\n                    }\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        className: \"recharts-errorBar\",\n                        key: \"bar-\".concat(lineCoordinates.map(function(c) {\n                            return \"\".concat(c.x1, \"-\").concat(c.x2, \"-\").concat(c.y1, \"-\").concat(c.y2);\n                        }))\n                    }, svgProps), lineCoordinates.map(function(coordinates) {\n                        return /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({}, coordinates, {\n                            key: \"line-\".concat(coordinates.x1, \"-\").concat(coordinates.x2, \"-\").concat(coordinates.y1, \"-\").concat(coordinates.y2)\n                        }));\n                    }));\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-errorBars\"\n                }, errorBars);\n            }\n        }\n    ]);\n}(_react[\"default\"].Component);\n_defineProperty(ErrorBar, \"defaultProps\", {\n    stroke: \"black\",\n    strokeWidth: 1.5,\n    width: 5,\n    offset: 0,\n    layout: \"horizontal\"\n});\n_defineProperty(ErrorBar, \"displayName\", \"ErrorBar\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9FcnJvckJhci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsZ0JBQWdCLEdBQUcsS0FBSztBQUN4QixJQUFJRyxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ25ELElBQUlDLGlCQUFpQkYsdUJBQXVCQyxtQkFBT0EsQ0FBQyxzQ0FBZ0I7QUFDcEUsSUFBSUUsU0FBU0YsbUJBQU9BLENBQUMsMEVBQW9CO0FBQ3pDLElBQUlHLGNBQWNILG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJSSxZQUFZO0lBQUM7SUFBVTtJQUFVO0lBQVM7SUFBVztJQUFRO0lBQXNCO0lBQVM7Q0FBUTtBQUN4RyxTQUFTTCx1QkFBdUJNLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLO0lBQWFBLFdBQVdwQixPQUFPcUIsTUFBTSxHQUFHckIsT0FBT3FCLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQUUsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQUUsSUFBSyxJQUFJSSxP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QWEsQ0FBQzdJLE9BQU84SSxLQUFLLEVBQUU7b0JBQ2hFQyxXQUFXO2dCQUNiLEdBQUc3QjtZQUNMO1FBQ0Y7S0FBRTtBQUNKLEVBQUV0SCxNQUFNLENBQUMsVUFBVSxDQUFDdUosU0FBUztBQUM3QnZELGdCQUFnQmpHLFVBQVUsZ0JBQWdCO0lBQ3hDeUosUUFBUTtJQUNSQyxhQUFhO0lBQ2IvQyxPQUFPO0lBQ1BGLFFBQVE7SUFDUkMsUUFBUTtBQUNWO0FBQ0FULGdCQUFnQmpHLFVBQVUsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL0Vycm9yQmFyLmpzP2NlZTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkVycm9yQmFyID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfdGlueUludmFyaWFudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInRpbnktaW52YXJpYW50XCIpKTtcbnZhciBfTGF5ZXIgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0xheWVyXCIpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcbnZhciBfZXhjbHVkZWQgPSBbXCJvZmZzZXRcIiwgXCJsYXlvdXRcIiwgXCJ3aWR0aFwiLCBcImRhdGFLZXlcIiwgXCJkYXRhXCIsIFwiZGF0YVBvaW50Rm9ybWF0dGVyXCIsIFwieEF4aXNcIiwgXCJ5QXhpc1wiXTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxuICogQGZpbGVPdmVydmlldyBSZW5kZXIgYSBncm91cCBvZiBlcnJvciBiYXJcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb24gLS0gcmVxdWlyZXMgc3RhdGljIGRlZmF1bHRQcm9wc1xudmFyIEVycm9yQmFyID0gZXhwb3J0cy5FcnJvckJhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBmdW5jdGlvbiBFcnJvckJhcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXJyb3JCYXIpO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEVycm9yQmFyLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhFcnJvckJhciwgX1JlYWN0JENvbXBvbmVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRXJyb3JCYXIsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBvZmZzZXQgPSBfdGhpcyRwcm9wcy5vZmZzZXQsXG4gICAgICAgIGxheW91dCA9IF90aGlzJHByb3BzLmxheW91dCxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wcy53aWR0aCxcbiAgICAgICAgZGF0YUtleSA9IF90aGlzJHByb3BzLmRhdGFLZXksXG4gICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wcy5kYXRhLFxuICAgICAgICBkYXRhUG9pbnRGb3JtYXR0ZXIgPSBfdGhpcyRwcm9wcy5kYXRhUG9pbnRGb3JtYXR0ZXIsXG4gICAgICAgIHhBeGlzID0gX3RoaXMkcHJvcHMueEF4aXMsXG4gICAgICAgIHlBeGlzID0gX3RoaXMkcHJvcHMueUF4aXMsXG4gICAgICAgIG90aGVycyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRwcm9wcywgX2V4Y2x1ZGVkKTtcbiAgICAgIHZhciBzdmdQcm9wcyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykob3RoZXJzLCBmYWxzZSk7XG4gICAgICAhISh0aGlzLnByb3BzLmRpcmVjdGlvbiA9PT0gJ3gnICYmIHhBeGlzLnR5cGUgIT09ICdudW1iZXInKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/ICgwLCBfdGlueUludmFyaWFudFtcImRlZmF1bHRcIl0pKGZhbHNlLCAnRXJyb3JCYXIgcmVxdWlyZXMgQXhpcyB0eXBlIHByb3BlcnR5IHRvIGJlIFwibnVtYmVyXCIuJykgOiAoMCwgX3RpbnlJbnZhcmlhbnRbXCJkZWZhdWx0XCJdKShmYWxzZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgZXJyb3JCYXJzID0gZGF0YS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHZhciBfZGF0YVBvaW50Rm9ybWF0dGVyID0gZGF0YVBvaW50Rm9ybWF0dGVyKGVudHJ5LCBkYXRhS2V5KSxcbiAgICAgICAgICB4ID0gX2RhdGFQb2ludEZvcm1hdHRlci54LFxuICAgICAgICAgIHkgPSBfZGF0YVBvaW50Rm9ybWF0dGVyLnksXG4gICAgICAgICAgdmFsdWUgPSBfZGF0YVBvaW50Rm9ybWF0dGVyLnZhbHVlLFxuICAgICAgICAgIGVycm9yVmFsID0gX2RhdGFQb2ludEZvcm1hdHRlci5lcnJvclZhbDtcbiAgICAgICAgaWYgKCFlcnJvclZhbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lQ29vcmRpbmF0ZXMgPSBbXTtcbiAgICAgICAgdmFyIGxvd0JvdW5kLCBoaWdoQm91bmQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVycm9yVmFsKSkge1xuICAgICAgICAgIHZhciBfZXJyb3JWYWwgPSBfc2xpY2VkVG9BcnJheShlcnJvclZhbCwgMik7XG4gICAgICAgICAgbG93Qm91bmQgPSBfZXJyb3JWYWxbMF07XG4gICAgICAgICAgaGlnaEJvdW5kID0gX2Vycm9yVmFsWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvd0JvdW5kID0gaGlnaEJvdW5kID0gZXJyb3JWYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxheW91dCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgIC8vIGVycm9yIGJhciBmb3IgaG9yaXpvbnRhbCBjaGFydHMsIHRoZSB5IGlzIGZpeGVkLCB4IGlzIGEgcmFuZ2UgdmFsdWVcbiAgICAgICAgICB2YXIgc2NhbGUgPSB4QXhpcy5zY2FsZTtcbiAgICAgICAgICB2YXIgeU1pZCA9IHkgKyBvZmZzZXQ7XG4gICAgICAgICAgdmFyIHlNaW4gPSB5TWlkICsgd2lkdGg7XG4gICAgICAgICAgdmFyIHlNYXggPSB5TWlkIC0gd2lkdGg7XG4gICAgICAgICAgdmFyIHhNaW4gPSBzY2FsZSh2YWx1ZSAtIGxvd0JvdW5kKTtcbiAgICAgICAgICB2YXIgeE1heCA9IHNjYWxlKHZhbHVlICsgaGlnaEJvdW5kKTtcblxuICAgICAgICAgIC8vIHRoZSByaWdodCBsaW5lIG9mIHwtLXxcbiAgICAgICAgICBsaW5lQ29vcmRpbmF0ZXMucHVzaCh7XG4gICAgICAgICAgICB4MTogeE1heCxcbiAgICAgICAgICAgIHkxOiB5TWluLFxuICAgICAgICAgICAgeDI6IHhNYXgsXG4gICAgICAgICAgICB5MjogeU1heFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIHRoZSBtaWRkbGUgbGluZSBvZiB8LS18XG4gICAgICAgICAgbGluZUNvb3JkaW5hdGVzLnB1c2goe1xuICAgICAgICAgICAgeDE6IHhNaW4sXG4gICAgICAgICAgICB5MTogeU1pZCxcbiAgICAgICAgICAgIHgyOiB4TWF4LFxuICAgICAgICAgICAgeTI6IHlNaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyB0aGUgbGVmdCBsaW5lIG9mIHwtLXxcbiAgICAgICAgICBsaW5lQ29vcmRpbmF0ZXMucHVzaCh7XG4gICAgICAgICAgICB4MTogeE1pbixcbiAgICAgICAgICAgIHkxOiB5TWluLFxuICAgICAgICAgICAgeDI6IHhNaW4sXG4gICAgICAgICAgICB5MjogeU1heFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgLy8gZXJyb3IgYmFyIGZvciBob3Jpem9udGFsIGNoYXJ0cywgdGhlIHggaXMgZml4ZWQsIHkgaXMgYSByYW5nZSB2YWx1ZVxuICAgICAgICAgIHZhciBfc2NhbGUgPSB5QXhpcy5zY2FsZTtcbiAgICAgICAgICB2YXIgeE1pZCA9IHggKyBvZmZzZXQ7XG4gICAgICAgICAgdmFyIF94TWluID0geE1pZCAtIHdpZHRoO1xuICAgICAgICAgIHZhciBfeE1heCA9IHhNaWQgKyB3aWR0aDtcbiAgICAgICAgICB2YXIgX3lNaW4gPSBfc2NhbGUodmFsdWUgLSBsb3dCb3VuZCk7XG4gICAgICAgICAgdmFyIF95TWF4ID0gX3NjYWxlKHZhbHVlICsgaGlnaEJvdW5kKTtcblxuICAgICAgICAgIC8vIHRoZSB0b3AgbGluZVxuICAgICAgICAgIGxpbmVDb29yZGluYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHgxOiBfeE1pbixcbiAgICAgICAgICAgIHkxOiBfeU1heCxcbiAgICAgICAgICAgIHgyOiBfeE1heCxcbiAgICAgICAgICAgIHkyOiBfeU1heFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIHRoZSBtaWRkbGUgbGluZVxuICAgICAgICAgIGxpbmVDb29yZGluYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHgxOiB4TWlkLFxuICAgICAgICAgICAgeTE6IF95TWluLFxuICAgICAgICAgICAgeDI6IHhNaWQsXG4gICAgICAgICAgICB5MjogX3lNYXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyB0aGUgYm90dG9tIGxpbmVcbiAgICAgICAgICBsaW5lQ29vcmRpbmF0ZXMucHVzaCh7XG4gICAgICAgICAgICB4MTogX3hNaW4sXG4gICAgICAgICAgICB5MTogX3lNaW4sXG4gICAgICAgICAgICB4MjogX3hNYXgsXG4gICAgICAgICAgICB5MjogX3lNaW5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIF9leHRlbmRzKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtZXJyb3JCYXJcIixcbiAgICAgICAgICBrZXk6IFwiYmFyLVwiLmNvbmNhdChsaW5lQ29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoYy54MSwgXCItXCIpLmNvbmNhdChjLngyLCBcIi1cIikuY29uY2F0KGMueTEsIFwiLVwiKS5jb25jYXQoYy55Mik7XG4gICAgICAgICAgfSkpXG4gICAgICAgIH0sIHN2Z1Byb3BzKSwgbGluZUNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImxpbmVcIiwgX2V4dGVuZHMoe30sIGNvb3JkaW5hdGVzLCB7XG4gICAgICAgICAgICBrZXk6IFwibGluZS1cIi5jb25jYXQoY29vcmRpbmF0ZXMueDEsIFwiLVwiKS5jb25jYXQoY29vcmRpbmF0ZXMueDIsIFwiLVwiKS5jb25jYXQoY29vcmRpbmF0ZXMueTEsIFwiLVwiKS5jb25jYXQoY29vcmRpbmF0ZXMueTIpXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtZXJyb3JCYXJzXCJcbiAgICAgIH0sIGVycm9yQmFycyk7XG4gICAgfVxuICB9XSk7XG59KF9yZWFjdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcbl9kZWZpbmVQcm9wZXJ0eShFcnJvckJhciwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBzdHJva2U6ICdibGFjaycsXG4gIHN0cm9rZVdpZHRoOiAxLjUsXG4gIHdpZHRoOiA1LFxuICBvZmZzZXQ6IDAsXG4gIGxheW91dDogJ2hvcml6b250YWwnXG59KTtcbl9kZWZpbmVQcm9wZXJ0eShFcnJvckJhciwgXCJkaXNwbGF5TmFtZVwiLCAnRXJyb3JCYXInKTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJFcnJvckJhciIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3RpbnlJbnZhcmlhbnQiLCJfTGF5ZXIiLCJfUmVhY3RVdGlscyIsIl9leGNsdWRlZCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfc2xpY2VkVG9BcnJheSIsImFyciIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJsZW4iLCJhcnIyIiwiciIsImwiLCJ0IiwiZSIsInUiLCJhIiwiZiIsIm5leHQiLCJkb25lIiwicHVzaCIsImlzQXJyYXkiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIl9kZWZpbmVQcm9wZXJ0eSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiX1JlYWN0JENvbXBvbmVudCIsInJlbmRlciIsIl90aGlzJHByb3BzIiwib2Zmc2V0IiwibGF5b3V0Iiwid2lkdGgiLCJkYXRhS2V5IiwiZGF0YSIsImRhdGFQb2ludEZvcm1hdHRlciIsInhBeGlzIiwieUF4aXMiLCJvdGhlcnMiLCJzdmdQcm9wcyIsImZpbHRlclByb3BzIiwiZGlyZWN0aW9uIiwidHlwZSIsInByb2Nlc3MiLCJlcnJvckJhcnMiLCJtYXAiLCJlbnRyeSIsIl9kYXRhUG9pbnRGb3JtYXR0ZXIiLCJ4IiwieSIsImVycm9yVmFsIiwibGluZUNvb3JkaW5hdGVzIiwibG93Qm91bmQiLCJoaWdoQm91bmQiLCJfZXJyb3JWYWwiLCJzY2FsZSIsInlNaWQiLCJ5TWluIiwieU1heCIsInhNaW4iLCJ4TWF4IiwieDEiLCJ5MSIsIngyIiwieTIiLCJfc2NhbGUiLCJ4TWlkIiwiX3hNaW4iLCJfeE1heCIsIl95TWluIiwiX3lNYXgiLCJjcmVhdGVFbGVtZW50IiwiTGF5ZXIiLCJjbGFzc05hbWUiLCJjb25jYXQiLCJjIiwiY29vcmRpbmF0ZXMiLCJDb21wb25lbnQiLCJzdHJva2UiLCJzdHJva2VXaWR0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/ErrorBar.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/cartesian/Line.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/Line.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Line = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _Curve = __webpack_require__(/*! ../shape/Curve */ \"./node_modules/recharts/lib/shape/Curve.js\");\nvar _Dot = __webpack_require__(/*! ../shape/Dot */ \"./node_modules/recharts/lib/shape/Dot.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"./node_modules/recharts/lib/component/LabelList.js\");\nvar _ErrorBar = __webpack_require__(/*! ./ErrorBar */ \"./node_modules/recharts/lib/cartesian/ErrorBar.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"./node_modules/recharts/lib/util/Global.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _excluded = [\n    \"type\",\n    \"layout\",\n    \"connectNulls\",\n    \"ref\"\n], _excluded2 = [\n    \"key\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Line\n */ \nvar Line = exports.Line = /*#__PURE__*/ function(_PureComponent) {\n    function Line() {\n        var _this;\n        _classCallCheck(this, Line);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Line, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            isAnimationFinished: true,\n            totalLength: 0\n        });\n        _defineProperty(_this, \"generateSimpleStrokeDasharray\", function(totalLength, length) {\n            return \"\".concat(length, \"px \").concat(totalLength - length, \"px\");\n        });\n        _defineProperty(_this, \"getStrokeDasharray\", function(length, totalLength, lines) {\n            var lineLength = lines.reduce(function(pre, next) {\n                return pre + next;\n            });\n            // if lineLength is 0 return the default when no strokeDasharray is provided\n            if (!lineLength) {\n                return _this.generateSimpleStrokeDasharray(totalLength, length);\n            }\n            var count = Math.floor(length / lineLength);\n            var remainLength = length % lineLength;\n            var restLength = totalLength - length;\n            var remainLines = [];\n            for(var i = 0, sum = 0; i < lines.length; sum += lines[i], ++i){\n                if (sum + lines[i] > remainLength) {\n                    remainLines = [].concat(_toConsumableArray(lines.slice(0, i)), [\n                        remainLength - sum\n                    ]);\n                    break;\n                }\n            }\n            var emptyLines = remainLines.length % 2 === 0 ? [\n                0,\n                restLength\n            ] : [\n                restLength\n            ];\n            return [].concat(_toConsumableArray(Line.repeat(lines, count)), _toConsumableArray(remainLines), emptyLines).map(function(line) {\n                return \"\".concat(line, \"px\");\n            }).join(\", \");\n        });\n        _defineProperty(_this, \"id\", (0, _DataUtils.uniqueId)(\"recharts-line-\"));\n        _defineProperty(_this, \"pathRef\", function(node) {\n            _this.mainCurve = node;\n        });\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if (_this.props.onAnimationEnd) {\n                _this.props.onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if (_this.props.onAnimationStart) {\n                _this.props.onAnimationStart();\n            }\n        });\n        return _this;\n    }\n    _inherits(Line, _PureComponent);\n    return _createClass(Line, [\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                if (!this.props.isAnimationActive) {\n                    return;\n                }\n                var totalLength = this.getTotalLength();\n                this.setState({\n                    totalLength: totalLength\n                });\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate() {\n                if (!this.props.isAnimationActive) {\n                    return;\n                }\n                var totalLength = this.getTotalLength();\n                if (totalLength !== this.state.totalLength) {\n                    this.setState({\n                        totalLength: totalLength\n                    });\n                }\n            }\n        },\n        {\n            key: \"getTotalLength\",\n            value: function getTotalLength() {\n                var curveDom = this.mainCurve;\n                try {\n                    return curveDom && curveDom.getTotalLength && curveDom.getTotalLength() || 0;\n                } catch (err) {\n                    return 0;\n                }\n            }\n        },\n        {\n            key: \"renderErrorBar\",\n            value: function renderErrorBar(needClip, clipPathId) {\n                if (this.props.isAnimationActive && !this.state.isAnimationFinished) {\n                    return null;\n                }\n                var _this$props = this.props, points = _this$props.points, xAxis = _this$props.xAxis, yAxis = _this$props.yAxis, layout = _this$props.layout, children = _this$props.children;\n                var errorBarItems = (0, _ReactUtils.findAllByType)(children, _ErrorBar.ErrorBar);\n                if (!errorBarItems) {\n                    return null;\n                }\n                var dataPointFormatter = function dataPointFormatter(dataPoint, dataKey) {\n                    return {\n                        x: dataPoint.x,\n                        y: dataPoint.y,\n                        value: dataPoint.value,\n                        errorVal: (0, _ChartUtils.getValueByDataKey)(dataPoint.payload, dataKey)\n                    };\n                };\n                var errorBarProps = {\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : null\n                };\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, errorBarProps, errorBarItems.map(function(item) {\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(item, {\n                        key: \"bar-\".concat(item.props.dataKey),\n                        data: points,\n                        xAxis: xAxis,\n                        yAxis: yAxis,\n                        layout: layout,\n                        dataPointFormatter: dataPointFormatter\n                    });\n                }));\n            }\n        },\n        {\n            key: \"renderDots\",\n            value: function renderDots(needClip, clipDot, clipPathId) {\n                var isAnimationActive = this.props.isAnimationActive;\n                if (isAnimationActive && !this.state.isAnimationFinished) {\n                    return null;\n                }\n                var _this$props2 = this.props, dot = _this$props2.dot, points = _this$props2.points, dataKey = _this$props2.dataKey;\n                var lineProps = (0, _ReactUtils.filterProps)(this.props, false);\n                var customDotProps = (0, _ReactUtils.filterProps)(dot, true);\n                var dots = points.map(function(entry, i) {\n                    var dotProps = _objectSpread(_objectSpread(_objectSpread({\n                        key: \"dot-\".concat(i),\n                        r: 3\n                    }, lineProps), customDotProps), {}, {\n                        value: entry.value,\n                        dataKey: dataKey,\n                        cx: entry.x,\n                        cy: entry.y,\n                        index: i,\n                        payload: entry.payload\n                    });\n                    return Line.renderDotItem(dot, dotProps);\n                });\n                var dotsProps = {\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipDot ? \"\" : \"dots-\").concat(clipPathId, \")\") : null\n                };\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                    className: \"recharts-line-dots\",\n                    key: \"dots\"\n                }, dotsProps), dots);\n            }\n        },\n        {\n            key: \"renderCurveStatically\",\n            value: function renderCurveStatically(points, needClip, clipPathId, props) {\n                var _this$props3 = this.props, type = _this$props3.type, layout = _this$props3.layout, connectNulls = _this$props3.connectNulls, ref = _this$props3.ref, others = _objectWithoutProperties(_this$props3, _excluded);\n                var curveProps = _objectSpread(_objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(others, true)), {}, {\n                    fill: \"none\",\n                    className: \"recharts-line-curve\",\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : null,\n                    points: points\n                }, props), {}, {\n                    type: type,\n                    layout: layout,\n                    connectNulls: connectNulls\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Curve.Curve, _extends({}, curveProps, {\n                    pathRef: this.pathRef\n                }));\n            }\n        },\n        {\n            key: \"renderCurveWithAnimation\",\n            value: function renderCurveWithAnimation(needClip, clipPathId) {\n                var _this2 = this;\n                var _this$props4 = this.props, points = _this$props4.points, strokeDasharray = _this$props4.strokeDasharray, isAnimationActive = _this$props4.isAnimationActive, animationBegin = _this$props4.animationBegin, animationDuration = _this$props4.animationDuration, animationEasing = _this$props4.animationEasing, animationId = _this$props4.animationId, animateNewValues = _this$props4.animateNewValues, width = _this$props4.width, height = _this$props4.height;\n                var _this$state = this.state, prevPoints = _this$state.prevPoints, totalLength = _this$state.totalLength;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"line-\".concat(animationId),\n                    onAnimationEnd: this.handleAnimationEnd,\n                    onAnimationStart: this.handleAnimationStart\n                }, function(_ref) {\n                    var t = _ref.t;\n                    if (prevPoints) {\n                        var prevPointsDiffFactor = prevPoints.length / points.length;\n                        var stepData = points.map(function(entry, index) {\n                            var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n                            if (prevPoints[prevPointIndex]) {\n                                var prev = prevPoints[prevPointIndex];\n                                var interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry.x);\n                                var interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry.y);\n                                return _objectSpread(_objectSpread({}, entry), {}, {\n                                    x: interpolatorX(t),\n                                    y: interpolatorY(t)\n                                });\n                            }\n                            // magic number of faking previous x and y location\n                            if (animateNewValues) {\n                                var _interpolatorX = (0, _DataUtils.interpolateNumber)(width * 2, entry.x);\n                                var _interpolatorY = (0, _DataUtils.interpolateNumber)(height / 2, entry.y);\n                                return _objectSpread(_objectSpread({}, entry), {}, {\n                                    x: _interpolatorX(t),\n                                    y: _interpolatorY(t)\n                                });\n                            }\n                            return _objectSpread(_objectSpread({}, entry), {}, {\n                                x: entry.x,\n                                y: entry.y\n                            });\n                        });\n                        return _this2.renderCurveStatically(stepData, needClip, clipPathId);\n                    }\n                    var interpolator = (0, _DataUtils.interpolateNumber)(0, totalLength);\n                    var curLength = interpolator(t);\n                    var currentStrokeDasharray;\n                    if (strokeDasharray) {\n                        var lines = \"\".concat(strokeDasharray).split(/[,\\s]+/gim).map(function(num) {\n                            return parseFloat(num);\n                        });\n                        currentStrokeDasharray = _this2.getStrokeDasharray(curLength, totalLength, lines);\n                    } else {\n                        currentStrokeDasharray = _this2.generateSimpleStrokeDasharray(totalLength, curLength);\n                    }\n                    return _this2.renderCurveStatically(points, needClip, clipPathId, {\n                        strokeDasharray: currentStrokeDasharray\n                    });\n                });\n            }\n        },\n        {\n            key: \"renderCurve\",\n            value: function renderCurve(needClip, clipPathId) {\n                var _this$props5 = this.props, points = _this$props5.points, isAnimationActive = _this$props5.isAnimationActive;\n                var _this$state2 = this.state, prevPoints = _this$state2.prevPoints, totalLength = _this$state2.totalLength;\n                if (isAnimationActive && points && points.length && (!prevPoints && totalLength > 0 || !(0, _isEqual[\"default\"])(prevPoints, points))) {\n                    return this.renderCurveWithAnimation(needClip, clipPathId);\n                }\n                return this.renderCurveStatically(points, needClip, clipPathId);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _filterProps;\n                var _this$props6 = this.props, hide = _this$props6.hide, dot = _this$props6.dot, points = _this$props6.points, className = _this$props6.className, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, top = _this$props6.top, left = _this$props6.left, width = _this$props6.width, height = _this$props6.height, isAnimationActive = _this$props6.isAnimationActive, id = _this$props6.id;\n                if (hide || !points || !points.length) {\n                    return null;\n                }\n                var isAnimationFinished = this.state.isAnimationFinished;\n                var hasSinglePoint = points.length === 1;\n                var layerClass = (0, _clsx[\"default\"])(\"recharts-line\", className);\n                var needClipX = xAxis && xAxis.allowDataOverflow;\n                var needClipY = yAxis && yAxis.allowDataOverflow;\n                var needClip = needClipX || needClipY;\n                var clipPathId = (0, _isNil[\"default\"])(id) ? this.id : id;\n                var _ref2 = (_filterProps = (0, _ReactUtils.filterProps)(dot, false)) !== null && _filterProps !== void 0 ? _filterProps : {\n                    r: 3,\n                    strokeWidth: 2\n                }, _ref2$r = _ref2.r, r = _ref2$r === void 0 ? 3 : _ref2$r, _ref2$strokeWidth = _ref2.strokeWidth, strokeWidth = _ref2$strokeWidth === void 0 ? 2 : _ref2$strokeWidth;\n                var _ref3 = (0, _ReactUtils.hasClipDot)(dot) ? dot : {}, _ref3$clipDot = _ref3.clipDot, clipDot = _ref3$clipDot === void 0 ? true : _ref3$clipDot;\n                var dotSize = r * 2 + strokeWidth;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass\n                }, needClipX || needClipY ? /*#__PURE__*/ _react[\"default\"].createElement(\"defs\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                    id: \"clipPath-\".concat(clipPathId)\n                }, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    x: needClipX ? left : left - width / 2,\n                    y: needClipY ? top : top - height / 2,\n                    width: needClipX ? width : width * 2,\n                    height: needClipY ? height : height * 2\n                })), !clipDot && /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                    id: \"clipPath-dots-\".concat(clipPathId)\n                }, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    x: left - dotSize / 2,\n                    y: top - dotSize / 2,\n                    width: width + dotSize,\n                    height: height + dotSize\n                }))) : null, !hasSinglePoint && this.renderCurve(needClip, clipPathId), this.renderErrorBar(needClip, clipPathId), (hasSinglePoint || dot) && this.renderDots(needClip, clipDot, clipPathId), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, points));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curPoints: nextProps.points,\n                        prevPoints: prevState.curPoints\n                    };\n                }\n                if (nextProps.points !== prevState.curPoints) {\n                    return {\n                        curPoints: nextProps.points\n                    };\n                }\n                return null;\n            }\n        },\n        {\n            key: \"repeat\",\n            value: function repeat(lines, count) {\n                var linesUnit = lines.length % 2 !== 0 ? [].concat(_toConsumableArray(lines), [\n                    0\n                ]) : lines;\n                var result = [];\n                for(var i = 0; i < count; ++i){\n                    result = [].concat(_toConsumableArray(result), _toConsumableArray(linesUnit));\n                }\n                return result;\n            }\n        },\n        {\n            key: \"renderDotItem\",\n            value: function renderDotItem(option, props) {\n                var dotItem;\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    dotItem = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                } else if ((0, _isFunction[\"default\"])(option)) {\n                    dotItem = option(props);\n                } else {\n                    var key = props.key, dotProps = _objectWithoutProperties(props, _excluded2);\n                    var className = (0, _clsx[\"default\"])(\"recharts-line-dot\", typeof option !== \"boolean\" ? option.className : \"\");\n                    dotItem = /*#__PURE__*/ _react[\"default\"].createElement(_Dot.Dot, _extends({\n                        key: key\n                    }, dotProps, {\n                        className: className\n                    }));\n                }\n                return dotItem;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(Line, \"displayName\", \"Line\");\n_defineProperty(Line, \"defaultProps\", {\n    xAxisId: 0,\n    yAxisId: 0,\n    connectNulls: false,\n    activeDot: true,\n    dot: true,\n    legendType: \"line\",\n    stroke: \"#3182bd\",\n    strokeWidth: 1,\n    fill: \"#fff\",\n    points: [],\n    isAnimationActive: !_Global.Global.isSsr,\n    animateNewValues: true,\n    animationBegin: 0,\n    animationDuration: 1500,\n    animationEasing: \"ease\",\n    hide: false,\n    label: false\n});\n/**\n * Compose the data of each group\n * @param {Object} props The props from the component\n * @param  {Object} xAxis   The configuration of x-axis\n * @param  {Object} yAxis   The configuration of y-axis\n * @param  {String} dataKey The unique key of a group\n * @return {Array}  Composed data\n */ _defineProperty(Line, \"getComposedData\", function(_ref4) {\n    var props = _ref4.props, xAxis = _ref4.xAxis, yAxis = _ref4.yAxis, xAxisTicks = _ref4.xAxisTicks, yAxisTicks = _ref4.yAxisTicks, dataKey = _ref4.dataKey, bandSize = _ref4.bandSize, displayedData = _ref4.displayedData, offset = _ref4.offset;\n    var layout = props.layout;\n    var points = displayedData.map(function(entry, index) {\n        var value = (0, _ChartUtils.getValueByDataKey)(entry, dataKey);\n        if (layout === \"horizontal\") {\n            return {\n                x: (0, _ChartUtils.getCateCoordinateOfLine)({\n                    axis: xAxis,\n                    ticks: xAxisTicks,\n                    bandSize: bandSize,\n                    entry: entry,\n                    index: index\n                }),\n                y: (0, _isNil[\"default\"])(value) ? null : yAxis.scale(value),\n                value: value,\n                payload: entry\n            };\n        }\n        return {\n            x: (0, _isNil[\"default\"])(value) ? null : xAxis.scale(value),\n            y: (0, _ChartUtils.getCateCoordinateOfLine)({\n                axis: yAxis,\n                ticks: yAxisTicks,\n                bandSize: bandSize,\n                entry: entry,\n                index: index\n            }),\n            value: value,\n            payload: entry\n        };\n    });\n    return _objectSpread({\n        points: points,\n        layout: layout\n    }, offset);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9MaW5lLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxZQUFZLEdBQUcsS0FBSztBQUNwQixJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLGVBQWVDLHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDaEUsSUFBSUcsY0FBY0QsdUJBQXVCRixtQkFBT0EsQ0FBQyw0Q0FBbUI7QUFDcEUsSUFBSUksU0FBU0YsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJSyxXQUFXSCx1QkFBdUJGLG1CQUFPQSxDQUFDLHNDQUFnQjtBQUM5RCxJQUFJTSxRQUFRSix1QkFBdUJGLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlPLFNBQVNQLG1CQUFPQSxDQUFDLGtFQUFnQjtBQUNyQyxJQUFJUSxPQUFPUixtQkFBT0EsQ0FBQyw4REFBYztBQUNqQyxJQUFJUyxTQUFTVCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDekMsSUFBSVUsYUFBYVYsbUJBQU9BLENBQUMsa0ZBQXdCO0FBQ2pELElBQUlXLFlBQVlYLG1CQUFPQSxDQUFDLHFFQUFZO0FBQ3BDLElBQUlZLGFBQWFaLG1CQUFPQSxDQUFDLHdFQUFtQjtBQUM1QyxJQUFJYSxjQUFjYixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSWMsVUFBVWQsbUJBQU9BLENBQUMsa0VBQWdCO0FBQ3RDLElBQUllLGNBQWNmLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJZ0IsWUFBWTtJQUFDO0lBQVE7SUFBVTtJQUFnQjtDQUFNLEVBQ3ZEQyxhQUFhO0lBQUM7Q0FBTTtBQUN0QixTQUFTZix1QkFBdUJnQixHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hH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QUk1TSxRQUFRLENBQUMsR0FBR21CLFlBQVlvSyxpQkFBaUIsRUFBRWlCLE9BQU9yQjtRQUN0RCxJQUFJUCxXQUFXLGNBQWM7WUFDM0IsT0FBTztnQkFDTFEsR0FBRyxDQUFDLEdBQUdqSyxZQUFZK1IsdUJBQXVCLEVBQUU7b0JBQzFDQyxNQUFNekk7b0JBQ04wSSxPQUFPUDtvQkFDUEUsVUFBVUE7b0JBQ1Z2RyxPQUFPQTtvQkFDUEksT0FBT0E7Z0JBQ1Q7Z0JBQ0F2QixHQUFHLENBQUMsR0FBRzdLLE1BQU0sQ0FBQyxVQUFVLEVBQUVSLFNBQVMsT0FBTzJLLE1BQU0wSSxLQUFLLENBQUNyVDtnQkFDdERBLE9BQU9BO2dCQUNQd0wsU0FBU2dCO1lBQ1g7UUFDRjtRQUNBLE9BQU87WUFDTHBCLEdBQUcsQ0FBQyxHQUFHNUssTUFBTSxDQUFDLFVBQVUsRUFBRVIsU0FBUyxPQUFPMEssTUFBTTJJLEtBQUssQ0FBQ3JUO1lBQ3REcUwsR0FBRyxDQUFDLEdBQUdsSyxZQUFZK1IsdUJBQXVCLEVBQUU7Z0JBQzFDQyxNQUFNeEk7Z0JBQ055SSxPQUFPTjtnQkFDUEMsVUFBVUE7Z0JBQ1Z2RyxPQUFPQTtnQkFDUEksT0FBT0E7WUFDVDtZQUNBNU0sT0FBT0E7WUFDUHdMLFNBQVNnQjtRQUNYO0lBQ0Y7SUFDQSxPQUFPckksY0FBYztRQUNuQnNHLFFBQVFBO1FBQ1JHLFFBQVFBO0lBQ1YsR0FBR3FJO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9MaW5lLmpzP2FiYzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkxpbmUgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcmVhY3RTbW9vdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1zbW9vdGhcIikpO1xudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xudmFyIF9pc05pbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc05pbFwiKSk7XG52YXIgX2lzRXF1YWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNFcXVhbFwiKSk7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfQ3VydmUgPSByZXF1aXJlKFwiLi4vc2hhcGUvQ3VydmVcIik7XG52YXIgX0RvdCA9IHJlcXVpcmUoXCIuLi9zaGFwZS9Eb3RcIik7XG52YXIgX0xheWVyID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9MYXllclwiKTtcbnZhciBfTGFiZWxMaXN0ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbExpc3RcIik7XG52YXIgX0Vycm9yQmFyID0gcmVxdWlyZShcIi4vRXJyb3JCYXJcIik7XG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XG52YXIgX0dsb2JhbCA9IHJlcXVpcmUoXCIuLi91dGlsL0dsb2JhbFwiKTtcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XG52YXIgX2V4Y2x1ZGVkID0gW1widHlwZVwiLCBcImxheW91dFwiLCBcImNvbm5lY3ROdWxsc1wiLCBcInJlZlwiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImtleVwiXTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxuICogQGZpbGVPdmVydmlldyBMaW5lXG4gKi9cbnZhciBMaW5lID0gZXhwb3J0cy5MaW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBmdW5jdGlvbiBMaW5lKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluZSk7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgTGluZSwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwic3RhdGVcIiwge1xuICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogdHJ1ZSxcbiAgICAgIHRvdGFsTGVuZ3RoOiAwXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImdlbmVyYXRlU2ltcGxlU3Ryb2tlRGFzaGFycmF5XCIsIGZ1bmN0aW9uICh0b3RhbExlbmd0aCwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQobGVuZ3RoLCBcInB4IFwiKS5jb25jYXQodG90YWxMZW5ndGggLSBsZW5ndGgsIFwicHhcIik7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImdldFN0cm9rZURhc2hhcnJheVwiLCBmdW5jdGlvbiAobGVuZ3RoLCB0b3RhbExlbmd0aCwgbGluZXMpIHtcbiAgICAgIHZhciBsaW5lTGVuZ3RoID0gbGluZXMucmVkdWNlKGZ1bmN0aW9uIChwcmUsIG5leHQpIHtcbiAgICAgICAgcmV0dXJuIHByZSArIG5leHQ7XG4gICAgICB9KTtcblxuICAgICAgLy8gaWYgbGluZUxlbmd0aCBpcyAwIHJldHVybiB0aGUgZGVmYXVsdCB3aGVuIG5vIHN0cm9rZURhc2hhcnJheSBpcyBwcm92aWRlZFxuICAgICAgaWYgKCFsaW5lTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5nZW5lcmF0ZVNpbXBsZVN0cm9rZURhc2hhcnJheSh0b3RhbExlbmd0aCwgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb3VudCA9IE1hdGguZmxvb3IobGVuZ3RoIC8gbGluZUxlbmd0aCk7XG4gICAgICB2YXIgcmVtYWluTGVuZ3RoID0gbGVuZ3RoICUgbGluZUxlbmd0aDtcbiAgICAgIHZhciByZXN0TGVuZ3RoID0gdG90YWxMZW5ndGggLSBsZW5ndGg7XG4gICAgICB2YXIgcmVtYWluTGluZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBzdW0gPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBzdW0gKz0gbGluZXNbaV0sICsraSkge1xuICAgICAgICBpZiAoc3VtICsgbGluZXNbaV0gPiByZW1haW5MZW5ndGgpIHtcbiAgICAgICAgICByZW1haW5MaW5lcyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobGluZXMuc2xpY2UoMCwgaSkpLCBbcmVtYWluTGVuZ3RoIC0gc3VtXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBlbXB0eUxpbmVzID0gcmVtYWluTGluZXMubGVuZ3RoICUgMiA9PT0gMCA/IFswLCByZXN0TGVuZ3RoXSA6IFtyZXN0TGVuZ3RoXTtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KExpbmUucmVwZWF0KGxpbmVzLCBjb3VudCkpLCBfdG9Db25zdW1hYmxlQXJyYXkocmVtYWluTGluZXMpLCBlbXB0eUxpbmVzKS5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGxpbmUsIFwicHhcIik7XG4gICAgICB9KS5qb2luKCcsICcpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpZFwiLCAoMCwgX0RhdGFVdGlscy51bmlxdWVJZCkoJ3JlY2hhcnRzLWxpbmUtJykpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJwYXRoUmVmXCIsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBfdGhpcy5tYWluQ3VydmUgPSBub2RlO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25FbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkFuaW1hdGlvbkVuZCkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkFuaW1hdGlvbkVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25TdGFydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkFuaW1hdGlvblN0YXJ0KSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uQW5pbWF0aW9uU3RhcnQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKExpbmUsIF9QdXJlQ29tcG9uZW50KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhMaW5lLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIGlmICghdGhpcy5wcm9wcy5pc0FuaW1hdGlvbkFjdGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdG90YWxMZW5ndGggPSB0aGlzLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdG90YWxMZW5ndGg6IHRvdGFsTGVuZ3RoXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgIGlmICghdGhpcy5wcm9wcy5pc0FuaW1hdGlvbkFjdGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdG90YWxMZW5ndGggPSB0aGlzLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICBpZiAodG90YWxMZW5ndGggIT09IHRoaXMuc3RhdGUudG90YWxMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgdG90YWxMZW5ndGg6IHRvdGFsTGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUb3RhbExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb3RhbExlbmd0aCgpIHtcbiAgICAgIHZhciBjdXJ2ZURvbSA9IHRoaXMubWFpbkN1cnZlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGN1cnZlRG9tICYmIGN1cnZlRG9tLmdldFRvdGFsTGVuZ3RoICYmIGN1cnZlRG9tLmdldFRvdGFsTGVuZ3RoKCkgfHwgMDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyRXJyb3JCYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyRXJyb3JCYXIobmVlZENsaXAsIGNsaXBQYXRoSWQpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmlzQW5pbWF0aW9uQWN0aXZlICYmICF0aGlzLnN0YXRlLmlzQW5pbWF0aW9uRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBwb2ludHMgPSBfdGhpcyRwcm9wcy5wb2ludHMsXG4gICAgICAgIHhBeGlzID0gX3RoaXMkcHJvcHMueEF4aXMsXG4gICAgICAgIHlBeGlzID0gX3RoaXMkcHJvcHMueUF4aXMsXG4gICAgICAgIGxheW91dCA9IF90aGlzJHByb3BzLmxheW91dCxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBlcnJvckJhckl0ZW1zID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRBbGxCeVR5cGUpKGNoaWxkcmVuLCBfRXJyb3JCYXIuRXJyb3JCYXIpO1xuICAgICAgaWYgKCFlcnJvckJhckl0ZW1zKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGFQb2ludEZvcm1hdHRlciA9IGZ1bmN0aW9uIGRhdGFQb2ludEZvcm1hdHRlcihkYXRhUG9pbnQsIGRhdGFLZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBkYXRhUG9pbnQueCxcbiAgICAgICAgICB5OiBkYXRhUG9pbnQueSxcbiAgICAgICAgICB2YWx1ZTogZGF0YVBvaW50LnZhbHVlLFxuICAgICAgICAgIGVycm9yVmFsOiAoMCwgX0NoYXJ0VXRpbHMuZ2V0VmFsdWVCeURhdGFLZXkpKGRhdGFQb2ludC5wYXlsb2FkLCBkYXRhS2V5KVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHZhciBlcnJvckJhclByb3BzID0ge1xuICAgICAgICBjbGlwUGF0aDogbmVlZENsaXAgPyBcInVybCgjY2xpcFBhdGgtXCIuY29uY2F0KGNsaXBQYXRoSWQsIFwiKVwiKSA6IG51bGxcbiAgICAgIH07XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIGVycm9yQmFyUHJvcHMsIGVycm9yQmFySXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQoaXRlbSwge1xuICAgICAgICAgIGtleTogXCJiYXItXCIuY29uY2F0KGl0ZW0ucHJvcHMuZGF0YUtleSksXG4gICAgICAgICAgZGF0YTogcG9pbnRzLFxuICAgICAgICAgIHhBeGlzOiB4QXhpcyxcbiAgICAgICAgICB5QXhpczogeUF4aXMsXG4gICAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgICAgZGF0YVBvaW50Rm9ybWF0dGVyOiBkYXRhUG9pbnRGb3JtYXR0ZXJcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckRvdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyRG90cyhuZWVkQ2xpcCwgY2xpcERvdCwgY2xpcFBhdGhJZCkge1xuICAgICAgdmFyIGlzQW5pbWF0aW9uQWN0aXZlID0gdGhpcy5wcm9wcy5pc0FuaW1hdGlvbkFjdGl2ZTtcbiAgICAgIGlmIChpc0FuaW1hdGlvbkFjdGl2ZSAmJiAhdGhpcy5zdGF0ZS5pc0FuaW1hdGlvbkZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIGRvdCA9IF90aGlzJHByb3BzMi5kb3QsXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzMi5wb2ludHMsXG4gICAgICAgIGRhdGFLZXkgPSBfdGhpcyRwcm9wczIuZGF0YUtleTtcbiAgICAgIHZhciBsaW5lUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIGZhbHNlKTtcbiAgICAgIHZhciBjdXN0b21Eb3RQcm9wcyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykoZG90LCB0cnVlKTtcbiAgICAgIHZhciBkb3RzID0gcG9pbnRzLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgICAgICAgdmFyIGRvdFByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIGtleTogXCJkb3QtXCIuY29uY2F0KGkpLFxuICAgICAgICAgIHI6IDNcbiAgICAgICAgfSwgbGluZVByb3BzKSwgY3VzdG9tRG90UHJvcHMpLCB7fSwge1xuICAgICAgICAgIHZhbHVlOiBlbnRyeS52YWx1ZSxcbiAgICAgICAgICBkYXRhS2V5OiBkYXRhS2V5LFxuICAgICAgICAgIGN4OiBlbnRyeS54LFxuICAgICAgICAgIGN5OiBlbnRyeS55LFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHBheWxvYWQ6IGVudHJ5LnBheWxvYWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBMaW5lLnJlbmRlckRvdEl0ZW0oZG90LCBkb3RQcm9wcyk7XG4gICAgICB9KTtcbiAgICAgIHZhciBkb3RzUHJvcHMgPSB7XG4gICAgICAgIGNsaXBQYXRoOiBuZWVkQ2xpcCA/IFwidXJsKCNjbGlwUGF0aC1cIi5jb25jYXQoY2xpcERvdCA/ICcnIDogJ2RvdHMtJykuY29uY2F0KGNsaXBQYXRoSWQsIFwiKVwiKSA6IG51bGxcbiAgICAgIH07XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIF9leHRlbmRzKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWxpbmUtZG90c1wiLFxuICAgICAgICBrZXk6IFwiZG90c1wiXG4gICAgICB9LCBkb3RzUHJvcHMpLCBkb3RzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQ3VydmVTdGF0aWNhbGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckN1cnZlU3RhdGljYWxseShwb2ludHMsIG5lZWRDbGlwLCBjbGlwUGF0aElkLCBwcm9wcykge1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHR5cGUgPSBfdGhpcyRwcm9wczMudHlwZSxcbiAgICAgICAgbGF5b3V0ID0gX3RoaXMkcHJvcHMzLmxheW91dCxcbiAgICAgICAgY29ubmVjdE51bGxzID0gX3RoaXMkcHJvcHMzLmNvbm5lY3ROdWxscyxcbiAgICAgICAgcmVmID0gX3RoaXMkcHJvcHMzLnJlZixcbiAgICAgICAgb3RoZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzMywgX2V4Y2x1ZGVkKTtcbiAgICAgIHZhciBjdXJ2ZVByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykob3RoZXJzLCB0cnVlKSksIHt9LCB7XG4gICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgY2xhc3NOYW1lOiAncmVjaGFydHMtbGluZS1jdXJ2ZScsXG4gICAgICAgIGNsaXBQYXRoOiBuZWVkQ2xpcCA/IFwidXJsKCNjbGlwUGF0aC1cIi5jb25jYXQoY2xpcFBhdGhJZCwgXCIpXCIpIDogbnVsbCxcbiAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgIH0sIHByb3BzKSwge30sIHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgIGNvbm5lY3ROdWxsczogY29ubmVjdE51bGxzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9DdXJ2ZS5DdXJ2ZSwgX2V4dGVuZHMoe30sIGN1cnZlUHJvcHMsIHtcbiAgICAgICAgcGF0aFJlZjogdGhpcy5wYXRoUmVmXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckN1cnZlV2l0aEFuaW1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDdXJ2ZVdpdGhBbmltYXRpb24obmVlZENsaXAsIGNsaXBQYXRoSWQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzNC5wb2ludHMsXG4gICAgICAgIHN0cm9rZURhc2hhcnJheSA9IF90aGlzJHByb3BzNC5zdHJva2VEYXNoYXJyYXksXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHM0LmlzQW5pbWF0aW9uQWN0aXZlLFxuICAgICAgICBhbmltYXRpb25CZWdpbiA9IF90aGlzJHByb3BzNC5hbmltYXRpb25CZWdpbixcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb24gPSBfdGhpcyRwcm9wczQuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZyA9IF90aGlzJHByb3BzNC5hbmltYXRpb25FYXNpbmcsXG4gICAgICAgIGFuaW1hdGlvbklkID0gX3RoaXMkcHJvcHM0LmFuaW1hdGlvbklkLFxuICAgICAgICBhbmltYXRlTmV3VmFsdWVzID0gX3RoaXMkcHJvcHM0LmFuaW1hdGVOZXdWYWx1ZXMsXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM0LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczQuaGVpZ2h0O1xuICAgICAgdmFyIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgcHJldlBvaW50cyA9IF90aGlzJHN0YXRlLnByZXZQb2ludHMsXG4gICAgICAgIHRvdGFsTGVuZ3RoID0gX3RoaXMkc3RhdGUudG90YWxMZW5ndGg7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfcmVhY3RTbW9vdGhbXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgIGJlZ2luOiBhbmltYXRpb25CZWdpbixcbiAgICAgICAgZHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICBpc0FjdGl2ZTogaXNBbmltYXRpb25BY3RpdmUsXG4gICAgICAgIGVhc2luZzogYW5pbWF0aW9uRWFzaW5nLFxuICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgdDogMFxuICAgICAgICB9LFxuICAgICAgICB0bzoge1xuICAgICAgICAgIHQ6IDFcbiAgICAgICAgfSxcbiAgICAgICAga2V5OiBcImxpbmUtXCIuY29uY2F0KGFuaW1hdGlvbklkKSxcbiAgICAgICAgb25BbmltYXRpb25FbmQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uRW5kLFxuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0OiB0aGlzLmhhbmRsZUFuaW1hdGlvblN0YXJ0XG4gICAgICB9LCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgdCA9IF9yZWYudDtcbiAgICAgICAgaWYgKHByZXZQb2ludHMpIHtcbiAgICAgICAgICB2YXIgcHJldlBvaW50c0RpZmZGYWN0b3IgPSBwcmV2UG9pbnRzLmxlbmd0aCAvIHBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgdmFyIHN0ZXBEYXRhID0gcG9pbnRzLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcHJldlBvaW50SW5kZXggPSBNYXRoLmZsb29yKGluZGV4ICogcHJldlBvaW50c0RpZmZGYWN0b3IpO1xuICAgICAgICAgICAgaWYgKHByZXZQb2ludHNbcHJldlBvaW50SW5kZXhdKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2ID0gcHJldlBvaW50c1twcmV2UG9pbnRJbmRleF07XG4gICAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JYID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXYueCwgZW50cnkueCk7XG4gICAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JZID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXYueSwgZW50cnkueSk7XG4gICAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcbiAgICAgICAgICAgICAgICB4OiBpbnRlcnBvbGF0b3JYKHQpLFxuICAgICAgICAgICAgICAgIHk6IGludGVycG9sYXRvclkodClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1hZ2ljIG51bWJlciBvZiBmYWtpbmcgcHJldmlvdXMgeCBhbmQgeSBsb2NhdGlvblxuICAgICAgICAgICAgaWYgKGFuaW1hdGVOZXdWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnRlcnBvbGF0b3JYID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHdpZHRoICogMiwgZW50cnkueCk7XG4gICAgICAgICAgICAgIHZhciBfaW50ZXJwb2xhdG9yWSA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShoZWlnaHQgLyAyLCBlbnRyeS55KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xuICAgICAgICAgICAgICAgIHg6IF9pbnRlcnBvbGF0b3JYKHQpLFxuICAgICAgICAgICAgICAgIHk6IF9pbnRlcnBvbGF0b3JZKHQpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xuICAgICAgICAgICAgICB4OiBlbnRyeS54LFxuICAgICAgICAgICAgICB5OiBlbnRyeS55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLnJlbmRlckN1cnZlU3RhdGljYWxseShzdGVwRGF0YSwgbmVlZENsaXAsIGNsaXBQYXRoSWQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRlcnBvbGF0b3IgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikoMCwgdG90YWxMZW5ndGgpO1xuICAgICAgICB2YXIgY3VyTGVuZ3RoID0gaW50ZXJwb2xhdG9yKHQpO1xuICAgICAgICB2YXIgY3VycmVudFN0cm9rZURhc2hhcnJheTtcbiAgICAgICAgaWYgKHN0cm9rZURhc2hhcnJheSkge1xuICAgICAgICAgIHZhciBsaW5lcyA9IFwiXCIuY29uY2F0KHN0cm9rZURhc2hhcnJheSkuc3BsaXQoL1ssXFxzXSsvZ2ltKS5tYXAoZnVuY3Rpb24gKG51bSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobnVtKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjdXJyZW50U3Ryb2tlRGFzaGFycmF5ID0gX3RoaXMyLmdldFN0cm9rZURhc2hhcnJheShjdXJMZW5ndGgsIHRvdGFsTGVuZ3RoLCBsaW5lcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFN0cm9rZURhc2hhcnJheSA9IF90aGlzMi5nZW5lcmF0ZVNpbXBsZVN0cm9rZURhc2hhcnJheSh0b3RhbExlbmd0aCwgY3VyTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXMyLnJlbmRlckN1cnZlU3RhdGljYWxseShwb2ludHMsIG5lZWRDbGlwLCBjbGlwUGF0aElkLCB7XG4gICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBjdXJyZW50U3Ryb2tlRGFzaGFycmF5XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckN1cnZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckN1cnZlKG5lZWRDbGlwLCBjbGlwUGF0aElkKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgcG9pbnRzID0gX3RoaXMkcHJvcHM1LnBvaW50cyxcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczUuaXNBbmltYXRpb25BY3RpdmU7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUyID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgcHJldlBvaW50cyA9IF90aGlzJHN0YXRlMi5wcmV2UG9pbnRzLFxuICAgICAgICB0b3RhbExlbmd0aCA9IF90aGlzJHN0YXRlMi50b3RhbExlbmd0aDtcbiAgICAgIGlmIChpc0FuaW1hdGlvbkFjdGl2ZSAmJiBwb2ludHMgJiYgcG9pbnRzLmxlbmd0aCAmJiAoIXByZXZQb2ludHMgJiYgdG90YWxMZW5ndGggPiAwIHx8ICEoMCwgX2lzRXF1YWxbXCJkZWZhdWx0XCJdKShwcmV2UG9pbnRzLCBwb2ludHMpKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDdXJ2ZVdpdGhBbmltYXRpb24obmVlZENsaXAsIGNsaXBQYXRoSWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ3VydmVTdGF0aWNhbGx5KHBvaW50cywgbmVlZENsaXAsIGNsaXBQYXRoSWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF9maWx0ZXJQcm9wcztcbiAgICAgIHZhciBfdGhpcyRwcm9wczYgPSB0aGlzLnByb3BzLFxuICAgICAgICBoaWRlID0gX3RoaXMkcHJvcHM2LmhpZGUsXG4gICAgICAgIGRvdCA9IF90aGlzJHByb3BzNi5kb3QsXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzNi5wb2ludHMsXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzNi5jbGFzc05hbWUsXG4gICAgICAgIHhBeGlzID0gX3RoaXMkcHJvcHM2LnhBeGlzLFxuICAgICAgICB5QXhpcyA9IF90aGlzJHByb3BzNi55QXhpcyxcbiAgICAgICAgdG9wID0gX3RoaXMkcHJvcHM2LnRvcCxcbiAgICAgICAgbGVmdCA9IF90aGlzJHByb3BzNi5sZWZ0LFxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM2LmhlaWdodCxcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczYuaXNBbmltYXRpb25BY3RpdmUsXG4gICAgICAgIGlkID0gX3RoaXMkcHJvcHM2LmlkO1xuICAgICAgaWYgKGhpZGUgfHwgIXBvaW50cyB8fCAhcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FuaW1hdGlvbkZpbmlzaGVkID0gdGhpcy5zdGF0ZS5pc0FuaW1hdGlvbkZpbmlzaGVkO1xuICAgICAgdmFyIGhhc1NpbmdsZVBvaW50ID0gcG9pbnRzLmxlbmd0aCA9PT0gMTtcbiAgICAgIHZhciBsYXllckNsYXNzID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLWxpbmUnLCBjbGFzc05hbWUpO1xuICAgICAgdmFyIG5lZWRDbGlwWCA9IHhBeGlzICYmIHhBeGlzLmFsbG93RGF0YU92ZXJmbG93O1xuICAgICAgdmFyIG5lZWRDbGlwWSA9IHlBeGlzICYmIHlBeGlzLmFsbG93RGF0YU92ZXJmbG93O1xuICAgICAgdmFyIG5lZWRDbGlwID0gbmVlZENsaXBYIHx8IG5lZWRDbGlwWTtcbiAgICAgIHZhciBjbGlwUGF0aElkID0gKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGlkKSA/IHRoaXMuaWQgOiBpZDtcbiAgICAgIHZhciBfcmVmMiA9IChfZmlsdGVyUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKGRvdCwgZmFsc2UpKSAhPT0gbnVsbCAmJiBfZmlsdGVyUHJvcHMgIT09IHZvaWQgMCA/IF9maWx0ZXJQcm9wcyA6IHtcbiAgICAgICAgICByOiAzLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAyXG4gICAgICAgIH0sXG4gICAgICAgIF9yZWYyJHIgPSBfcmVmMi5yLFxuICAgICAgICByID0gX3JlZjIkciA9PT0gdm9pZCAwID8gMyA6IF9yZWYyJHIsXG4gICAgICAgIF9yZWYyJHN0cm9rZVdpZHRoID0gX3JlZjIuc3Ryb2tlV2lkdGgsXG4gICAgICAgIHN0cm9rZVdpZHRoID0gX3JlZjIkc3Ryb2tlV2lkdGggPT09IHZvaWQgMCA/IDIgOiBfcmVmMiRzdHJva2VXaWR0aDtcbiAgICAgIHZhciBfcmVmMyA9ICgwLCBfUmVhY3RVdGlscy5oYXNDbGlwRG90KShkb3QpID8gZG90IDoge30sXG4gICAgICAgIF9yZWYzJGNsaXBEb3QgPSBfcmVmMy5jbGlwRG90LFxuICAgICAgICBjbGlwRG90ID0gX3JlZjMkY2xpcERvdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYzJGNsaXBEb3Q7XG4gICAgICB2YXIgZG90U2l6ZSA9IHIgKiAyICsgc3Ryb2tlV2lkdGg7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBsYXllckNsYXNzXG4gICAgICB9LCBuZWVkQ2xpcFggfHwgbmVlZENsaXBZID8gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRlZnNcIiwgbnVsbCwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIsIHtcbiAgICAgICAgaWQ6IFwiY2xpcFBhdGgtXCIuY29uY2F0KGNsaXBQYXRoSWQpXG4gICAgICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgICAgIHg6IG5lZWRDbGlwWCA/IGxlZnQgOiBsZWZ0IC0gd2lkdGggLyAyLFxuICAgICAgICB5OiBuZWVkQ2xpcFkgPyB0b3AgOiB0b3AgLSBoZWlnaHQgLyAyLFxuICAgICAgICB3aWR0aDogbmVlZENsaXBYID8gd2lkdGggOiB3aWR0aCAqIDIsXG4gICAgICAgIGhlaWdodDogbmVlZENsaXBZID8gaGVpZ2h0IDogaGVpZ2h0ICogMlxuICAgICAgfSkpLCAhY2xpcERvdCAmJiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwge1xuICAgICAgICBpZDogXCJjbGlwUGF0aC1kb3RzLVwiLmNvbmNhdChjbGlwUGF0aElkKVxuICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAgICB4OiBsZWZ0IC0gZG90U2l6ZSAvIDIsXG4gICAgICAgIHk6IHRvcCAtIGRvdFNpemUgLyAyLFxuICAgICAgICB3aWR0aDogd2lkdGggKyBkb3RTaXplLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCArIGRvdFNpemVcbiAgICAgIH0pKSkgOiBudWxsLCAhaGFzU2luZ2xlUG9pbnQgJiYgdGhpcy5yZW5kZXJDdXJ2ZShuZWVkQ2xpcCwgY2xpcFBhdGhJZCksIHRoaXMucmVuZGVyRXJyb3JCYXIobmVlZENsaXAsIGNsaXBQYXRoSWQpLCAoaGFzU2luZ2xlUG9pbnQgfHwgZG90KSAmJiB0aGlzLnJlbmRlckRvdHMobmVlZENsaXAsIGNsaXBEb3QsIGNsaXBQYXRoSWQpLCAoIWlzQW5pbWF0aW9uQWN0aXZlIHx8IGlzQW5pbWF0aW9uRmluaXNoZWQpICYmIF9MYWJlbExpc3QuTGFiZWxMaXN0LnJlbmRlckNhbGxCeVBhcmVudCh0aGlzLnByb3BzLCBwb2ludHMpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmFuaW1hdGlvbklkICE9PSBwcmV2U3RhdGUucHJldkFuaW1hdGlvbklkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJldkFuaW1hdGlvbklkOiBuZXh0UHJvcHMuYW5pbWF0aW9uSWQsXG4gICAgICAgICAgY3VyUG9pbnRzOiBuZXh0UHJvcHMucG9pbnRzLFxuICAgICAgICAgIHByZXZQb2ludHM6IHByZXZTdGF0ZS5jdXJQb2ludHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0UHJvcHMucG9pbnRzICE9PSBwcmV2U3RhdGUuY3VyUG9pbnRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY3VyUG9pbnRzOiBuZXh0UHJvcHMucG9pbnRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVwZWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGVhdChsaW5lcywgY291bnQpIHtcbiAgICAgIHZhciBsaW5lc1VuaXQgPSBsaW5lcy5sZW5ndGggJSAyICE9PSAwID8gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsaW5lcyksIFswXSkgOiBsaW5lcztcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICByZXN1bHQgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlc3VsdCksIF90b0NvbnN1bWFibGVBcnJheShsaW5lc1VuaXQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckRvdEl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyRG90SXRlbShvcHRpb24sIHByb3BzKSB7XG4gICAgICB2YXIgZG90SXRlbTtcbiAgICAgIGlmICggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQob3B0aW9uKSkge1xuICAgICAgICBkb3RJdGVtID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KG9wdGlvbiwgcHJvcHMpO1xuICAgICAgfSBlbHNlIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvcHRpb24pKSB7XG4gICAgICAgIGRvdEl0ZW0gPSBvcHRpb24ocHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzLmtleSxcbiAgICAgICAgICBkb3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkMik7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtbGluZS1kb3QnLCB0eXBlb2Ygb3B0aW9uICE9PSAnYm9vbGVhbicgPyBvcHRpb24uY2xhc3NOYW1lIDogJycpO1xuICAgICAgICBkb3RJdGVtID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfRG90LkRvdCwgX2V4dGVuZHMoe1xuICAgICAgICAgIGtleToga2V5XG4gICAgICAgIH0sIGRvdFByb3BzLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvdEl0ZW07XG4gICAgfVxuICB9XSk7XG59KF9yZWFjdC5QdXJlQ29tcG9uZW50KTtcbl9kZWZpbmVQcm9wZXJ0eShMaW5lLCBcImRpc3BsYXlOYW1lXCIsICdMaW5lJyk7XG5fZGVmaW5lUHJvcGVydHkoTGluZSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICB4QXhpc0lkOiAwLFxuICB5QXhpc0lkOiAwLFxuICBjb25uZWN0TnVsbHM6IGZhbHNlLFxuICBhY3RpdmVEb3Q6IHRydWUsXG4gIGRvdDogdHJ1ZSxcbiAgbGVnZW5kVHlwZTogJ2xpbmUnLFxuICBzdHJva2U6ICcjMzE4MmJkJyxcbiAgc3Ryb2tlV2lkdGg6IDEsXG4gIGZpbGw6ICcjZmZmJyxcbiAgcG9pbnRzOiBbXSxcbiAgaXNBbmltYXRpb25BY3RpdmU6ICFfR2xvYmFsLkdsb2JhbC5pc1NzcixcbiAgYW5pbWF0ZU5ld1ZhbHVlczogdHJ1ZSxcbiAgYW5pbWF0aW9uQmVnaW46IDAsXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiAxNTAwLFxuICBhbmltYXRpb25FYXNpbmc6ICdlYXNlJyxcbiAgaGlkZTogZmFsc2UsXG4gIGxhYmVsOiBmYWxzZVxufSk7XG4vKipcbiAqIENvbXBvc2UgdGhlIGRhdGEgb2YgZWFjaCBncm91cFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFRoZSBwcm9wcyBmcm9tIHRoZSBjb21wb25lbnRcbiAqIEBwYXJhbSAge09iamVjdH0geEF4aXMgICBUaGUgY29uZmlndXJhdGlvbiBvZiB4LWF4aXNcbiAqIEBwYXJhbSAge09iamVjdH0geUF4aXMgICBUaGUgY29uZmlndXJhdGlvbiBvZiB5LWF4aXNcbiAqIEBwYXJhbSAge1N0cmluZ30gZGF0YUtleSBUaGUgdW5pcXVlIGtleSBvZiBhIGdyb3VwXG4gKiBAcmV0dXJuIHtBcnJheX0gIENvbXBvc2VkIGRhdGFcbiAqL1xuX2RlZmluZVByb3BlcnR5KExpbmUsIFwiZ2V0Q29tcG9zZWREYXRhXCIsIGZ1bmN0aW9uIChfcmVmNCkge1xuICB2YXIgcHJvcHMgPSBfcmVmNC5wcm9wcyxcbiAgICB4QXhpcyA9IF9yZWY0LnhBeGlzLFxuICAgIHlBeGlzID0gX3JlZjQueUF4aXMsXG4gICAgeEF4aXNUaWNrcyA9IF9yZWY0LnhBeGlzVGlja3MsXG4gICAgeUF4aXNUaWNrcyA9IF9yZWY0LnlBeGlzVGlja3MsXG4gICAgZGF0YUtleSA9IF9yZWY0LmRhdGFLZXksXG4gICAgYmFuZFNpemUgPSBfcmVmNC5iYW5kU2l6ZSxcbiAgICBkaXNwbGF5ZWREYXRhID0gX3JlZjQuZGlzcGxheWVkRGF0YSxcbiAgICBvZmZzZXQgPSBfcmVmNC5vZmZzZXQ7XG4gIHZhciBsYXlvdXQgPSBwcm9wcy5sYXlvdXQ7XG4gIHZhciBwb2ludHMgPSBkaXNwbGF5ZWREYXRhLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XG4gICAgdmFyIHZhbHVlID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgZGF0YUtleSk7XG4gICAgaWYgKGxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoMCwgX0NoYXJ0VXRpbHMuZ2V0Q2F0ZUNvb3JkaW5hdGVPZkxpbmUpKHtcbiAgICAgICAgICBheGlzOiB4QXhpcyxcbiAgICAgICAgICB0aWNrczogeEF4aXNUaWNrcyxcbiAgICAgICAgICBiYW5kU2l6ZTogYmFuZFNpemUsXG4gICAgICAgICAgZW50cnk6IGVudHJ5LFxuICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9KSxcbiAgICAgICAgeTogKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKHZhbHVlKSA/IG51bGwgOiB5QXhpcy5zY2FsZSh2YWx1ZSksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgcGF5bG9hZDogZW50cnlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4OiAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkodmFsdWUpID8gbnVsbCA6IHhBeGlzLnNjYWxlKHZhbHVlKSxcbiAgICAgIHk6ICgwLCBfQ2hhcnRVdGlscy5nZXRDYXRlQ29vcmRpbmF0ZU9mTGluZSkoe1xuICAgICAgICBheGlzOiB5QXhpcyxcbiAgICAgICAgdGlja3M6IHlBeGlzVGlja3MsXG4gICAgICAgIGJhbmRTaXplOiBiYW5kU2l6ZSxcbiAgICAgICAgZW50cnk6IGVudHJ5LFxuICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgIH0pLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgcGF5bG9hZDogZW50cnlcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgIHBvaW50czogcG9pbnRzLFxuICAgIGxheW91dDogbGF5b3V0XG4gIH0sIG9mZnNldCk7XG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJMaW5lIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX3JlYWN0U21vb3RoIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9pc0Z1bmN0aW9uIiwiX2lzTmlsIiwiX2lzRXF1YWwiLCJfY2xzeCIsIl9DdXJ2ZSIsIl9Eb3QiLCJfTGF5ZXIiLCJfTGFiZWxMaXN0IiwiX0Vycm9yQmFyIiwiX0RhdGFVdGlscyIsIl9SZWFjdFV0aWxzIiwiX0dsb2JhbCIsIl9DaGFydFV0aWxzIiwiX2V4Y2x1ZGVkIiwiX2V4Y2x1ZGVkMiIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZSIsImV4Y2x1ZGVkIiwidGFyZ2V0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJrZXkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwibGVuZ3RoIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJvd25LZXlzIiwia2V5cyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl90b0NvbnN1bWFibGVBcnJheSIsImFyciIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJUeXBlRXJyb3IiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsIml0ZXIiLCJpc0FycmF5IiwibGVuIiwiYXJyMiIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJfUHVyZUNvbXBvbmVudCIsIl90aGlzIiwiX2xlbiIsImFyZ3MiLCJfa2V5IiwiY29uY2F0IiwiaXNBbmltYXRpb25GaW5pc2hlZCIsInRvdGFsTGVuZ3RoIiwibGluZXMiLCJsaW5lTGVuZ3RoIiwicmVkdWNlIiwicHJlIiwibmV4dCIsImdlbmVyYXRlU2ltcGxlU3Ryb2tlRGFzaGFycmF5IiwiY291bnQiLCJNYXRoIiwiZmxvb3IiLCJyZW1haW5MZW5ndGgiLCJyZXN0TGVuZ3RoIiwicmVtYWluTGluZXMiLCJzdW0iLCJlbXB0eUxpbmVzIiwicmVwZWF0IiwibWFwIiwibGluZSIsImpvaW4iLCJ1bmlxdWVJZCIsIm5vZGUiLCJtYWluQ3VydmUiLCJzZXRTdGF0ZSIsIm9uQW5pbWF0aW9uRW5kIiwib25BbmltYXRpb25TdGFydCIsImNvbXBvbmVudERpZE1vdW50IiwiaXNBbmltYXRpb25BY3RpdmUiLCJnZXRUb3RhbExlbmd0aCIsImNvbXBvbmVudERpZFVwZGF0ZSIsInN0YXRlIiwiY3VydmVEb20iLCJlcnIiLCJyZW5kZXJFcnJvckJhciIsIm5lZWRDbGlwIiwiY2xpcFBhdGhJZCIsIl90aGlzJHByb3BzIiwicG9pbnRzIiwieEF4aXMiLCJ5QXhpcyIsImxheW91dCIsImNoaWxkcmVuIiwiZXJyb3JCYXJJdGVtcyIsImZpbmRBbGxCeVR5cGUiLCJFcnJvckJhciIsImRhdGFQb2ludEZvcm1hdHRlciIsImRhdGFQb2ludCIsImRhdGFLZXkiLCJ4IiwieSIsImVycm9yVmFsIiwiZ2V0VmFsdWVCeURhdGFLZXkiLCJwYXlsb2FkIiwiZXJyb3JCYXJQcm9wcyIsImNsaXBQYXRoIiwiY3JlYXRlRWxlbWVudCIsIkxheWVyIiwiaXRlbSIsImNsb25lRWxlbWVudCIsImRhdGEiLCJyZW5kZXJEb3RzIiwiY2xpcERvdCIsIl90aGlzJHByb3BzMiIsImRvdCIsImxpbmVQcm9wcyIsImZpbHRlclByb3BzIiwiY3VzdG9tRG90UHJvcHMiLCJkb3RzIiwiZW50cnkiLCJkb3RQcm9wcyIsImN4IiwiY3kiLCJpbmRleCIsInJlbmRlckRvdEl0ZW0iLCJkb3RzUHJvcHMiLCJjbGFzc05hbWUiLCJyZW5kZXJDdXJ2ZVN0YXRpY2FsbHkiLCJfdGhpcyRwcm9wczMiLCJ0eXBlIiwiY29ubmVjdE51bGxzIiwicmVmIiwib3RoZXJzIiwiY3VydmVQcm9wcyIsImZpbGwiLCJDdXJ2ZSIsInBhdGhSZWYiLCJyZW5kZXJDdXJ2ZVdpdGhBbmltYXRpb24iLCJfdGhpczIiLCJfdGhpcyRwcm9wczQiLCJzdHJva2VEYXNoYXJyYXkiLCJhbmltYXRpb25CZWdpbiIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRWFzaW5nIiwiYW5pbWF0aW9uSWQiLCJhbmltYXRlTmV3VmFsdWVzIiwid2lkdGgiLCJoZWlnaHQiLCJfdGhpcyRzdGF0ZSIsInByZXZQb2ludHMiLCJiZWdpbiIsImR1cmF0aW9uIiwiaXNBY3RpdmUiLCJlYXNpbmciLCJ0byIsImhhbmRsZUFuaW1hdGlvbkVuZCIsImhhbmRsZUFuaW1hdGlvblN0YXJ0IiwiX3JlZiIsInByZXZQb2ludHNEaWZmRmFjdG9yIiwic3RlcERhdGEiLCJwcmV2UG9pbnRJbmRleCIsInByZXYiLCJpbnRlcnBvbGF0b3JYIiwiaW50ZXJwb2xhdGVOdW1iZXIiLCJpbnRlcnBvbGF0b3JZIiwiX2ludGVycG9sYXRvclgiLCJfaW50ZXJwb2xhdG9yWSIsImludGVycG9sYXRvciIsImN1ckxlbmd0aCIsImN1cnJlbnRTdHJva2VEYXNoYXJyYXkiLCJzcGxpdCIsIm51bSIsInBhcnNlRmxvYXQiLCJnZXRTdHJva2VEYXNoYXJyYXkiLCJyZW5kZXJDdXJ2ZSIsIl90aGlzJHByb3BzNSIsIl90aGlzJHN0YXRlMiIsInJlbmRlciIsIl9maWx0ZXJQcm9wcyIsIl90aGlzJHByb3BzNiIsImhpZGUiLCJ0b3AiLCJsZWZ0IiwiaWQiLCJoYXNTaW5nbGVQb2ludCIsImxheWVyQ2xhc3MiLCJuZWVkQ2xpcFgiLCJhbGxvd0RhdGFPdmVyZmxvdyIsIm5lZWRDbGlwWSIsIl9yZWYyIiwic3Ryb2tlV2lkdGgiLCJfcmVmMiRyIiwiX3JlZjIkc3Ryb2tlV2lkdGgiLCJfcmVmMyIsImhhc0NsaXBEb3QiLCJfcmVmMyRjbGlwRG90IiwiZG90U2l6ZSIsIkxhYmVsTGlzdCIsInJlbmRlckNhbGxCeVBhcmVudCIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIm5leHRQcm9wcyIsInByZXZTdGF0ZSIsInByZXZBbmltYXRpb25JZCIsImN1clBvaW50cyIsImxpbmVzVW5pdCIsInJlc3VsdCIsIm9wdGlvbiIsImRvdEl0ZW0iLCJpc1ZhbGlkRWxlbWVudCIsIkRvdCIsIlB1cmVDb21wb25lbnQiLCJ4QXhpc0lkIiwieUF4aXNJZCIsImFjdGl2ZURvdCIsImxlZ2VuZFR5cGUiLCJzdHJva2UiLCJHbG9iYWwiLCJpc1NzciIsImxhYmVsIiwiX3JlZjQiLCJ4QXhpc1RpY2tzIiwieUF4aXNUaWNrcyIsImJhbmRTaXplIiwiZGlzcGxheWVkRGF0YSIsIm9mZnNldCIsImdldENhdGVDb29yZGluYXRlT2ZMaW5lIiwiYXhpcyIsInRpY2tzIiwic2NhbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/Line.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/cartesian/ReferenceArea.js":
/*!**************************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/ReferenceArea.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ReferenceArea = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _Label = __webpack_require__(/*! ../component/Label */ \"./node_modules/recharts/lib/component/Label.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"./node_modules/recharts/lib/util/CartesianUtils.js\");\nvar _IfOverflowMatches = __webpack_require__(/*! ../util/IfOverflowMatches */ \"./node_modules/recharts/lib/util/IfOverflowMatches.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"./node_modules/recharts/lib/util/LogUtils.js\");\nvar _Rectangle = __webpack_require__(/*! ../shape/Rectangle */ \"./node_modules/recharts/lib/shape/Rectangle.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Reference Line\n */ \nvar getRect = function getRect(hasX1, hasX2, hasY1, hasY2, props) {\n    var xValue1 = props.x1, xValue2 = props.x2, yValue1 = props.y1, yValue2 = props.y2, xAxis = props.xAxis, yAxis = props.yAxis;\n    if (!xAxis || !yAxis) return null;\n    var scales = (0, _CartesianUtils.createLabeledScales)({\n        x: xAxis.scale,\n        y: yAxis.scale\n    });\n    var p1 = {\n        x: hasX1 ? scales.x.apply(xValue1, {\n            position: \"start\"\n        }) : scales.x.rangeMin,\n        y: hasY1 ? scales.y.apply(yValue1, {\n            position: \"start\"\n        }) : scales.y.rangeMin\n    };\n    var p2 = {\n        x: hasX2 ? scales.x.apply(xValue2, {\n            position: \"end\"\n        }) : scales.x.rangeMax,\n        y: hasY2 ? scales.y.apply(yValue2, {\n            position: \"end\"\n        }) : scales.y.rangeMax\n    };\n    if ((0, _IfOverflowMatches.ifOverflowMatches)(props, \"discard\") && (!scales.isInRange(p1) || !scales.isInRange(p2))) {\n        return null;\n    }\n    return (0, _CartesianUtils.rectWithPoints)(p1, p2);\n};\n// eslint-disable-next-line react/prefer-stateless-function -- requires static defaultProps\nvar ReferenceArea = exports.ReferenceArea = /*#__PURE__*/ function(_React$Component) {\n    function ReferenceArea() {\n        _classCallCheck(this, ReferenceArea);\n        return _callSuper(this, ReferenceArea, arguments);\n    }\n    _inherits(ReferenceArea, _React$Component);\n    return _createClass(ReferenceArea, [\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props = this.props, x1 = _this$props.x1, x2 = _this$props.x2, y1 = _this$props.y1, y2 = _this$props.y2, className = _this$props.className, alwaysShow = _this$props.alwaysShow, clipPathId = _this$props.clipPathId;\n                (0, _LogUtils.warn)(alwaysShow === undefined, 'The alwaysShow prop is deprecated. Please use ifOverflow=\"extendDomain\" instead.');\n                var hasX1 = (0, _DataUtils.isNumOrStr)(x1);\n                var hasX2 = (0, _DataUtils.isNumOrStr)(x2);\n                var hasY1 = (0, _DataUtils.isNumOrStr)(y1);\n                var hasY2 = (0, _DataUtils.isNumOrStr)(y2);\n                var shape = this.props.shape;\n                if (!hasX1 && !hasX2 && !hasY1 && !hasY2 && !shape) {\n                    return null;\n                }\n                var rect = getRect(hasX1, hasX2, hasY1, hasY2, this.props);\n                if (!rect && !shape) {\n                    return null;\n                }\n                var clipPath = (0, _IfOverflowMatches.ifOverflowMatches)(this.props, \"hidden\") ? \"url(#\".concat(clipPathId, \")\") : undefined;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: (0, _clsx[\"default\"])(\"recharts-reference-area\", className)\n                }, ReferenceArea.renderRect(shape, _objectSpread(_objectSpread({\n                    clipPath: clipPath\n                }, (0, _ReactUtils.filterProps)(this.props, true)), rect)), _Label.Label.renderCallByParent(this.props, rect));\n            }\n        }\n    ]);\n}(_react[\"default\"].Component);\n_defineProperty(ReferenceArea, \"displayName\", \"ReferenceArea\");\n_defineProperty(ReferenceArea, \"defaultProps\", {\n    isFront: false,\n    ifOverflow: \"discard\",\n    xAxisId: 0,\n    yAxisId: 0,\n    r: 10,\n    fill: \"#ccc\",\n    fillOpacity: 0.5,\n    stroke: \"none\",\n    strokeWidth: 1\n});\n_defineProperty(ReferenceArea, \"renderRect\", function(option, props) {\n    var rect;\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n        rect = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n    } else if ((0, _isFunction[\"default\"])(option)) {\n        rect = option(props);\n    } else {\n        rect = /*#__PURE__*/ _react[\"default\"].createElement(_Rectangle.Rectangle, _extends({}, props, {\n            className: \"recharts-reference-area-rect\"\n        }));\n    }\n    return rect;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9SZWZlcmVuY2VBcmVhLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxxQkFBcUIsR0FBRyxLQUFLO0FBQzdCLElBQUlHLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDbkQsSUFBSUMsY0FBY0YsdUJBQXVCQyxtQkFBT0EsQ0FBQyw0Q0FBbUI7QUFDcEUsSUFBSUUsUUFBUUgsdUJBQXVCQyxtQkFBT0EsQ0FBQyxrQkFBTTtBQUNqRCxJQUFJRyxTQUFTSCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDekMsSUFBSUksU0FBU0osbUJBQU9BLENBQUMsMEVBQW9CO0FBQ3pDLElBQUlLLGtCQUFrQkwsbUJBQU9BLENBQUMsa0ZBQXdCO0FBQ3RELElBQUlNLHFCQUFxQk4sbUJBQU9BLENBQUMsd0ZBQTJCO0FBQzVELElBQUlPLGFBQWFQLG1CQUFPQSxDQUFDLHdFQUFtQjtBQUM1QyxJQUFJUSxZQUFZUixtQkFBT0EsQ0FBQyxzRUFBa0I7QUFDMUMsSUFBSVMsYUFBYVQsbUJBQU9BLENBQUMsMEVBQW9CO0FBQzdDLElBQUlVLGNBQWNWLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxTQUFTRCx1QkFBdUJZLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0U7SUFBYUEsV0FBV3BCLE9BQU9xQixNQUFNLEdBQUdyQixPQUFPcUIsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFBRSxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFBRSxJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQUUsSUFBSTNCLE9BQU82QixTQUFTLENB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QUM3QnZGLGdCQUFnQjlDLGVBQWUsZUFBZTtBQUM5QzhDLGdCQUFnQjlDLGVBQWUsZ0JBQWdCO0lBQzdDc0ksU0FBUztJQUNUQyxZQUFZO0lBQ1pDLFNBQVM7SUFDVEMsU0FBUztJQUNUckcsR0FBRztJQUNIc0csTUFBTTtJQUNOQyxhQUFhO0lBQ2JDLFFBQVE7SUFDUkMsYUFBYTtBQUNmO0FBQ0EvRixnQkFBZ0I5QyxlQUFlLGNBQWMsU0FBVThJLE1BQU0sRUFBRXhGLEtBQUs7SUFDbEUsSUFBSXNFO0lBQ0osSUFBSyxXQUFXLEdBQUUzSCxNQUFNLENBQUMsVUFBVSxDQUFDOEksY0FBYyxDQUFDRCxTQUFTO1FBQzFEbEIsT0FBTyxXQUFXLEdBQUUzSCxNQUFNLENBQUMsVUFBVSxDQUFDK0ksWUFBWSxDQUFDRixRQUFReEY7SUFDN0QsT0FBTyxJQUFJLENBQUMsR0FBR2xELFdBQVcsQ0FBQyxVQUFVLEVBQUUwSSxTQUFTO1FBQzlDbEIsT0FBT2tCLE9BQU94RjtJQUNoQixPQUFPO1FBQ0xzRSxPQUFPLFdBQVcsR0FBRTNILE1BQU0sQ0FBQyxVQUFVLENBQUM4SCxhQUFhLENBQUNuSCxXQUFXcUksU0FBUyxFQUFFakksU0FBUyxDQUFDLEdBQUdzQyxPQUFPO1lBQzVGK0QsV0FBVztRQUNiO0lBQ0Y7SUFDQSxPQUFPTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9jYXJ0ZXNpYW4vUmVmZXJlbmNlQXJlYS5qcz8wYWFhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5SZWZlcmVuY2VBcmVhID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XG52YXIgX0xhYmVsID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbFwiKTtcbnZhciBfQ2FydGVzaWFuVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9DYXJ0ZXNpYW5VdGlsc1wiKTtcbnZhciBfSWZPdmVyZmxvd01hdGNoZXMgPSByZXF1aXJlKFwiLi4vdXRpbC9JZk92ZXJmbG93TWF0Y2hlc1wiKTtcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xudmFyIF9Mb2dVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0xvZ1V0aWxzXCIpO1xudmFyIF9SZWN0YW5nbGUgPSByZXF1aXJlKFwiLi4vc2hhcGUvUmVjdGFuZ2xlXCIpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFJlZmVyZW5jZSBMaW5lXG4gKi9cbnZhciBnZXRSZWN0ID0gZnVuY3Rpb24gZ2V0UmVjdChoYXNYMSwgaGFzWDIsIGhhc1kxLCBoYXNZMiwgcHJvcHMpIHtcbiAgdmFyIHhWYWx1ZTEgPSBwcm9wcy54MSxcbiAgICB4VmFsdWUyID0gcHJvcHMueDIsXG4gICAgeVZhbHVlMSA9IHByb3BzLnkxLFxuICAgIHlWYWx1ZTIgPSBwcm9wcy55MixcbiAgICB4QXhpcyA9IHByb3BzLnhBeGlzLFxuICAgIHlBeGlzID0gcHJvcHMueUF4aXM7XG4gIGlmICgheEF4aXMgfHwgIXlBeGlzKSByZXR1cm4gbnVsbDtcbiAgdmFyIHNjYWxlcyA9ICgwLCBfQ2FydGVzaWFuVXRpbHMuY3JlYXRlTGFiZWxlZFNjYWxlcykoe1xuICAgIHg6IHhBeGlzLnNjYWxlLFxuICAgIHk6IHlBeGlzLnNjYWxlXG4gIH0pO1xuICB2YXIgcDEgPSB7XG4gICAgeDogaGFzWDEgPyBzY2FsZXMueC5hcHBseSh4VmFsdWUxLCB7XG4gICAgICBwb3NpdGlvbjogJ3N0YXJ0J1xuICAgIH0pIDogc2NhbGVzLngucmFuZ2VNaW4sXG4gICAgeTogaGFzWTEgPyBzY2FsZXMueS5hcHBseSh5VmFsdWUxLCB7XG4gICAgICBwb3NpdGlvbjogJ3N0YXJ0J1xuICAgIH0pIDogc2NhbGVzLnkucmFuZ2VNaW5cbiAgfTtcbiAgdmFyIHAyID0ge1xuICAgIHg6IGhhc1gyID8gc2NhbGVzLnguYXBwbHkoeFZhbHVlMiwge1xuICAgICAgcG9zaXRpb246ICdlbmQnXG4gICAgfSkgOiBzY2FsZXMueC5yYW5nZU1heCxcbiAgICB5OiBoYXNZMiA/IHNjYWxlcy55LmFwcGx5KHlWYWx1ZTIsIHtcbiAgICAgIHBvc2l0aW9uOiAnZW5kJ1xuICAgIH0pIDogc2NhbGVzLnkucmFuZ2VNYXhcbiAgfTtcbiAgaWYgKCgwLCBfSWZPdmVyZmxvd01hdGNoZXMuaWZPdmVyZmxvd01hdGNoZXMpKHByb3BzLCAnZGlzY2FyZCcpICYmICghc2NhbGVzLmlzSW5SYW5nZShwMSkgfHwgIXNjYWxlcy5pc0luUmFuZ2UocDIpKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAoMCwgX0NhcnRlc2lhblV0aWxzLnJlY3RXaXRoUG9pbnRzKShwMSwgcDIpO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb24gLS0gcmVxdWlyZXMgc3RhdGljIGRlZmF1bHRQcm9wc1xudmFyIFJlZmVyZW5jZUFyZWEgPSBleHBvcnRzLlJlZmVyZW5jZUFyZWEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgZnVuY3Rpb24gUmVmZXJlbmNlQXJlYSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVmZXJlbmNlQXJlYSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgUmVmZXJlbmNlQXJlYSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoUmVmZXJlbmNlQXJlYSwgX1JlYWN0JENvbXBvbmVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUmVmZXJlbmNlQXJlYSwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHgxID0gX3RoaXMkcHJvcHMueDEsXG4gICAgICAgIHgyID0gX3RoaXMkcHJvcHMueDIsXG4gICAgICAgIHkxID0gX3RoaXMkcHJvcHMueTEsXG4gICAgICAgIHkyID0gX3RoaXMkcHJvcHMueTIsXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgYWx3YXlzU2hvdyA9IF90aGlzJHByb3BzLmFsd2F5c1Nob3csXG4gICAgICAgIGNsaXBQYXRoSWQgPSBfdGhpcyRwcm9wcy5jbGlwUGF0aElkO1xuICAgICAgKDAsIF9Mb2dVdGlscy53YXJuKShhbHdheXNTaG93ID09PSB1bmRlZmluZWQsICdUaGUgYWx3YXlzU2hvdyBwcm9wIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgaWZPdmVyZmxvdz1cImV4dGVuZERvbWFpblwiIGluc3RlYWQuJyk7XG4gICAgICB2YXIgaGFzWDEgPSAoMCwgX0RhdGFVdGlscy5pc051bU9yU3RyKSh4MSk7XG4gICAgICB2YXIgaGFzWDIgPSAoMCwgX0RhdGFVdGlscy5pc051bU9yU3RyKSh4Mik7XG4gICAgICB2YXIgaGFzWTEgPSAoMCwgX0RhdGFVdGlscy5pc051bU9yU3RyKSh5MSk7XG4gICAgICB2YXIgaGFzWTIgPSAoMCwgX0RhdGFVdGlscy5pc051bU9yU3RyKSh5Mik7XG4gICAgICB2YXIgc2hhcGUgPSB0aGlzLnByb3BzLnNoYXBlO1xuICAgICAgaWYgKCFoYXNYMSAmJiAhaGFzWDIgJiYgIWhhc1kxICYmICFoYXNZMiAmJiAhc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgcmVjdCA9IGdldFJlY3QoaGFzWDEsIGhhc1gyLCBoYXNZMSwgaGFzWTIsIHRoaXMucHJvcHMpO1xuICAgICAgaWYgKCFyZWN0ICYmICFzaGFwZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBjbGlwUGF0aCA9ICgwLCBfSWZPdmVyZmxvd01hdGNoZXMuaWZPdmVyZmxvd01hdGNoZXMpKHRoaXMucHJvcHMsICdoaWRkZW4nKSA/IFwidXJsKCNcIi5jb25jYXQoY2xpcFBhdGhJZCwgXCIpXCIpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XG4gICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXJlZmVyZW5jZS1hcmVhJywgY2xhc3NOYW1lKVxuICAgICAgfSwgUmVmZXJlbmNlQXJlYS5yZW5kZXJSZWN0KHNoYXBlLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBjbGlwUGF0aDogY2xpcFBhdGhcbiAgICAgIH0sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykodGhpcy5wcm9wcywgdHJ1ZSkpLCByZWN0KSksIF9MYWJlbC5MYWJlbC5yZW5kZXJDYWxsQnlQYXJlbnQodGhpcy5wcm9wcywgcmVjdCkpO1xuICAgIH1cbiAgfV0pO1xufShfcmVhY3RbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5fZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlQXJlYSwgXCJkaXNwbGF5TmFtZVwiLCAnUmVmZXJlbmNlQXJlYScpO1xuX2RlZmluZVByb3BlcnR5KFJlZmVyZW5jZUFyZWEsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgaXNGcm9udDogZmFsc2UsXG4gIGlmT3ZlcmZsb3c6ICdkaXNjYXJkJyxcbiAgeEF4aXNJZDogMCxcbiAgeUF4aXNJZDogMCxcbiAgcjogMTAsXG4gIGZpbGw6ICcjY2NjJyxcbiAgZmlsbE9wYWNpdHk6IDAuNSxcbiAgc3Ryb2tlOiAnbm9uZScsXG4gIHN0cm9rZVdpZHRoOiAxXG59KTtcbl9kZWZpbmVQcm9wZXJ0eShSZWZlcmVuY2VBcmVhLCBcInJlbmRlclJlY3RcIiwgZnVuY3Rpb24gKG9wdGlvbiwgcHJvcHMpIHtcbiAgdmFyIHJlY3Q7XG4gIGlmICggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQob3B0aW9uKSkge1xuICAgIHJlY3QgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQob3B0aW9uLCBwcm9wcyk7XG4gIH0gZWxzZSBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob3B0aW9uKSkge1xuICAgIHJlY3QgPSBvcHRpb24ocHJvcHMpO1xuICB9IGVsc2Uge1xuICAgIHJlY3QgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9SZWN0YW5nbGUuUmVjdGFuZ2xlLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1yZWZlcmVuY2UtYXJlYS1yZWN0XCJcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIHJlY3Q7XG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSZWZlcmVuY2VBcmVhIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfaXNGdW5jdGlvbiIsIl9jbHN4IiwiX0xheWVyIiwiX0xhYmVsIiwiX0NhcnRlc2lhblV0aWxzIiwiX0lmT3ZlcmZsb3dNYXRjaGVzIiwiX0RhdGFVdGlscyIsIl9Mb2dVdGlscyIsIl9SZWN0YW5nbGUiLCJfUmVhY3RVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJvd25LZXlzIiwiZSIsInIiLCJ0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJnZXRSZWN0IiwiaGFzWDEiLCJoYXNYMiIsImhhc1kxIiwiaGFzWTIiLCJ4VmFsdWUxIiwieDEiLCJ4VmFsdWUyIiwieDIiLCJ5VmFsdWUxIiwieTEiLCJ5VmFsdWUyIiwieTIiLCJ4QXhpcyIsInlBeGlzIiwic2NhbGVzIiwiY3JlYXRlTGFiZWxlZFNjYWxlcyIsIngiLCJzY2FsZSIsInkiLCJwMSIsInBvc2l0aW9uIiwicmFuZ2VNaW4iLCJwMiIsInJhbmdlTWF4IiwiaWZPdmVyZmxvd01hdGNoZXMiLCJpc0luUmFuZ2UiLCJyZWN0V2l0aFBvaW50cyIsIl9SZWFjdCRDb21wb25lbnQiLCJyZW5kZXIiLCJfdGhpcyRwcm9wcyIsImNsYXNzTmFtZSIsImFsd2F5c1Nob3ciLCJjbGlwUGF0aElkIiwid2FybiIsInVuZGVmaW5lZCIsImlzTnVtT3JTdHIiLCJzaGFwZSIsInJlY3QiLCJjbGlwUGF0aCIsImNvbmNhdCIsImNyZWF0ZUVsZW1lbnQiLCJMYXllciIsInJlbmRlclJlY3QiLCJmaWx0ZXJQcm9wcyIsIkxhYmVsIiwicmVuZGVyQ2FsbEJ5UGFyZW50IiwiQ29tcG9uZW50IiwiaXNGcm9udCIsImlmT3ZlcmZsb3ciLCJ4QXhpc0lkIiwieUF4aXNJZCIsImZpbGwiLCJmaWxsT3BhY2l0eSIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwib3B0aW9uIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJSZWN0YW5nbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/ReferenceArea.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/cartesian/ReferenceDot.js":
/*!*************************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/ReferenceDot.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ReferenceDot = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _Dot = __webpack_require__(/*! ../shape/Dot */ \"./node_modules/recharts/lib/shape/Dot.js\");\nvar _Label = __webpack_require__(/*! ../component/Label */ \"./node_modules/recharts/lib/component/Label.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _IfOverflowMatches = __webpack_require__(/*! ../util/IfOverflowMatches */ \"./node_modules/recharts/lib/util/IfOverflowMatches.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"./node_modules/recharts/lib/util/CartesianUtils.js\");\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"./node_modules/recharts/lib/util/LogUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Reference Dot\n */ \nvar getCoordinate = function getCoordinate(props) {\n    var x = props.x, y = props.y, xAxis = props.xAxis, yAxis = props.yAxis;\n    var scales = (0, _CartesianUtils.createLabeledScales)({\n        x: xAxis.scale,\n        y: yAxis.scale\n    });\n    var result = scales.apply({\n        x: x,\n        y: y\n    }, {\n        bandAware: true\n    });\n    if ((0, _IfOverflowMatches.ifOverflowMatches)(props, \"discard\") && !scales.isInRange(result)) {\n        return null;\n    }\n    return result;\n};\n// eslint-disable-next-line react/prefer-stateless-function -- requires static defaultProps\nvar ReferenceDot = exports.ReferenceDot = /*#__PURE__*/ function(_React$Component) {\n    function ReferenceDot() {\n        _classCallCheck(this, ReferenceDot);\n        return _callSuper(this, ReferenceDot, arguments);\n    }\n    _inherits(ReferenceDot, _React$Component);\n    return _createClass(ReferenceDot, [\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props = this.props, x = _this$props.x, y = _this$props.y, r = _this$props.r, alwaysShow = _this$props.alwaysShow, clipPathId = _this$props.clipPathId;\n                var isX = (0, _DataUtils.isNumOrStr)(x);\n                var isY = (0, _DataUtils.isNumOrStr)(y);\n                (0, _LogUtils.warn)(alwaysShow === undefined, 'The alwaysShow prop is deprecated. Please use ifOverflow=\"extendDomain\" instead.');\n                if (!isX || !isY) {\n                    return null;\n                }\n                var coordinate = getCoordinate(this.props);\n                if (!coordinate) {\n                    return null;\n                }\n                var cx = coordinate.x, cy = coordinate.y;\n                var _this$props2 = this.props, shape = _this$props2.shape, className = _this$props2.className;\n                var clipPath = (0, _IfOverflowMatches.ifOverflowMatches)(this.props, \"hidden\") ? \"url(#\".concat(clipPathId, \")\") : undefined;\n                var dotProps = _objectSpread(_objectSpread({\n                    clipPath: clipPath\n                }, (0, _ReactUtils.filterProps)(this.props, true)), {}, {\n                    cx: cx,\n                    cy: cy\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: (0, _clsx[\"default\"])(\"recharts-reference-dot\", className)\n                }, ReferenceDot.renderDot(shape, dotProps), _Label.Label.renderCallByParent(this.props, {\n                    x: cx - r,\n                    y: cy - r,\n                    width: 2 * r,\n                    height: 2 * r\n                }));\n            }\n        }\n    ]);\n}(_react[\"default\"].Component);\n_defineProperty(ReferenceDot, \"displayName\", \"ReferenceDot\");\n_defineProperty(ReferenceDot, \"defaultProps\", {\n    isFront: false,\n    ifOverflow: \"discard\",\n    xAxisId: 0,\n    yAxisId: 0,\n    r: 10,\n    fill: \"#fff\",\n    stroke: \"#ccc\",\n    fillOpacity: 1,\n    strokeWidth: 1\n});\n_defineProperty(ReferenceDot, \"renderDot\", function(option, props) {\n    var dot;\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n        dot = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n    } else if ((0, _isFunction[\"default\"])(option)) {\n        dot = option(props);\n    } else {\n        dot = /*#__PURE__*/ _react[\"default\"].createElement(_Dot.Dot, _extends({}, props, {\n            cx: props.cx,\n            cy: props.cy,\n            className: \"recharts-reference-dot-dot\"\n        }));\n    }\n    return dot;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9SZWZlcmVuY2VEb3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELG9CQUFvQixHQUFHLEtBQUs7QUFDNUIsSUFBSUcsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxjQUFjRix1QkFBdUJDLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJRSxRQUFRSCx1QkFBdUJDLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlHLFNBQVNILG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJSSxPQUFPSixtQkFBT0EsQ0FBQyw4REFBYztBQUNqQyxJQUFJSyxTQUFTTCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDekMsSUFBSU0sYUFBYU4sbUJBQU9BLENBQUMsd0VBQW1CO0FBQzVDLElBQUlPLHFCQUFxQlAsbUJBQU9BLENBQUMsd0ZBQTJCO0FBQzVELElBQUlRLGtCQUFrQlIsbUJBQU9BLENBQUMsa0ZBQXdCO0FBQ3RELElBQUlTLFlBQVlULG1CQUFPQSxDQUFDLHNFQUFrQjtBQUMxQyxJQUFJVSxjQUFjVixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsU0FBU0QsdUJBQXVCWSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFO0lBQWFBLFdBQVdwQixPQUFPcUIsTUFBTSxHQUFHckIsT0FBT3FCLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQUUsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQUUsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUFFLElBQUkzQixPQUFPNkIsU0FBUyxDQUFD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QUl2RCxNQUFNdUQsRUFBRTtZQUNaQyxJQUFJeEQsTUFBTXdELEVBQUU7WUFDWkcsV0FBVztRQUNiO0lBQ0Y7SUFDQSxPQUFPc0I7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL1JlZmVyZW5jZURvdC5qcz8yOTRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5SZWZlcmVuY2VEb3QgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX0xheWVyID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9MYXllclwiKTtcbnZhciBfRG90ID0gcmVxdWlyZShcIi4uL3NoYXBlL0RvdFwiKTtcbnZhciBfTGFiZWwgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L0xhYmVsXCIpO1xudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XG52YXIgX0lmT3ZlcmZsb3dNYXRjaGVzID0gcmVxdWlyZShcIi4uL3V0aWwvSWZPdmVyZmxvd01hdGNoZXNcIik7XG52YXIgX0NhcnRlc2lhblV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQ2FydGVzaWFuVXRpbHNcIik7XG52YXIgX0xvZ1V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvTG9nVXRpbHNcIik7XG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKipcbiAqIEBmaWxlT3ZlcnZpZXcgUmVmZXJlbmNlIERvdFxuICovXG52YXIgZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUocHJvcHMpIHtcbiAgdmFyIHggPSBwcm9wcy54LFxuICAgIHkgPSBwcm9wcy55LFxuICAgIHhBeGlzID0gcHJvcHMueEF4aXMsXG4gICAgeUF4aXMgPSBwcm9wcy55QXhpcztcbiAgdmFyIHNjYWxlcyA9ICgwLCBfQ2FydGVzaWFuVXRpbHMuY3JlYXRlTGFiZWxlZFNjYWxlcykoe1xuICAgIHg6IHhBeGlzLnNjYWxlLFxuICAgIHk6IHlBeGlzLnNjYWxlXG4gIH0pO1xuICB2YXIgcmVzdWx0ID0gc2NhbGVzLmFwcGx5KHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSwge1xuICAgIGJhbmRBd2FyZTogdHJ1ZVxuICB9KTtcbiAgaWYgKCgwLCBfSWZPdmVyZmxvd01hdGNoZXMuaWZPdmVyZmxvd01hdGNoZXMpKHByb3BzLCAnZGlzY2FyZCcpICYmICFzY2FsZXMuaXNJblJhbmdlKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb24gLS0gcmVxdWlyZXMgc3RhdGljIGRlZmF1bHRQcm9wc1xudmFyIFJlZmVyZW5jZURvdCA9IGV4cG9ydHMuUmVmZXJlbmNlRG90ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIFJlZmVyZW5jZURvdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVmZXJlbmNlRG90KTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBSZWZlcmVuY2VEb3QsIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2luaGVyaXRzKFJlZmVyZW5jZURvdCwgX1JlYWN0JENvbXBvbmVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUmVmZXJlbmNlRG90LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgeCA9IF90aGlzJHByb3BzLngsXG4gICAgICAgIHkgPSBfdGhpcyRwcm9wcy55LFxuICAgICAgICByID0gX3RoaXMkcHJvcHMucixcbiAgICAgICAgYWx3YXlzU2hvdyA9IF90aGlzJHByb3BzLmFsd2F5c1Nob3csXG4gICAgICAgIGNsaXBQYXRoSWQgPSBfdGhpcyRwcm9wcy5jbGlwUGF0aElkO1xuICAgICAgdmFyIGlzWCA9ICgwLCBfRGF0YVV0aWxzLmlzTnVtT3JTdHIpKHgpO1xuICAgICAgdmFyIGlzWSA9ICgwLCBfRGF0YVV0aWxzLmlzTnVtT3JTdHIpKHkpO1xuICAgICAgKDAsIF9Mb2dVdGlscy53YXJuKShhbHdheXNTaG93ID09PSB1bmRlZmluZWQsICdUaGUgYWx3YXlzU2hvdyBwcm9wIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgaWZPdmVyZmxvdz1cImV4dGVuZERvbWFpblwiIGluc3RlYWQuJyk7XG4gICAgICBpZiAoIWlzWCB8fCAhaXNZKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGNvb3JkaW5hdGUgPSBnZXRDb29yZGluYXRlKHRoaXMucHJvcHMpO1xuICAgICAgaWYgKCFjb29yZGluYXRlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGN4ID0gY29vcmRpbmF0ZS54LFxuICAgICAgICBjeSA9IGNvb3JkaW5hdGUueTtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBzaGFwZSA9IF90aGlzJHByb3BzMi5zaGFwZSxcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMyLmNsYXNzTmFtZTtcbiAgICAgIHZhciBjbGlwUGF0aCA9ICgwLCBfSWZPdmVyZmxvd01hdGNoZXMuaWZPdmVyZmxvd01hdGNoZXMpKHRoaXMucHJvcHMsICdoaWRkZW4nKSA/IFwidXJsKCNcIi5jb25jYXQoY2xpcFBhdGhJZCwgXCIpXCIpIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGRvdFByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgY2xpcFBhdGg6IGNsaXBQYXRoXG4gICAgICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIHRydWUpKSwge30sIHtcbiAgICAgICAgY3g6IGN4LFxuICAgICAgICBjeTogY3lcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XG4gICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXJlZmVyZW5jZS1kb3QnLCBjbGFzc05hbWUpXG4gICAgICB9LCBSZWZlcmVuY2VEb3QucmVuZGVyRG90KHNoYXBlLCBkb3RQcm9wcyksIF9MYWJlbC5MYWJlbC5yZW5kZXJDYWxsQnlQYXJlbnQodGhpcy5wcm9wcywge1xuICAgICAgICB4OiBjeCAtIHIsXG4gICAgICAgIHk6IGN5IC0gcixcbiAgICAgICAgd2lkdGg6IDIgKiByLFxuICAgICAgICBoZWlnaHQ6IDIgKiByXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG59KF9yZWFjdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcbl9kZWZpbmVQcm9wZXJ0eShSZWZlcmVuY2VEb3QsIFwiZGlzcGxheU5hbWVcIiwgJ1JlZmVyZW5jZURvdCcpO1xuX2RlZmluZVByb3BlcnR5KFJlZmVyZW5jZURvdCwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBpc0Zyb250OiBmYWxzZSxcbiAgaWZPdmVyZmxvdzogJ2Rpc2NhcmQnLFxuICB4QXhpc0lkOiAwLFxuICB5QXhpc0lkOiAwLFxuICByOiAxMCxcbiAgZmlsbDogJyNmZmYnLFxuICBzdHJva2U6ICcjY2NjJyxcbiAgZmlsbE9wYWNpdHk6IDEsXG4gIHN0cm9rZVdpZHRoOiAxXG59KTtcbl9kZWZpbmVQcm9wZXJ0eShSZWZlcmVuY2VEb3QsIFwicmVuZGVyRG90XCIsIGZ1bmN0aW9uIChvcHRpb24sIHByb3BzKSB7XG4gIHZhciBkb3Q7XG4gIGlmICggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQob3B0aW9uKSkge1xuICAgIGRvdCA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChvcHRpb24sIHByb3BzKTtcbiAgfSBlbHNlIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvcHRpb24pKSB7XG4gICAgZG90ID0gb3B0aW9uKHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICBkb3QgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9Eb3QuRG90LCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIGN4OiBwcm9wcy5jeCxcbiAgICAgIGN5OiBwcm9wcy5jeSxcbiAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1yZWZlcmVuY2UtZG90LWRvdFwiXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiBkb3Q7XG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSZWZlcmVuY2VEb3QiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9pc0Z1bmN0aW9uIiwiX2Nsc3giLCJfTGF5ZXIiLCJfRG90IiwiX0xhYmVsIiwiX0RhdGFVdGlscyIsIl9JZk92ZXJmbG93TWF0Y2hlcyIsIl9DYXJ0ZXNpYW5VdGlscyIsIl9Mb2dVdGlscyIsIl9SZWFjdFV0aWxzIiwib2JqIiwiX19lc01vZHVsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsIm93bktleXMiLCJlIiwiciIsInQiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsImdldENvb3JkaW5hdGUiLCJ4IiwieSIsInhBeGlzIiwieUF4aXMiLCJzY2FsZXMiLCJjcmVhdGVMYWJlbGVkU2NhbGVzIiwic2NhbGUiLCJyZXN1bHQiLCJiYW5kQXdhcmUiLCJpZk92ZXJmbG93TWF0Y2hlcyIsImlzSW5SYW5nZSIsIl9SZWFjdCRDb21wb25lbnQiLCJyZW5kZXIiLCJfdGhpcyRwcm9wcyIsImFsd2F5c1Nob3ciLCJjbGlwUGF0aElkIiwiaXNYIiwiaXNOdW1PclN0ciIsImlzWSIsIndhcm4iLCJ1bmRlZmluZWQiLCJjb29yZGluYXRlIiwiY3giLCJjeSIsIl90aGlzJHByb3BzMiIsInNoYXBlIiwiY2xhc3NOYW1lIiwiY2xpcFBhdGgiLCJjb25jYXQiLCJkb3RQcm9wcyIsImZpbHRlclByb3BzIiwiY3JlYXRlRWxlbWVudCIsIkxheWVyIiwicmVuZGVyRG90IiwiTGFiZWwiLCJyZW5kZXJDYWxsQnlQYXJlbnQiLCJ3aWR0aCIsImhlaWdodCIsIkNvbXBvbmVudCIsImlzRnJvbnQiLCJpZk92ZXJmbG93IiwieEF4aXNJZCIsInlBeGlzSWQiLCJmaWxsIiwic3Ryb2tlIiwiZmlsbE9wYWNpdHkiLCJzdHJva2VXaWR0aCIsIm9wdGlvbiIsImRvdCIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiRG90Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/ReferenceDot.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/cartesian/ReferenceLine.js":
/*!**************************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/ReferenceLine.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getEndPoints = exports.ReferenceLine = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _some = _interopRequireDefault(__webpack_require__(/*! lodash/some */ \"lodash/some\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _Label = __webpack_require__(/*! ../component/Label */ \"./node_modules/recharts/lib/component/Label.js\");\nvar _IfOverflowMatches = __webpack_require__(/*! ../util/IfOverflowMatches */ \"./node_modules/recharts/lib/util/IfOverflowMatches.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"./node_modules/recharts/lib/util/CartesianUtils.js\");\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"./node_modules/recharts/lib/util/LogUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _chartLayoutContext = __webpack_require__(/*! ../context/chartLayoutContext */ \"./node_modules/recharts/lib/context/chartLayoutContext.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n} /**\n * @fileOverview Reference Line\n */ \n/**\n * This excludes `viewBox` prop from svg for two reasons:\n * 1. The components wants viewBox of object type, and svg wants string\n *    - so there's a conflict, and the component will throw if it gets string\n * 2. Internally the component calls `filterProps` which filters the viewBox away anyway\n */ var renderLine = function renderLine(option, props) {\n    var line;\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n        line = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n    } else if ((0, _isFunction[\"default\"])(option)) {\n        line = option(props);\n    } else {\n        line = /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({}, props, {\n            className: \"recharts-reference-line-line\"\n        }));\n    }\n    return line;\n};\n// TODO: ScaleHelper\nvar getEndPoints = exports.getEndPoints = function getEndPoints(scales, isFixedX, isFixedY, isSegment, viewBox, position, xAxisOrientation, yAxisOrientation, props) {\n    var x = viewBox.x, y = viewBox.y, width = viewBox.width, height = viewBox.height;\n    if (isFixedY) {\n        var yCoord = props.y;\n        var coord = scales.y.apply(yCoord, {\n            position: position\n        });\n        if ((0, _IfOverflowMatches.ifOverflowMatches)(props, \"discard\") && !scales.y.isInRange(coord)) {\n            return null;\n        }\n        var points = [\n            {\n                x: x + width,\n                y: coord\n            },\n            {\n                x: x,\n                y: coord\n            }\n        ];\n        return yAxisOrientation === \"left\" ? points.reverse() : points;\n    }\n    if (isFixedX) {\n        var xCoord = props.x;\n        var _coord = scales.x.apply(xCoord, {\n            position: position\n        });\n        if ((0, _IfOverflowMatches.ifOverflowMatches)(props, \"discard\") && !scales.x.isInRange(_coord)) {\n            return null;\n        }\n        var _points = [\n            {\n                x: _coord,\n                y: y + height\n            },\n            {\n                x: _coord,\n                y: y\n            }\n        ];\n        return xAxisOrientation === \"top\" ? _points.reverse() : _points;\n    }\n    if (isSegment) {\n        var segment = props.segment;\n        var _points2 = segment.map(function(p) {\n            return scales.apply(p, {\n                position: position\n            });\n        });\n        if ((0, _IfOverflowMatches.ifOverflowMatches)(props, \"discard\") && (0, _some[\"default\"])(_points2, function(p) {\n            return !scales.isInRange(p);\n        })) {\n            return null;\n        }\n        return _points2;\n    }\n    return null;\n};\nfunction ReferenceLineImpl(props) {\n    var fixedX = props.x, fixedY = props.y, segment = props.segment, xAxisId = props.xAxisId, yAxisId = props.yAxisId, shape = props.shape, className = props.className, alwaysShow = props.alwaysShow;\n    var clipPathId = (0, _chartLayoutContext.useClipPathId)();\n    var xAxis = (0, _chartLayoutContext.useXAxisOrThrow)(xAxisId);\n    var yAxis = (0, _chartLayoutContext.useYAxisOrThrow)(yAxisId);\n    var viewBox = (0, _chartLayoutContext.useViewBox)();\n    if (!clipPathId || !viewBox) {\n        return null;\n    }\n    (0, _LogUtils.warn)(alwaysShow === undefined, 'The alwaysShow prop is deprecated. Please use ifOverflow=\"extendDomain\" instead.');\n    var scales = (0, _CartesianUtils.createLabeledScales)({\n        x: xAxis.scale,\n        y: yAxis.scale\n    });\n    var isX = (0, _DataUtils.isNumOrStr)(fixedX);\n    var isY = (0, _DataUtils.isNumOrStr)(fixedY);\n    var isSegment = segment && segment.length === 2;\n    var endPoints = getEndPoints(scales, isX, isY, isSegment, viewBox, props.position, xAxis.orientation, yAxis.orientation, props);\n    if (!endPoints) {\n        return null;\n    }\n    var _endPoints = _slicedToArray(endPoints, 2), _endPoints$ = _endPoints[0], x1 = _endPoints$.x, y1 = _endPoints$.y, _endPoints$2 = _endPoints[1], x2 = _endPoints$2.x, y2 = _endPoints$2.y;\n    var clipPath = (0, _IfOverflowMatches.ifOverflowMatches)(props, \"hidden\") ? \"url(#\".concat(clipPathId, \")\") : undefined;\n    var lineProps = _objectSpread(_objectSpread({\n        clipPath: clipPath\n    }, (0, _ReactUtils.filterProps)(props, true)), {}, {\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2\n    });\n    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n        className: (0, _clsx[\"default\"])(\"recharts-reference-line\", className)\n    }, renderLine(shape, lineProps), _Label.Label.renderCallByParent(props, (0, _CartesianUtils.rectWithCoords)({\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2\n    })));\n}\n// eslint-disable-next-line react/prefer-stateless-function -- requires static defaultProps\nvar ReferenceLine = exports.ReferenceLine = /*#__PURE__*/ function(_React$Component) {\n    function ReferenceLine() {\n        _classCallCheck(this, ReferenceLine);\n        return _callSuper(this, ReferenceLine, arguments);\n    }\n    _inherits(ReferenceLine, _React$Component);\n    return _createClass(ReferenceLine, [\n        {\n            key: \"render\",\n            value: function render() {\n                return /*#__PURE__*/ _react[\"default\"].createElement(ReferenceLineImpl, this.props);\n            }\n        }\n    ]);\n}(_react[\"default\"].Component);\n_defineProperty(ReferenceLine, \"displayName\", \"ReferenceLine\");\n_defineProperty(ReferenceLine, \"defaultProps\", {\n    isFront: false,\n    ifOverflow: \"discard\",\n    xAxisId: 0,\n    yAxisId: 0,\n    fill: \"none\",\n    stroke: \"#ccc\",\n    fillOpacity: 1,\n    strokeWidth: 1,\n    position: \"middle\"\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9SZWZlcmVuY2VMaW5lLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdUSyw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsb0JBQW9CLEdBQUdBLHFCQUFxQixHQUFHLEtBQUs7QUFDcEQsSUFBSUksU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxjQUFjRix1QkFBdUJDLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJRSxRQUFRSCx1QkFBdUJDLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3hELElBQUlHLFFBQVFKLHVCQUF1QkMsbUJBQU9BLENBQUMsa0JBQU07QUFDakQsSUFBSUksU0FBU0osbUJBQU9BLENBQUMsMEVBQW9CO0FBQ3pDLElBQUlLLFNBQVNMLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJTSxxQkFBcUJOLG1CQUFPQSxDQUFDLHdGQUEyQjtBQUM1RCxJQUFJTyxhQUFhUCxtQkFBT0EsQ0FBQyx3RUFBbUI7QUFDNUMsSUFBSVEsa0JBQWtCUixtQkFBT0EsQ0FBQyxrRkFBd0I7QUFDdEQsSUFBSVMsWUFBWVQsbUJBQU9BLENBQUMsc0VBQWtCO0FBQzFDLElBQUlVLGNBQWNWLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJVyxzQkFBc0JYLG1CQUFPQSxDQUFDLGdHQUErQjtBQUNq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LElBQUlBO1FBQ0pDLElBQUlBO0lBQ047QUFDRjtBQUVBLDJGQUEyRjtBQUMzRixJQUFJckssZ0JBQWdCSCxxQkFBcUIsR0FBRyxXQUFXLEdBQUUsU0FBVWlMLGdCQUFnQjtJQUNqRixTQUFTOUs7UUFDUGlCLGdCQUFnQixJQUFJLEVBQUVqQjtRQUN0QixPQUFPbUMsV0FBVyxJQUFJLEVBQUVuQyxlQUFlb0U7SUFDekM7SUFDQWQsVUFBVXRELGVBQWU4SztJQUN6QixPQUFPOUksYUFBYWhDLGVBQWU7UUFBQztZQUNsQytCLEtBQUs7WUFDTGpDLE9BQU8sU0FBU2lMO2dCQUNkLE9BQU8sV0FBVyxHQUFFOUssTUFBTSxDQUFDLFVBQVUsQ0FBQzZHLGFBQWEsQ0FBQzBCLG1CQUFtQixJQUFJLENBQUNqSCxLQUFLO1lBQ25GO1FBQ0Y7S0FBRTtBQUNKLEVBQUV0QixNQUFNLENBQUMsVUFBVSxDQUFDK0ssU0FBUztBQUM3QjFHLGdCQUFnQnRFLGVBQWUsZUFBZTtBQUM5Q3NFLGdCQUFnQnRFLGVBQWUsZ0JBQWdCO0lBQzdDaUwsU0FBUztJQUNUQyxZQUFZO0lBQ1p2QyxTQUFTO0lBQ1RDLFNBQVM7SUFDVHVDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxhQUFhO0lBQ2JDLGFBQWE7SUFDYmpFLFVBQVU7QUFDWiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2FydGVzaWFuL1JlZmVyZW5jZUxpbmUuanM/YzBjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0RW5kUG9pbnRzID0gZXhwb3J0cy5SZWZlcmVuY2VMaW5lID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcbnZhciBfc29tZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9zb21lXCIpKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XG52YXIgX0xhYmVsID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbFwiKTtcbnZhciBfSWZPdmVyZmxvd01hdGNoZXMgPSByZXF1aXJlKFwiLi4vdXRpbC9JZk92ZXJmbG93TWF0Y2hlc1wiKTtcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xudmFyIF9DYXJ0ZXNpYW5VdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NhcnRlc2lhblV0aWxzXCIpO1xudmFyIF9Mb2dVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0xvZ1V0aWxzXCIpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcbnZhciBfY2hhcnRMYXlvdXRDb250ZXh0ID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY2hhcnRMYXlvdXRDb250ZXh0XCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IC8qKlxuICogQGZpbGVPdmVydmlldyBSZWZlcmVuY2UgTGluZVxuICovXG4vKipcbiAqIFRoaXMgZXhjbHVkZXMgYHZpZXdCb3hgIHByb3AgZnJvbSBzdmcgZm9yIHR3byByZWFzb25zOlxuICogMS4gVGhlIGNvbXBvbmVudHMgd2FudHMgdmlld0JveCBvZiBvYmplY3QgdHlwZSwgYW5kIHN2ZyB3YW50cyBzdHJpbmdcbiAqICAgIC0gc28gdGhlcmUncyBhIGNvbmZsaWN0LCBhbmQgdGhlIGNvbXBvbmVudCB3aWxsIHRocm93IGlmIGl0IGdldHMgc3RyaW5nXG4gKiAyLiBJbnRlcm5hbGx5IHRoZSBjb21wb25lbnQgY2FsbHMgYGZpbHRlclByb3BzYCB3aGljaCBmaWx0ZXJzIHRoZSB2aWV3Qm94IGF3YXkgYW55d2F5XG4gKi9cblxudmFyIHJlbmRlckxpbmUgPSBmdW5jdGlvbiByZW5kZXJMaW5lKG9wdGlvbiwgcHJvcHMpIHtcbiAgdmFyIGxpbmU7XG4gIGlmICggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQob3B0aW9uKSkge1xuICAgIGxpbmUgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQob3B0aW9uLCBwcm9wcyk7XG4gIH0gZWxzZSBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob3B0aW9uKSkge1xuICAgIGxpbmUgPSBvcHRpb24ocHJvcHMpO1xuICB9IGVsc2Uge1xuICAgIGxpbmUgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwibGluZVwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1yZWZlcmVuY2UtbGluZS1saW5lXCJcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIGxpbmU7XG59O1xuLy8gVE9ETzogU2NhbGVIZWxwZXJcbnZhciBnZXRFbmRQb2ludHMgPSBleHBvcnRzLmdldEVuZFBvaW50cyA9IGZ1bmN0aW9uIGdldEVuZFBvaW50cyhzY2FsZXMsIGlzRml4ZWRYLCBpc0ZpeGVkWSwgaXNTZWdtZW50LCB2aWV3Qm94LCBwb3NpdGlvbiwgeEF4aXNPcmllbnRhdGlvbiwgeUF4aXNPcmllbnRhdGlvbiwgcHJvcHMpIHtcbiAgdmFyIHggPSB2aWV3Qm94LngsXG4gICAgeSA9IHZpZXdCb3gueSxcbiAgICB3aWR0aCA9IHZpZXdCb3gud2lkdGgsXG4gICAgaGVpZ2h0ID0gdmlld0JveC5oZWlnaHQ7XG4gIGlmIChpc0ZpeGVkWSkge1xuICAgIHZhciB5Q29vcmQgPSBwcm9wcy55O1xuICAgIHZhciBjb29yZCA9IHNjYWxlcy55LmFwcGx5KHlDb29yZCwge1xuICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgfSk7XG4gICAgaWYgKCgwLCBfSWZPdmVyZmxvd01hdGNoZXMuaWZPdmVyZmxvd01hdGNoZXMpKHByb3BzLCAnZGlzY2FyZCcpICYmICFzY2FsZXMueS5pc0luUmFuZ2UoY29vcmQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICB4OiB4ICsgd2lkdGgsXG4gICAgICB5OiBjb29yZFxuICAgIH0sIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiBjb29yZFxuICAgIH1dO1xuICAgIHJldHVybiB5QXhpc09yaWVudGF0aW9uID09PSAnbGVmdCcgPyBwb2ludHMucmV2ZXJzZSgpIDogcG9pbnRzO1xuICB9XG4gIGlmIChpc0ZpeGVkWCkge1xuICAgIHZhciB4Q29vcmQgPSBwcm9wcy54O1xuICAgIHZhciBfY29vcmQgPSBzY2FsZXMueC5hcHBseSh4Q29vcmQsIHtcbiAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgIH0pO1xuICAgIGlmICgoMCwgX0lmT3ZlcmZsb3dNYXRjaGVzLmlmT3ZlcmZsb3dNYXRjaGVzKShwcm9wcywgJ2Rpc2NhcmQnKSAmJiAhc2NhbGVzLnguaXNJblJhbmdlKF9jb29yZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgX3BvaW50cyA9IFt7XG4gICAgICB4OiBfY29vcmQsXG4gICAgICB5OiB5ICsgaGVpZ2h0XG4gICAgfSwge1xuICAgICAgeDogX2Nvb3JkLFxuICAgICAgeTogeVxuICAgIH1dO1xuICAgIHJldHVybiB4QXhpc09yaWVudGF0aW9uID09PSAndG9wJyA/IF9wb2ludHMucmV2ZXJzZSgpIDogX3BvaW50cztcbiAgfVxuICBpZiAoaXNTZWdtZW50KSB7XG4gICAgdmFyIHNlZ21lbnQgPSBwcm9wcy5zZWdtZW50O1xuICAgIHZhciBfcG9pbnRzMiA9IHNlZ21lbnQubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gc2NhbGVzLmFwcGx5KHAsIHtcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoKDAsIF9JZk92ZXJmbG93TWF0Y2hlcy5pZk92ZXJmbG93TWF0Y2hlcykocHJvcHMsICdkaXNjYXJkJykgJiYgKDAsIF9zb21lW1wiZGVmYXVsdFwiXSkoX3BvaW50czIsIGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gIXNjYWxlcy5pc0luUmFuZ2UocCk7XG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gX3BvaW50czI7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuZnVuY3Rpb24gUmVmZXJlbmNlTGluZUltcGwocHJvcHMpIHtcbiAgdmFyIGZpeGVkWCA9IHByb3BzLngsXG4gICAgZml4ZWRZID0gcHJvcHMueSxcbiAgICBzZWdtZW50ID0gcHJvcHMuc2VnbWVudCxcbiAgICB4QXhpc0lkID0gcHJvcHMueEF4aXNJZCxcbiAgICB5QXhpc0lkID0gcHJvcHMueUF4aXNJZCxcbiAgICBzaGFwZSA9IHByb3BzLnNoYXBlLFxuICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICBhbHdheXNTaG93ID0gcHJvcHMuYWx3YXlzU2hvdztcbiAgdmFyIGNsaXBQYXRoSWQgPSAoMCwgX2NoYXJ0TGF5b3V0Q29udGV4dC51c2VDbGlwUGF0aElkKSgpO1xuICB2YXIgeEF4aXMgPSAoMCwgX2NoYXJ0TGF5b3V0Q29udGV4dC51c2VYQXhpc09yVGhyb3cpKHhBeGlzSWQpO1xuICB2YXIgeUF4aXMgPSAoMCwgX2NoYXJ0TGF5b3V0Q29udGV4dC51c2VZQXhpc09yVGhyb3cpKHlBeGlzSWQpO1xuICB2YXIgdmlld0JveCA9ICgwLCBfY2hhcnRMYXlvdXRDb250ZXh0LnVzZVZpZXdCb3gpKCk7XG4gIGlmICghY2xpcFBhdGhJZCB8fCAhdmlld0JveCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gICgwLCBfTG9nVXRpbHMud2FybikoYWx3YXlzU2hvdyA9PT0gdW5kZWZpbmVkLCAnVGhlIGFsd2F5c1Nob3cgcHJvcCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGlmT3ZlcmZsb3c9XCJleHRlbmREb21haW5cIiBpbnN0ZWFkLicpO1xuICB2YXIgc2NhbGVzID0gKDAsIF9DYXJ0ZXNpYW5VdGlscy5jcmVhdGVMYWJlbGVkU2NhbGVzKSh7XG4gICAgeDogeEF4aXMuc2NhbGUsXG4gICAgeTogeUF4aXMuc2NhbGVcbiAgfSk7XG4gIHZhciBpc1ggPSAoMCwgX0RhdGFVdGlscy5pc051bU9yU3RyKShmaXhlZFgpO1xuICB2YXIgaXNZID0gKDAsIF9EYXRhVXRpbHMuaXNOdW1PclN0cikoZml4ZWRZKTtcbiAgdmFyIGlzU2VnbWVudCA9IHNlZ21lbnQgJiYgc2VnbWVudC5sZW5ndGggPT09IDI7XG4gIHZhciBlbmRQb2ludHMgPSBnZXRFbmRQb2ludHMoc2NhbGVzLCBpc1gsIGlzWSwgaXNTZWdtZW50LCB2aWV3Qm94LCBwcm9wcy5wb3NpdGlvbiwgeEF4aXMub3JpZW50YXRpb24sIHlBeGlzLm9yaWVudGF0aW9uLCBwcm9wcyk7XG4gIGlmICghZW5kUG9pbnRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIF9lbmRQb2ludHMgPSBfc2xpY2VkVG9BcnJheShlbmRQb2ludHMsIDIpLFxuICAgIF9lbmRQb2ludHMkID0gX2VuZFBvaW50c1swXSxcbiAgICB4MSA9IF9lbmRQb2ludHMkLngsXG4gICAgeTEgPSBfZW5kUG9pbnRzJC55LFxuICAgIF9lbmRQb2ludHMkMiA9IF9lbmRQb2ludHNbMV0sXG4gICAgeDIgPSBfZW5kUG9pbnRzJDIueCxcbiAgICB5MiA9IF9lbmRQb2ludHMkMi55O1xuICB2YXIgY2xpcFBhdGggPSAoMCwgX0lmT3ZlcmZsb3dNYXRjaGVzLmlmT3ZlcmZsb3dNYXRjaGVzKShwcm9wcywgJ2hpZGRlbicpID8gXCJ1cmwoI1wiLmNvbmNhdChjbGlwUGF0aElkLCBcIilcIikgOiB1bmRlZmluZWQ7XG4gIHZhciBsaW5lUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgIGNsaXBQYXRoOiBjbGlwUGF0aFxuICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHByb3BzLCB0cnVlKSksIHt9LCB7XG4gICAgeDE6IHgxLFxuICAgIHkxOiB5MSxcbiAgICB4MjogeDIsXG4gICAgeTI6IHkyXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcbiAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1yZWZlcmVuY2UtbGluZScsIGNsYXNzTmFtZSlcbiAgfSwgcmVuZGVyTGluZShzaGFwZSwgbGluZVByb3BzKSwgX0xhYmVsLkxhYmVsLnJlbmRlckNhbGxCeVBhcmVudChwcm9wcywgKDAsIF9DYXJ0ZXNpYW5VdGlscy5yZWN0V2l0aENvb3Jkcykoe1xuICAgIHgxOiB4MSxcbiAgICB5MTogeTEsXG4gICAgeDI6IHgyLFxuICAgIHkyOiB5MlxuICB9KSkpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvcHJlZmVyLXN0YXRlbGVzcy1mdW5jdGlvbiAtLSByZXF1aXJlcyBzdGF0aWMgZGVmYXVsdFByb3BzXG52YXIgUmVmZXJlbmNlTGluZSA9IGV4cG9ydHMuUmVmZXJlbmNlTGluZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBmdW5jdGlvbiBSZWZlcmVuY2VMaW5lKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWZlcmVuY2VMaW5lKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBSZWZlcmVuY2VMaW5lLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhSZWZlcmVuY2VMaW5lLCBfUmVhY3QkQ29tcG9uZW50KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhSZWZlcmVuY2VMaW5lLCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoUmVmZXJlbmNlTGluZUltcGwsIHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfV0pO1xufShfcmVhY3RbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5fZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlTGluZSwgXCJkaXNwbGF5TmFtZVwiLCAnUmVmZXJlbmNlTGluZScpO1xuX2RlZmluZVByb3BlcnR5KFJlZmVyZW5jZUxpbmUsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgaXNGcm9udDogZmFsc2UsXG4gIGlmT3ZlcmZsb3c6ICdkaXNjYXJkJyxcbiAgeEF4aXNJZDogMCxcbiAgeUF4aXNJZDogMCxcbiAgZmlsbDogJ25vbmUnLFxuICBzdHJva2U6ICcjY2NjJyxcbiAgZmlsbE9wYWNpdHk6IDEsXG4gIHN0cm9rZVdpZHRoOiAxLFxuICBwb3NpdGlvbjogJ21pZGRsZSdcbn0pOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEVuZFBvaW50cyIsIlJlZmVyZW5jZUxpbmUiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9pc0Z1bmN0aW9uIiwiX3NvbWUiLCJfY2xzeCIsIl9MYXllciIsIl9MYWJlbCIsIl9JZk92ZXJmbG93TWF0Y2hlcyIsIl9EYXRhVXRpbHMiLCJfQ2FydGVzaWFuVXRpbHMiLCJfTG9nVXRpbHMiLCJfUmVhY3RVdGlscyIsIl9jaGFydExheW91dENvbnRleHQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsInQiLCJlIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImFwcGx5Iiwic2VsZiIsImNhbGwiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJiaW5kIiwiX19wcm90b19fIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIm93bktleXMiLCJyIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJfc2xpY2VkVG9BcnJheSIsImFyciIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJsZW4iLCJhcnIyIiwibCIsInUiLCJhIiwiZiIsIm5leHQiLCJkb25lIiwiaXNBcnJheSIsIl9leHRlbmRzIiwiYXNzaWduIiwic291cmNlIiwiaGFzT3duUHJvcGVydHkiLCJyZW5kZXJMaW5lIiwib3B0aW9uIiwibGluZSIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsInNjYWxlcyIsImlzRml4ZWRYIiwiaXNGaXhlZFkiLCJpc1NlZ21lbnQiLCJ2aWV3Qm94IiwicG9zaXRpb24iLCJ4QXhpc09yaWVudGF0aW9uIiwieUF4aXNPcmllbnRhdGlvbiIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJ5Q29vcmQiLCJjb29yZCIsImlmT3ZlcmZsb3dNYXRjaGVzIiwiaXNJblJhbmdlIiwicG9pbnRzIiwicmV2ZXJzZSIsInhDb29yZCIsIl9jb29yZCIsIl9wb2ludHMiLCJzZWdtZW50IiwiX3BvaW50czIiLCJtYXAiLCJSZWZlcmVuY2VMaW5lSW1wbCIsImZpeGVkWCIsImZpeGVkWSIsInhBeGlzSWQiLCJ5QXhpc0lkIiwic2hhcGUiLCJhbHdheXNTaG93IiwiY2xpcFBhdGhJZCIsInVzZUNsaXBQYXRoSWQiLCJ4QXhpcyIsInVzZVhBeGlzT3JUaHJvdyIsInlBeGlzIiwidXNlWUF4aXNPclRocm93IiwidXNlVmlld0JveCIsIndhcm4iLCJ1bmRlZmluZWQiLCJjcmVhdGVMYWJlbGVkU2NhbGVzIiwic2NhbGUiLCJpc1giLCJpc051bU9yU3RyIiwiaXNZIiwiZW5kUG9pbnRzIiwib3JpZW50YXRpb24iLCJfZW5kUG9pbnRzIiwiX2VuZFBvaW50cyQiLCJ4MSIsInkxIiwiX2VuZFBvaW50cyQyIiwieDIiLCJ5MiIsImNsaXBQYXRoIiwiY29uY2F0IiwibGluZVByb3BzIiwiZmlsdGVyUHJvcHMiLCJMYXllciIsIkxhYmVsIiwicmVuZGVyQ2FsbEJ5UGFyZW50IiwicmVjdFdpdGhDb29yZHMiLCJfUmVhY3QkQ29tcG9uZW50IiwicmVuZGVyIiwiQ29tcG9uZW50IiwiaXNGcm9udCIsImlmT3ZlcmZsb3ciLCJmaWxsIiwic3Ryb2tlIiwiZmlsbE9wYWNpdHkiLCJzdHJva2VXaWR0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/ReferenceLine.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/cartesian/Scatter.js":
/*!********************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/Scatter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Scatter = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"./node_modules/recharts/lib/component/LabelList.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"./node_modules/recharts/lib/util/Global.js\");\nvar _ZAxis = __webpack_require__(/*! ./ZAxis */ \"./node_modules/recharts/lib/cartesian/ZAxis.js\");\nvar _Curve = __webpack_require__(/*! ../shape/Curve */ \"./node_modules/recharts/lib/shape/Curve.js\");\nvar _ErrorBar = __webpack_require__(/*! ./ErrorBar */ \"./node_modules/recharts/lib/cartesian/ErrorBar.js\");\nvar _Cell = __webpack_require__(/*! ../component/Cell */ \"./node_modules/recharts/lib/component/Cell.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"./node_modules/recharts/lib/util/types.js\");\nvar _ScatterUtils = __webpack_require__(/*! ../util/ScatterUtils */ \"./node_modules/recharts/lib/util/ScatterUtils.js\");\nvar _Scatter;\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Render a group of scatters\n */ \nvar Scatter = exports.Scatter = /*#__PURE__*/ function(_PureComponent) {\n    function Scatter() {\n        var _this;\n        _classCallCheck(this, Scatter);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Scatter, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            isAnimationFinished: false\n        });\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            _this.setState({\n                isAnimationFinished: true\n            });\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            _this.setState({\n                isAnimationFinished: false\n            });\n        });\n        _defineProperty(_this, \"id\", (0, _DataUtils.uniqueId)(\"recharts-scatter-\"));\n        return _this;\n    }\n    _inherits(Scatter, _PureComponent);\n    return _createClass(Scatter, [\n        {\n            key: \"renderSymbolsStatically\",\n            value: function renderSymbolsStatically(points) {\n                var _this2 = this;\n                var _this$props = this.props, shape = _this$props.shape, activeShape = _this$props.activeShape, activeIndex = _this$props.activeIndex;\n                var baseProps = (0, _ReactUtils.filterProps)(this.props, false);\n                return points.map(function(entry, i) {\n                    var isActive = activeIndex === i;\n                    var option = isActive ? activeShape : shape;\n                    var props = _objectSpread(_objectSpread({}, baseProps), entry);\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        className: \"recharts-scatter-symbol\",\n                        key: \"symbol-\".concat(entry === null || entry === void 0 ? void 0 : entry.cx, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.cy, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.size, \"-\").concat(i)\n                    }, (0, _types.adaptEventsOfChild)(_this2.props, entry, i), {\n                        role: \"img\"\n                    }), /*#__PURE__*/ _react[\"default\"].createElement(_ScatterUtils.ScatterSymbol, _extends({\n                        option: option,\n                        isActive: isActive,\n                        key: \"symbol-\".concat(i)\n                    }, props)));\n                });\n            }\n        },\n        {\n            key: \"renderSymbolsWithAnimation\",\n            value: function renderSymbolsWithAnimation() {\n                var _this3 = this;\n                var _this$props2 = this.props, points = _this$props2.points, isAnimationActive = _this$props2.isAnimationActive, animationBegin = _this$props2.animationBegin, animationDuration = _this$props2.animationDuration, animationEasing = _this$props2.animationEasing, animationId = _this$props2.animationId;\n                var prevPoints = this.state.prevPoints;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"pie-\".concat(animationId),\n                    onAnimationEnd: this.handleAnimationEnd,\n                    onAnimationStart: this.handleAnimationStart\n                }, function(_ref) {\n                    var t = _ref.t;\n                    var stepData = points.map(function(entry, index) {\n                        var prev = prevPoints && prevPoints[index];\n                        if (prev) {\n                            var interpolatorCx = (0, _DataUtils.interpolateNumber)(prev.cx, entry.cx);\n                            var interpolatorCy = (0, _DataUtils.interpolateNumber)(prev.cy, entry.cy);\n                            var interpolatorSize = (0, _DataUtils.interpolateNumber)(prev.size, entry.size);\n                            return _objectSpread(_objectSpread({}, entry), {}, {\n                                cx: interpolatorCx(t),\n                                cy: interpolatorCy(t),\n                                size: interpolatorSize(t)\n                            });\n                        }\n                        var interpolator = (0, _DataUtils.interpolateNumber)(0, entry.size);\n                        return _objectSpread(_objectSpread({}, entry), {}, {\n                            size: interpolator(t)\n                        });\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, null, _this3.renderSymbolsStatically(stepData));\n                });\n            }\n        },\n        {\n            key: \"renderSymbols\",\n            value: function renderSymbols() {\n                var _this$props3 = this.props, points = _this$props3.points, isAnimationActive = _this$props3.isAnimationActive;\n                var prevPoints = this.state.prevPoints;\n                if (isAnimationActive && points && points.length && (!prevPoints || !(0, _isEqual[\"default\"])(prevPoints, points))) {\n                    return this.renderSymbolsWithAnimation();\n                }\n                return this.renderSymbolsStatically(points);\n            }\n        },\n        {\n            key: \"renderErrorBar\",\n            value: function renderErrorBar() {\n                var isAnimationActive = this.props.isAnimationActive;\n                if (isAnimationActive && !this.state.isAnimationFinished) {\n                    return null;\n                }\n                var _this$props4 = this.props, points = _this$props4.points, xAxis = _this$props4.xAxis, yAxis = _this$props4.yAxis, children = _this$props4.children;\n                var errorBarItems = (0, _ReactUtils.findAllByType)(children, _ErrorBar.ErrorBar);\n                if (!errorBarItems) {\n                    return null;\n                }\n                return errorBarItems.map(function(item, i) {\n                    var _item$props = item.props, direction = _item$props.direction, errorDataKey = _item$props.dataKey;\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(item, {\n                        key: \"\".concat(direction, \"-\").concat(errorDataKey, \"-\").concat(points[i]),\n                        data: points,\n                        xAxis: xAxis,\n                        yAxis: yAxis,\n                        layout: direction === \"x\" ? \"vertical\" : \"horizontal\",\n                        dataPointFormatter: function dataPointFormatter(dataPoint, dataKey) {\n                            return {\n                                x: dataPoint.cx,\n                                y: dataPoint.cy,\n                                value: direction === \"x\" ? +dataPoint.node.x : +dataPoint.node.y,\n                                errorVal: (0, _ChartUtils.getValueByDataKey)(dataPoint, dataKey)\n                            };\n                        }\n                    });\n                });\n            }\n        },\n        {\n            key: \"renderLine\",\n            value: function renderLine() {\n                var _this$props5 = this.props, points = _this$props5.points, line = _this$props5.line, lineType = _this$props5.lineType, lineJointType = _this$props5.lineJointType;\n                var scatterProps = (0, _ReactUtils.filterProps)(this.props, false);\n                var customLineProps = (0, _ReactUtils.filterProps)(line, false);\n                var linePoints, lineItem;\n                if (lineType === \"joint\") {\n                    linePoints = points.map(function(entry) {\n                        return {\n                            x: entry.cx,\n                            y: entry.cy\n                        };\n                    });\n                } else if (lineType === \"fitting\") {\n                    var _getLinearRegression = (0, _DataUtils.getLinearRegression)(points), xmin = _getLinearRegression.xmin, xmax = _getLinearRegression.xmax, a = _getLinearRegression.a, b = _getLinearRegression.b;\n                    var linearExp = function linearExp(x) {\n                        return a * x + b;\n                    };\n                    linePoints = [\n                        {\n                            x: xmin,\n                            y: linearExp(xmin)\n                        },\n                        {\n                            x: xmax,\n                            y: linearExp(xmax)\n                        }\n                    ];\n                }\n                var lineProps = _objectSpread(_objectSpread(_objectSpread({}, scatterProps), {}, {\n                    fill: \"none\",\n                    stroke: scatterProps && scatterProps.fill\n                }, customLineProps), {}, {\n                    points: linePoints\n                });\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(line)) {\n                    lineItem = /*#__PURE__*/ _react[\"default\"].cloneElement(line, lineProps);\n                } else if ((0, _isFunction[\"default\"])(line)) {\n                    lineItem = line(lineProps);\n                } else {\n                    lineItem = /*#__PURE__*/ _react[\"default\"].createElement(_Curve.Curve, _extends({}, lineProps, {\n                        type: lineJointType\n                    }));\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-scatter-line\",\n                    key: \"recharts-scatter-line\"\n                }, lineItem);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props6 = this.props, hide = _this$props6.hide, points = _this$props6.points, line = _this$props6.line, className = _this$props6.className, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, left = _this$props6.left, top = _this$props6.top, width = _this$props6.width, height = _this$props6.height, id = _this$props6.id, isAnimationActive = _this$props6.isAnimationActive;\n                if (hide || !points || !points.length) {\n                    return null;\n                }\n                var isAnimationFinished = this.state.isAnimationFinished;\n                var layerClass = (0, _clsx[\"default\"])(\"recharts-scatter\", className);\n                var needClipX = xAxis && xAxis.allowDataOverflow;\n                var needClipY = yAxis && yAxis.allowDataOverflow;\n                var needClip = needClipX || needClipY;\n                var clipPathId = (0, _isNil[\"default\"])(id) ? this.id : id;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass,\n                    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : null\n                }, needClipX || needClipY ? /*#__PURE__*/ _react[\"default\"].createElement(\"defs\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                    id: \"clipPath-\".concat(clipPathId)\n                }, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                    x: needClipX ? left : left - width / 2,\n                    y: needClipY ? top : top - height / 2,\n                    width: needClipX ? width : width * 2,\n                    height: needClipY ? height : height * 2\n                }))) : null, line && this.renderLine(), this.renderErrorBar(), /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    key: \"recharts-scatter-symbols\"\n                }, this.renderSymbols()), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, points));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curPoints: nextProps.points,\n                        prevPoints: prevState.curPoints\n                    };\n                }\n                if (nextProps.points !== prevState.curPoints) {\n                    return {\n                        curPoints: nextProps.points\n                    };\n                }\n                return null;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_Scatter = Scatter;\n_defineProperty(Scatter, \"displayName\", \"Scatter\");\n_defineProperty(Scatter, \"defaultProps\", {\n    xAxisId: 0,\n    yAxisId: 0,\n    zAxisId: 0,\n    legendType: \"circle\",\n    lineType: \"joint\",\n    lineJointType: \"linear\",\n    data: [],\n    shape: \"circle\",\n    hide: false,\n    isAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 0,\n    animationDuration: 400,\n    animationEasing: \"linear\"\n});\n/**\n * Compose the data of each group\n * @param  {Object} xAxis   The configuration of x-axis\n * @param  {Object} yAxis   The configuration of y-axis\n * @param  {String} dataKey The unique key of a group\n * @return {Array}  Composed data\n */ _defineProperty(Scatter, \"getComposedData\", function(_ref2) {\n    var xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, zAxis = _ref2.zAxis, item = _ref2.item, displayedData = _ref2.displayedData, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, offset = _ref2.offset;\n    var tooltipType = item.props.tooltipType;\n    var cells = (0, _ReactUtils.findAllByType)(item.props.children, _Cell.Cell);\n    var xAxisDataKey = (0, _isNil[\"default\"])(xAxis.dataKey) ? item.props.dataKey : xAxis.dataKey;\n    var yAxisDataKey = (0, _isNil[\"default\"])(yAxis.dataKey) ? item.props.dataKey : yAxis.dataKey;\n    var zAxisDataKey = zAxis && zAxis.dataKey;\n    var defaultRangeZ = zAxis ? zAxis.range : _ZAxis.ZAxis.defaultProps.range;\n    var defaultZ = defaultRangeZ && defaultRangeZ[0];\n    var xBandSize = xAxis.scale.bandwidth ? xAxis.scale.bandwidth() : 0;\n    var yBandSize = yAxis.scale.bandwidth ? yAxis.scale.bandwidth() : 0;\n    var points = displayedData.map(function(entry, index) {\n        var x = (0, _ChartUtils.getValueByDataKey)(entry, xAxisDataKey);\n        var y = (0, _ChartUtils.getValueByDataKey)(entry, yAxisDataKey);\n        var z = !(0, _isNil[\"default\"])(zAxisDataKey) && (0, _ChartUtils.getValueByDataKey)(entry, zAxisDataKey) || \"-\";\n        var tooltipPayload = [\n            {\n                name: (0, _isNil[\"default\"])(xAxis.dataKey) ? item.props.name : xAxis.name || xAxis.dataKey,\n                unit: xAxis.unit || \"\",\n                value: x,\n                payload: entry,\n                dataKey: xAxisDataKey,\n                type: tooltipType\n            },\n            {\n                name: (0, _isNil[\"default\"])(yAxis.dataKey) ? item.props.name : yAxis.name || yAxis.dataKey,\n                unit: yAxis.unit || \"\",\n                value: y,\n                payload: entry,\n                dataKey: yAxisDataKey,\n                type: tooltipType\n            }\n        ];\n        if (z !== \"-\") {\n            tooltipPayload.push({\n                name: zAxis.name || zAxis.dataKey,\n                unit: zAxis.unit || \"\",\n                value: z,\n                payload: entry,\n                dataKey: zAxisDataKey,\n                type: tooltipType\n            });\n        }\n        var cx = (0, _ChartUtils.getCateCoordinateOfLine)({\n            axis: xAxis,\n            ticks: xAxisTicks,\n            bandSize: xBandSize,\n            entry: entry,\n            index: index,\n            dataKey: xAxisDataKey\n        });\n        var cy = (0, _ChartUtils.getCateCoordinateOfLine)({\n            axis: yAxis,\n            ticks: yAxisTicks,\n            bandSize: yBandSize,\n            entry: entry,\n            index: index,\n            dataKey: yAxisDataKey\n        });\n        var size = z !== \"-\" ? zAxis.scale(z) : defaultZ;\n        var radius = Math.sqrt(Math.max(size, 0) / Math.PI);\n        return _objectSpread(_objectSpread({}, entry), {}, {\n            cx: cx,\n            cy: cy,\n            x: cx - radius,\n            y: cy - radius,\n            xAxis: xAxis,\n            yAxis: yAxis,\n            zAxis: zAxis,\n            width: 2 * radius,\n            height: 2 * radius,\n            size: size,\n            node: {\n                x: x,\n                y: y,\n                z: z\n            },\n            tooltipPayload: tooltipPayload,\n            tooltipPosition: {\n                x: cx,\n                y: cy\n            },\n            payload: entry\n        }, cells && cells[index] && cells[index].props);\n    });\n    return _objectSpread({\n        points: points\n    }, offset);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9TY2F0dGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxlQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLGVBQWVDLHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDaEUsSUFBSUcsU0FBU0QsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJSSxXQUFXRix1QkFBdUJGLG1CQUFPQSxDQUFDLHNDQUFnQjtBQUM5RCxJQUFJSyxjQUFjSCx1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJTSxRQUFRSix1QkFBdUJGLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlPLFNBQVNQLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJUSxhQUFhUixtQkFBT0EsQ0FBQyxrRkFBd0I7QUFDakQsSUFBSVMsY0FBY1QsbUJBQU9BLENBQUMsMEVBQW9CO0FBQzlDLElBQUlVLFVBQVVWLG1CQUFPQSxDQUFDLGtFQUFnQjtBQUN0QyxJQUFJVyxTQUFTWCxtQkFBT0EsQ0FBQywrREFBUztBQUM5QixJQUFJWSxTQUFTWixtQkFBT0EsQ0FBQyxrRUFBZ0I7QUFDckMsSUFBSWEsWUFBWWIsbUJBQU9BLENBQUMscUVBQVk7QUFDcEMsSUFBSWMsUUFBUWQsbUJBQU9BLENBQUMsd0VBQW1CO0FBQ3ZDLElBQUllLGFBQWFmLG1CQUFPQSxDQUFDLHdFQUFtQjtBQUM1QyxJQUFJZ0IsY0FBY2hCLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJaUIsU0FBU2pCLG1CQUFPQSxDQUFDLGdFQUFlO0FBQ3BDLElBQUlrQixnQkFBZ0JsQixtQkFBT0EsQ0FBQyw4RUFBc0I7QUFDbEQsSUFBSW1CO0FBQ0osU0FBU2pCLHVCQUF1QmtCLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UseUJBQXlCQyxDQUFDO0lBQUksSUFBSSxjQUFjLE9BQU9DLFNBQVMsT0FBTztJQUFNLElBQUlDLElBQUksSUFBSUQsV0FBV0UsSUFBSSxJQUFJRjtJQUFXLE9BQU8sQ0FBQ0YsMkJBQTJCLFNBQVNBLHlCQUF5QkMsQ0FBQztRQUFJLE9BQU9BLElBQUlHLElBQUlEO0lBQUcsR0FBR0Y7QUFBSTtBQUNuTyxTQUFTeEIsd0JBQXdCd0IsQ0FBQyxFQUFFRSxDQUFDO0lBQUksSUFBSSxDQUFDQSxLQUFLRixLQUFLQSxFQUFFRixVQUFVLEVBQUUsT0FBT0U7SUFBRyxJQUFJLFNBQVNBLEtBQUssWUFBWUksUUFBUUosTUFBTSxjQUFjLE9BQU9BLEdBQUcsT0FBTztRQUFFLFdBQVdBO0lBQUU7SUFBRyxJQUFJRyxJQUFJSix5QkFBeUJHO0lBQUksSUFBSUMsS0FBS0EsRUFBRUUsR0FBRyxDQUFDTCxJQUFJLE9BQU9HLEVBQUVHLEdBQUcsQ0FBQ047SUFBSSxJQUFJTyxJQUFJO1FBQUVDLFdBQVc7SUFBSyxHQUFHQyxJQUFJdkMsT0FBT0MsY0FBYyxJQUFJRCxPQUFPd0Msd0JBQXdCO0lBQUUsSUFBSyxJQUFJQyxLQUFLWCxFQUFHLElBQUksY0FBY1csS0FBSyxFQUFDLEdBQUVDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDYixHQUFHVyxJQUFJO1FBQUUsSUFBSUcsSUFBSUwsSUFBSXZDLE9BQU93Qyx3QkFBd0IsQ0FBQ1YsR0FBR1csS0FBSztRQUFNRyxLQUFNQSxDQUFBQSxFQUFFUixHQUFHLElBQUlRLEVBQUVDLEdBQUcsSUFBSTdDLE9BQU9DLGNBQWMsQ0FBQ29DLEdBQUdJLEdBQUdHLEtBQUtQLENBQUMsQ0FBQ0ksRUFBRSxHQUFHWCxDQUFDLENBQUNXLEVBQUU7SUFBRTtJQUFFLE9BQU9KLENBQUMsQ0FBQyxVQUFVLEdBQUdQLEdBQUdHLEtBQUtBLEVBQUVZLEdBQUcsQ0FBQ2YsR0FBR08sSUFBSUE7QUFBRztBQUN6a0IsU0FBU0gsUUFBUVksQ0FBQztJQUFJO0lBQTJCLE9BQU9aLFVBQVUsY0FBYyxPQUFPYSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHWixRQUFRWTtBQUFJO0FBQzdULFNBQVNLO0lBQWFBLFdBQVduRCxPQUFPb0QsTUFBTSxHQUFHcEQsT0FBT29ELE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFBSSxJQUFLLElBQUlWLElBQUksR0FBR0EsSUFBSVcsVUFBVUMsTUFBTSxFQUFFWixJQUFLO1lBQUUsSUFBSWEsU0FBU0YsU0FBUyxDQUFDWCxFQUFFO1lBQUUsSUFBSyxJQUFJYyxPQUFPRCxPQUFRO2dCQUFFLElBQUl6RCxPQUFPa0QsU0FBUyxDQUFDUixjQUFjLENBQUNDLElBQUksQ0FBQ2MsUUFBUUMsTUFBTTtvQkFBRUosTUFBTSxDQUFDSSxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFBRTtZQUFFO1FBQUU7UUFBRSxPQUFPSjtJQUFRO0lBQUcsT0FBT0gsU0FBU1EsS0FBSyxDQUFDLElBQUksRUFBRUo7QUFBWTtBQUNsVixTQUFTSyxRQUFROUIsQ0FBQyxFQUFFRSxDQUFDO0lBQUksSUFBSUMsSUFBSWpDLE9BQU82RCxJQUFJLENBQUMvQjtJQUFJLElBQUk5QixPQUFPOEQscUJBQXFCLEVBQUU7UUFBRSxJQUFJaEIsSUFBSTlDLE9BQU84RCxxQkFBcUIsQ0FBQ2hDO1FBQUlFLEtBQU1jLENBQUFBLElBQUlBLEVBQUVpQixNQUFNLENBQUMsU0FBVS9CLENBQUM7WUFBSSxPQUFPaEMsT0FBT3dDLHdCQUF3QixDQUFDVixHQUFHRSxHQUFHZ0MsVUFBVTtRQUFFLEVBQUMsR0FBSS9CLEVBQUVnQyxJQUFJLENBQUNOLEtBQUssQ0FBQzFCLEdBQUdhO0lBQUk7SUFBRSxPQUFPYjtBQUFHO0FBQzlQLFNBQVNpQyxjQUFjcEMsQ0FBQztJQUFJLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJdUIsVUFBVUMsTUFBTSxFQUFFeEIsSUFBSztRQUFFLElBQUlDLElBQUksUUFBUXNCLFNBQVMsQ0FBQ3ZCLEVBQUUsR0FBR3VCLFNBQVMsQ0FBQ3ZCLEVBQUUsR0FBRyxDQUFDO1FBQUdBLElBQUksSUFBSTRCLFFBQVE1RCxPQUFPaUMsSUFBSSxDQUFDLEdBQUdrQyxPQUFPLENBQUMsU0FBVW5DLENBQUM7WUFBSW9DLGdCQUFnQnRDLEdBQUdFLEdBQUdDLENBQUMsQ0FBQ0QsRUFBRTtRQUFHLEtBQUtoQyxPQUFPcUUseUJBQXlCLEdBQUdyRSxPQUFPc0UsZ0JBQWdCLENBQUN4QyxHQUFHOUIsT0FBT3FFLHlCQUF5QixDQUFDcEMsTUFBTTJCLFFBQVE1RCxPQUFPaUMsSUFBSWtDLE9BQU8sQ0FBQyxTQUFVbkMsQ0FBQztZQUFJaEMsT0FBT0MsY0FBYyxDQUFDNkIsR0FBR0UsR0FBR2hDLE9BQU93Qyx3QkFBd0IsQ0FBQ1AsR0FBR0Q7UUFBSztJQUFJO0lBQUUsT0FBT0Y7QUFBRztBQUN0YixTQUFTeUMsZ0JBQWdCQyxRQUFRLEVBQUVDLFdBQVc7SUFBSSxJQUFJLENBQUVELENBQUFBLG9CQUFvQkMsV0FBVSxHQUFJO1FBQUUsTUFBTSxJQUFJQyxVQUFVO0lBQXNDO0FBQUU7QUFDeEosU0FBU0Msa0JBQWtCckIsTUFBTSxFQUFFc0IsS0FBSztJQUFJLElBQUssSUFBSWhDLElBQUksR0FBR0EsSUFBSWdDLE1BQU1wQixNQUFNLEVBQUVaLElBQUs7UUFBRSxJQUFJaUMsYUFBYUQsS0FBSyxDQUFDaEMsRUFBRTtRQUFFaUMsV0FBV2IsVUFBVSxHQUFHYSxXQUFXYixVQUFVLElBQUk7UUFBT2EsV0FBV0MsWUFBWSxHQUFHO1FBQU0sSUFBSSxXQUFXRCxZQUFZQSxXQUFXRSxRQUFRLEdBQUc7UUFBTS9FLE9BQU9DLGNBQWMsQ0FBQ3FELFFBQVEwQixlQUFlSCxXQUFXbkIsR0FBRyxHQUFHbUI7SUFBYTtBQUFFO0FBQzVVLFNBQVNJLGFBQWFSLFdBQVcsRUFBRVMsVUFBVSxFQUFFQyxXQUFXO0lBQUksSUFBSUQsWUFBWVAsa0JBQWtCRixZQUFZdkIsU0FBUyxFQUFFZ0M7SUFBYSxJQUFJQyxhQUFhUixrQkFBa0JGLGFBQWFVO0lBQWNuRixPQUFPQyxjQUFjLENBQUN3RSxhQUFhLGFBQWE7UUFBRU0sVUFBVTtJQUFNO0lBQUksT0FBT047QUFBYTtBQUM1UixTQUFTVyxXQUFXbkQsQ0FBQyxFQUFFYSxDQUFDLEVBQUVoQixDQUFDO0lBQUksT0FBT2dCLElBQUl1QyxnQkFBZ0J2QyxJQUFJd0MsMkJBQTJCckQsR0FBR3NELDhCQUE4QkMsUUFBUUMsU0FBUyxDQUFDM0MsR0FBR2hCLEtBQUssRUFBRSxFQUFFdUQsZ0JBQWdCcEQsR0FBR2dCLFdBQVcsSUFBSUgsRUFBRWEsS0FBSyxDQUFDMUIsR0FBR0g7QUFBSztBQUMxTSxTQUFTd0QsMkJBQTJCSSxJQUFJLEVBQUUvQyxJQUFJO0lBQUksSUFBSUEsUUFBU1QsQ0FBQUEsUUFBUVMsVUFBVSxZQUFZLE9BQU9BLFNBQVMsVUFBUyxHQUFJO1FBQUUsT0FBT0E7SUFBTSxPQUFPLElBQUlBLFNBQVMsS0FBSyxHQUFHO1FBQUUsTUFBTSxJQUFJK0IsVUFBVTtJQUE2RDtJQUFFLE9BQU9pQix1QkFBdUJEO0FBQU87QUFDL1IsU0FBU0MsdUJBQXVCRCxJQUFJO0lBQUksSUFBSUEsU0FBUyxLQUFLLEdBQUc7UUFBRSxNQUFNLElBQUlFLGVBQWU7SUFBOEQ7SUFBRSxPQUFPRjtBQUFNO0FBQ3JLLFNBQVNIO0lBQThCLElBQUk7UUFBRSxJQUFJdEQsSUFBSSxDQUFDNEQsUUFBUTNDLFNBQVMsQ0FBQzRDLE9BQU8sQ0FBQ25ELElBQUksQ0FBQzZDLFFBQVFDLFNBQVMsQ0FBQ0ksU0FBUyxFQUFFLEVBQUUsWUFBYTtJQUFLLEVBQUUsT0FBTzVELEdBQUcsQ0FBQztJQUFFLE9BQU8sQ0FBQ3NELDRCQUE0QixTQUFTQTtRQUE4QixPQUFPLENBQUMsQ0FBQ3REO0lBQUc7QUFBTTtBQUNsUCxTQUFTb0QsZ0JBQWdCdkMsQ0FBQztJQUFJdUMsa0JBQWtCckYsT0FBTytGLGNBQWMsR0FBRy9GLE9BQU9nRyxjQUFjLENBQUMzQyxJQUFJLEtBQUssU0FBU2dDLGdCQUFnQnZDLENBQUM7UUFBSSxPQUFPQSxFQUFFUixTQUFTLElBQUl0QyxPQUFPZ0csY0FBYyxDQUFDbEQ7SUFBSTtJQUFHLE9BQU91QyxnQkFBZ0J2QztBQUFJO0FBQ25OLFNBQVNtRCxVQUFVQyxRQUFRLEVBQUVDLFVBQVU7SUFBSSxJQUFJLE9BQU9BLGVBQWUsY0FBY0EsZUFBZSxNQUFNO1FBQUUsTUFBTSxJQUFJekIsVUFBVTtJQUF1RDtJQUFFd0IsU0FBU2hELFNBQVMsR0FBR2xELE9BQU9vRyxNQUFNLENBQUNELGNBQWNBLFdBQVdqRCxTQUFTLEVBQUU7UUFBRUQsYUFBYTtZQUFFOUMsT0FBTytGO1lBQVVuQixVQUFVO1lBQU1ELGNBQWM7UUFBSztJQUFFO0lBQUk5RSxPQUFPQyxjQUFjLENBQUNpRyxVQUFVLGFBQWE7UUFBRW5CLFVBQVU7SUFBTTtJQUFJLElBQUlvQixZQUFZRSxnQkFBZ0JILFVBQVVDO0FBQWE7QUFDbmMsU0FBU0UsZ0JBQWdCdkQsQ0FBQyxFQUFFd0QsQ0FBQztJQUFJRCxrQkFBa0JyRyxPQUFPK0YsY0FBYyxHQUFHL0YsT0FBTytGLGNBQWMsQ0FBQzFDLElBQUksS0FBSyxTQUFTZ0QsZ0JBQWdCdkQsQ0FBQyxFQUFFd0QsQ0FBQztRQUFJeEQsRUFBRVIsU0FBUyxHQUFHZ0U7UUFBRyxPQUFPeEQ7SUFBRztJQUFHLE9BQU91RCxnQkFBZ0J2RCxHQUFHd0Q7QUFBSTtBQUN2TSxTQUFTbEMsZ0JBQWdCekMsR0FBRyxFQUFFK0IsR0FBRyxFQUFFdkQsS0FBSztJQUFJdUQsTUFBTXNCLGVBQWV0QjtJQUFNLElBQUlBLE9BQU8vQixLQUFLO1FBQUUzQixPQUFPQyxjQUFjLENBQUMwQixLQUFLK0IsS0FBSztZQUFFdkQsT0FBT0E7WUFBTzZELFlBQVk7WUFBTWMsY0FBYztZQUFNQyxVQUFVO1FBQUs7SUFBSSxPQUFPO1FBQUVwRCxHQUFHLENBQUMrQixJQUFJLEdBQUd2RDtJQUFPO0lBQUUsT0FBT3dCO0FBQUs7QUFDM08sU0FBU3FELGVBQWUvQyxDQUFDO0lBQUksSUFBSVcsSUFBSTJELGFBQWF0RSxHQUFHO0lBQVcsT0FBTyxZQUFZQyxRQUFRVSxLQUFLQSxJQUFJQSxJQUFJO0FBQUk7QUFDNUcsU0FBUzJELGFBQWF0RSxDQUFDLEVBQUVELENBQUM7SUFBSSxJQUFJLFlBQVlFLFFBQVFELE1BQU0sQ0FBQ0EsR0FBRyxPQUFPQTtJQUFHLElBQUlILElBQUlHLENBQUMsQ0FBQ2MsT0FBT3lELFdBQVcsQ0FBQztJQUFFLElBQUksS0FBSyxNQUFNMUUsR0FBRztRQUFFLElBQUljLElBQUlkLEVBQUVhLElBQUksQ0FBQ1YsR0FBR0QsS0FBSztRQUFZLElBQUksWUFBWUUsUUFBUVUsSUFBSSxPQUFPQTtRQUFHLE1BQU0sSUFBSThCLFVBQVU7SUFBaUQ7SUFBRSxPQUFPLENBQUMsYUFBYTFDLElBQUl5RSxTQUFTQyxNQUFLLEVBQUd6RTtBQUFJLEVBQUU7O0NBRTVUO0FBQ0QsSUFBSTdCLFVBQVVGLGVBQWUsR0FBRyxXQUFXLEdBQUUsU0FBVXlHLGNBQWM7SUFDbkUsU0FBU3ZHO1FBQ1AsSUFBSXdHO1FBQ0pyQyxnQkFBZ0IsSUFBSSxFQUFFbkU7UUFDdEIsSUFBSyxJQUFJeUcsT0FBT3RELFVBQVVDLE1BQU0sRUFBRXNELE9BQU8sSUFBSUMsTUFBTUYsT0FBT0csT0FBTyxHQUFHQSxPQUFPSCxNQUFNRyxPQUFRO1lBQ3ZGRixJQUFJLENBQUNFLEtBQUssR0FBR3pELFNBQVMsQ0FBQ3lELEtBQUs7UUFDOUI7UUFDQUosUUFBUXhCLFdBQVcsSUFBSSxFQUFFaEYsU0FBUyxFQUFFLENBQUM2RyxNQUFNLENBQUNIO1FBQzVDMUMsZ0JBQWdCd0MsT0FBTyxTQUFTO1lBQzlCTSxxQkFBcUI7UUFDdkI7UUFDQTlDLGdCQUFnQndDLE9BQU8sc0JBQXNCO1lBQzNDQSxNQUFNTyxRQUFRLENBQUM7Z0JBQ2JELHFCQUFxQjtZQUN2QjtRQUNGO1FBQ0E5QyxnQkFBZ0J3QyxPQUFPLHdCQUF3QjtZQUM3Q0EsTUFBTU8sUUFBUSxDQUFDO2dCQUNiRCxxQkFBcUI7WUFDdkI7UUFDRjtRQUNBOUMsZ0JBQWdCd0MsT0FBTyxNQUFNLENBQUMsR0FBR3RGLFdBQVc4RixRQUFRLEVBQUU7UUFDdEQsT0FBT1I7SUFDVDtJQUNBWCxVQUFVN0YsU0FBU3VHO0lBQ25CLE9BQU8xQixhQUFhN0UsU0FBUztRQUFDO1lBQzVCc0QsS0FBSztZQUNMdkQsT0FBTyxTQUFTa0gsd0JBQXdCQyxNQUFNO2dCQUM1QyxJQUFJQyxTQUFTLElBQUk7Z0JBQ2pCLElBQUlDLGNBQWMsSUFBSSxDQUFDNUMsS0FBSyxFQUMxQjZDLFFBQVFELFlBQVlDLEtBQUssRUFDekJDLGNBQWNGLFlBQVlFLFdBQVcsRUFDckNDLGNBQWNILFlBQVlHLFdBQVc7Z0JBQ3ZDLElBQUlDLFlBQVksQ0FBQyxHQUFHNUcsWUFBWTZHLFdBQVcsRUFBRSxJQUFJLENBQUNqRCxLQUFLLEVBQUU7Z0JBQ3pELE9BQU8wQyxPQUFPUSxHQUFHLENBQUMsU0FBVUMsS0FBSyxFQUFFbkYsQ0FBQztvQkFDbEMsSUFBSW9GLFdBQVdMLGdCQUFnQi9FO29CQUMvQixJQUFJcUYsU0FBU0QsV0FBV04sY0FBY0Q7b0JBQ3RDLElBQUk3QyxRQUFRVixjQUFjQSxjQUFjLENBQUMsR0FBRzBELFlBQVlHO29CQUN4RCxPQUFPLFdBQVcsR0FBRTFILE1BQU0sQ0FBQyxVQUFVLENBQUM2SCxhQUFhLENBQUNwSCxPQUFPcUgsS0FBSyxFQUFFaEYsU0FBUzt3QkFDekVpRixXQUFXO3dCQUdYMUUsS0FBSyxVQUFVdUQsTUFBTSxDQUFDYyxVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSUEsTUFBTU0sRUFBRSxFQUFFLEtBQUtwQixNQUFNLENBQUNjLFVBQVUsUUFBUUEsVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJQSxNQUFNTyxFQUFFLEVBQUUsS0FBS3JCLE1BQU0sQ0FBQ2MsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU1RLElBQUksRUFBRSxLQUFLdEIsTUFBTSxDQUFDckU7b0JBQ3RPLEdBQUcsQ0FBQyxHQUFHcEIsT0FBT2dILGtCQUFrQixFQUFFakIsT0FBTzNDLEtBQUssRUFBRW1ELE9BQU9uRixJQUFJO3dCQUN6RDZGLE1BQU07b0JBQ1IsSUFBSSxXQUFXLEdBQUVwSSxNQUFNLENBQUMsVUFBVSxDQUFDNkgsYUFBYSxDQUFDekcsY0FBY2lILGFBQWEsRUFBRXZGLFNBQVM7d0JBQ3JGOEUsUUFBUUE7d0JBQ1JELFVBQVVBO3dCQUdWdEUsS0FBSyxVQUFVdUQsTUFBTSxDQUFDckU7b0JBQ3hCLEdBQUdnQztnQkFDTDtZQUNGO1FBQ0Y7UUFBRztZQUNEbEIsS0FBSztZQUNMdkQsT0FBTyxTQUFTd0k7Z0JBQ2QsSUFBSUMsU0FBUyxJQUFJO2dCQUNqQixJQUFJQyxlQUFlLElBQUksQ0FBQ2pFLEtBQUssRUFDM0IwQyxTQUFTdUIsYUFBYXZCLE1BQU0sRUFDNUJ3QixvQkFBb0JELGFBQWFDLGlCQUFpQixFQUNsREMsaUJBQWlCRixhQUFhRSxjQUFjLEVBQzVDQyxvQkFBb0JILGFBQWFHLGlCQUFpQixFQUNsREMsa0JBQWtCSixhQUFhSSxlQUFlLEVBQzlDQyxjQUFjTCxhQUFhSyxXQUFXO2dCQUN4QyxJQUFJQyxhQUFhLElBQUksQ0FBQ0MsS0FBSyxDQUFDRCxVQUFVO2dCQUN0QyxPQUFPLFdBQVcsR0FBRTlJLE1BQU0sQ0FBQyxVQUFVLENBQUM2SCxhQUFhLENBQUMxSCxZQUFZLENBQUMsVUFBVSxFQUFFO29CQUMzRTZJLE9BQU9OO29CQUNQTyxVQUFVTjtvQkFDVmhCLFVBQVVjO29CQUNWUyxRQUFRTjtvQkFDUk8sTUFBTTt3QkFDSnZILEdBQUc7b0JBQ0w7b0JBQ0F3SCxJQUFJO3dCQUNGeEgsR0FBRztvQkFDTDtvQkFDQXlCLEtBQUssT0FBT3VELE1BQU0sQ0FBQ2lDO29CQUNuQlEsZ0JBQWdCLElBQUksQ0FBQ0Msa0JBQWtCO29CQUN2Q0Msa0JBQWtCLElBQUksQ0FBQ0Msb0JBQW9CO2dCQUM3QyxHQUFHLFNBQVVDLElBQUk7b0JBQ2YsSUFBSTdILElBQUk2SCxLQUFLN0gsQ0FBQztvQkFDZCxJQUFJOEgsV0FBV3pDLE9BQU9RLEdBQUcsQ0FBQyxTQUFVQyxLQUFLLEVBQUVpQyxLQUFLO3dCQUM5QyxJQUFJQyxPQUFPZCxjQUFjQSxVQUFVLENBQUNhLE1BQU07d0JBQzFDLElBQUlDLE1BQU07NEJBQ1IsSUFBSUMsaUJBQWlCLENBQUMsR0FBRzVJLFdBQVc2SSxpQkFBaUIsRUFBRUYsS0FBSzVCLEVBQUUsRUFBRU4sTUFBTU0sRUFBRTs0QkFDeEUsSUFBSStCLGlCQUFpQixDQUFDLEdBQUc5SSxXQUFXNkksaUJBQWlCLEVBQUVGLEtBQUszQixFQUFFLEVBQUVQLE1BQU1PLEVBQUU7NEJBQ3hFLElBQUkrQixtQkFBbUIsQ0FBQyxHQUFHL0ksV0FBVzZJLGlCQUFpQixFQUFFRixLQUFLMUIsSUFBSSxFQUFFUixNQUFNUSxJQUFJOzRCQUM5RSxPQUFPckUsY0FBY0EsY0FBYyxDQUFDLEdBQUc2RCxRQUFRLENBQUMsR0FBRztnQ0FDakRNLElBQUk2QixlQUFlakk7Z0NBQ25CcUcsSUFBSThCLGVBQWVuSTtnQ0FDbkJzRyxNQUFNOEIsaUJBQWlCcEk7NEJBQ3pCO3dCQUNGO3dCQUNBLElBQUlxSSxlQUFlLENBQUMsR0FBR2hKLFdBQVc2SSxpQkFBaUIsRUFBRSxHQUFHcEMsTUFBTVEsSUFBSTt3QkFDbEUsT0FBT3JFLGNBQWNBLGNBQWMsQ0FBQyxHQUFHNkQsUUFBUSxDQUFDLEdBQUc7NEJBQ2pEUSxNQUFNK0IsYUFBYXJJO3dCQUNyQjtvQkFDRjtvQkFDQSxPQUFPLFdBQVcsR0FBRTVCLE1BQU0sQ0FBQyxVQUFVLENBQUM2SCxhQUFhLENBQUNwSCxPQUFPcUgsS0FBSyxFQUFFLE1BQU1TLE9BQU92Qix1QkFBdUIsQ0FBQzBDO2dCQUN6RztZQUNGO1FBQ0Y7UUFBRztZQUNEckcsS0FBSztZQUNMdkQsT0FBTyxTQUFTb0s7Z0JBQ2QsSUFBSUMsZUFBZSxJQUFJLENBQUM1RixLQUFLLEVBQzNCMEMsU0FBU2tELGFBQWFsRCxNQUFNLEVBQzVCd0Isb0JBQW9CMEIsYUFBYTFCLGlCQUFpQjtnQkFDcEQsSUFBSUssYUFBYSxJQUFJLENBQUNDLEtBQUssQ0FBQ0QsVUFBVTtnQkFDdEMsSUFBSUwscUJBQXFCeEIsVUFBVUEsT0FBTzlELE1BQU0sSUFBSyxFQUFDMkYsY0FBYyxDQUFDLENBQUMsR0FBR3hJLFFBQVEsQ0FBQyxVQUFVLEVBQUV3SSxZQUFZN0IsT0FBTSxHQUFJO29CQUNsSCxPQUFPLElBQUksQ0FBQ3FCLDBCQUEwQjtnQkFDeEM7Z0JBQ0EsT0FBTyxJQUFJLENBQUN0Qix1QkFBdUIsQ0FBQ0M7WUFDdEM7UUFDRjtRQUFHO1lBQ0Q1RCxLQUFLO1lBQ0x2RCxPQUFPLFNBQVNzSztnQkFDZCxJQUFJM0Isb0JBQW9CLElBQUksQ0FBQ2xFLEtBQUssQ0FBQ2tFLGlCQUFpQjtnQkFDcEQsSUFBSUEscUJBQXFCLENBQUMsSUFBSSxDQUFDTSxLQUFLLENBQUNsQyxtQkFBbUIsRUFBRTtvQkFDeEQsT0FBTztnQkFDVDtnQkFDQSxJQUFJd0QsZUFBZSxJQUFJLENBQUM5RixLQUFLLEVBQzNCMEMsU0FBU29ELGFBQWFwRCxNQUFNLEVBQzVCcUQsUUFBUUQsYUFBYUMsS0FBSyxFQUMxQkMsUUFBUUYsYUFBYUUsS0FBSyxFQUMxQkMsV0FBV0gsYUFBYUcsUUFBUTtnQkFDbEMsSUFBSUMsZ0JBQWdCLENBQUMsR0FBRzlKLFlBQVkrSixhQUFhLEVBQUVGLFVBQVV6SixVQUFVNEosUUFBUTtnQkFDL0UsSUFBSSxDQUFDRixlQUFlO29CQUNsQixPQUFPO2dCQUNUO2dCQUNBLE9BQU9BLGNBQWNoRCxHQUFHLENBQUMsU0FBVW1ELElBQUksRUFBRXJJLENBQUM7b0JBQ3hDLElBQUlzSSxjQUFjRCxLQUFLckcsS0FBSyxFQUMxQnVHLFlBQVlELFlBQVlDLFNBQVMsRUFDakNDLGVBQWVGLFlBQVlHLE9BQU87b0JBQ3BDLE9BQU8sV0FBVyxHQUFFaEwsTUFBTSxDQUFDLFVBQVUsQ0FBQ2lMLFlBQVksQ0FBQ0wsTUFBTTt3QkFDdkR2SCxLQUFLLEdBQUd1RCxNQUFNLENBQUNrRSxXQUFXLEtBQUtsRSxNQUFNLENBQUNtRSxjQUFjLEtBQUtuRSxNQUFNLENBQUNLLE1BQU0sQ0FBQzFFLEVBQUU7d0JBQ3pFMkksTUFBTWpFO3dCQUNOcUQsT0FBT0E7d0JBQ1BDLE9BQU9BO3dCQUNQWSxRQUFRTCxjQUFjLE1BQU0sYUFBYTt3QkFDekNNLG9CQUFvQixTQUFTQSxtQkFBbUJDLFNBQVMsRUFBRUwsT0FBTzs0QkFDaEUsT0FBTztnQ0FDTE0sR0FBR0QsVUFBVXJELEVBQUU7Z0NBQ2Z1RCxHQUFHRixVQUFVcEQsRUFBRTtnQ0FDZm5JLE9BQU9nTCxjQUFjLE1BQU0sQ0FBQ08sVUFBVUcsSUFBSSxDQUFDRixDQUFDLEdBQUcsQ0FBQ0QsVUFBVUcsSUFBSSxDQUFDRCxDQUFDO2dDQUNoRUUsVUFBVSxDQUFDLEdBQUd2SyxZQUFZd0ssaUJBQWlCLEVBQUVMLFdBQVdMOzRCQUMxRDt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFBRztZQUNEM0gsS0FBSztZQUNMdkQsT0FBTyxTQUFTNkw7Z0JBQ2QsSUFBSUMsZUFBZSxJQUFJLENBQUNySCxLQUFLLEVBQzNCMEMsU0FBUzJFLGFBQWEzRSxNQUFNLEVBQzVCNEUsT0FBT0QsYUFBYUMsSUFBSSxFQUN4QkMsV0FBV0YsYUFBYUUsUUFBUSxFQUNoQ0MsZ0JBQWdCSCxhQUFhRyxhQUFhO2dCQUM1QyxJQUFJQyxlQUFlLENBQUMsR0FBR3JMLFlBQVk2RyxXQUFXLEVBQUUsSUFBSSxDQUFDakQsS0FBSyxFQUFFO2dCQUM1RCxJQUFJMEgsa0JBQWtCLENBQUMsR0FBR3RMLFlBQVk2RyxXQUFXLEVBQUVxRSxNQUFNO2dCQUN6RCxJQUFJSyxZQUFZQztnQkFDaEIsSUFBSUwsYUFBYSxTQUFTO29CQUN4QkksYUFBYWpGLE9BQU9RLEdBQUcsQ0FBQyxTQUFVQyxLQUFLO3dCQUNyQyxPQUFPOzRCQUNMNEQsR0FBRzVELE1BQU1NLEVBQUU7NEJBQ1h1RCxHQUFHN0QsTUFBTU8sRUFBRTt3QkFDYjtvQkFDRjtnQkFDRixPQUFPLElBQUk2RCxhQUFhLFdBQVc7b0JBQ2pDLElBQUlNLHVCQUF1QixDQUFDLEdBQUduTCxXQUFXb0wsbUJBQW1CLEVBQUVwRixTQUM3RHFGLE9BQU9GLHFCQUFxQkUsSUFBSSxFQUNoQ0MsT0FBT0gscUJBQXFCRyxJQUFJLEVBQ2hDckssSUFBSWtLLHFCQUFxQmxLLENBQUMsRUFDMUJzSyxJQUFJSixxQkFBcUJJLENBQUM7b0JBQzVCLElBQUlDLFlBQVksU0FBU0EsVUFBVW5CLENBQUM7d0JBQ2xDLE9BQU9wSixJQUFJb0osSUFBSWtCO29CQUNqQjtvQkFDQU4sYUFBYTt3QkFBQzs0QkFDWlosR0FBR2dCOzRCQUNIZixHQUFHa0IsVUFBVUg7d0JBQ2Y7d0JBQUc7NEJBQ0RoQixHQUFHaUI7NEJBQ0hoQixHQUFHa0IsVUFBVUY7d0JBQ2Y7cUJBQUU7Z0JBQ0o7Z0JBQ0EsSUFBSUcsWUFBWTdJLGNBQWNBLGNBQWNBLGNBQWMsQ0FBQyxHQUFHbUksZUFBZSxDQUFDLEdBQUc7b0JBQy9FVyxNQUFNO29CQUNOQyxRQUFRWixnQkFBZ0JBLGFBQWFXLElBQUk7Z0JBQzNDLEdBQUdWLGtCQUFrQixDQUFDLEdBQUc7b0JBQ3ZCaEYsUUFBUWlGO2dCQUNWO2dCQUNBLElBQUssV0FBVyxHQUFFbE0sTUFBTSxDQUFDLFVBQVUsQ0FBQzZNLGNBQWMsQ0FBQ2hCLE9BQU87b0JBQ3hETSxXQUFXLFdBQVcsR0FBRW5NLE1BQU0sQ0FBQyxVQUFVLENBQUNpTCxZQUFZLENBQUNZLE1BQU1hO2dCQUMvRCxPQUFPLElBQUksQ0FBQyxHQUFHbk0sV0FBVyxDQUFDLFVBQVUsRUFBRXNMLE9BQU87b0JBQzVDTSxXQUFXTixLQUFLYTtnQkFDbEIsT0FBTztvQkFDTFAsV0FBVyxXQUFXLEdBQUVuTSxNQUFNLENBQUMsVUFBVSxDQUFDNkgsYUFBYSxDQUFDL0csT0FBT2dNLEtBQUssRUFBRWhLLFNBQVMsQ0FBQyxHQUFHNEosV0FBVzt3QkFDNUZLLE1BQU1oQjtvQkFDUjtnQkFDRjtnQkFDQSxPQUFPLFdBQVcsR0FBRS9MLE1BQU0sQ0FBQyxVQUFVLENBQUM2SCxhQUFhLENBQUNwSCxPQUFPcUgsS0FBSyxFQUFFO29CQUNoRUMsV0FBVztvQkFDWDFFLEtBQUs7Z0JBQ1AsR0FBRzhJO1lBQ0w7UUFDRjtRQUFHO1lBQ0Q5SSxLQUFLO1lBQ0x2RCxPQUFPLFNBQVNrTjtnQkFDZCxJQUFJQyxlQUFlLElBQUksQ0FBQzFJLEtBQUssRUFDM0IySSxPQUFPRCxhQUFhQyxJQUFJLEVBQ3hCakcsU0FBU2dHLGFBQWFoRyxNQUFNLEVBQzVCNEUsT0FBT29CLGFBQWFwQixJQUFJLEVBQ3hCOUQsWUFBWWtGLGFBQWFsRixTQUFTLEVBQ2xDdUMsUUFBUTJDLGFBQWEzQyxLQUFLLEVBQzFCQyxRQUFRMEMsYUFBYTFDLEtBQUssRUFDMUI0QyxPQUFPRixhQUFhRSxJQUFJLEVBQ3hCQyxNQUFNSCxhQUFhRyxHQUFHLEVBQ3RCQyxRQUFRSixhQUFhSSxLQUFLLEVBQzFCQyxTQUFTTCxhQUFhSyxNQUFNLEVBQzVCQyxLQUFLTixhQUFhTSxFQUFFLEVBQ3BCOUUsb0JBQW9Cd0UsYUFBYXhFLGlCQUFpQjtnQkFDcEQsSUFBSXlFLFFBQVEsQ0FBQ2pHLFVBQVUsQ0FBQ0EsT0FBTzlELE1BQU0sRUFBRTtvQkFDckMsT0FBTztnQkFDVDtnQkFDQSxJQUFJMEQsc0JBQXNCLElBQUksQ0FBQ2tDLEtBQUssQ0FBQ2xDLG1CQUFtQjtnQkFDeEQsSUFBSTJHLGFBQWEsQ0FBQyxHQUFHaE4sS0FBSyxDQUFDLFVBQVUsRUFBRSxvQkFBb0J1SDtnQkFDM0QsSUFBSTBGLFlBQVluRCxTQUFTQSxNQUFNb0QsaUJBQWlCO2dCQUNoRCxJQUFJQyxZQUFZcEQsU0FBU0EsTUFBTW1ELGlCQUFpQjtnQkFDaEQsSUFBSUUsV0FBV0gsYUFBYUU7Z0JBQzVCLElBQUlFLGFBQWEsQ0FBQyxHQUFHeE4sTUFBTSxDQUFDLFVBQVUsRUFBRWtOLE1BQU0sSUFBSSxDQUFDQSxFQUFFLEdBQUdBO2dCQUN4RCxPQUFPLFdBQVcsR0FBRXZOLE1BQU0sQ0FBQyxVQUFVLENBQUM2SCxhQUFhLENBQUNwSCxPQUFPcUgsS0FBSyxFQUFFO29CQUNoRUMsV0FBV3lGO29CQUNYTSxVQUFVRixXQUFXLGlCQUFpQmhILE1BQU0sQ0FBQ2lILFlBQVksT0FBTztnQkFDbEUsR0FBR0osYUFBYUUsWUFBWSxXQUFXLEdBQUUzTixNQUFNLENBQUMsVUFBVSxDQUFDNkgsYUFBYSxDQUFDLFFBQVEsTUFBTSxXQUFXLEdBQUU3SCxNQUFNLENBQUMsVUFBVSxDQUFDNkgsYUFBYSxDQUFDLFlBQVk7b0JBQzlJMEYsSUFBSSxZQUFZM0csTUFBTSxDQUFDaUg7Z0JBQ3pCLEdBQUcsV0FBVyxHQUFFN04sTUFBTSxDQUFDLFVBQVUsQ0FBQzZILGFBQWEsQ0FBQyxRQUFRO29CQUN0RHlELEdBQUdtQyxZQUFZTixPQUFPQSxPQUFPRSxRQUFRO29CQUNyQzlCLEdBQUdvQyxZQUFZUCxNQUFNQSxNQUFNRSxTQUFTO29CQUNwQ0QsT0FBT0ksWUFBWUosUUFBUUEsUUFBUTtvQkFDbkNDLFFBQVFLLFlBQVlMLFNBQVNBLFNBQVM7Z0JBQ3hDLE9BQU8sTUFBTXpCLFFBQVEsSUFBSSxDQUFDRixVQUFVLElBQUksSUFBSSxDQUFDdkIsY0FBYyxJQUFJLFdBQVcsR0FBRXBLLE1BQU0sQ0FBQyxVQUFVLENBQUM2SCxhQUFhLENBQUNwSCxPQUFPcUgsS0FBSyxFQUFFO29CQUN4SHpFLEtBQUs7Z0JBQ1AsR0FBRyxJQUFJLENBQUM2RyxhQUFhLEtBQUssQ0FBQyxDQUFDekIscUJBQXFCNUIsbUJBQWtCLEtBQU1uRyxXQUFXcU4sU0FBUyxDQUFDQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUN6SixLQUFLLEVBQUUwQztZQUMvSDtRQUNGO0tBQUUsRUFBRTtRQUFDO1lBQ0g1RCxLQUFLO1lBQ0x2RCxPQUFPLFNBQVNtTyx5QkFBeUJDLFNBQVMsRUFBRUMsU0FBUztnQkFDM0QsSUFBSUQsVUFBVXJGLFdBQVcsS0FBS3NGLFVBQVVDLGVBQWUsRUFBRTtvQkFDdkQsT0FBTzt3QkFDTEEsaUJBQWlCRixVQUFVckYsV0FBVzt3QkFDdEN3RixXQUFXSCxVQUFVakgsTUFBTTt3QkFDM0I2QixZQUFZcUYsVUFBVUUsU0FBUztvQkFDakM7Z0JBQ0Y7Z0JBQ0EsSUFBSUgsVUFBVWpILE1BQU0sS0FBS2tILFVBQVVFLFNBQVMsRUFBRTtvQkFDNUMsT0FBTzt3QkFDTEEsV0FBV0gsVUFBVWpILE1BQU07b0JBQzdCO2dCQUNGO2dCQUNBLE9BQU87WUFDVDtRQUNGO0tBQUU7QUFDSixFQUFFakgsT0FBT3NPLGFBQWE7QUFDdEJqTixXQUFXdEI7QUFDWGdFLGdCQUFnQmhFLFNBQVMsZUFBZTtBQUN4Q2dFLGdCQUFnQmhFLFNBQVMsZ0JBQWdCO0lBQ3ZDd08sU0FBUztJQUNUQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsWUFBWTtJQUNaNUMsVUFBVTtJQUNWQyxlQUFlO0lBQ2ZiLE1BQU0sRUFBRTtJQUNSOUQsT0FBTztJQUNQOEYsTUFBTTtJQUNOekUsbUJBQW1CLENBQUM3SCxRQUFRK04sTUFBTSxDQUFDQyxLQUFLO0lBQ3hDbEcsZ0JBQWdCO0lBQ2hCQyxtQkFBbUI7SUFDbkJDLGlCQUFpQjtBQUNuQjtBQUNBOzs7Ozs7Q0FNQyxHQUNEN0UsZ0JBQWdCaEUsU0FBUyxtQkFBbUIsU0FBVThPLEtBQUs7SUFDekQsSUFBSXZFLFFBQVF1RSxNQUFNdkUsS0FBSyxFQUNyQkMsUUFBUXNFLE1BQU10RSxLQUFLLEVBQ25CdUUsUUFBUUQsTUFBTUMsS0FBSyxFQUNuQmxFLE9BQU9pRSxNQUFNakUsSUFBSSxFQUNqQm1FLGdCQUFnQkYsTUFBTUUsYUFBYSxFQUNuQ0MsYUFBYUgsTUFBTUcsVUFBVSxFQUM3QkMsYUFBYUosTUFBTUksVUFBVSxFQUM3QkMsU0FBU0wsTUFBTUssTUFBTTtJQUN2QixJQUFJQyxjQUFjdkUsS0FBS3JHLEtBQUssQ0FBQzRLLFdBQVc7SUFDeEMsSUFBSUMsUUFBUSxDQUFDLEdBQUd6TyxZQUFZK0osYUFBYSxFQUFFRSxLQUFLckcsS0FBSyxDQUFDaUcsUUFBUSxFQUFFeEosTUFBTXFPLElBQUk7SUFDMUUsSUFBSUMsZUFBZSxDQUFDLEdBQUdqUCxNQUFNLENBQUMsVUFBVSxFQUFFaUssTUFBTVUsT0FBTyxJQUFJSixLQUFLckcsS0FBSyxDQUFDeUcsT0FBTyxHQUFHVixNQUFNVSxPQUFPO0lBQzdGLElBQUl1RSxlQUFlLENBQUMsR0FBR2xQLE1BQU0sQ0FBQyxVQUFVLEVBQUVrSyxNQUFNUyxPQUFPLElBQUlKLEtBQUtyRyxLQUFLLENBQUN5RyxPQUFPLEdBQUdULE1BQU1TLE9BQU87SUFDN0YsSUFBSXdFLGVBQWVWLFNBQVNBLE1BQU05RCxPQUFPO0lBQ3pDLElBQUl5RSxnQkFBZ0JYLFFBQVFBLE1BQU1ZLEtBQUssR0FBRzdPLE9BQU84TyxLQUFLLENBQUNDLFlBQVksQ0FBQ0YsS0FBSztJQUN6RSxJQUFJRyxXQUFXSixpQkFBaUJBLGFBQWEsQ0FBQyxFQUFFO0lBQ2hELElBQUlLLFlBQVl4RixNQUFNeUYsS0FBSyxDQUFDQyxTQUFTLEdBQUcxRixNQUFNeUYsS0FBSyxDQUFDQyxTQUFTLEtBQUs7SUFDbEUsSUFBSUMsWUFBWTFGLE1BQU13RixLQUFLLENBQUNDLFNBQVMsR0FBR3pGLE1BQU13RixLQUFLLENBQUNDLFNBQVMsS0FBSztJQUNsRSxJQUFJL0ksU0FBUzhILGNBQWN0SCxHQUFHLENBQUMsU0FBVUMsS0FBSyxFQUFFaUMsS0FBSztRQUNuRCxJQUFJMkIsSUFBSSxDQUFDLEdBQUdwSyxZQUFZd0ssaUJBQWlCLEVBQUVoRSxPQUFPNEg7UUFDbEQsSUFBSS9ELElBQUksQ0FBQyxHQUFHckssWUFBWXdLLGlCQUFpQixFQUFFaEUsT0FBTzZIO1FBQ2xELElBQUlXLElBQUksQ0FBQyxDQUFDLEdBQUc3UCxNQUFNLENBQUMsVUFBVSxFQUFFbVAsaUJBQWlCLENBQUMsR0FBR3RPLFlBQVl3SyxpQkFBaUIsRUFBRWhFLE9BQU84SCxpQkFBaUI7UUFDNUcsSUFBSVcsaUJBQWlCO1lBQUM7Z0JBQ3BCQyxNQUFNLENBQUMsR0FBRy9QLE1BQU0sQ0FBQyxVQUFVLEVBQUVpSyxNQUFNVSxPQUFPLElBQUlKLEtBQUtyRyxLQUFLLENBQUM2TCxJQUFJLEdBQUc5RixNQUFNOEYsSUFBSSxJQUFJOUYsTUFBTVUsT0FBTztnQkFDM0ZxRixNQUFNL0YsTUFBTStGLElBQUksSUFBSTtnQkFDcEJ2USxPQUFPd0w7Z0JBQ1BnRixTQUFTNUk7Z0JBQ1RzRCxTQUFTc0U7Z0JBQ1R2QyxNQUFNb0M7WUFDUjtZQUFHO2dCQUNEaUIsTUFBTSxDQUFDLEdBQUcvUCxNQUFNLENBQUMsVUFBVSxFQUFFa0ssTUFBTVMsT0FBTyxJQUFJSixLQUFLckcsS0FBSyxDQUFDNkwsSUFBSSxHQUFHN0YsTUFBTTZGLElBQUksSUFBSTdGLE1BQU1TLE9BQU87Z0JBQzNGcUYsTUFBTTlGLE1BQU04RixJQUFJLElBQUk7Z0JBQ3BCdlEsT0FBT3lMO2dCQUNQK0UsU0FBUzVJO2dCQUNUc0QsU0FBU3VFO2dCQUNUeEMsTUFBTW9DO1lBQ1I7U0FBRTtRQUNGLElBQUllLE1BQU0sS0FBSztZQUNiQyxlQUFldk0sSUFBSSxDQUFDO2dCQUNsQndNLE1BQU10QixNQUFNc0IsSUFBSSxJQUFJdEIsTUFBTTlELE9BQU87Z0JBQ2pDcUYsTUFBTXZCLE1BQU11QixJQUFJLElBQUk7Z0JBQ3BCdlEsT0FBT29RO2dCQUNQSSxTQUFTNUk7Z0JBQ1RzRCxTQUFTd0U7Z0JBQ1R6QyxNQUFNb0M7WUFDUjtRQUNGO1FBQ0EsSUFBSW5ILEtBQUssQ0FBQyxHQUFHOUcsWUFBWXFQLHVCQUF1QixFQUFFO1lBQ2hEQyxNQUFNbEc7WUFDTm1HLE9BQU96QjtZQUNQMEIsVUFBVVo7WUFDVnBJLE9BQU9BO1lBQ1BpQyxPQUFPQTtZQUNQcUIsU0FBU3NFO1FBQ1g7UUFDQSxJQUFJckgsS0FBSyxDQUFDLEdBQUcvRyxZQUFZcVAsdUJBQXVCLEVBQUU7WUFDaERDLE1BQU1qRztZQUNOa0csT0FBT3hCO1lBQ1B5QixVQUFVVDtZQUNWdkksT0FBT0E7WUFDUGlDLE9BQU9BO1lBQ1BxQixTQUFTdUU7UUFDWDtRQUNBLElBQUlySCxPQUFPZ0ksTUFBTSxNQUFNcEIsTUFBTWlCLEtBQUssQ0FBQ0csS0FBS0w7UUFDeEMsSUFBSWMsU0FBU0MsS0FBS0MsSUFBSSxDQUFDRCxLQUFLRSxHQUFHLENBQUM1SSxNQUFNLEtBQUswSSxLQUFLRyxFQUFFO1FBQ2xELE9BQU9sTixjQUFjQSxjQUFjLENBQUMsR0FBRzZELFFBQVEsQ0FBQyxHQUFHO1lBQ2pETSxJQUFJQTtZQUNKQyxJQUFJQTtZQUNKcUQsR0FBR3RELEtBQUsySTtZQUNScEYsR0FBR3RELEtBQUswSTtZQUNSckcsT0FBT0E7WUFDUEMsT0FBT0E7WUFDUHVFLE9BQU9BO1lBQ1B6QixPQUFPLElBQUlzRDtZQUNYckQsUUFBUSxJQUFJcUQ7WUFDWnpJLE1BQU1BO1lBQ05zRCxNQUFNO2dCQUNKRixHQUFHQTtnQkFDSEMsR0FBR0E7Z0JBQ0gyRSxHQUFHQTtZQUNMO1lBQ0FDLGdCQUFnQkE7WUFDaEJhLGlCQUFpQjtnQkFDZjFGLEdBQUd0RDtnQkFDSHVELEdBQUd0RDtZQUNMO1lBQ0FxSSxTQUFTNUk7UUFDWCxHQUFHMEgsU0FBU0EsS0FBSyxDQUFDekYsTUFBTSxJQUFJeUYsS0FBSyxDQUFDekYsTUFBTSxDQUFDcEYsS0FBSztJQUNoRDtJQUNBLE9BQU9WLGNBQWM7UUFDbkJvRCxRQUFRQTtJQUNWLEdBQUdpSTtBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9jYXJ0ZXNpYW4vU2NhdHRlci5qcz85MmFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5TY2F0dGVyID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3JlYWN0U21vb3RoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3Qtc21vb3RoXCIpKTtcbnZhciBfaXNOaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNOaWxcIikpO1xudmFyIF9pc0VxdWFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRXF1YWxcIikpO1xudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX0xheWVyID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9MYXllclwiKTtcbnZhciBfTGFiZWxMaXN0ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbExpc3RcIik7XG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xudmFyIF9HbG9iYWwgPSByZXF1aXJlKFwiLi4vdXRpbC9HbG9iYWxcIik7XG52YXIgX1pBeGlzID0gcmVxdWlyZShcIi4vWkF4aXNcIik7XG52YXIgX0N1cnZlID0gcmVxdWlyZShcIi4uL3NoYXBlL0N1cnZlXCIpO1xudmFyIF9FcnJvckJhciA9IHJlcXVpcmUoXCIuL0Vycm9yQmFyXCIpO1xudmFyIF9DZWxsID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9DZWxsXCIpO1xudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XG52YXIgX0NoYXJ0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9DaGFydFV0aWxzXCIpO1xudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi91dGlsL3R5cGVzXCIpO1xudmFyIF9TY2F0dGVyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9TY2F0dGVyVXRpbHNcIik7XG52YXIgX1NjYXR0ZXI7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFJlbmRlciBhIGdyb3VwIG9mIHNjYXR0ZXJzXG4gKi9cbnZhciBTY2F0dGVyID0gZXhwb3J0cy5TY2F0dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBmdW5jdGlvbiBTY2F0dGVyKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2NhdHRlcik7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgU2NhdHRlciwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwic3RhdGVcIiwge1xuICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogZmFsc2VcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQW5pbWF0aW9uRW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZUFuaW1hdGlvblN0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpZFwiLCAoMCwgX0RhdGFVdGlscy51bmlxdWVJZCkoJ3JlY2hhcnRzLXNjYXR0ZXItJykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoU2NhdHRlciwgX1B1cmVDb21wb25lbnQpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFNjYXR0ZXIsIFt7XG4gICAga2V5OiBcInJlbmRlclN5bWJvbHNTdGF0aWNhbGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclN5bWJvbHNTdGF0aWNhbGx5KHBvaW50cykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBzaGFwZSA9IF90aGlzJHByb3BzLnNoYXBlLFxuICAgICAgICBhY3RpdmVTaGFwZSA9IF90aGlzJHByb3BzLmFjdGl2ZVNoYXBlLFxuICAgICAgICBhY3RpdmVJbmRleCA9IF90aGlzJHByb3BzLmFjdGl2ZUluZGV4O1xuICAgICAgdmFyIGJhc2VQcm9wcyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykodGhpcy5wcm9wcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHBvaW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gICAgICAgIHZhciBpc0FjdGl2ZSA9IGFjdGl2ZUluZGV4ID09PSBpO1xuICAgICAgICB2YXIgb3B0aW9uID0gaXNBY3RpdmUgPyBhY3RpdmVTaGFwZSA6IHNoYXBlO1xuICAgICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGJhc2VQcm9wcyksIGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXNjYXR0ZXItc3ltYm9sXCJcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICAgICAgLFxuICAgICAgICAgIGtleTogXCJzeW1ib2wtXCIuY29uY2F0KGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS5jeCwgXCItXCIpLmNvbmNhdChlbnRyeSA9PT0gbnVsbCB8fCBlbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW50cnkuY3ksIFwiLVwiKS5jb25jYXQoZW50cnkgPT09IG51bGwgfHwgZW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVudHJ5LnNpemUsIFwiLVwiKS5jb25jYXQoaSlcbiAgICAgICAgfSwgKDAsIF90eXBlcy5hZGFwdEV2ZW50c09mQ2hpbGQpKF90aGlzMi5wcm9wcywgZW50cnksIGkpLCB7XG4gICAgICAgICAgcm9sZTogXCJpbWdcIlxuICAgICAgICB9KSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfU2NhdHRlclV0aWxzLlNjYXR0ZXJTeW1ib2wsIF9leHRlbmRzKHtcbiAgICAgICAgICBvcHRpb246IG9wdGlvbixcbiAgICAgICAgICBpc0FjdGl2ZTogaXNBY3RpdmVcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICAgICAgLFxuICAgICAgICAgIGtleTogXCJzeW1ib2wtXCIuY29uY2F0KGkpXG4gICAgICAgIH0sIHByb3BzKSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclN5bWJvbHNXaXRoQW5pbWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclN5bWJvbHNXaXRoQW5pbWF0aW9uKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgcG9pbnRzID0gX3RoaXMkcHJvcHMyLnBvaW50cyxcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczIuaXNBbmltYXRpb25BY3RpdmUsXG4gICAgICAgIGFuaW1hdGlvbkJlZ2luID0gX3RoaXMkcHJvcHMyLmFuaW1hdGlvbkJlZ2luLFxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbiA9IF90aGlzJHByb3BzMi5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nID0gX3RoaXMkcHJvcHMyLmFuaW1hdGlvbkVhc2luZyxcbiAgICAgICAgYW5pbWF0aW9uSWQgPSBfdGhpcyRwcm9wczIuYW5pbWF0aW9uSWQ7XG4gICAgICB2YXIgcHJldlBvaW50cyA9IHRoaXMuc3RhdGUucHJldlBvaW50cztcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9yZWFjdFNtb290aFtcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgYmVnaW46IGFuaW1hdGlvbkJlZ2luLFxuICAgICAgICBkdXJhdGlvbjogYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgIGlzQWN0aXZlOiBpc0FuaW1hdGlvbkFjdGl2ZSxcbiAgICAgICAgZWFzaW5nOiBhbmltYXRpb25FYXNpbmcsXG4gICAgICAgIGZyb206IHtcbiAgICAgICAgICB0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHRvOiB7XG4gICAgICAgICAgdDogMVxuICAgICAgICB9LFxuICAgICAgICBrZXk6IFwicGllLVwiLmNvbmNhdChhbmltYXRpb25JZCksXG4gICAgICAgIG9uQW5pbWF0aW9uRW5kOiB0aGlzLmhhbmRsZUFuaW1hdGlvbkVuZCxcbiAgICAgICAgb25BbmltYXRpb25TdGFydDogdGhpcy5oYW5kbGVBbmltYXRpb25TdGFydFxuICAgICAgfSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHQgPSBfcmVmLnQ7XG4gICAgICAgIHZhciBzdGVwRGF0YSA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xuICAgICAgICAgIHZhciBwcmV2ID0gcHJldlBvaW50cyAmJiBwcmV2UG9pbnRzW2luZGV4XTtcbiAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgdmFyIGludGVycG9sYXRvckN4ID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXYuY3gsIGVudHJ5LmN4KTtcbiAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JDeSA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2LmN5LCBlbnRyeS5jeSk7XG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yU2l6ZSA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2LnNpemUsIGVudHJ5LnNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xuICAgICAgICAgICAgICBjeDogaW50ZXJwb2xhdG9yQ3godCksXG4gICAgICAgICAgICAgIGN5OiBpbnRlcnBvbGF0b3JDeSh0KSxcbiAgICAgICAgICAgICAgc2l6ZTogaW50ZXJwb2xhdG9yU2l6ZSh0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3IgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikoMCwgZW50cnkuc2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xuICAgICAgICAgICAgc2l6ZTogaW50ZXJwb2xhdG9yKHQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIG51bGwsIF90aGlzMy5yZW5kZXJTeW1ib2xzU3RhdGljYWxseShzdGVwRGF0YSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclN5bWJvbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyU3ltYm9scygpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICBwb2ludHMgPSBfdGhpcyRwcm9wczMucG9pbnRzLFxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzMy5pc0FuaW1hdGlvbkFjdGl2ZTtcbiAgICAgIHZhciBwcmV2UG9pbnRzID0gdGhpcy5zdGF0ZS5wcmV2UG9pbnRzO1xuICAgICAgaWYgKGlzQW5pbWF0aW9uQWN0aXZlICYmIHBvaW50cyAmJiBwb2ludHMubGVuZ3RoICYmICghcHJldlBvaW50cyB8fCAhKDAsIF9pc0VxdWFsW1wiZGVmYXVsdFwiXSkocHJldlBvaW50cywgcG9pbnRzKSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyU3ltYm9sc1dpdGhBbmltYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclN5bWJvbHNTdGF0aWNhbGx5KHBvaW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckVycm9yQmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckVycm9yQmFyKCkge1xuICAgICAgdmFyIGlzQW5pbWF0aW9uQWN0aXZlID0gdGhpcy5wcm9wcy5pc0FuaW1hdGlvbkFjdGl2ZTtcbiAgICAgIGlmIChpc0FuaW1hdGlvbkFjdGl2ZSAmJiAhdGhpcy5zdGF0ZS5pc0FuaW1hdGlvbkZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzNC5wb2ludHMsXG4gICAgICAgIHhBeGlzID0gX3RoaXMkcHJvcHM0LnhBeGlzLFxuICAgICAgICB5QXhpcyA9IF90aGlzJHByb3BzNC55QXhpcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczQuY2hpbGRyZW47XG4gICAgICB2YXIgZXJyb3JCYXJJdGVtcyA9ICgwLCBfUmVhY3RVdGlscy5maW5kQWxsQnlUeXBlKShjaGlsZHJlbiwgX0Vycm9yQmFyLkVycm9yQmFyKTtcbiAgICAgIGlmICghZXJyb3JCYXJJdGVtcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvckJhckl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICB2YXIgX2l0ZW0kcHJvcHMgPSBpdGVtLnByb3BzLFxuICAgICAgICAgIGRpcmVjdGlvbiA9IF9pdGVtJHByb3BzLmRpcmVjdGlvbixcbiAgICAgICAgICBlcnJvckRhdGFLZXkgPSBfaXRlbSRwcm9wcy5kYXRhS2V5O1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGl0ZW0sIHtcbiAgICAgICAgICBrZXk6IFwiXCIuY29uY2F0KGRpcmVjdGlvbiwgXCItXCIpLmNvbmNhdChlcnJvckRhdGFLZXksIFwiLVwiKS5jb25jYXQocG9pbnRzW2ldKSxcbiAgICAgICAgICBkYXRhOiBwb2ludHMsXG4gICAgICAgICAgeEF4aXM6IHhBeGlzLFxuICAgICAgICAgIHlBeGlzOiB5QXhpcyxcbiAgICAgICAgICBsYXlvdXQ6IGRpcmVjdGlvbiA9PT0gJ3gnID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJyxcbiAgICAgICAgICBkYXRhUG9pbnRGb3JtYXR0ZXI6IGZ1bmN0aW9uIGRhdGFQb2ludEZvcm1hdHRlcihkYXRhUG9pbnQsIGRhdGFLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHg6IGRhdGFQb2ludC5jeCxcbiAgICAgICAgICAgICAgeTogZGF0YVBvaW50LmN5LFxuICAgICAgICAgICAgICB2YWx1ZTogZGlyZWN0aW9uID09PSAneCcgPyArZGF0YVBvaW50Lm5vZGUueCA6ICtkYXRhUG9pbnQubm9kZS55LFxuICAgICAgICAgICAgICBlcnJvclZhbDogKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShkYXRhUG9pbnQsIGRhdGFLZXkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJMaW5lKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzNS5wb2ludHMsXG4gICAgICAgIGxpbmUgPSBfdGhpcyRwcm9wczUubGluZSxcbiAgICAgICAgbGluZVR5cGUgPSBfdGhpcyRwcm9wczUubGluZVR5cGUsXG4gICAgICAgIGxpbmVKb2ludFR5cGUgPSBfdGhpcyRwcm9wczUubGluZUpvaW50VHlwZTtcbiAgICAgIHZhciBzY2F0dGVyUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIGZhbHNlKTtcbiAgICAgIHZhciBjdXN0b21MaW5lUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKGxpbmUsIGZhbHNlKTtcbiAgICAgIHZhciBsaW5lUG9pbnRzLCBsaW5lSXRlbTtcbiAgICAgIGlmIChsaW5lVHlwZSA9PT0gJ2pvaW50Jykge1xuICAgICAgICBsaW5lUG9pbnRzID0gcG9pbnRzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogZW50cnkuY3gsXG4gICAgICAgICAgICB5OiBlbnRyeS5jeVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChsaW5lVHlwZSA9PT0gJ2ZpdHRpbmcnKSB7XG4gICAgICAgIHZhciBfZ2V0TGluZWFyUmVncmVzc2lvbiA9ICgwLCBfRGF0YVV0aWxzLmdldExpbmVhclJlZ3Jlc3Npb24pKHBvaW50cyksXG4gICAgICAgICAgeG1pbiA9IF9nZXRMaW5lYXJSZWdyZXNzaW9uLnhtaW4sXG4gICAgICAgICAgeG1heCA9IF9nZXRMaW5lYXJSZWdyZXNzaW9uLnhtYXgsXG4gICAgICAgICAgYSA9IF9nZXRMaW5lYXJSZWdyZXNzaW9uLmEsXG4gICAgICAgICAgYiA9IF9nZXRMaW5lYXJSZWdyZXNzaW9uLmI7XG4gICAgICAgIHZhciBsaW5lYXJFeHAgPSBmdW5jdGlvbiBsaW5lYXJFeHAoeCkge1xuICAgICAgICAgIHJldHVybiBhICogeCArIGI7XG4gICAgICAgIH07XG4gICAgICAgIGxpbmVQb2ludHMgPSBbe1xuICAgICAgICAgIHg6IHhtaW4sXG4gICAgICAgICAgeTogbGluZWFyRXhwKHhtaW4pXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiB4bWF4LFxuICAgICAgICAgIHk6IGxpbmVhckV4cCh4bWF4KVxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc2NhdHRlclByb3BzKSwge30sIHtcbiAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICBzdHJva2U6IHNjYXR0ZXJQcm9wcyAmJiBzY2F0dGVyUHJvcHMuZmlsbFxuICAgICAgfSwgY3VzdG9tTGluZVByb3BzKSwge30sIHtcbiAgICAgICAgcG9pbnRzOiBsaW5lUG9pbnRzXG4gICAgICB9KTtcbiAgICAgIGlmICggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQobGluZSkpIHtcbiAgICAgICAgbGluZUl0ZW0gPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQobGluZSwgbGluZVByb3BzKTtcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkobGluZSkpIHtcbiAgICAgICAgbGluZUl0ZW0gPSBsaW5lKGxpbmVQcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lSXRlbSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0N1cnZlLkN1cnZlLCBfZXh0ZW5kcyh7fSwgbGluZVByb3BzLCB7XG4gICAgICAgICAgdHlwZTogbGluZUpvaW50VHlwZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXNjYXR0ZXItbGluZVwiLFxuICAgICAgICBrZXk6IFwicmVjaGFydHMtc2NhdHRlci1saW5lXCJcbiAgICAgIH0sIGxpbmVJdGVtKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczYgPSB0aGlzLnByb3BzLFxuICAgICAgICBoaWRlID0gX3RoaXMkcHJvcHM2LmhpZGUsXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzNi5wb2ludHMsXG4gICAgICAgIGxpbmUgPSBfdGhpcyRwcm9wczYubGluZSxcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHM2LmNsYXNzTmFtZSxcbiAgICAgICAgeEF4aXMgPSBfdGhpcyRwcm9wczYueEF4aXMsXG4gICAgICAgIHlBeGlzID0gX3RoaXMkcHJvcHM2LnlBeGlzLFxuICAgICAgICBsZWZ0ID0gX3RoaXMkcHJvcHM2LmxlZnQsXG4gICAgICAgIHRvcCA9IF90aGlzJHByb3BzNi50b3AsXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM2LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczYuaGVpZ2h0LFxuICAgICAgICBpZCA9IF90aGlzJHByb3BzNi5pZCxcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczYuaXNBbmltYXRpb25BY3RpdmU7XG4gICAgICBpZiAoaGlkZSB8fCAhcG9pbnRzIHx8ICFwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGlzQW5pbWF0aW9uRmluaXNoZWQgPSB0aGlzLnN0YXRlLmlzQW5pbWF0aW9uRmluaXNoZWQ7XG4gICAgICB2YXIgbGF5ZXJDbGFzcyA9ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1zY2F0dGVyJywgY2xhc3NOYW1lKTtcbiAgICAgIHZhciBuZWVkQ2xpcFggPSB4QXhpcyAmJiB4QXhpcy5hbGxvd0RhdGFPdmVyZmxvdztcbiAgICAgIHZhciBuZWVkQ2xpcFkgPSB5QXhpcyAmJiB5QXhpcy5hbGxvd0RhdGFPdmVyZmxvdztcbiAgICAgIHZhciBuZWVkQ2xpcCA9IG5lZWRDbGlwWCB8fCBuZWVkQ2xpcFk7XG4gICAgICB2YXIgY2xpcFBhdGhJZCA9ICgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShpZCkgPyB0aGlzLmlkIDogaWQ7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBsYXllckNsYXNzLFxuICAgICAgICBjbGlwUGF0aDogbmVlZENsaXAgPyBcInVybCgjY2xpcFBhdGgtXCIuY29uY2F0KGNsaXBQYXRoSWQsIFwiKVwiKSA6IG51bGxcbiAgICAgIH0sIG5lZWRDbGlwWCB8fCBuZWVkQ2xpcFkgPyAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwge1xuICAgICAgICBpZDogXCJjbGlwUGF0aC1cIi5jb25jYXQoY2xpcFBhdGhJZClcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICAgICAgeDogbmVlZENsaXBYID8gbGVmdCA6IGxlZnQgLSB3aWR0aCAvIDIsXG4gICAgICAgIHk6IG5lZWRDbGlwWSA/IHRvcCA6IHRvcCAtIGhlaWdodCAvIDIsXG4gICAgICAgIHdpZHRoOiBuZWVkQ2xpcFggPyB3aWR0aCA6IHdpZHRoICogMixcbiAgICAgICAgaGVpZ2h0OiBuZWVkQ2xpcFkgPyBoZWlnaHQgOiBoZWlnaHQgKiAyXG4gICAgICB9KSkpIDogbnVsbCwgbGluZSAmJiB0aGlzLnJlbmRlckxpbmUoKSwgdGhpcy5yZW5kZXJFcnJvckJhcigpLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xuICAgICAgICBrZXk6IFwicmVjaGFydHMtc2NhdHRlci1zeW1ib2xzXCJcbiAgICAgIH0sIHRoaXMucmVuZGVyU3ltYm9scygpKSwgKCFpc0FuaW1hdGlvbkFjdGl2ZSB8fCBpc0FuaW1hdGlvbkZpbmlzaGVkKSAmJiBfTGFiZWxMaXN0LkxhYmVsTGlzdC5yZW5kZXJDYWxsQnlQYXJlbnQodGhpcy5wcm9wcywgcG9pbnRzKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgaWYgKG5leHRQcm9wcy5hbmltYXRpb25JZCAhPT0gcHJldlN0YXRlLnByZXZBbmltYXRpb25JZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByZXZBbmltYXRpb25JZDogbmV4dFByb3BzLmFuaW1hdGlvbklkLFxuICAgICAgICAgIGN1clBvaW50czogbmV4dFByb3BzLnBvaW50cyxcbiAgICAgICAgICBwcmV2UG9pbnRzOiBwcmV2U3RhdGUuY3VyUG9pbnRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAobmV4dFByb3BzLnBvaW50cyAhPT0gcHJldlN0YXRlLmN1clBvaW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGN1clBvaW50czogbmV4dFByb3BzLnBvaW50c1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XSk7XG59KF9yZWFjdC5QdXJlQ29tcG9uZW50KTtcbl9TY2F0dGVyID0gU2NhdHRlcjtcbl9kZWZpbmVQcm9wZXJ0eShTY2F0dGVyLCBcImRpc3BsYXlOYW1lXCIsICdTY2F0dGVyJyk7XG5fZGVmaW5lUHJvcGVydHkoU2NhdHRlciwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICB4QXhpc0lkOiAwLFxuICB5QXhpc0lkOiAwLFxuICB6QXhpc0lkOiAwLFxuICBsZWdlbmRUeXBlOiAnY2lyY2xlJyxcbiAgbGluZVR5cGU6ICdqb2ludCcsXG4gIGxpbmVKb2ludFR5cGU6ICdsaW5lYXInLFxuICBkYXRhOiBbXSxcbiAgc2hhcGU6ICdjaXJjbGUnLFxuICBoaWRlOiBmYWxzZSxcbiAgaXNBbmltYXRpb25BY3RpdmU6ICFfR2xvYmFsLkdsb2JhbC5pc1NzcixcbiAgYW5pbWF0aW9uQmVnaW46IDAsXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA0MDAsXG4gIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcidcbn0pO1xuLyoqXG4gKiBDb21wb3NlIHRoZSBkYXRhIG9mIGVhY2ggZ3JvdXBcbiAqIEBwYXJhbSAge09iamVjdH0geEF4aXMgICBUaGUgY29uZmlndXJhdGlvbiBvZiB4LWF4aXNcbiAqIEBwYXJhbSAge09iamVjdH0geUF4aXMgICBUaGUgY29uZmlndXJhdGlvbiBvZiB5LWF4aXNcbiAqIEBwYXJhbSAge1N0cmluZ30gZGF0YUtleSBUaGUgdW5pcXVlIGtleSBvZiBhIGdyb3VwXG4gKiBAcmV0dXJuIHtBcnJheX0gIENvbXBvc2VkIGRhdGFcbiAqL1xuX2RlZmluZVByb3BlcnR5KFNjYXR0ZXIsIFwiZ2V0Q29tcG9zZWREYXRhXCIsIGZ1bmN0aW9uIChfcmVmMikge1xuICB2YXIgeEF4aXMgPSBfcmVmMi54QXhpcyxcbiAgICB5QXhpcyA9IF9yZWYyLnlBeGlzLFxuICAgIHpBeGlzID0gX3JlZjIuekF4aXMsXG4gICAgaXRlbSA9IF9yZWYyLml0ZW0sXG4gICAgZGlzcGxheWVkRGF0YSA9IF9yZWYyLmRpc3BsYXllZERhdGEsXG4gICAgeEF4aXNUaWNrcyA9IF9yZWYyLnhBeGlzVGlja3MsXG4gICAgeUF4aXNUaWNrcyA9IF9yZWYyLnlBeGlzVGlja3MsXG4gICAgb2Zmc2V0ID0gX3JlZjIub2Zmc2V0O1xuICB2YXIgdG9vbHRpcFR5cGUgPSBpdGVtLnByb3BzLnRvb2x0aXBUeXBlO1xuICB2YXIgY2VsbHMgPSAoMCwgX1JlYWN0VXRpbHMuZmluZEFsbEJ5VHlwZSkoaXRlbS5wcm9wcy5jaGlsZHJlbiwgX0NlbGwuQ2VsbCk7XG4gIHZhciB4QXhpc0RhdGFLZXkgPSAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoeEF4aXMuZGF0YUtleSkgPyBpdGVtLnByb3BzLmRhdGFLZXkgOiB4QXhpcy5kYXRhS2V5O1xuICB2YXIgeUF4aXNEYXRhS2V5ID0gKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKHlBeGlzLmRhdGFLZXkpID8gaXRlbS5wcm9wcy5kYXRhS2V5IDogeUF4aXMuZGF0YUtleTtcbiAgdmFyIHpBeGlzRGF0YUtleSA9IHpBeGlzICYmIHpBeGlzLmRhdGFLZXk7XG4gIHZhciBkZWZhdWx0UmFuZ2VaID0gekF4aXMgPyB6QXhpcy5yYW5nZSA6IF9aQXhpcy5aQXhpcy5kZWZhdWx0UHJvcHMucmFuZ2U7XG4gIHZhciBkZWZhdWx0WiA9IGRlZmF1bHRSYW5nZVogJiYgZGVmYXVsdFJhbmdlWlswXTtcbiAgdmFyIHhCYW5kU2l6ZSA9IHhBeGlzLnNjYWxlLmJhbmR3aWR0aCA/IHhBeGlzLnNjYWxlLmJhbmR3aWR0aCgpIDogMDtcbiAgdmFyIHlCYW5kU2l6ZSA9IHlBeGlzLnNjYWxlLmJhbmR3aWR0aCA/IHlBeGlzLnNjYWxlLmJhbmR3aWR0aCgpIDogMDtcbiAgdmFyIHBvaW50cyA9IGRpc3BsYXllZERhdGEubWFwKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcbiAgICB2YXIgeCA9ICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkoZW50cnksIHhBeGlzRGF0YUtleSk7XG4gICAgdmFyIHkgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0VmFsdWVCeURhdGFLZXkpKGVudHJ5LCB5QXhpc0RhdGFLZXkpO1xuICAgIHZhciB6ID0gISgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKSh6QXhpc0RhdGFLZXkpICYmICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkoZW50cnksIHpBeGlzRGF0YUtleSkgfHwgJy0nO1xuICAgIHZhciB0b29sdGlwUGF5bG9hZCA9IFt7XG4gICAgICBuYW1lOiAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoeEF4aXMuZGF0YUtleSkgPyBpdGVtLnByb3BzLm5hbWUgOiB4QXhpcy5uYW1lIHx8IHhBeGlzLmRhdGFLZXksXG4gICAgICB1bml0OiB4QXhpcy51bml0IHx8ICcnLFxuICAgICAgdmFsdWU6IHgsXG4gICAgICBwYXlsb2FkOiBlbnRyeSxcbiAgICAgIGRhdGFLZXk6IHhBeGlzRGF0YUtleSxcbiAgICAgIHR5cGU6IHRvb2x0aXBUeXBlXG4gICAgfSwge1xuICAgICAgbmFtZTogKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKHlBeGlzLmRhdGFLZXkpID8gaXRlbS5wcm9wcy5uYW1lIDogeUF4aXMubmFtZSB8fCB5QXhpcy5kYXRhS2V5LFxuICAgICAgdW5pdDogeUF4aXMudW5pdCB8fCAnJyxcbiAgICAgIHZhbHVlOiB5LFxuICAgICAgcGF5bG9hZDogZW50cnksXG4gICAgICBkYXRhS2V5OiB5QXhpc0RhdGFLZXksXG4gICAgICB0eXBlOiB0b29sdGlwVHlwZVxuICAgIH1dO1xuICAgIGlmICh6ICE9PSAnLScpIHtcbiAgICAgIHRvb2x0aXBQYXlsb2FkLnB1c2goe1xuICAgICAgICBuYW1lOiB6QXhpcy5uYW1lIHx8IHpBeGlzLmRhdGFLZXksXG4gICAgICAgIHVuaXQ6IHpBeGlzLnVuaXQgfHwgJycsXG4gICAgICAgIHZhbHVlOiB6LFxuICAgICAgICBwYXlsb2FkOiBlbnRyeSxcbiAgICAgICAgZGF0YUtleTogekF4aXNEYXRhS2V5LFxuICAgICAgICB0eXBlOiB0b29sdGlwVHlwZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBjeCA9ICgwLCBfQ2hhcnRVdGlscy5nZXRDYXRlQ29vcmRpbmF0ZU9mTGluZSkoe1xuICAgICAgYXhpczogeEF4aXMsXG4gICAgICB0aWNrczogeEF4aXNUaWNrcyxcbiAgICAgIGJhbmRTaXplOiB4QmFuZFNpemUsXG4gICAgICBlbnRyeTogZW50cnksXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBkYXRhS2V5OiB4QXhpc0RhdGFLZXlcbiAgICB9KTtcbiAgICB2YXIgY3kgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0Q2F0ZUNvb3JkaW5hdGVPZkxpbmUpKHtcbiAgICAgIGF4aXM6IHlBeGlzLFxuICAgICAgdGlja3M6IHlBeGlzVGlja3MsXG4gICAgICBiYW5kU2l6ZTogeUJhbmRTaXplLFxuICAgICAgZW50cnk6IGVudHJ5LFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgZGF0YUtleTogeUF4aXNEYXRhS2V5XG4gICAgfSk7XG4gICAgdmFyIHNpemUgPSB6ICE9PSAnLScgPyB6QXhpcy5zY2FsZSh6KSA6IGRlZmF1bHRaO1xuICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoTWF0aC5tYXgoc2l6ZSwgMCkgLyBNYXRoLlBJKTtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XG4gICAgICBjeDogY3gsXG4gICAgICBjeTogY3ksXG4gICAgICB4OiBjeCAtIHJhZGl1cyxcbiAgICAgIHk6IGN5IC0gcmFkaXVzLFxuICAgICAgeEF4aXM6IHhBeGlzLFxuICAgICAgeUF4aXM6IHlBeGlzLFxuICAgICAgekF4aXM6IHpBeGlzLFxuICAgICAgd2lkdGg6IDIgKiByYWRpdXMsXG4gICAgICBoZWlnaHQ6IDIgKiByYWRpdXMsXG4gICAgICBzaXplOiBzaXplLFxuICAgICAgbm9kZToge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB6OiB6XG4gICAgICB9LFxuICAgICAgdG9vbHRpcFBheWxvYWQ6IHRvb2x0aXBQYXlsb2FkLFxuICAgICAgdG9vbHRpcFBvc2l0aW9uOiB7XG4gICAgICAgIHg6IGN4LFxuICAgICAgICB5OiBjeVxuICAgICAgfSxcbiAgICAgIHBheWxvYWQ6IGVudHJ5XG4gICAgfSwgY2VsbHMgJiYgY2VsbHNbaW5kZXhdICYmIGNlbGxzW2luZGV4XS5wcm9wcyk7XG4gIH0pO1xuICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgcG9pbnRzOiBwb2ludHNcbiAgfSwgb2Zmc2V0KTtcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNjYXR0ZXIiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfcmVhY3RTbW9vdGgiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2lzTmlsIiwiX2lzRXF1YWwiLCJfaXNGdW5jdGlvbiIsIl9jbHN4IiwiX0xheWVyIiwiX0xhYmVsTGlzdCIsIl9SZWFjdFV0aWxzIiwiX0dsb2JhbCIsIl9aQXhpcyIsIl9DdXJ2ZSIsIl9FcnJvckJhciIsIl9DZWxsIiwiX0RhdGFVdGlscyIsIl9DaGFydFV0aWxzIiwiX3R5cGVzIiwiX1NjYXR0ZXJVdGlscyIsIl9TY2F0dGVyIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfdHlwZW9mIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaSIsInNldCIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiYXBwbHkiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJfUHVyZUNvbXBvbmVudCIsIl90aGlzIiwiX2xlbiIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJjb25jYXQiLCJpc0FuaW1hdGlvbkZpbmlzaGVkIiwic2V0U3RhdGUiLCJ1bmlxdWVJZCIsInJlbmRlclN5bWJvbHNTdGF0aWNhbGx5IiwicG9pbnRzIiwiX3RoaXMyIiwiX3RoaXMkcHJvcHMiLCJzaGFwZSIsImFjdGl2ZVNoYXBlIiwiYWN0aXZlSW5kZXgiLCJiYXNlUHJvcHMiLCJmaWx0ZXJQcm9wcyIsIm1hcCIsImVudHJ5IiwiaXNBY3RpdmUiLCJvcHRpb24iLCJjcmVhdGVFbGVtZW50IiwiTGF5ZXIiLCJjbGFzc05hbWUiLCJjeCIsImN5Iiwic2l6ZSIsImFkYXB0RXZlbnRzT2ZDaGlsZCIsInJvbGUiLCJTY2F0dGVyU3ltYm9sIiwicmVuZGVyU3ltYm9sc1dpdGhBbmltYXRpb24iLCJfdGhpczMiLCJfdGhpcyRwcm9wczIiLCJpc0FuaW1hdGlvbkFjdGl2ZSIsImFuaW1hdGlvbkJlZ2luIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJhbmltYXRpb25FYXNpbmciLCJhbmltYXRpb25JZCIsInByZXZQb2ludHMiLCJzdGF0ZSIsImJlZ2luIiwiZHVyYXRpb24iLCJlYXNpbmciLCJmcm9tIiwidG8iLCJvbkFuaW1hdGlvbkVuZCIsImhhbmRsZUFuaW1hdGlvbkVuZCIsIm9uQW5pbWF0aW9uU3RhcnQiLCJoYW5kbGVBbmltYXRpb25TdGFydCIsIl9yZWYiLCJzdGVwRGF0YSIsImluZGV4IiwicHJldiIsImludGVycG9sYXRvckN4IiwiaW50ZXJwb2xhdGVOdW1iZXIiLCJpbnRlcnBvbGF0b3JDeSIsImludGVycG9sYXRvclNpemUiLCJpbnRlcnBvbGF0b3IiLCJyZW5kZXJTeW1ib2xzIiwiX3RoaXMkcHJvcHMzIiwicmVuZGVyRXJyb3JCYXIiLCJfdGhpcyRwcm9wczQiLCJ4QXhpcyIsInlBeGlzIiwiY2hpbGRyZW4iLCJlcnJvckJhckl0ZW1zIiwiZmluZEFsbEJ5VHlwZSIsIkVycm9yQmFyIiwiaXRlbSIsIl9pdGVtJHByb3BzIiwiZGlyZWN0aW9uIiwiZXJyb3JEYXRhS2V5IiwiZGF0YUtleSIsImNsb25lRWxlbWVudCIsImRhdGEiLCJsYXlvdXQiLCJkYXRhUG9pbnRGb3JtYXR0ZXIiLCJkYXRhUG9pbnQiLCJ4IiwieSIsIm5vZGUiLCJlcnJvclZhbCIsImdldFZhbHVlQnlEYXRhS2V5IiwicmVuZGVyTGluZSIsIl90aGlzJHByb3BzNSIsImxpbmUiLCJsaW5lVHlwZSIsImxpbmVKb2ludFR5cGUiLCJzY2F0dGVyUHJvcHMiLCJjdXN0b21MaW5lUHJvcHMiLCJsaW5lUG9pbnRzIiwibGluZUl0ZW0iLCJfZ2V0TGluZWFyUmVncmVzc2lvbiIsImdldExpbmVhclJlZ3Jlc3Npb24iLCJ4bWluIiwieG1heCIsImIiLCJsaW5lYXJFeHAiLCJsaW5lUHJvcHMiLCJmaWxsIiwic3Ryb2tlIiwiaXNWYWxpZEVsZW1lbnQiLCJDdXJ2ZSIsInR5cGUiLCJyZW5kZXIiLCJfdGhpcyRwcm9wczYiLCJoaWRlIiwibGVmdCIsInRvcCIsIndpZHRoIiwiaGVpZ2h0IiwiaWQiLCJsYXllckNsYXNzIiwibmVlZENsaXBYIiwiYWxsb3dEYXRhT3ZlcmZsb3ciLCJuZWVkQ2xpcFkiLCJuZWVkQ2xpcCIsImNsaXBQYXRoSWQiLCJjbGlwUGF0aCIsIkxhYmVsTGlzdCIsInJlbmRlckNhbGxCeVBhcmVudCIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIm5leHRQcm9wcyIsInByZXZTdGF0ZSIsInByZXZBbmltYXRpb25JZCIsImN1clBvaW50cyIsIlB1cmVDb21wb25lbnQiLCJ4QXhpc0lkIiwieUF4aXNJZCIsInpBeGlzSWQiLCJsZWdlbmRUeXBlIiwiR2xvYmFsIiwiaXNTc3IiLCJfcmVmMiIsInpBeGlzIiwiZGlzcGxheWVkRGF0YSIsInhBeGlzVGlja3MiLCJ5QXhpc1RpY2tzIiwib2Zmc2V0IiwidG9vbHRpcFR5cGUiLCJjZWxscyIsIkNlbGwiLCJ4QXhpc0RhdGFLZXkiLCJ5QXhpc0RhdGFLZXkiLCJ6QXhpc0RhdGFLZXkiLCJkZWZhdWx0UmFuZ2VaIiwicmFuZ2UiLCJaQXhpcyIsImRlZmF1bHRQcm9wcyIsImRlZmF1bHRaIiwieEJhbmRTaXplIiwic2NhbGUiLCJiYW5kd2lkdGgiLCJ5QmFuZFNpemUiLCJ6IiwidG9vbHRpcFBheWxvYWQiLCJuYW1lIiwidW5pdCIsInBheWxvYWQiLCJnZXRDYXRlQ29vcmRpbmF0ZU9mTGluZSIsImF4aXMiLCJ0aWNrcyIsImJhbmRTaXplIiwicmFkaXVzIiwiTWF0aCIsInNxcnQiLCJtYXgiLCJQSSIsInRvb2x0aXBQb3NpdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/Scatter.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/cartesian/XAxis.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/XAxis.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.XAxis = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _chartLayoutContext = __webpack_require__(/*! ../context/chartLayoutContext */ \"./node_modules/recharts/lib/context/chartLayoutContext.js\");\nvar _CartesianAxis = __webpack_require__(/*! ./CartesianAxis */ \"./node_modules/recharts/lib/cartesian/CartesianAxis.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n} /**\n * @fileOverview X Axis\n */ \n/** Define of XAxis props */ function XAxisImpl(_ref) {\n    var xAxisId = _ref.xAxisId;\n    var width = (0, _chartLayoutContext.useChartWidth)();\n    var height = (0, _chartLayoutContext.useChartHeight)();\n    var axisOptions = (0, _chartLayoutContext.useXAxisOrThrow)(xAxisId);\n    if (axisOptions == null) {\n        return null;\n    }\n    return(/*#__PURE__*/ // @ts-expect-error the axisOptions type is not exactly what CartesianAxis is expecting.\n    _react[\"default\"].createElement(_CartesianAxis.CartesianAxis, _extends({}, axisOptions, {\n        className: (0, _clsx[\"default\"])(\"recharts-\".concat(axisOptions.axisType, \" \").concat(axisOptions.axisType), axisOptions.className),\n        viewBox: {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n        },\n        ticksGenerator: function ticksGenerator(axis) {\n            return (0, _ChartUtils.getTicksOfAxis)(axis, true);\n        }\n    })));\n}\n// eslint-disable-next-line react/prefer-stateless-function -- requires static defaultProps\nvar XAxis = exports.XAxis = /*#__PURE__*/ function(_React$Component) {\n    function XAxis() {\n        _classCallCheck(this, XAxis);\n        return _callSuper(this, XAxis, arguments);\n    }\n    _inherits(XAxis, _React$Component);\n    return _createClass(XAxis, [\n        {\n            key: \"render\",\n            value: function render() {\n                return /*#__PURE__*/ _react[\"default\"].createElement(XAxisImpl, this.props);\n            }\n        }\n    ]);\n}(_react[\"default\"].Component);\n_defineProperty(XAxis, \"displayName\", \"XAxis\");\n_defineProperty(XAxis, \"defaultProps\", {\n    allowDecimals: true,\n    hide: false,\n    orientation: \"bottom\",\n    width: 0,\n    height: 30,\n    mirror: false,\n    xAxisId: 0,\n    tickCount: 5,\n    type: \"category\",\n    padding: {\n        left: 0,\n        right: 0\n    },\n    allowDataOverflow: false,\n    scale: \"auto\",\n    reversed: false,\n    allowDuplicatedCategory: true\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9YQXhpcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VEssOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGFBQWEsR0FBRyxLQUFLO0FBQ3JCLElBQUlHLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDbkQsSUFBSUMsUUFBUUYsdUJBQXVCQyxtQkFBT0EsQ0FBQyxrQkFBTTtBQUNqRCxJQUFJRSxzQkFBc0JGLG1CQUFPQSxDQUFDLGdHQUErQjtBQUNqRSxJQUFJRyxpQkFBaUJILG1CQUFPQSxDQUFDLCtFQUFpQjtBQUM5QyxJQUFJSSxjQUFjSixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsU0FBU0QsdUJBQXVCTSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLGdCQUFnQkMsUUFBUSxFQUFFQyxXQUFXO0lBQUksSUFBSSxDQUFFRCxDQUFBQSxvQkFBb0JDLFdBQVUsR0FBSTtRQUFFLE1BQU0sSUFBSUMsVUFBVTtJQUFzQztBQUFFO0FBQ3hKLFNBQVNDLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSztRQUFFLElBQUlFLGFBQWFILEtB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SUFDQWQsVUFBVS9DLE9BQU9vRjtJQUNqQixPQUFPM0QsYUFBYXpCLE9BQU87UUFBQztZQUMxQndCLEtBQUs7WUFDTHpCLE9BQU8sU0FBU3NGO2dCQUNkLE9BQU8sV0FBVyxHQUFFcEYsTUFBTSxDQUFDLFVBQVUsQ0FBQ3dFLGFBQWEsQ0FBQ1QsV0FBVyxJQUFJLENBQUNoRCxLQUFLO1lBQzNFO1FBQ0Y7S0FBRTtBQUNKLEVBQUVmLE1BQU0sQ0FBQyxVQUFVLENBQUNxRixTQUFTO0FBQzdCakMsZ0JBQWdCckQsT0FBTyxlQUFlO0FBQ3RDcUQsZ0JBQWdCckQsT0FBTyxnQkFBZ0I7SUFDckN1RixlQUFlO0lBQ2ZDLE1BQU07SUFDTkMsYUFBYTtJQUNidEIsT0FBTztJQUNQRSxRQUFRO0lBQ1JxQixRQUFRO0lBQ1J4QixTQUFTO0lBQ1R5QixXQUFXO0lBQ1hDLE1BQU07SUFDTkMsU0FBUztRQUNQQyxNQUFNO1FBQ05DLE9BQU87SUFDVDtJQUNBQyxtQkFBbUI7SUFDbkJDLE9BQU87SUFDUEMsVUFBVTtJQUNWQyx5QkFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9YQXhpcy5qcz83NGJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5YQXhpcyA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfY2hhcnRMYXlvdXRDb250ZXh0ID0gcmVxdWlyZShcIi4uL2NvbnRleHQvY2hhcnRMYXlvdXRDb250ZXh0XCIpO1xudmFyIF9DYXJ0ZXNpYW5BeGlzID0gcmVxdWlyZShcIi4vQ2FydGVzaWFuQXhpc1wiKTtcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSAvKipcbiAqIEBmaWxlT3ZlcnZpZXcgWCBBeGlzXG4gKi9cbi8qKiBEZWZpbmUgb2YgWEF4aXMgcHJvcHMgKi9cblxuZnVuY3Rpb24gWEF4aXNJbXBsKF9yZWYpIHtcbiAgdmFyIHhBeGlzSWQgPSBfcmVmLnhBeGlzSWQ7XG4gIHZhciB3aWR0aCA9ICgwLCBfY2hhcnRMYXlvdXRDb250ZXh0LnVzZUNoYXJ0V2lkdGgpKCk7XG4gIHZhciBoZWlnaHQgPSAoMCwgX2NoYXJ0TGF5b3V0Q29udGV4dC51c2VDaGFydEhlaWdodCkoKTtcbiAgdmFyIGF4aXNPcHRpb25zID0gKDAsIF9jaGFydExheW91dENvbnRleHQudXNlWEF4aXNPclRocm93KSh4QXhpc0lkKTtcbiAgaWYgKGF4aXNPcHRpb25zID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSBheGlzT3B0aW9ucyB0eXBlIGlzIG5vdCBleGFjdGx5IHdoYXQgQ2FydGVzaWFuQXhpcyBpcyBleHBlY3RpbmcuXG4gICAgX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9DYXJ0ZXNpYW5BeGlzLkNhcnRlc2lhbkF4aXMsIF9leHRlbmRzKHt9LCBheGlzT3B0aW9ucywge1xuICAgICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKShcInJlY2hhcnRzLVwiLmNvbmNhdChheGlzT3B0aW9ucy5heGlzVHlwZSwgXCIgXCIpLmNvbmNhdChheGlzT3B0aW9ucy5heGlzVHlwZSksIGF4aXNPcHRpb25zLmNsYXNzTmFtZSksXG4gICAgICB2aWV3Qm94OiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0sXG4gICAgICB0aWNrc0dlbmVyYXRvcjogZnVuY3Rpb24gdGlja3NHZW5lcmF0b3IoYXhpcykge1xuICAgICAgICByZXR1cm4gKDAsIF9DaGFydFV0aWxzLmdldFRpY2tzT2ZBeGlzKShheGlzLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KSlcbiAgKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb24gLS0gcmVxdWlyZXMgc3RhdGljIGRlZmF1bHRQcm9wc1xudmFyIFhBeGlzID0gZXhwb3J0cy5YQXhpcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBmdW5jdGlvbiBYQXhpcygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWEF4aXMpO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIFhBeGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhYQXhpcywgX1JlYWN0JENvbXBvbmVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoWEF4aXMsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChYQXhpc0ltcGwsIHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfV0pO1xufShfcmVhY3RbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5fZGVmaW5lUHJvcGVydHkoWEF4aXMsIFwiZGlzcGxheU5hbWVcIiwgJ1hBeGlzJyk7XG5fZGVmaW5lUHJvcGVydHkoWEF4aXMsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgYWxsb3dEZWNpbWFsczogdHJ1ZSxcbiAgaGlkZTogZmFsc2UsXG4gIG9yaWVudGF0aW9uOiAnYm90dG9tJyxcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMzAsXG4gIG1pcnJvcjogZmFsc2UsXG4gIHhBeGlzSWQ6IDAsXG4gIHRpY2tDb3VudDogNSxcbiAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgcGFkZGluZzoge1xuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDBcbiAgfSxcbiAgYWxsb3dEYXRhT3ZlcmZsb3c6IGZhbHNlLFxuICBzY2FsZTogJ2F1dG8nLFxuICByZXZlcnNlZDogZmFsc2UsXG4gIGFsbG93RHVwbGljYXRlZENhdGVnb3J5OiB0cnVlXG59KTsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJYQXhpcyIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2Nsc3giLCJfY2hhcnRMYXlvdXRDb250ZXh0IiwiX0NhcnRlc2lhbkF4aXMiLCJfQ2hhcnRVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwidCIsImUiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiYXBwbHkiLCJzZWxmIiwiY2FsbCIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsImJpbmQiLCJfX3Byb3RvX18iLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwiX2RlZmluZVByb3BlcnR5IiwiX3RvUHJpbWl0aXZlIiwiciIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJoYXNPd25Qcm9wZXJ0eSIsIlhBeGlzSW1wbCIsIl9yZWYiLCJ4QXhpc0lkIiwid2lkdGgiLCJ1c2VDaGFydFdpZHRoIiwiaGVpZ2h0IiwidXNlQ2hhcnRIZWlnaHQiLCJheGlzT3B0aW9ucyIsInVzZVhBeGlzT3JUaHJvdyIsImNyZWF0ZUVsZW1lbnQiLCJDYXJ0ZXNpYW5BeGlzIiwiY2xhc3NOYW1lIiwiY29uY2F0IiwiYXhpc1R5cGUiLCJ2aWV3Qm94IiwieCIsInkiLCJ0aWNrc0dlbmVyYXRvciIsImF4aXMiLCJnZXRUaWNrc09mQXhpcyIsIl9SZWFjdCRDb21wb25lbnQiLCJyZW5kZXIiLCJDb21wb25lbnQiLCJhbGxvd0RlY2ltYWxzIiwiaGlkZSIsIm9yaWVudGF0aW9uIiwibWlycm9yIiwidGlja0NvdW50IiwidHlwZSIsInBhZGRpbmciLCJsZWZ0IiwicmlnaHQiLCJhbGxvd0RhdGFPdmVyZmxvdyIsInNjYWxlIiwicmV2ZXJzZWQiLCJhbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/XAxis.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/cartesian/YAxis.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/YAxis.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.YAxis = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _chartLayoutContext = __webpack_require__(/*! ../context/chartLayoutContext */ \"./node_modules/recharts/lib/context/chartLayoutContext.js\");\nvar _CartesianAxis = __webpack_require__(/*! ./CartesianAxis */ \"./node_modules/recharts/lib/cartesian/CartesianAxis.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n} /**\n * @fileOverview Y Axis\n */ \nvar YAxisImpl = function YAxisImpl(_ref) {\n    var yAxisId = _ref.yAxisId;\n    var width = (0, _chartLayoutContext.useChartWidth)();\n    var height = (0, _chartLayoutContext.useChartHeight)();\n    var axisOptions = (0, _chartLayoutContext.useYAxisOrThrow)(yAxisId);\n    if (axisOptions == null) {\n        return null;\n    }\n    return(/*#__PURE__*/ // @ts-expect-error the axisOptions type is not exactly what CartesianAxis is expecting.\n    _react[\"default\"].createElement(_CartesianAxis.CartesianAxis, _extends({}, axisOptions, {\n        className: (0, _clsx[\"default\"])(\"recharts-\".concat(axisOptions.axisType, \" \").concat(axisOptions.axisType), axisOptions.className),\n        viewBox: {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n        },\n        ticksGenerator: function ticksGenerator(axis) {\n            return (0, _ChartUtils.getTicksOfAxis)(axis, true);\n        }\n    })));\n};\n// eslint-disable-next-line react/prefer-stateless-function -- requires static defaultProps\nvar YAxis = exports.YAxis = /*#__PURE__*/ function(_React$Component) {\n    function YAxis() {\n        _classCallCheck(this, YAxis);\n        return _callSuper(this, YAxis, arguments);\n    }\n    _inherits(YAxis, _React$Component);\n    return _createClass(YAxis, [\n        {\n            key: \"render\",\n            value: function render() {\n                return /*#__PURE__*/ _react[\"default\"].createElement(YAxisImpl, this.props);\n            }\n        }\n    ]);\n}(_react[\"default\"].Component);\n_defineProperty(YAxis, \"displayName\", \"YAxis\");\n_defineProperty(YAxis, \"defaultProps\", {\n    allowDuplicatedCategory: true,\n    allowDecimals: true,\n    hide: false,\n    orientation: \"left\",\n    width: 60,\n    height: 0,\n    mirror: false,\n    yAxisId: 0,\n    tickCount: 5,\n    type: \"number\",\n    padding: {\n        top: 0,\n        bottom: 0\n    },\n    allowDataOverflow: false,\n    scale: \"auto\",\n    reversed: false\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9ZQXhpcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VEssOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGFBQWEsR0FBRyxLQUFLO0FBQ3JCLElBQUlHLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDbkQsSUFBSUMsUUFBUUYsdUJBQXVCQyxtQkFBT0EsQ0FBQyxrQkFBTTtBQUNqRCxJQUFJRSxzQkFBc0JGLG1CQUFPQSxDQUFDLGdHQUErQjtBQUNqRSxJQUFJRyxpQkFBaUJILG1CQUFPQSxDQUFDLCtFQUFpQjtBQUM5QyxJQUFJSSxjQUFjSixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsU0FBU0QsdUJBQXVCTSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLGdCQUFnQkMsUUFBUSxFQUFFQyxXQUFXO0lBQUksSUFBSSxDQUFFRCxDQUFBQSxvQkFBb0JDLFdBQVUsR0FBSTtRQUFFLE1BQU0sSUFBSUMsVUFBVTtJQUFzQztBQUFFO0FBQ3hKLFNBQVNDLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSztRQUFFLElBQUlFLGFBQWFILEtB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Q0FkLFVBQVUvQyxPQUFPb0Y7SUFDakIsT0FBTzNELGFBQWF6QixPQUFPO1FBQUM7WUFDMUJ3QixLQUFLO1lBQ0x6QixPQUFPLFNBQVNzRjtnQkFDZCxPQUFPLFdBQVcsR0FBRXBGLE1BQU0sQ0FBQyxVQUFVLENBQUN3RSxhQUFhLENBQUNULFdBQVcsSUFBSSxDQUFDaEQsS0FBSztZQUMzRTtRQUNGO0tBQUU7QUFDSixFQUFFZixNQUFNLENBQUMsVUFBVSxDQUFDcUYsU0FBUztBQUM3QmpDLGdCQUFnQnJELE9BQU8sZUFBZTtBQUN0Q3FELGdCQUFnQnJELE9BQU8sZ0JBQWdCO0lBQ3JDdUYseUJBQXlCO0lBQ3pCQyxlQUFlO0lBQ2ZDLE1BQU07SUFDTkMsYUFBYTtJQUNidkIsT0FBTztJQUNQRSxRQUFRO0lBQ1JzQixRQUFRO0lBQ1J6QixTQUFTO0lBQ1QwQixXQUFXO0lBQ1hDLE1BQU07SUFDTkMsU0FBUztRQUNQQyxLQUFLO1FBQ0xDLFFBQVE7SUFDVjtJQUNBQyxtQkFBbUI7SUFDbkJDLE9BQU87SUFDUEMsVUFBVTtBQUNaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9jYXJ0ZXNpYW4vWUF4aXMuanM/MTI5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuWUF4aXMgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX2NoYXJ0TGF5b3V0Q29udGV4dCA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L2NoYXJ0TGF5b3V0Q29udGV4dFwiKTtcbnZhciBfQ2FydGVzaWFuQXhpcyA9IHJlcXVpcmUoXCIuL0NhcnRlc2lhbkF4aXNcIik7XG52YXIgX0NoYXJ0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9DaGFydFV0aWxzXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFkgQXhpc1xuICovXG52YXIgWUF4aXNJbXBsID0gZnVuY3Rpb24gWUF4aXNJbXBsKF9yZWYpIHtcbiAgdmFyIHlBeGlzSWQgPSBfcmVmLnlBeGlzSWQ7XG4gIHZhciB3aWR0aCA9ICgwLCBfY2hhcnRMYXlvdXRDb250ZXh0LnVzZUNoYXJ0V2lkdGgpKCk7XG4gIHZhciBoZWlnaHQgPSAoMCwgX2NoYXJ0TGF5b3V0Q29udGV4dC51c2VDaGFydEhlaWdodCkoKTtcbiAgdmFyIGF4aXNPcHRpb25zID0gKDAsIF9jaGFydExheW91dENvbnRleHQudXNlWUF4aXNPclRocm93KSh5QXhpc0lkKTtcbiAgaWYgKGF4aXNPcHRpb25zID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSBheGlzT3B0aW9ucyB0eXBlIGlzIG5vdCBleGFjdGx5IHdoYXQgQ2FydGVzaWFuQXhpcyBpcyBleHBlY3RpbmcuXG4gICAgX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9DYXJ0ZXNpYW5BeGlzLkNhcnRlc2lhbkF4aXMsIF9leHRlbmRzKHt9LCBheGlzT3B0aW9ucywge1xuICAgICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKShcInJlY2hhcnRzLVwiLmNvbmNhdChheGlzT3B0aW9ucy5heGlzVHlwZSwgXCIgXCIpLmNvbmNhdChheGlzT3B0aW9ucy5heGlzVHlwZSksIGF4aXNPcHRpb25zLmNsYXNzTmFtZSksXG4gICAgICB2aWV3Qm94OiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0sXG4gICAgICB0aWNrc0dlbmVyYXRvcjogZnVuY3Rpb24gdGlja3NHZW5lcmF0b3IoYXhpcykge1xuICAgICAgICByZXR1cm4gKDAsIF9DaGFydFV0aWxzLmdldFRpY2tzT2ZBeGlzKShheGlzLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KSlcbiAgKTtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9wcmVmZXItc3RhdGVsZXNzLWZ1bmN0aW9uIC0tIHJlcXVpcmVzIHN0YXRpYyBkZWZhdWx0UHJvcHNcbnZhciBZQXhpcyA9IGV4cG9ydHMuWUF4aXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgZnVuY3Rpb24gWUF4aXMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFlBeGlzKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBZQXhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoWUF4aXMsIF9SZWFjdCRDb21wb25lbnQpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFlBeGlzLCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoWUF4aXNJbXBsLCB0aGlzLnByb3BzKTtcbiAgICB9XG4gIH1dKTtcbn0oX3JlYWN0W1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO1xuX2RlZmluZVByb3BlcnR5KFlBeGlzLCBcImRpc3BsYXlOYW1lXCIsICdZQXhpcycpO1xuX2RlZmluZVByb3BlcnR5KFlBeGlzLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIGFsbG93RHVwbGljYXRlZENhdGVnb3J5OiB0cnVlLFxuICBhbGxvd0RlY2ltYWxzOiB0cnVlLFxuICBoaWRlOiBmYWxzZSxcbiAgb3JpZW50YXRpb246ICdsZWZ0JyxcbiAgd2lkdGg6IDYwLFxuICBoZWlnaHQ6IDAsXG4gIG1pcnJvcjogZmFsc2UsXG4gIHlBeGlzSWQ6IDAsXG4gIHRpY2tDb3VudDogNSxcbiAgdHlwZTogJ251bWJlcicsXG4gIHBhZGRpbmc6IHtcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiAwXG4gIH0sXG4gIGFsbG93RGF0YU92ZXJmbG93OiBmYWxzZSxcbiAgc2NhbGU6ICdhdXRvJyxcbiAgcmV2ZXJzZWQ6IGZhbHNlXG59KTsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJZQXhpcyIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2Nsc3giLCJfY2hhcnRMYXlvdXRDb250ZXh0IiwiX0NhcnRlc2lhbkF4aXMiLCJfQ2hhcnRVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwidCIsImUiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiYXBwbHkiLCJzZWxmIiwiY2FsbCIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsImJpbmQiLCJfX3Byb3RvX18iLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwiX2RlZmluZVByb3BlcnR5IiwiX3RvUHJpbWl0aXZlIiwiciIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJoYXNPd25Qcm9wZXJ0eSIsIllBeGlzSW1wbCIsIl9yZWYiLCJ5QXhpc0lkIiwid2lkdGgiLCJ1c2VDaGFydFdpZHRoIiwiaGVpZ2h0IiwidXNlQ2hhcnRIZWlnaHQiLCJheGlzT3B0aW9ucyIsInVzZVlBeGlzT3JUaHJvdyIsImNyZWF0ZUVsZW1lbnQiLCJDYXJ0ZXNpYW5BeGlzIiwiY2xhc3NOYW1lIiwiY29uY2F0IiwiYXhpc1R5cGUiLCJ2aWV3Qm94IiwieCIsInkiLCJ0aWNrc0dlbmVyYXRvciIsImF4aXMiLCJnZXRUaWNrc09mQXhpcyIsIl9SZWFjdCRDb21wb25lbnQiLCJyZW5kZXIiLCJDb21wb25lbnQiLCJhbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeSIsImFsbG93RGVjaW1hbHMiLCJoaWRlIiwib3JpZW50YXRpb24iLCJtaXJyb3IiLCJ0aWNrQ291bnQiLCJ0eXBlIiwicGFkZGluZyIsInRvcCIsImJvdHRvbSIsImFsbG93RGF0YU92ZXJmbG93Iiwic2NhbGUiLCJyZXZlcnNlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/YAxis.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/cartesian/ZAxis.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/ZAxis.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ZAxis = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Z Axis\n */ \n// eslint-disable-next-line react/prefer-stateless-function -- requires static defaultProps\nvar ZAxis = exports.ZAxis = /*#__PURE__*/ function(_React$Component) {\n    function ZAxis() {\n        _classCallCheck(this, ZAxis);\n        return _callSuper(this, ZAxis, arguments);\n    }\n    _inherits(ZAxis, _React$Component);\n    return _createClass(ZAxis, [\n        {\n            key: \"render\",\n            value: function render() {\n                return null;\n            }\n        }\n    ]);\n}(_react[\"default\"].Component);\n_defineProperty(ZAxis, \"displayName\", \"ZAxis\");\n_defineProperty(ZAxis, \"defaultProps\", {\n    zAxisId: 0,\n    range: [\n        64,\n        64\n    ],\n    scale: \"auto\",\n    type: \"number\"\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9aQXhpcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsYUFBYSxHQUFHLEtBQUs7QUFDckIsSUFBSUcsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxTQUFTRCx1QkFBdUJFLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLLGdCQUFnQkMsUUFBUSxFQUFFQyxXQUFXO0lBQUksSUFBSSxDQUFFRCxDQUFBQSxvQkFBb0JDLFdBQVUsR0FBSTtRQUFFLE1BQU0sSUFBSUMsVUFBVTtJQUFzQztBQUFFO0FBQ3hKLFNBQVNDLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSztRQUFFLElBQUlFLGFBQWFILEtBQUssQ0FBQ0MsRUFBRTtRQUFFRSxXQUFXQyxVQUFVLEdBQUdELFdBQVdDLFVBQVUsSUFBSTtRQUFPRCxXQUFXRSxZQUFZLEdBQUc7UUFBTSxJQUFJLFdBQVdGLFlBQVlBLFdBQVdHLFFBQVEsR0FBRztRQUFNNUIsT0FBT0MsY0FBYyxDQUFDb0IsUUFBUVEsZUFBZUosV0FBV0ssR0FB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WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9jYXJ0ZXNpYW4vWkF4aXMuanM/MjhmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuWkF4aXMgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxuICogQGZpbGVPdmVydmlldyBaIEF4aXNcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb24gLS0gcmVxdWlyZXMgc3RhdGljIGRlZmF1bHRQcm9wc1xudmFyIFpBeGlzID0gZXhwb3J0cy5aQXhpcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBmdW5jdGlvbiBaQXhpcygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWkF4aXMpO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIFpBeGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhaQXhpcywgX1JlYWN0JENvbXBvbmVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoWkF4aXMsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcbn0oX3JlYWN0W1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO1xuX2RlZmluZVByb3BlcnR5KFpBeGlzLCBcImRpc3BsYXlOYW1lXCIsICdaQXhpcycpO1xuX2RlZmluZVByb3BlcnR5KFpBeGlzLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIHpBeGlzSWQ6IDAsXG4gIHJhbmdlOiBbNjQsIDY0XSxcbiAgc2NhbGU6ICdhdXRvJyxcbiAgdHlwZTogJ251bWJlcidcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlpBeGlzIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsInQiLCJlIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImFwcGx5Iiwic2VsZiIsImNhbGwiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJiaW5kIiwiX19wcm90b19fIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIl9kZWZpbmVQcm9wZXJ0eSIsIl90b1ByaW1pdGl2ZSIsInIiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIl9SZWFjdCRDb21wb25lbnQiLCJhcmd1bWVudHMiLCJyZW5kZXIiLCJDb21wb25lbnQiLCJ6QXhpc0lkIiwicmFuZ2UiLCJzY2FsZSIsInR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/ZAxis.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/cartesian/getEquidistantTicks.js":
/*!********************************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/getEquidistantTicks.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getEquidistantTicks = getEquidistantTicks;\nvar _TickUtils = __webpack_require__(/*! ../util/TickUtils */ \"./node_modules/recharts/lib/util/TickUtils.js\");\nvar _getEveryNthWithCondition = __webpack_require__(/*! ../util/getEveryNthWithCondition */ \"./node_modules/recharts/lib/util/getEveryNthWithCondition.js\");\nfunction getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n    var result = (ticks || []).slice();\n    var initialStart = boundaries.start, end = boundaries.end;\n    var index = 0;\n    // Premature optimisation idea 1: Estimate a lower bound, and start from there.\n    // For now, start from every tick\n    var stepsize = 1;\n    var start = initialStart;\n    var _loop = function _loop() {\n        // Given stepsize, evaluate whether every stepsize-th tick can be shown.\n        // If it can not, then increase the stepsize by 1, and try again.\n        var entry = ticks === null || ticks === void 0 ? void 0 : ticks[index];\n        // Break condition - If we have evaluate all the ticks, then we are done.\n        if (entry === undefined) {\n            return {\n                v: (0, _getEveryNthWithCondition.getEveryNthWithCondition)(ticks, stepsize)\n            };\n        }\n        // Check if the element collides with the next element\n        var i = index;\n        var size;\n        var getSize = function getSize() {\n            if (size === undefined) {\n                size = getTickSize(entry, i);\n            }\n            return size;\n        };\n        var tickCoord = entry.coordinate;\n        // We will always show the first tick.\n        var isShow = index === 0 || (0, _TickUtils.isVisible)(sign, tickCoord, getSize, start, end);\n        if (!isShow) {\n            // Start all over with a larger stepsize\n            index = 0;\n            start = initialStart;\n            stepsize += 1;\n        }\n        if (isShow) {\n            // If it can be shown, update the start\n            start = tickCoord + sign * (getSize() / 2 + minTickGap);\n            index += stepsize;\n        }\n    }, _ret;\n    while(stepsize <= result.length){\n        _ret = _loop();\n        if (_ret) return _ret.v;\n    }\n    return [];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9nZXRFcXVpZGlzdGFudFRpY2tzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCwyQkFBMkIsR0FBR0U7QUFDOUIsSUFBSUMsYUFBYUMsbUJBQU9BLENBQUMsd0VBQW1CO0FBQzVDLElBQUlDLDRCQUE0QkQsbUJBQU9BLENBQUMsc0dBQWtDO0FBQzFFLFNBQVNGLG9CQUFvQkksSUFBSSxFQUFFQyxVQUFVLEVBQUVDLFdBQVcsRUFBRUMsS0FBSyxFQUFFQyxVQUFVO0lBQzNFLElBQUlDLFNBQVMsQ0FBQ0YsU0FBUyxFQUFFLEVBQUVHLEtBQUs7SUFDaEMsSUFBSUMsZUFBZU4sV0FBV08sS0FBSyxFQUNqQ0MsTUFBTVIsV0FBV1EsR0FBRztJQUN0QixJQUFJQyxRQUFRO0lBQ1osK0VBQStFO0lBQy9FLGlDQUFpQztJQUNqQyxJQUFJQyxXQUFXO0lBQ2YsSUFBSUgsUUFBUUQ7SUFDWixJQUFJSyxRQUFRLFNBQVNBO1FBQ2pCLHdFQUF3RTtRQUN4RSxpRUFBaUU7UUFFakUsSUFBSUMsUUFBUVYsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUssQ0FBQ08sTUFBTTtRQUV0RSx5RUFBeUU7UUFDekUsSUFBSUcsVUFBVUMsV0FBVztZQUN2QixPQUFPO2dCQUNMQyxHQUFHLENBQUMsR0FBR2hCLDBCQUEwQmlCLHdCQUF3QixFQUFFYixPQUFPUTtZQUNwRTtRQUNGO1FBRUEsc0RBQXNEO1FBQ3RELElBQUlNLElBQUlQO1FBQ1IsSUFBSVE7UUFDSixJQUFJQyxVQUFVLFNBQVNBO1lBQ3JCLElBQUlELFNBQVNKLFdBQVc7Z0JBQ3RCSSxPQUFPaEIsWUFBWVcsT0FBT0k7WUFDNUI7WUFDQSxPQUFPQztRQUNUO1FBQ0EsSUFBSUUsWUFBWVAsTUFBTVEsVUFBVTtRQUNoQyxzQ0FBc0M7UUFDdEMsSUFBSUMsU0FBU1osVUFBVSxLQUFLLENBQUMsR0FBR2IsV0FBVzBCLFNBQVMsRUFBRXZCLE1BQU1vQixXQUFXRCxTQUFTWCxPQUFPQztRQUN2RixJQUFJLENBQUNhLFFBQVE7WUFDWCx3Q0FBd0M7WUFDeENaLFFBQVE7WUFDUkYsUUFBUUQ7WUFDUkksWUFBWTtRQUNkO1FBQ0EsSUFBSVcsUUFBUTtZQUNWLHVDQUF1QztZQUN2Q2QsUUFBUVksWUFBWXBCLE9BQVFtQixDQUFBQSxZQUFZLElBQUlmLFVBQVM7WUFDckRNLFNBQVNDO1FBQ1g7SUFDRixHQUNBYTtJQUNGLE1BQU9iLFlBQVlOLE9BQU9vQixNQUFNLENBQUU7UUFDaENELE9BQU9aO1FBQ1AsSUFBSVksTUFBTSxPQUFPQSxLQUFLVCxDQUFDO0lBQ3pCO0lBQ0EsT0FBTyxFQUFFO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9nZXRFcXVpZGlzdGFudFRpY2tzLmpzP2U2NTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldEVxdWlkaXN0YW50VGlja3MgPSBnZXRFcXVpZGlzdGFudFRpY2tzO1xudmFyIF9UaWNrVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9UaWNrVXRpbHNcIik7XG52YXIgX2dldEV2ZXJ5TnRoV2l0aENvbmRpdGlvbiA9IHJlcXVpcmUoXCIuLi91dGlsL2dldEV2ZXJ5TnRoV2l0aENvbmRpdGlvblwiKTtcbmZ1bmN0aW9uIGdldEVxdWlkaXN0YW50VGlja3Moc2lnbiwgYm91bmRhcmllcywgZ2V0VGlja1NpemUsIHRpY2tzLCBtaW5UaWNrR2FwKSB7XG4gIHZhciByZXN1bHQgPSAodGlja3MgfHwgW10pLnNsaWNlKCk7XG4gIHZhciBpbml0aWFsU3RhcnQgPSBib3VuZGFyaWVzLnN0YXJ0LFxuICAgIGVuZCA9IGJvdW5kYXJpZXMuZW5kO1xuICB2YXIgaW5kZXggPSAwO1xuICAvLyBQcmVtYXR1cmUgb3B0aW1pc2F0aW9uIGlkZWEgMTogRXN0aW1hdGUgYSBsb3dlciBib3VuZCwgYW5kIHN0YXJ0IGZyb20gdGhlcmUuXG4gIC8vIEZvciBub3csIHN0YXJ0IGZyb20gZXZlcnkgdGlja1xuICB2YXIgc3RlcHNpemUgPSAxO1xuICB2YXIgc3RhcnQgPSBpbml0aWFsU3RhcnQ7XG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgLy8gR2l2ZW4gc3RlcHNpemUsIGV2YWx1YXRlIHdoZXRoZXIgZXZlcnkgc3RlcHNpemUtdGggdGljayBjYW4gYmUgc2hvd24uXG4gICAgICAvLyBJZiBpdCBjYW4gbm90LCB0aGVuIGluY3JlYXNlIHRoZSBzdGVwc2l6ZSBieSAxLCBhbmQgdHJ5IGFnYWluLlxuXG4gICAgICB2YXIgZW50cnkgPSB0aWNrcyA9PT0gbnVsbCB8fCB0aWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGlja3NbaW5kZXhdO1xuXG4gICAgICAvLyBCcmVhayBjb25kaXRpb24gLSBJZiB3ZSBoYXZlIGV2YWx1YXRlIGFsbCB0aGUgdGlja3MsIHRoZW4gd2UgYXJlIGRvbmUuXG4gICAgICBpZiAoZW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHY6ICgwLCBfZ2V0RXZlcnlOdGhXaXRoQ29uZGl0aW9uLmdldEV2ZXJ5TnRoV2l0aENvbmRpdGlvbikodGlja3MsIHN0ZXBzaXplKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBjb2xsaWRlcyB3aXRoIHRoZSBuZXh0IGVsZW1lbnRcbiAgICAgIHZhciBpID0gaW5kZXg7XG4gICAgICB2YXIgc2l6ZTtcbiAgICAgIHZhciBnZXRTaXplID0gZnVuY3Rpb24gZ2V0U2l6ZSgpIHtcbiAgICAgICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNpemUgPSBnZXRUaWNrU2l6ZShlbnRyeSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICB9O1xuICAgICAgdmFyIHRpY2tDb29yZCA9IGVudHJ5LmNvb3JkaW5hdGU7XG4gICAgICAvLyBXZSB3aWxsIGFsd2F5cyBzaG93IHRoZSBmaXJzdCB0aWNrLlxuICAgICAgdmFyIGlzU2hvdyA9IGluZGV4ID09PSAwIHx8ICgwLCBfVGlja1V0aWxzLmlzVmlzaWJsZSkoc2lnbiwgdGlja0Nvb3JkLCBnZXRTaXplLCBzdGFydCwgZW5kKTtcbiAgICAgIGlmICghaXNTaG93KSB7XG4gICAgICAgIC8vIFN0YXJ0IGFsbCBvdmVyIHdpdGggYSBsYXJnZXIgc3RlcHNpemVcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBzdGFydCA9IGluaXRpYWxTdGFydDtcbiAgICAgICAgc3RlcHNpemUgKz0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Nob3cpIHtcbiAgICAgICAgLy8gSWYgaXQgY2FuIGJlIHNob3duLCB1cGRhdGUgdGhlIHN0YXJ0XG4gICAgICAgIHN0YXJ0ID0gdGlja0Nvb3JkICsgc2lnbiAqIChnZXRTaXplKCkgLyAyICsgbWluVGlja0dhcCk7XG4gICAgICAgIGluZGV4ICs9IHN0ZXBzaXplO1xuICAgICAgfVxuICAgIH0sXG4gICAgX3JldDtcbiAgd2hpbGUgKHN0ZXBzaXplIDw9IHJlc3VsdC5sZW5ndGgpIHtcbiAgICBfcmV0ID0gX2xvb3AoKTtcbiAgICBpZiAoX3JldCkgcmV0dXJuIF9yZXQudjtcbiAgfVxuICByZXR1cm4gW107XG59Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0RXF1aWRpc3RhbnRUaWNrcyIsIl9UaWNrVXRpbHMiLCJyZXF1aXJlIiwiX2dldEV2ZXJ5TnRoV2l0aENvbmRpdGlvbiIsInNpZ24iLCJib3VuZGFyaWVzIiwiZ2V0VGlja1NpemUiLCJ0aWNrcyIsIm1pblRpY2tHYXAiLCJyZXN1bHQiLCJzbGljZSIsImluaXRpYWxTdGFydCIsInN0YXJ0IiwiZW5kIiwiaW5kZXgiLCJzdGVwc2l6ZSIsIl9sb29wIiwiZW50cnkiLCJ1bmRlZmluZWQiLCJ2IiwiZ2V0RXZlcnlOdGhXaXRoQ29uZGl0aW9uIiwiaSIsInNpemUiLCJnZXRTaXplIiwidGlja0Nvb3JkIiwiY29vcmRpbmF0ZSIsImlzU2hvdyIsImlzVmlzaWJsZSIsIl9yZXQiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/getEquidistantTicks.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/cartesian/getTicks.js":
/*!*********************************************************!*\
  !*** ./node_modules/recharts/lib/cartesian/getTicks.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getTicks = getTicks;\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _DOMUtils = __webpack_require__(/*! ../util/DOMUtils */ \"./node_modules/recharts/lib/util/DOMUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"./node_modules/recharts/lib/util/Global.js\");\nvar _TickUtils = __webpack_require__(/*! ../util/TickUtils */ \"./node_modules/recharts/lib/util/TickUtils.js\");\nvar _getEquidistantTicks = __webpack_require__(/*! ./getEquidistantTicks */ \"./node_modules/recharts/lib/cartesian/getEquidistantTicks.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction getTicksEnd(sign, boundaries, getTickSize, ticks, minTickGap) {\n    var result = (ticks || []).slice();\n    var len = result.length;\n    var start = boundaries.start;\n    var end = boundaries.end;\n    var _loop = function _loop(i) {\n        var entry = result[i];\n        var size;\n        var getSize = function getSize() {\n            if (size === undefined) {\n                size = getTickSize(entry, i);\n            }\n            return size;\n        };\n        if (i === len - 1) {\n            var gap = sign * (entry.coordinate + sign * getSize() / 2 - end);\n            result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n                tickCoord: gap > 0 ? entry.coordinate - gap * sign : entry.coordinate\n            });\n        } else {\n            result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n                tickCoord: entry.coordinate\n            });\n        }\n        var isShow = (0, _TickUtils.isVisible)(sign, entry.tickCoord, getSize, start, end);\n        if (isShow) {\n            end = entry.tickCoord - sign * (getSize() / 2 + minTickGap);\n            result[i] = _objectSpread(_objectSpread({}, entry), {}, {\n                isShow: true\n            });\n        }\n    };\n    for(var i = len - 1; i >= 0; i--){\n        _loop(i);\n    }\n    return result;\n}\nfunction getTicksStart(sign, boundaries, getTickSize, ticks, minTickGap, preserveEnd) {\n    var result = (ticks || []).slice();\n    var len = result.length;\n    var start = boundaries.start, end = boundaries.end;\n    if (preserveEnd) {\n        // Try to guarantee the tail to be displayed\n        var tail = ticks[len - 1];\n        var tailSize = getTickSize(tail, len - 1);\n        var tailGap = sign * (tail.coordinate + sign * tailSize / 2 - end);\n        result[len - 1] = tail = _objectSpread(_objectSpread({}, tail), {}, {\n            tickCoord: tailGap > 0 ? tail.coordinate - tailGap * sign : tail.coordinate\n        });\n        var isTailShow = (0, _TickUtils.isVisible)(sign, tail.tickCoord, function() {\n            return tailSize;\n        }, start, end);\n        if (isTailShow) {\n            end = tail.tickCoord - sign * (tailSize / 2 + minTickGap);\n            result[len - 1] = _objectSpread(_objectSpread({}, tail), {}, {\n                isShow: true\n            });\n        }\n    }\n    var count = preserveEnd ? len - 1 : len;\n    var _loop2 = function _loop2(i) {\n        var entry = result[i];\n        var size;\n        var getSize = function getSize() {\n            if (size === undefined) {\n                size = getTickSize(entry, i);\n            }\n            return size;\n        };\n        if (i === 0) {\n            var gap = sign * (entry.coordinate - sign * getSize() / 2 - start);\n            result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n                tickCoord: gap < 0 ? entry.coordinate - gap * sign : entry.coordinate\n            });\n        } else {\n            result[i] = entry = _objectSpread(_objectSpread({}, entry), {}, {\n                tickCoord: entry.coordinate\n            });\n        }\n        var isShow = (0, _TickUtils.isVisible)(sign, entry.tickCoord, getSize, start, end);\n        if (isShow) {\n            start = entry.tickCoord + sign * (getSize() / 2 + minTickGap);\n            result[i] = _objectSpread(_objectSpread({}, entry), {}, {\n                isShow: true\n            });\n        }\n    };\n    for(var i = 0; i < count; i++){\n        _loop2(i);\n    }\n    return result;\n}\nfunction getTicks(props, fontSize, letterSpacing) {\n    var tick = props.tick, ticks = props.ticks, viewBox = props.viewBox, minTickGap = props.minTickGap, orientation = props.orientation, interval = props.interval, tickFormatter = props.tickFormatter, unit = props.unit, angle = props.angle;\n    if (!ticks || !ticks.length || !tick) {\n        return [];\n    }\n    if ((0, _DataUtils.isNumber)(interval) || _Global.Global.isSsr) {\n        return (0, _TickUtils.getNumberIntervalTicks)(ticks, typeof interval === \"number\" && (0, _DataUtils.isNumber)(interval) ? interval : 0);\n    }\n    var candidates = [];\n    var sizeKey = orientation === \"top\" || orientation === \"bottom\" ? \"width\" : \"height\";\n    var unitSize = unit && sizeKey === \"width\" ? (0, _DOMUtils.getStringSize)(unit, {\n        fontSize: fontSize,\n        letterSpacing: letterSpacing\n    }) : {\n        width: 0,\n        height: 0\n    };\n    var getTickSize = function getTickSize(content, index) {\n        var value = (0, _isFunction[\"default\"])(tickFormatter) ? tickFormatter(content.value, index) : content.value;\n        // Recharts only supports angles when sizeKey === 'width'\n        return sizeKey === \"width\" ? (0, _TickUtils.getAngledTickWidth)((0, _DOMUtils.getStringSize)(value, {\n            fontSize: fontSize,\n            letterSpacing: letterSpacing\n        }), unitSize, angle) : (0, _DOMUtils.getStringSize)(value, {\n            fontSize: fontSize,\n            letterSpacing: letterSpacing\n        })[sizeKey];\n    };\n    var sign = ticks.length >= 2 ? (0, _DataUtils.mathSign)(ticks[1].coordinate - ticks[0].coordinate) : 1;\n    var boundaries = (0, _TickUtils.getTickBoundaries)(viewBox, sign, sizeKey);\n    if (interval === \"equidistantPreserveStart\") {\n        return (0, _getEquidistantTicks.getEquidistantTicks)(sign, boundaries, getTickSize, ticks, minTickGap);\n    }\n    if (interval === \"preserveStart\" || interval === \"preserveStartEnd\") {\n        candidates = getTicksStart(sign, boundaries, getTickSize, ticks, minTickGap, interval === \"preserveStartEnd\");\n    } else {\n        candidates = getTicksEnd(sign, boundaries, getTickSize, ticks, minTickGap);\n    }\n    return candidates.filter(function(entry) {\n        return entry.isShow;\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NhcnRlc2lhbi9nZXRUaWNrcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsZ0JBQWdCLEdBQUdFO0FBQ25CLElBQUlDLGNBQWNDLHVCQUF1QkMsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlDLGFBQWFELG1CQUFPQSxDQUFDLHdFQUFtQjtBQUM1QyxJQUFJRSxZQUFZRixtQkFBT0EsQ0FBQyxzRUFBa0I7QUFDMUMsSUFBSUcsVUFBVUgsbUJBQU9BLENBQUMsa0VBQWdCO0FBQ3RDLElBQUlJLGFBQWFKLG1CQUFPQSxDQUFDLHdFQUFtQjtBQUM1QyxJQUFJSyx1QkFBdUJMLG1CQUFPQSxDQUFDLDJGQUF1QjtBQUMxRCxTQUFTRCx1QkFBdUJPLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLLFFBQVFDLENBQUMsRUFBRUMsQ0FBQztJQUFJLElBQUlDLElBQUl4QixPQUFPeUIsSUFBSSxDQUFDSDtJQUFJLElBQUl0QixPQUFPMEIscUJBQXFCLEVBQUU7UUFBRSxJQUFJVixJQUFJaEIsT0FBTzBCLHFCQUFxQixDQUFDSjtRQUFJQyxLQUFNUCxDQUFBQSxJQUFJQSxFQUFFVyxNQUFNLENBQUMsU0FBVUosQ0FB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VCxhQUFhLDRCQUE0QjtRQUMzQyxPQUFPLENBQUMsR0FBR3pFLHFCQUFxQjRGLG1CQUFtQixFQUFFckQsTUFBTUMsWUFBWUMsYUFBYUMsT0FBT0M7SUFDN0Y7SUFDQSxJQUFJOEIsYUFBYSxtQkFBbUJBLGFBQWEsb0JBQW9CO1FBQ25FUSxhQUFhdEIsY0FBY3BCLE1BQU1DLFlBQVlDLGFBQWFDLE9BQU9DLFlBQVk4QixhQUFhO0lBQzVGLE9BQU87UUFDTFEsYUFBYTNDLFlBQVlDLE1BQU1DLFlBQVlDLGFBQWFDLE9BQU9DO0lBQ2pFO0lBQ0EsT0FBT3NDLFdBQVdsRSxNQUFNLENBQUMsU0FBVW1DLEtBQUs7UUFDdEMsT0FBT0EsTUFBTU8sTUFBTTtJQUNyQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9jYXJ0ZXNpYW4vZ2V0VGlja3MuanM/YTZkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0VGlja3MgPSBnZXRUaWNrcztcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RPTVV0aWxzXCIpO1xudmFyIF9HbG9iYWwgPSByZXF1aXJlKFwiLi4vdXRpbC9HbG9iYWxcIik7XG52YXIgX1RpY2tVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1RpY2tVdGlsc1wiKTtcbnZhciBfZ2V0RXF1aWRpc3RhbnRUaWNrcyA9IHJlcXVpcmUoXCIuL2dldEVxdWlkaXN0YW50VGlja3NcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBnZXRUaWNrc0VuZChzaWduLCBib3VuZGFyaWVzLCBnZXRUaWNrU2l6ZSwgdGlja3MsIG1pblRpY2tHYXApIHtcbiAgdmFyIHJlc3VsdCA9ICh0aWNrcyB8fCBbXSkuc2xpY2UoKTtcbiAgdmFyIGxlbiA9IHJlc3VsdC5sZW5ndGg7XG4gIHZhciBzdGFydCA9IGJvdW5kYXJpZXMuc3RhcnQ7XG4gIHZhciBlbmQgPSBib3VuZGFyaWVzLmVuZDtcbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgIHZhciBlbnRyeSA9IHJlc3VsdFtpXTtcbiAgICB2YXIgc2l6ZTtcbiAgICB2YXIgZ2V0U2l6ZSA9IGZ1bmN0aW9uIGdldFNpemUoKSB7XG4gICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNpemUgPSBnZXRUaWNrU2l6ZShlbnRyeSwgaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9O1xuICAgIGlmIChpID09PSBsZW4gLSAxKSB7XG4gICAgICB2YXIgZ2FwID0gc2lnbiAqIChlbnRyeS5jb29yZGluYXRlICsgc2lnbiAqIGdldFNpemUoKSAvIDIgLSBlbmQpO1xuICAgICAgcmVzdWx0W2ldID0gZW50cnkgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcbiAgICAgICAgdGlja0Nvb3JkOiBnYXAgPiAwID8gZW50cnkuY29vcmRpbmF0ZSAtIGdhcCAqIHNpZ24gOiBlbnRyeS5jb29yZGluYXRlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2ldID0gZW50cnkgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcbiAgICAgICAgdGlja0Nvb3JkOiBlbnRyeS5jb29yZGluYXRlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGlzU2hvdyA9ICgwLCBfVGlja1V0aWxzLmlzVmlzaWJsZSkoc2lnbiwgZW50cnkudGlja0Nvb3JkLCBnZXRTaXplLCBzdGFydCwgZW5kKTtcbiAgICBpZiAoaXNTaG93KSB7XG4gICAgICBlbmQgPSBlbnRyeS50aWNrQ29vcmQgLSBzaWduICogKGdldFNpemUoKSAvIDIgKyBtaW5UaWNrR2FwKTtcbiAgICAgIHJlc3VsdFtpXSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xuICAgICAgICBpc1Nob3c6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgX2xvb3AoaSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFRpY2tzU3RhcnQoc2lnbiwgYm91bmRhcmllcywgZ2V0VGlja1NpemUsIHRpY2tzLCBtaW5UaWNrR2FwLCBwcmVzZXJ2ZUVuZCkge1xuICB2YXIgcmVzdWx0ID0gKHRpY2tzIHx8IFtdKS5zbGljZSgpO1xuICB2YXIgbGVuID0gcmVzdWx0Lmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gYm91bmRhcmllcy5zdGFydCxcbiAgICBlbmQgPSBib3VuZGFyaWVzLmVuZDtcbiAgaWYgKHByZXNlcnZlRW5kKSB7XG4gICAgLy8gVHJ5IHRvIGd1YXJhbnRlZSB0aGUgdGFpbCB0byBiZSBkaXNwbGF5ZWRcbiAgICB2YXIgdGFpbCA9IHRpY2tzW2xlbiAtIDFdO1xuICAgIHZhciB0YWlsU2l6ZSA9IGdldFRpY2tTaXplKHRhaWwsIGxlbiAtIDEpO1xuICAgIHZhciB0YWlsR2FwID0gc2lnbiAqICh0YWlsLmNvb3JkaW5hdGUgKyBzaWduICogdGFpbFNpemUgLyAyIC0gZW5kKTtcbiAgICByZXN1bHRbbGVuIC0gMV0gPSB0YWlsID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0YWlsKSwge30sIHtcbiAgICAgIHRpY2tDb29yZDogdGFpbEdhcCA+IDAgPyB0YWlsLmNvb3JkaW5hdGUgLSB0YWlsR2FwICogc2lnbiA6IHRhaWwuY29vcmRpbmF0ZVxuICAgIH0pO1xuICAgIHZhciBpc1RhaWxTaG93ID0gKDAsIF9UaWNrVXRpbHMuaXNWaXNpYmxlKShzaWduLCB0YWlsLnRpY2tDb29yZCwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRhaWxTaXplO1xuICAgIH0sIHN0YXJ0LCBlbmQpO1xuICAgIGlmIChpc1RhaWxTaG93KSB7XG4gICAgICBlbmQgPSB0YWlsLnRpY2tDb29yZCAtIHNpZ24gKiAodGFpbFNpemUgLyAyICsgbWluVGlja0dhcCk7XG4gICAgICByZXN1bHRbbGVuIC0gMV0gPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRhaWwpLCB7fSwge1xuICAgICAgICBpc1Nob3c6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB2YXIgY291bnQgPSBwcmVzZXJ2ZUVuZCA/IGxlbiAtIDEgOiBsZW47XG4gIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoaSkge1xuICAgIHZhciBlbnRyeSA9IHJlc3VsdFtpXTtcbiAgICB2YXIgc2l6ZTtcbiAgICB2YXIgZ2V0U2l6ZSA9IGZ1bmN0aW9uIGdldFNpemUoKSB7XG4gICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNpemUgPSBnZXRUaWNrU2l6ZShlbnRyeSwgaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9O1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICB2YXIgZ2FwID0gc2lnbiAqIChlbnRyeS5jb29yZGluYXRlIC0gc2lnbiAqIGdldFNpemUoKSAvIDIgLSBzdGFydCk7XG4gICAgICByZXN1bHRbaV0gPSBlbnRyeSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xuICAgICAgICB0aWNrQ29vcmQ6IGdhcCA8IDAgPyBlbnRyeS5jb29yZGluYXRlIC0gZ2FwICogc2lnbiA6IGVudHJ5LmNvb3JkaW5hdGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRbaV0gPSBlbnRyeSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xuICAgICAgICB0aWNrQ29vcmQ6IGVudHJ5LmNvb3JkaW5hdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgaXNTaG93ID0gKDAsIF9UaWNrVXRpbHMuaXNWaXNpYmxlKShzaWduLCBlbnRyeS50aWNrQ29vcmQsIGdldFNpemUsIHN0YXJ0LCBlbmQpO1xuICAgIGlmIChpc1Nob3cpIHtcbiAgICAgIHN0YXJ0ID0gZW50cnkudGlja0Nvb3JkICsgc2lnbiAqIChnZXRTaXplKCkgLyAyICsgbWluVGlja0dhcCk7XG4gICAgICByZXN1bHRbaV0gPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcbiAgICAgICAgaXNTaG93OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIF9sb29wMihpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0VGlja3MocHJvcHMsIGZvbnRTaXplLCBsZXR0ZXJTcGFjaW5nKSB7XG4gIHZhciB0aWNrID0gcHJvcHMudGljayxcbiAgICB0aWNrcyA9IHByb3BzLnRpY2tzLFxuICAgIHZpZXdCb3ggPSBwcm9wcy52aWV3Qm94LFxuICAgIG1pblRpY2tHYXAgPSBwcm9wcy5taW5UaWNrR2FwLFxuICAgIG9yaWVudGF0aW9uID0gcHJvcHMub3JpZW50YXRpb24sXG4gICAgaW50ZXJ2YWwgPSBwcm9wcy5pbnRlcnZhbCxcbiAgICB0aWNrRm9ybWF0dGVyID0gcHJvcHMudGlja0Zvcm1hdHRlcixcbiAgICB1bml0ID0gcHJvcHMudW5pdCxcbiAgICBhbmdsZSA9IHByb3BzLmFuZ2xlO1xuICBpZiAoIXRpY2tzIHx8ICF0aWNrcy5sZW5ndGggfHwgIXRpY2spIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShpbnRlcnZhbCkgfHwgX0dsb2JhbC5HbG9iYWwuaXNTc3IpIHtcbiAgICByZXR1cm4gKDAsIF9UaWNrVXRpbHMuZ2V0TnVtYmVySW50ZXJ2YWxUaWNrcykodGlja3MsIHR5cGVvZiBpbnRlcnZhbCA9PT0gJ251bWJlcicgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGludGVydmFsKSA/IGludGVydmFsIDogMCk7XG4gIH1cbiAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcbiAgdmFyIHNpemVLZXkgPSBvcmllbnRhdGlvbiA9PT0gJ3RvcCcgfHwgb3JpZW50YXRpb24gPT09ICdib3R0b20nID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICB2YXIgdW5pdFNpemUgPSB1bml0ICYmIHNpemVLZXkgPT09ICd3aWR0aCcgPyAoMCwgX0RPTVV0aWxzLmdldFN0cmluZ1NpemUpKHVuaXQsIHtcbiAgICBmb250U2l6ZTogZm9udFNpemUsXG4gICAgbGV0dGVyU3BhY2luZzogbGV0dGVyU3BhY2luZ1xuICB9KSA6IHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfTtcbiAgdmFyIGdldFRpY2tTaXplID0gZnVuY3Rpb24gZ2V0VGlja1NpemUoY29udGVudCwgaW5kZXgpIHtcbiAgICB2YXIgdmFsdWUgPSAoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKSh0aWNrRm9ybWF0dGVyKSA/IHRpY2tGb3JtYXR0ZXIoY29udGVudC52YWx1ZSwgaW5kZXgpIDogY29udGVudC52YWx1ZTtcbiAgICAvLyBSZWNoYXJ0cyBvbmx5IHN1cHBvcnRzIGFuZ2xlcyB3aGVuIHNpemVLZXkgPT09ICd3aWR0aCdcbiAgICByZXR1cm4gc2l6ZUtleSA9PT0gJ3dpZHRoJyA/ICgwLCBfVGlja1V0aWxzLmdldEFuZ2xlZFRpY2tXaWR0aCkoKDAsIF9ET01VdGlscy5nZXRTdHJpbmdTaXplKSh2YWx1ZSwge1xuICAgICAgZm9udFNpemU6IGZvbnRTaXplLFxuICAgICAgbGV0dGVyU3BhY2luZzogbGV0dGVyU3BhY2luZ1xuICAgIH0pLCB1bml0U2l6ZSwgYW5nbGUpIDogKDAsIF9ET01VdGlscy5nZXRTdHJpbmdTaXplKSh2YWx1ZSwge1xuICAgICAgZm9udFNpemU6IGZvbnRTaXplLFxuICAgICAgbGV0dGVyU3BhY2luZzogbGV0dGVyU3BhY2luZ1xuICAgIH0pW3NpemVLZXldO1xuICB9O1xuICB2YXIgc2lnbiA9IHRpY2tzLmxlbmd0aCA+PSAyID8gKDAsIF9EYXRhVXRpbHMubWF0aFNpZ24pKHRpY2tzWzFdLmNvb3JkaW5hdGUgLSB0aWNrc1swXS5jb29yZGluYXRlKSA6IDE7XG4gIHZhciBib3VuZGFyaWVzID0gKDAsIF9UaWNrVXRpbHMuZ2V0VGlja0JvdW5kYXJpZXMpKHZpZXdCb3gsIHNpZ24sIHNpemVLZXkpO1xuICBpZiAoaW50ZXJ2YWwgPT09ICdlcXVpZGlzdGFudFByZXNlcnZlU3RhcnQnKSB7XG4gICAgcmV0dXJuICgwLCBfZ2V0RXF1aWRpc3RhbnRUaWNrcy5nZXRFcXVpZGlzdGFudFRpY2tzKShzaWduLCBib3VuZGFyaWVzLCBnZXRUaWNrU2l6ZSwgdGlja3MsIG1pblRpY2tHYXApO1xuICB9XG4gIGlmIChpbnRlcnZhbCA9PT0gJ3ByZXNlcnZlU3RhcnQnIHx8IGludGVydmFsID09PSAncHJlc2VydmVTdGFydEVuZCcpIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0VGlja3NTdGFydChzaWduLCBib3VuZGFyaWVzLCBnZXRUaWNrU2l6ZSwgdGlja3MsIG1pblRpY2tHYXAsIGludGVydmFsID09PSAncHJlc2VydmVTdGFydEVuZCcpO1xuICB9IGVsc2Uge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRUaWNrc0VuZChzaWduLCBib3VuZGFyaWVzLCBnZXRUaWNrU2l6ZSwgdGlja3MsIG1pblRpY2tHYXApO1xuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuaXNTaG93O1xuICB9KTtcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRUaWNrcyIsIl9pc0Z1bmN0aW9uIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfRGF0YVV0aWxzIiwiX0RPTVV0aWxzIiwiX0dsb2JhbCIsIl9UaWNrVXRpbHMiLCJfZ2V0RXF1aWRpc3RhbnRUaWNrcyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJvd25LZXlzIiwiZSIsInIiLCJ0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwia2V5IiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImkiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJnZXRUaWNrc0VuZCIsInNpZ24iLCJib3VuZGFyaWVzIiwiZ2V0VGlja1NpemUiLCJ0aWNrcyIsIm1pblRpY2tHYXAiLCJyZXN1bHQiLCJzbGljZSIsImxlbiIsInN0YXJ0IiwiZW5kIiwiX2xvb3AiLCJlbnRyeSIsInNpemUiLCJnZXRTaXplIiwidW5kZWZpbmVkIiwiZ2FwIiwiY29vcmRpbmF0ZSIsInRpY2tDb29yZCIsImlzU2hvdyIsImlzVmlzaWJsZSIsImdldFRpY2tzU3RhcnQiLCJwcmVzZXJ2ZUVuZCIsInRhaWwiLCJ0YWlsU2l6ZSIsInRhaWxHYXAiLCJpc1RhaWxTaG93IiwiY291bnQiLCJfbG9vcDIiLCJwcm9wcyIsImZvbnRTaXplIiwibGV0dGVyU3BhY2luZyIsInRpY2siLCJ2aWV3Qm94Iiwib3JpZW50YXRpb24iLCJpbnRlcnZhbCIsInRpY2tGb3JtYXR0ZXIiLCJ1bml0IiwiYW5nbGUiLCJpc051bWJlciIsIkdsb2JhbCIsImlzU3NyIiwiZ2V0TnVtYmVySW50ZXJ2YWxUaWNrcyIsImNhbmRpZGF0ZXMiLCJzaXplS2V5IiwidW5pdFNpemUiLCJnZXRTdHJpbmdTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJjb250ZW50IiwiaW5kZXgiLCJnZXRBbmdsZWRUaWNrV2lkdGgiLCJtYXRoU2lnbiIsImdldFRpY2tCb3VuZGFyaWVzIiwiZ2V0RXF1aWRpc3RhbnRUaWNrcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/cartesian/getTicks.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/chart/AccessibilityManager.js":
/*!*****************************************************************!*\
  !*** ./node_modules/recharts/lib/chart/AccessibilityManager.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AccessibilityManager = void 0;\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar AccessibilityManager = exports.AccessibilityManager = /*#__PURE__*/ function() {\n    function AccessibilityManager() {\n        _classCallCheck(this, AccessibilityManager);\n        _defineProperty(this, \"activeIndex\", 0);\n        _defineProperty(this, \"coordinateList\", []);\n        _defineProperty(this, \"layout\", \"horizontal\");\n    }\n    return _createClass(AccessibilityManager, [\n        {\n            key: \"setDetails\",\n            value: function setDetails(_ref) {\n                var _ref2;\n                var _ref$coordinateList = _ref.coordinateList, coordinateList = _ref$coordinateList === void 0 ? null : _ref$coordinateList, _ref$container = _ref.container, container = _ref$container === void 0 ? null : _ref$container, _ref$layout = _ref.layout, layout = _ref$layout === void 0 ? null : _ref$layout, _ref$offset = _ref.offset, offset = _ref$offset === void 0 ? null : _ref$offset, _ref$mouseHandlerCall = _ref.mouseHandlerCallback, mouseHandlerCallback = _ref$mouseHandlerCall === void 0 ? null : _ref$mouseHandlerCall;\n                this.coordinateList = (_ref2 = coordinateList !== null && coordinateList !== void 0 ? coordinateList : this.coordinateList) !== null && _ref2 !== void 0 ? _ref2 : [];\n                this.container = container !== null && container !== void 0 ? container : this.container;\n                this.layout = layout !== null && layout !== void 0 ? layout : this.layout;\n                this.offset = offset !== null && offset !== void 0 ? offset : this.offset;\n                this.mouseHandlerCallback = mouseHandlerCallback !== null && mouseHandlerCallback !== void 0 ? mouseHandlerCallback : this.mouseHandlerCallback;\n                // Keep activeIndex in the bounds between 0 and the last coordinate index\n                this.activeIndex = Math.min(Math.max(this.activeIndex, 0), this.coordinateList.length - 1);\n            }\n        },\n        {\n            key: \"focus\",\n            value: function focus() {\n                this.spoofMouse();\n            }\n        },\n        {\n            key: \"keyboardEvent\",\n            value: function keyboardEvent(e) {\n                // The AccessibilityManager relies on the Tooltip component. When tooltips suddenly stop existing,\n                // it can cause errors. We use this function to check. We don't want arrow keys to be processed\n                // if there are no tooltips, since that will cause unexpected behavior of users.\n                if (this.coordinateList.length === 0) {\n                    return;\n                }\n                switch(e.key){\n                    case \"ArrowRight\":\n                        {\n                            if (this.layout !== \"horizontal\") {\n                                return;\n                            }\n                            this.activeIndex = Math.min(this.activeIndex + 1, this.coordinateList.length - 1);\n                            this.spoofMouse();\n                            break;\n                        }\n                    case \"ArrowLeft\":\n                        {\n                            if (this.layout !== \"horizontal\") {\n                                return;\n                            }\n                            this.activeIndex = Math.max(this.activeIndex - 1, 0);\n                            this.spoofMouse();\n                            break;\n                        }\n                    default:\n                        {\n                            break;\n                        }\n                }\n            }\n        },\n        {\n            key: \"setIndex\",\n            value: function setIndex(newIndex) {\n                this.activeIndex = newIndex;\n            }\n        },\n        {\n            key: \"spoofMouse\",\n            value: function spoofMouse() {\n                var _window, _window2;\n                if (this.layout !== \"horizontal\") {\n                    return;\n                }\n                // This can happen when the tooltips suddenly stop existing as children of the component\n                // That update doesn't otherwise fire events, so we have to double check here.\n                if (this.coordinateList.length === 0) {\n                    return;\n                }\n                var _this$container$getBo = this.container.getBoundingClientRect(), x = _this$container$getBo.x, y = _this$container$getBo.y, height = _this$container$getBo.height;\n                var coordinate = this.coordinateList[this.activeIndex].coordinate;\n                var scrollOffsetX = ((_window = window) === null || _window === void 0 ? void 0 : _window.scrollX) || 0;\n                var scrollOffsetY = ((_window2 = window) === null || _window2 === void 0 ? void 0 : _window2.scrollY) || 0;\n                var pageX = x + coordinate + scrollOffsetX;\n                var pageY = y + this.offset.top + height / 2 + scrollOffsetY;\n                this.mouseHandlerCallback({\n                    pageX: pageX,\n                    pageY: pageY\n                });\n            }\n        }\n    ]);\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L0FjY2Vzc2liaWxpdHlNYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCw0QkFBNEIsR0FBRyxLQUFLO0FBQ3BDLFNBQVNHLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSyxnQkFBZ0JDLFFBQVEsRUFBRUMsV0FBVztJQUFJLElBQUksQ0FBRUQsQ0FBQUEsb0JBQW9CQyxXQUFVLEdBQUk7UUFBRSxNQUFNLElBQUlDLFVBQVU7SUFBc0M7QUFBRTtBQUN4SixTQUFTQyxrQkFBa0JDLE1BQU0sRUFBRUMsS0FBSztJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxNQUFNRSxNQUFNLEVBQUVELElBQUs7UUFBRSxJQUFJRSxhQUFhSCxLQUFLLENBQUNDLEVBQUU7UUFBRUUsV0FBV0MsVUFBVSxHQUFHRCxXQUFXQyxVQUFVLElBQUk7UUFBT0QsV0FBV0UsWUFBWSxHQUFHO1FBQU0sSUFBSSxXQUFXRixZQUFZQSxXQUFXRyxRQUFRLEdBQUc7UUFBTXZCLE9BQU9DLGNBQWMsQ0FBQ2UsUUFBUVEsZUFBZUosV0FBV0ssR0FBRyxHQUFHTDtJQUFhO0FBQUU7QUFDNVUsU0FBU00sYUFBYWIsV0FBVyxFQUFFYyxVQUFVLEVBQUVDLFdBQVc7SUFBSSxJQUFJRCxZQUFZWixrQkFBa0JGLFlBQVlILFNBQVMsRUFBRWlCO0lBQWEsSUFBSUMs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Q2QsSUFBSUksU0FBU0M7Z0JBQ2IsSUFBSSxJQUFJLENBQUNmLE1BQU0sS0FBSyxjQUFjO29CQUNoQztnQkFDRjtnQkFFQSx3RkFBd0Y7Z0JBQ3hGLDhFQUE4RTtnQkFDOUUsSUFBSSxJQUFJLENBQUNKLGNBQWMsQ0FBQ3hCLE1BQU0sS0FBSyxHQUFHO29CQUNwQztnQkFDRjtnQkFDQSxJQUFJNEMsd0JBQXdCLElBQUksQ0FBQ2xCLFNBQVMsQ0FBQ21CLHFCQUFxQixJQUM5REMsSUFBSUYsc0JBQXNCRSxDQUFDLEVBQzNCQyxJQUFJSCxzQkFBc0JHLENBQUMsRUFDM0JDLFNBQVNKLHNCQUFzQkksTUFBTTtnQkFDdkMsSUFBSUMsYUFBYSxJQUFJLENBQUN6QixjQUFjLENBQUMsSUFBSSxDQUFDUyxXQUFXLENBQUMsQ0FBQ2dCLFVBQVU7Z0JBQ2pFLElBQUlDLGdCQUFnQixDQUFDLENBQUNSLFVBQVVTLE1BQUssTUFBTyxRQUFRVCxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFVLE9BQU8sS0FBSztnQkFDdEcsSUFBSUMsZ0JBQWdCLENBQUMsQ0FBQ1YsV0FBV1EsTUFBSyxNQUFPLFFBQVFSLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU1csT0FBTyxLQUFLO2dCQUN6RyxJQUFJQyxRQUFRVCxJQUFJRyxhQUFhQztnQkFDN0IsSUFBSU0sUUFBUVQsSUFBSSxJQUFJLENBQUNqQixNQUFNLENBQUMyQixHQUFHLEdBQUdULFNBQVMsSUFBSUs7Z0JBQy9DLElBQUksQ0FBQ3JCLG9CQUFvQixDQUFDO29CQUN4QnVCLE9BQU9BO29CQUNQQyxPQUFPQTtnQkFDVDtZQUNGO1FBQ0Y7S0FBRTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9jaGFydC9BY2Nlc3NpYmlsaXR5TWFuYWdlci5qcz9hOTMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5BY2Nlc3NpYmlsaXR5TWFuYWdlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIEFjY2Vzc2liaWxpdHlNYW5hZ2VyID0gZXhwb3J0cy5BY2Nlc3NpYmlsaXR5TWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFjY2Vzc2liaWxpdHlNYW5hZ2VyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBY2Nlc3NpYmlsaXR5TWFuYWdlcik7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYWN0aXZlSW5kZXhcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29vcmRpbmF0ZUxpc3RcIiwgW10pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxheW91dFwiLCAnaG9yaXpvbnRhbCcpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQWNjZXNzaWJpbGl0eU1hbmFnZXIsIFt7XG4gICAga2V5OiBcInNldERldGFpbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGV0YWlscyhfcmVmKSB7XG4gICAgICB2YXIgX3JlZjI7XG4gICAgICB2YXIgX3JlZiRjb29yZGluYXRlTGlzdCA9IF9yZWYuY29vcmRpbmF0ZUxpc3QsXG4gICAgICAgIGNvb3JkaW5hdGVMaXN0ID0gX3JlZiRjb29yZGluYXRlTGlzdCA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkY29vcmRpbmF0ZUxpc3QsXG4gICAgICAgIF9yZWYkY29udGFpbmVyID0gX3JlZi5jb250YWluZXIsXG4gICAgICAgIGNvbnRhaW5lciA9IF9yZWYkY29udGFpbmVyID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRjb250YWluZXIsXG4gICAgICAgIF9yZWYkbGF5b3V0ID0gX3JlZi5sYXlvdXQsXG4gICAgICAgIGxheW91dCA9IF9yZWYkbGF5b3V0ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRsYXlvdXQsXG4gICAgICAgIF9yZWYkb2Zmc2V0ID0gX3JlZi5vZmZzZXQsXG4gICAgICAgIG9mZnNldCA9IF9yZWYkb2Zmc2V0ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRvZmZzZXQsXG4gICAgICAgIF9yZWYkbW91c2VIYW5kbGVyQ2FsbCA9IF9yZWYubW91c2VIYW5kbGVyQ2FsbGJhY2ssXG4gICAgICAgIG1vdXNlSGFuZGxlckNhbGxiYWNrID0gX3JlZiRtb3VzZUhhbmRsZXJDYWxsID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRtb3VzZUhhbmRsZXJDYWxsO1xuICAgICAgdGhpcy5jb29yZGluYXRlTGlzdCA9IChfcmVmMiA9IGNvb3JkaW5hdGVMaXN0ICE9PSBudWxsICYmIGNvb3JkaW5hdGVMaXN0ICE9PSB2b2lkIDAgPyBjb29yZGluYXRlTGlzdCA6IHRoaXMuY29vcmRpbmF0ZUxpc3QpICE9PSBudWxsICYmIF9yZWYyICE9PSB2b2lkIDAgPyBfcmVmMiA6IFtdO1xuICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXIgIT09IG51bGwgJiYgY29udGFpbmVyICE9PSB2b2lkIDAgPyBjb250YWluZXIgOiB0aGlzLmNvbnRhaW5lcjtcbiAgICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0ICE9PSBudWxsICYmIGxheW91dCAhPT0gdm9pZCAwID8gbGF5b3V0IDogdGhpcy5sYXlvdXQ7XG4gICAgICB0aGlzLm9mZnNldCA9IG9mZnNldCAhPT0gbnVsbCAmJiBvZmZzZXQgIT09IHZvaWQgMCA/IG9mZnNldCA6IHRoaXMub2Zmc2V0O1xuICAgICAgdGhpcy5tb3VzZUhhbmRsZXJDYWxsYmFjayA9IG1vdXNlSGFuZGxlckNhbGxiYWNrICE9PSBudWxsICYmIG1vdXNlSGFuZGxlckNhbGxiYWNrICE9PSB2b2lkIDAgPyBtb3VzZUhhbmRsZXJDYWxsYmFjayA6IHRoaXMubW91c2VIYW5kbGVyQ2FsbGJhY2s7XG5cbiAgICAgIC8vIEtlZXAgYWN0aXZlSW5kZXggaW4gdGhlIGJvdW5kcyBiZXR3ZWVuIDAgYW5kIHRoZSBsYXN0IGNvb3JkaW5hdGUgaW5kZXhcbiAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzLmFjdGl2ZUluZGV4LCAwKSwgdGhpcy5jb29yZGluYXRlTGlzdC5sZW5ndGggLSAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9jdXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgICB0aGlzLnNwb29mTW91c2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia2V5Ym9hcmRFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlib2FyZEV2ZW50KGUpIHtcbiAgICAgIC8vIFRoZSBBY2Nlc3NpYmlsaXR5TWFuYWdlciByZWxpZXMgb24gdGhlIFRvb2x0aXAgY29tcG9uZW50LiBXaGVuIHRvb2x0aXBzIHN1ZGRlbmx5IHN0b3AgZXhpc3RpbmcsXG4gICAgICAvLyBpdCBjYW4gY2F1c2UgZXJyb3JzLiBXZSB1c2UgdGhpcyBmdW5jdGlvbiB0byBjaGVjay4gV2UgZG9uJ3Qgd2FudCBhcnJvdyBrZXlzIHRvIGJlIHByb2Nlc3NlZFxuICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIHRvb2x0aXBzLCBzaW5jZSB0aGF0IHdpbGwgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvciBvZiB1c2Vycy5cbiAgICAgIGlmICh0aGlzLmNvb3JkaW5hdGVMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dCAhPT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBNYXRoLm1pbih0aGlzLmFjdGl2ZUluZGV4ICsgMSwgdGhpcy5jb29yZGluYXRlTGlzdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHRoaXMuc3Bvb2ZNb3VzZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dCAhPT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBNYXRoLm1heCh0aGlzLmFjdGl2ZUluZGV4IC0gMSwgMCk7XG4gICAgICAgICAgICB0aGlzLnNwb29mTW91c2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZGV4KG5ld0luZGV4KSB7XG4gICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gbmV3SW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNwb29mTW91c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3Bvb2ZNb3VzZSgpIHtcbiAgICAgIHZhciBfd2luZG93LCBfd2luZG93MjtcbiAgICAgIGlmICh0aGlzLmxheW91dCAhPT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gdGhlIHRvb2x0aXBzIHN1ZGRlbmx5IHN0b3AgZXhpc3RpbmcgYXMgY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudFxuICAgICAgLy8gVGhhdCB1cGRhdGUgZG9lc24ndCBvdGhlcndpc2UgZmlyZSBldmVudHMsIHNvIHdlIGhhdmUgdG8gZG91YmxlIGNoZWNrIGhlcmUuXG4gICAgICBpZiAodGhpcy5jb29yZGluYXRlTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIF90aGlzJGNvbnRhaW5lciRnZXRCbyA9IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICB4ID0gX3RoaXMkY29udGFpbmVyJGdldEJvLngsXG4gICAgICAgIHkgPSBfdGhpcyRjb250YWluZXIkZ2V0Qm8ueSxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkY29udGFpbmVyJGdldEJvLmhlaWdodDtcbiAgICAgIHZhciBjb29yZGluYXRlID0gdGhpcy5jb29yZGluYXRlTGlzdFt0aGlzLmFjdGl2ZUluZGV4XS5jb29yZGluYXRlO1xuICAgICAgdmFyIHNjcm9sbE9mZnNldFggPSAoKF93aW5kb3cgPSB3aW5kb3cpID09PSBudWxsIHx8IF93aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3cuc2Nyb2xsWCkgfHwgMDtcbiAgICAgIHZhciBzY3JvbGxPZmZzZXRZID0gKChfd2luZG93MiA9IHdpbmRvdykgPT09IG51bGwgfHwgX3dpbmRvdzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3cyLnNjcm9sbFkpIHx8IDA7XG4gICAgICB2YXIgcGFnZVggPSB4ICsgY29vcmRpbmF0ZSArIHNjcm9sbE9mZnNldFg7XG4gICAgICB2YXIgcGFnZVkgPSB5ICsgdGhpcy5vZmZzZXQudG9wICsgaGVpZ2h0IC8gMiArIHNjcm9sbE9mZnNldFk7XG4gICAgICB0aGlzLm1vdXNlSGFuZGxlckNhbGxiYWNrKHtcbiAgICAgICAgcGFnZVg6IHBhZ2VYLFxuICAgICAgICBwYWdlWTogcGFnZVlcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xufSgpOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFjY2Vzc2liaWxpdHlNYW5hZ2VyIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwidCIsIl90b1ByaW1pdGl2ZSIsInIiLCJlIiwidG9QcmltaXRpdmUiLCJjYWxsIiwiU3RyaW5nIiwiTnVtYmVyIiwic2V0RGV0YWlscyIsIl9yZWYiLCJfcmVmMiIsIl9yZWYkY29vcmRpbmF0ZUxpc3QiLCJjb29yZGluYXRlTGlzdCIsIl9yZWYkY29udGFpbmVyIiwiY29udGFpbmVyIiwiX3JlZiRsYXlvdXQiLCJsYXlvdXQiLCJfcmVmJG9mZnNldCIsIm9mZnNldCIsIl9yZWYkbW91c2VIYW5kbGVyQ2FsbCIsIm1vdXNlSGFuZGxlckNhbGxiYWNrIiwiYWN0aXZlSW5kZXgiLCJNYXRoIiwibWluIiwibWF4IiwiZm9jdXMiLCJzcG9vZk1vdXNlIiwia2V5Ym9hcmRFdmVudCIsInNldEluZGV4IiwibmV3SW5kZXgiLCJfd2luZG93IiwiX3dpbmRvdzIiLCJfdGhpcyRjb250YWluZXIkZ2V0Qm8iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ4IiwieSIsImhlaWdodCIsImNvb3JkaW5hdGUiLCJzY3JvbGxPZmZzZXRYIiwid2luZG93Iiwic2Nyb2xsWCIsInNjcm9sbE9mZnNldFkiLCJzY3JvbGxZIiwicGFnZVgiLCJwYWdlWSIsInRvcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/chart/AccessibilityManager.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/chart/AreaChart.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/chart/AreaChart.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AreaChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _Area = __webpack_require__(/*! ../cartesian/Area */ \"./node_modules/recharts/lib/cartesian/Area.js\");\nvar _XAxis = __webpack_require__(/*! ../cartesian/XAxis */ \"./node_modules/recharts/lib/cartesian/XAxis.js\");\nvar _YAxis = __webpack_require__(/*! ../cartesian/YAxis */ \"./node_modules/recharts/lib/cartesian/YAxis.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"./node_modules/recharts/lib/util/CartesianUtils.js\");\n/**\n * @fileOverview Area Chart\n */ var AreaChart = exports.AreaChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: \"AreaChart\",\n    GraphicalChild: _Area.Area,\n    axisComponents: [\n        {\n            axisType: \"xAxis\",\n            AxisComp: _XAxis.XAxis\n        },\n        {\n            axisType: \"yAxis\",\n            AxisComp: _YAxis.YAxis\n        }\n    ],\n    formatAxisMap: _CartesianUtils.formatAxisMap\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L0FyZWFDaGFydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixJQUFJRyw0QkFBNEJDLG1CQUFPQSxDQUFDLGlHQUE0QjtBQUNwRSxJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQyx3RUFBbUI7QUFDdkMsSUFBSUUsU0FBU0YsbUJBQU9BLENBQUMsMEVBQW9CO0FBQ3pDLElBQUlHLFNBQVNILG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJSSxrQkFBa0JKLG1CQUFPQSxDQUFDLGtGQUF3QjtBQUN0RDs7Q0FFQyxHQUVELElBQUlGLFlBQVlGLGlCQUFpQixHQUFHLENBQUMsR0FBR0csMEJBQTBCTSx3QkFBd0IsRUFBRTtJQUMxRkMsV0FBVztJQUNYQyxnQkFBZ0JOLE1BQU1PLElBQUk7SUFDMUJDLGdCQUFnQjtRQUFDO1lBQ2ZDLFVBQVU7WUFDVkMsVUFBVVQsT0FBT1UsS0FBSztRQUN4QjtRQUFHO1lBQ0RGLFVBQVU7WUFDVkMsVUFBVVIsT0FBT1UsS0FBSztRQUN4QjtLQUFFO0lBQ0ZDLGVBQWVWLGdCQUFnQlUsYUFBYTtBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvQXJlYUNoYXJ0LmpzPzQ5ODciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkFyZWFDaGFydCA9IHZvaWQgMDtcbnZhciBfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0ID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0XCIpO1xudmFyIF9BcmVhID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9BcmVhXCIpO1xudmFyIF9YQXhpcyA9IHJlcXVpcmUoXCIuLi9jYXJ0ZXNpYW4vWEF4aXNcIik7XG52YXIgX1lBeGlzID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9ZQXhpc1wiKTtcbnZhciBfQ2FydGVzaWFuVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9DYXJ0ZXNpYW5VdGlsc1wiKTtcbi8qKlxuICogQGZpbGVPdmVydmlldyBBcmVhIENoYXJ0XG4gKi9cblxudmFyIEFyZWFDaGFydCA9IGV4cG9ydHMuQXJlYUNoYXJ0ID0gKDAsIF9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQuZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0KSh7XG4gIGNoYXJ0TmFtZTogJ0FyZWFDaGFydCcsXG4gIEdyYXBoaWNhbENoaWxkOiBfQXJlYS5BcmVhLFxuICBheGlzQ29tcG9uZW50czogW3tcbiAgICBheGlzVHlwZTogJ3hBeGlzJyxcbiAgICBBeGlzQ29tcDogX1hBeGlzLlhBeGlzXG4gIH0sIHtcbiAgICBheGlzVHlwZTogJ3lBeGlzJyxcbiAgICBBeGlzQ29tcDogX1lBeGlzLllBeGlzXG4gIH1dLFxuICBmb3JtYXRBeGlzTWFwOiBfQ2FydGVzaWFuVXRpbHMuZm9ybWF0QXhpc01hcFxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXJlYUNoYXJ0IiwiX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsInJlcXVpcmUiLCJfQXJlYSIsIl9YQXhpcyIsIl9ZQXhpcyIsIl9DYXJ0ZXNpYW5VdGlscyIsImdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsImNoYXJ0TmFtZSIsIkdyYXBoaWNhbENoaWxkIiwiQXJlYSIsImF4aXNDb21wb25lbnRzIiwiYXhpc1R5cGUiLCJBeGlzQ29tcCIsIlhBeGlzIiwiWUF4aXMiLCJmb3JtYXRBeGlzTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/chart/AreaChart.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/chart/BarChart.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/chart/BarChart.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BarChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _Bar = __webpack_require__(/*! ../cartesian/Bar */ \"./node_modules/recharts/lib/cartesian/Bar.js\");\nvar _XAxis = __webpack_require__(/*! ../cartesian/XAxis */ \"./node_modules/recharts/lib/cartesian/XAxis.js\");\nvar _YAxis = __webpack_require__(/*! ../cartesian/YAxis */ \"./node_modules/recharts/lib/cartesian/YAxis.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"./node_modules/recharts/lib/util/CartesianUtils.js\");\n/**\n * @fileOverview Bar Chart\n */ var BarChart = exports.BarChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: \"BarChart\",\n    GraphicalChild: _Bar.Bar,\n    defaultTooltipEventType: \"axis\",\n    validateTooltipEventTypes: [\n        \"axis\",\n        \"item\"\n    ],\n    axisComponents: [\n        {\n            axisType: \"xAxis\",\n            AxisComp: _XAxis.XAxis\n        },\n        {\n            axisType: \"yAxis\",\n            AxisComp: _YAxis.YAxis\n        }\n    ],\n    formatAxisMap: _CartesianUtils.formatAxisMap\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L0JhckNoYXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3hCLElBQUlHLDRCQUE0QkMsbUJBQU9BLENBQUMsaUdBQTRCO0FBQ3BFLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDLHNFQUFrQjtBQUNyQyxJQUFJRSxTQUFTRixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDekMsSUFBSUcsU0FBU0gsbUJBQU9BLENBQUMsMEVBQW9CO0FBQ3pDLElBQUlJLGtCQUFrQkosbUJBQU9BLENBQUMsa0ZBQXdCO0FBQ3REOztDQUVDLEdBRUQsSUFBSUYsV0FBV0YsZ0JBQWdCLEdBQUcsQ0FBQyxHQUFHRywwQkFBMEJNLHdCQUF3QixFQUFFO0lBQ3hGQyxXQUFXO0lBQ1hDLGdCQUFnQk4sS0FBS08sR0FBRztJQUN4QkMseUJBQXlCO0lBQ3pCQywyQkFBMkI7UUFBQztRQUFRO0tBQU87SUFDM0NDLGdCQUFnQjtRQUFDO1lBQ2ZDLFVBQVU7WUFDVkMsVUFBVVgsT0FBT1ksS0FBSztRQUN4QjtRQUFHO1lBQ0RGLFVBQVU7WUFDVkMsVUFBVVYsT0FBT1ksS0FBSztRQUN4QjtLQUFFO0lBQ0ZDLGVBQWVaLGdCQUFnQlksYUFBYTtBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvQmFyQ2hhcnQuanM/ODlhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQmFyQ2hhcnQgPSB2b2lkIDA7XG52YXIgX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydFwiKTtcbnZhciBfQmFyID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9CYXJcIik7XG52YXIgX1hBeGlzID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9YQXhpc1wiKTtcbnZhciBfWUF4aXMgPSByZXF1aXJlKFwiLi4vY2FydGVzaWFuL1lBeGlzXCIpO1xudmFyIF9DYXJ0ZXNpYW5VdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NhcnRlc2lhblV0aWxzXCIpO1xuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IEJhciBDaGFydFxuICovXG5cbnZhciBCYXJDaGFydCA9IGV4cG9ydHMuQmFyQ2hhcnQgPSAoMCwgX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydC5nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQpKHtcbiAgY2hhcnROYW1lOiAnQmFyQ2hhcnQnLFxuICBHcmFwaGljYWxDaGlsZDogX0Jhci5CYXIsXG4gIGRlZmF1bHRUb29sdGlwRXZlbnRUeXBlOiAnYXhpcycsXG4gIHZhbGlkYXRlVG9vbHRpcEV2ZW50VHlwZXM6IFsnYXhpcycsICdpdGVtJ10sXG4gIGF4aXNDb21wb25lbnRzOiBbe1xuICAgIGF4aXNUeXBlOiAneEF4aXMnLFxuICAgIEF4aXNDb21wOiBfWEF4aXMuWEF4aXNcbiAgfSwge1xuICAgIGF4aXNUeXBlOiAneUF4aXMnLFxuICAgIEF4aXNDb21wOiBfWUF4aXMuWUF4aXNcbiAgfV0sXG4gIGZvcm1hdEF4aXNNYXA6IF9DYXJ0ZXNpYW5VdGlscy5mb3JtYXRBeGlzTWFwXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCYXJDaGFydCIsIl9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQiLCJyZXF1aXJlIiwiX0JhciIsIl9YQXhpcyIsIl9ZQXhpcyIsIl9DYXJ0ZXNpYW5VdGlscyIsImdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsImNoYXJ0TmFtZSIsIkdyYXBoaWNhbENoaWxkIiwiQmFyIiwiZGVmYXVsdFRvb2x0aXBFdmVudFR5cGUiLCJ2YWxpZGF0ZVRvb2x0aXBFdmVudFR5cGVzIiwiYXhpc0NvbXBvbmVudHMiLCJheGlzVHlwZSIsIkF4aXNDb21wIiwiWEF4aXMiLCJZQXhpcyIsImZvcm1hdEF4aXNNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/chart/BarChart.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/chart/ComposedChart.js":
/*!**********************************************************!*\
  !*** ./node_modules/recharts/lib/chart/ComposedChart.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ComposedChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _Area = __webpack_require__(/*! ../cartesian/Area */ \"./node_modules/recharts/lib/cartesian/Area.js\");\nvar _Bar = __webpack_require__(/*! ../cartesian/Bar */ \"./node_modules/recharts/lib/cartesian/Bar.js\");\nvar _Line = __webpack_require__(/*! ../cartesian/Line */ \"./node_modules/recharts/lib/cartesian/Line.js\");\nvar _Scatter = __webpack_require__(/*! ../cartesian/Scatter */ \"./node_modules/recharts/lib/cartesian/Scatter.js\");\nvar _XAxis = __webpack_require__(/*! ../cartesian/XAxis */ \"./node_modules/recharts/lib/cartesian/XAxis.js\");\nvar _YAxis = __webpack_require__(/*! ../cartesian/YAxis */ \"./node_modules/recharts/lib/cartesian/YAxis.js\");\nvar _ZAxis = __webpack_require__(/*! ../cartesian/ZAxis */ \"./node_modules/recharts/lib/cartesian/ZAxis.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"./node_modules/recharts/lib/util/CartesianUtils.js\");\n/**\n * @fileOverview Composed Chart\n */ var ComposedChart = exports.ComposedChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: \"ComposedChart\",\n    GraphicalChild: [\n        _Line.Line,\n        _Area.Area,\n        _Bar.Bar,\n        _Scatter.Scatter\n    ],\n    axisComponents: [\n        {\n            axisType: \"xAxis\",\n            AxisComp: _XAxis.XAxis\n        },\n        {\n            axisType: \"yAxis\",\n            AxisComp: _YAxis.YAxis\n        },\n        {\n            axisType: \"zAxis\",\n            AxisComp: _ZAxis.ZAxis\n        }\n    ],\n    formatAxisMap: _CartesianUtils.formatAxisMap\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L0NvbXBvc2VkQ2hhcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHFCQUFxQixHQUFHLEtBQUs7QUFDN0IsSUFBSUcsNEJBQTRCQyxtQkFBT0EsQ0FBQyxpR0FBNEI7QUFDcEUsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUMsd0VBQW1CO0FBQ3ZDLElBQUlFLE9BQU9GLG1CQUFPQSxDQUFDLHNFQUFrQjtBQUNyQyxJQUFJRyxRQUFRSCxtQkFBT0EsQ0FBQyx3RUFBbUI7QUFDdkMsSUFBSUksV0FBV0osbUJBQU9BLENBQUMsOEVBQXNCO0FBQzdDLElBQUlLLFNBQVNMLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJTSxTQUFTTixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDekMsSUFBSU8sU0FBU1AsbUJBQU9BLENBQUMsMEVBQW9CO0FBQ3pDLElBQUlRLGtCQUFrQlIsbUJBQU9BLENBQUMsa0ZBQXdCO0FBQ3REOztDQUVDLEdBRUQsSUFBSUYsZ0JBQWdCRixxQkFBcUIsR0FBRyxDQUFDLEdBQUdHLDBCQUEwQlUsd0JBQXdCLEVBQUU7SUFDbEdDLFdBQVc7SUFDWEMsZ0JBQWdCO1FBQUNSLE1BQU1TLElBQUk7UUFBRVgsTUFBTVksSUFBSTtRQUFFWCxLQUFLWSxHQUFHO1FBQUVWLFNBQVNXLE9BQU87S0FBQztJQUNwRUMsZ0JBQWdCO1FBQUM7WUFDZkMsVUFBVTtZQUNWQyxVQUFVYixPQUFPYyxLQUFLO1FBQ3hCO1FBQUc7WUFDREYsVUFBVTtZQUNWQyxVQUFVWixPQUFPYyxLQUFLO1FBQ3hCO1FBQUc7WUFDREgsVUFBVTtZQUNWQyxVQUFVWCxPQUFPYyxLQUFLO1FBQ3hCO0tBQUU7SUFDRkMsZUFBZWQsZ0JBQWdCYyxhQUFhO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9jaGFydC9Db21wb3NlZENoYXJ0LmpzP2Q1MGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNvbXBvc2VkQ2hhcnQgPSB2b2lkIDA7XG52YXIgX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydFwiKTtcbnZhciBfQXJlYSA9IHJlcXVpcmUoXCIuLi9jYXJ0ZXNpYW4vQXJlYVwiKTtcbnZhciBfQmFyID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9CYXJcIik7XG52YXIgX0xpbmUgPSByZXF1aXJlKFwiLi4vY2FydGVzaWFuL0xpbmVcIik7XG52YXIgX1NjYXR0ZXIgPSByZXF1aXJlKFwiLi4vY2FydGVzaWFuL1NjYXR0ZXJcIik7XG52YXIgX1hBeGlzID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9YQXhpc1wiKTtcbnZhciBfWUF4aXMgPSByZXF1aXJlKFwiLi4vY2FydGVzaWFuL1lBeGlzXCIpO1xudmFyIF9aQXhpcyA9IHJlcXVpcmUoXCIuLi9jYXJ0ZXNpYW4vWkF4aXNcIik7XG52YXIgX0NhcnRlc2lhblV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQ2FydGVzaWFuVXRpbHNcIik7XG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgQ29tcG9zZWQgQ2hhcnRcbiAqL1xuXG52YXIgQ29tcG9zZWRDaGFydCA9IGV4cG9ydHMuQ29tcG9zZWRDaGFydCA9ICgwLCBfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0LmdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCkoe1xuICBjaGFydE5hbWU6ICdDb21wb3NlZENoYXJ0JyxcbiAgR3JhcGhpY2FsQ2hpbGQ6IFtfTGluZS5MaW5lLCBfQXJlYS5BcmVhLCBfQmFyLkJhciwgX1NjYXR0ZXIuU2NhdHRlcl0sXG4gIGF4aXNDb21wb25lbnRzOiBbe1xuICAgIGF4aXNUeXBlOiAneEF4aXMnLFxuICAgIEF4aXNDb21wOiBfWEF4aXMuWEF4aXNcbiAgfSwge1xuICAgIGF4aXNUeXBlOiAneUF4aXMnLFxuICAgIEF4aXNDb21wOiBfWUF4aXMuWUF4aXNcbiAgfSwge1xuICAgIGF4aXNUeXBlOiAnekF4aXMnLFxuICAgIEF4aXNDb21wOiBfWkF4aXMuWkF4aXNcbiAgfV0sXG4gIGZvcm1hdEF4aXNNYXA6IF9DYXJ0ZXNpYW5VdGlscy5mb3JtYXRBeGlzTWFwXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDb21wb3NlZENoYXJ0IiwiX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsInJlcXVpcmUiLCJfQXJlYSIsIl9CYXIiLCJfTGluZSIsIl9TY2F0dGVyIiwiX1hBeGlzIiwiX1lBeGlzIiwiX1pBeGlzIiwiX0NhcnRlc2lhblV0aWxzIiwiZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IiwiY2hhcnROYW1lIiwiR3JhcGhpY2FsQ2hpbGQiLCJMaW5lIiwiQXJlYSIsIkJhciIsIlNjYXR0ZXIiLCJheGlzQ29tcG9uZW50cyIsImF4aXNUeXBlIiwiQXhpc0NvbXAiLCJYQXhpcyIsIllBeGlzIiwiWkF4aXMiLCJmb3JtYXRBeGlzTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/chart/ComposedChart.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/chart/FunnelChart.js":
/*!********************************************************!*\
  !*** ./node_modules/recharts/lib/chart/FunnelChart.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FunnelChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _Funnel = __webpack_require__(/*! ../numberAxis/Funnel */ \"./node_modules/recharts/lib/numberAxis/Funnel.js\");\n/**\n * @fileOverview Funnel Chart\n */ var FunnelChart = exports.FunnelChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: \"FunnelChart\",\n    GraphicalChild: _Funnel.Funnel,\n    validateTooltipEventTypes: [\n        \"item\"\n    ],\n    defaultTooltipEventType: \"item\",\n    axisComponents: [],\n    defaultProps: {\n        layout: \"centric\"\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L0Z1bm5lbENoYXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxtQkFBbUIsR0FBRyxLQUFLO0FBQzNCLElBQUlHLDRCQUE0QkMsbUJBQU9BLENBQUMsaUdBQTRCO0FBQ3BFLElBQUlDLFVBQVVELG1CQUFPQSxDQUFDLDhFQUFzQjtBQUM1Qzs7Q0FFQyxHQUVELElBQUlGLGNBQWNGLG1CQUFtQixHQUFHLENBQUMsR0FBR0csMEJBQTBCRyx3QkFBd0IsRUFBRTtJQUM5RkMsV0FBVztJQUNYQyxnQkFBZ0JILFFBQVFJLE1BQU07SUFDOUJDLDJCQUEyQjtRQUFDO0tBQU87SUFDbkNDLHlCQUF5QjtJQUN6QkMsZ0JBQWdCLEVBQUU7SUFDbEJDLGNBQWM7UUFDWkMsUUFBUTtJQUNWO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L0Z1bm5lbENoYXJ0LmpzPzdjMTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkZ1bm5lbENoYXJ0ID0gdm9pZCAwO1xudmFyIF9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnRcIik7XG52YXIgX0Z1bm5lbCA9IHJlcXVpcmUoXCIuLi9udW1iZXJBeGlzL0Z1bm5lbFwiKTtcbi8qKlxuICogQGZpbGVPdmVydmlldyBGdW5uZWwgQ2hhcnRcbiAqL1xuXG52YXIgRnVubmVsQ2hhcnQgPSBleHBvcnRzLkZ1bm5lbENoYXJ0ID0gKDAsIF9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQuZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0KSh7XG4gIGNoYXJ0TmFtZTogJ0Z1bm5lbENoYXJ0JyxcbiAgR3JhcGhpY2FsQ2hpbGQ6IF9GdW5uZWwuRnVubmVsLFxuICB2YWxpZGF0ZVRvb2x0aXBFdmVudFR5cGVzOiBbJ2l0ZW0nXSxcbiAgZGVmYXVsdFRvb2x0aXBFdmVudFR5cGU6ICdpdGVtJyxcbiAgYXhpc0NvbXBvbmVudHM6IFtdLFxuICBkZWZhdWx0UHJvcHM6IHtcbiAgICBsYXlvdXQ6ICdjZW50cmljJ1xuICB9XG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJGdW5uZWxDaGFydCIsIl9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQiLCJyZXF1aXJlIiwiX0Z1bm5lbCIsImdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsImNoYXJ0TmFtZSIsIkdyYXBoaWNhbENoaWxkIiwiRnVubmVsIiwidmFsaWRhdGVUb29sdGlwRXZlbnRUeXBlcyIsImRlZmF1bHRUb29sdGlwRXZlbnRUeXBlIiwiYXhpc0NvbXBvbmVudHMiLCJkZWZhdWx0UHJvcHMiLCJsYXlvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/chart/FunnelChart.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/chart/LineChart.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/chart/LineChart.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LineChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _Line = __webpack_require__(/*! ../cartesian/Line */ \"./node_modules/recharts/lib/cartesian/Line.js\");\nvar _XAxis = __webpack_require__(/*! ../cartesian/XAxis */ \"./node_modules/recharts/lib/cartesian/XAxis.js\");\nvar _YAxis = __webpack_require__(/*! ../cartesian/YAxis */ \"./node_modules/recharts/lib/cartesian/YAxis.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"./node_modules/recharts/lib/util/CartesianUtils.js\");\n/**\n * @fileOverview Line Chart\n */ var LineChart = exports.LineChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: \"LineChart\",\n    GraphicalChild: _Line.Line,\n    axisComponents: [\n        {\n            axisType: \"xAxis\",\n            AxisComp: _XAxis.XAxis\n        },\n        {\n            axisType: \"yAxis\",\n            AxisComp: _YAxis.YAxis\n        }\n    ],\n    formatAxisMap: _CartesianUtils.formatAxisMap\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L0xpbmVDaGFydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixJQUFJRyw0QkFBNEJDLG1CQUFPQSxDQUFDLGlHQUE0QjtBQUNwRSxJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQyx3RUFBbUI7QUFDdkMsSUFBSUUsU0FBU0YsbUJBQU9BLENBQUMsMEVBQW9CO0FBQ3pDLElBQUlHLFNBQVNILG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJSSxrQkFBa0JKLG1CQUFPQSxDQUFDLGtGQUF3QjtBQUN0RDs7Q0FFQyxHQUVELElBQUlGLFlBQVlGLGlCQUFpQixHQUFHLENBQUMsR0FBR0csMEJBQTBCTSx3QkFBd0IsRUFBRTtJQUMxRkMsV0FBVztJQUNYQyxnQkFBZ0JOLE1BQU1PLElBQUk7SUFDMUJDLGdCQUFnQjtRQUFDO1lBQ2ZDLFVBQVU7WUFDVkMsVUFBVVQsT0FBT1UsS0FBSztRQUN4QjtRQUFHO1lBQ0RGLFVBQVU7WUFDVkMsVUFBVVIsT0FBT1UsS0FBSztRQUN4QjtLQUFFO0lBQ0ZDLGVBQWVWLGdCQUFnQlUsYUFBYTtBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvTGluZUNoYXJ0LmpzP2NhN2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkxpbmVDaGFydCA9IHZvaWQgMDtcbnZhciBfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0ID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0XCIpO1xudmFyIF9MaW5lID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9MaW5lXCIpO1xudmFyIF9YQXhpcyA9IHJlcXVpcmUoXCIuLi9jYXJ0ZXNpYW4vWEF4aXNcIik7XG52YXIgX1lBeGlzID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9ZQXhpc1wiKTtcbnZhciBfQ2FydGVzaWFuVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9DYXJ0ZXNpYW5VdGlsc1wiKTtcbi8qKlxuICogQGZpbGVPdmVydmlldyBMaW5lIENoYXJ0XG4gKi9cblxudmFyIExpbmVDaGFydCA9IGV4cG9ydHMuTGluZUNoYXJ0ID0gKDAsIF9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQuZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0KSh7XG4gIGNoYXJ0TmFtZTogJ0xpbmVDaGFydCcsXG4gIEdyYXBoaWNhbENoaWxkOiBfTGluZS5MaW5lLFxuICBheGlzQ29tcG9uZW50czogW3tcbiAgICBheGlzVHlwZTogJ3hBeGlzJyxcbiAgICBBeGlzQ29tcDogX1hBeGlzLlhBeGlzXG4gIH0sIHtcbiAgICBheGlzVHlwZTogJ3lBeGlzJyxcbiAgICBBeGlzQ29tcDogX1lBeGlzLllBeGlzXG4gIH1dLFxuICBmb3JtYXRBeGlzTWFwOiBfQ2FydGVzaWFuVXRpbHMuZm9ybWF0QXhpc01hcFxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTGluZUNoYXJ0IiwiX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsInJlcXVpcmUiLCJfTGluZSIsIl9YQXhpcyIsIl9ZQXhpcyIsIl9DYXJ0ZXNpYW5VdGlscyIsImdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsImNoYXJ0TmFtZSIsIkdyYXBoaWNhbENoaWxkIiwiTGluZSIsImF4aXNDb21wb25lbnRzIiwiYXhpc1R5cGUiLCJBeGlzQ29tcCIsIlhBeGlzIiwiWUF4aXMiLCJmb3JtYXRBeGlzTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/chart/LineChart.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/chart/PieChart.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/chart/PieChart.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PieChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _PolarAngleAxis = __webpack_require__(/*! ../polar/PolarAngleAxis */ \"./node_modules/recharts/lib/polar/PolarAngleAxis.js\");\nvar _PolarRadiusAxis = __webpack_require__(/*! ../polar/PolarRadiusAxis */ \"./node_modules/recharts/lib/polar/PolarRadiusAxis.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _Pie = __webpack_require__(/*! ../polar/Pie */ \"./node_modules/recharts/lib/polar/Pie.js\");\n/**\n * @fileOverview Pie Chart\n */ var PieChart = exports.PieChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: \"PieChart\",\n    GraphicalChild: _Pie.Pie,\n    validateTooltipEventTypes: [\n        \"item\"\n    ],\n    defaultTooltipEventType: \"item\",\n    legendContent: \"children\",\n    axisComponents: [\n        {\n            axisType: \"angleAxis\",\n            AxisComp: _PolarAngleAxis.PolarAngleAxis\n        },\n        {\n            axisType: \"radiusAxis\",\n            AxisComp: _PolarRadiusAxis.PolarRadiusAxis\n        }\n    ],\n    formatAxisMap: _PolarUtils.formatAxisMap,\n    defaultProps: {\n        layout: \"centric\",\n        startAngle: 0,\n        endAngle: 360,\n        cx: \"50%\",\n        cy: \"50%\",\n        innerRadius: 0,\n        outerRadius: \"80%\"\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L1BpZUNoYXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3hCLElBQUlHLDRCQUE0QkMsbUJBQU9BLENBQUMsaUdBQTRCO0FBQ3BFLElBQUlDLGtCQUFrQkQsbUJBQU9BLENBQUMsb0ZBQXlCO0FBQ3ZELElBQUlFLG1CQUFtQkYsbUJBQU9BLENBQUMsc0ZBQTBCO0FBQ3pELElBQUlHLGNBQWNILG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJSSxPQUFPSixtQkFBT0EsQ0FBQyw4REFBYztBQUNqQzs7Q0FFQyxHQUVELElBQUlGLFdBQVdGLGdCQUFnQixHQUFHLENBQUMsR0FBR0csMEJBQTBCTSx3QkFBd0IsRUFBRTtJQUN4RkMsV0FBVztJQUNYQyxnQkFBZ0JILEtBQUtJLEdBQUc7SUFDeEJDLDJCQUEyQjtRQUFDO0tBQU87SUFDbkNDLHlCQUF5QjtJQUN6QkMsZUFBZTtJQUNmQyxnQkFBZ0I7UUFBQztZQUNmQyxVQUFVO1lBQ1ZDLFVBQVViLGdCQUFnQmMsY0FBYztRQUMxQztRQUFHO1lBQ0RGLFVBQVU7WUFDVkMsVUFBVVosaUJBQWlCYyxlQUFlO1FBQzVDO0tBQUU7SUFDRkMsZUFBZWQsWUFBWWMsYUFBYTtJQUN4Q0MsY0FBYztRQUNaQyxRQUFRO1FBQ1JDLFlBQVk7UUFDWkMsVUFBVTtRQUNWQyxJQUFJO1FBQ0pDLElBQUk7UUFDSkMsYUFBYTtRQUNiQyxhQUFhO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvUGllQ2hhcnQuanM/NTFjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUGllQ2hhcnQgPSB2b2lkIDA7XG52YXIgX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydFwiKTtcbnZhciBfUG9sYXJBbmdsZUF4aXMgPSByZXF1aXJlKFwiLi4vcG9sYXIvUG9sYXJBbmdsZUF4aXNcIik7XG52YXIgX1BvbGFyUmFkaXVzQXhpcyA9IHJlcXVpcmUoXCIuLi9wb2xhci9Qb2xhclJhZGl1c0F4aXNcIik7XG52YXIgX1BvbGFyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Qb2xhclV0aWxzXCIpO1xudmFyIF9QaWUgPSByZXF1aXJlKFwiLi4vcG9sYXIvUGllXCIpO1xuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFBpZSBDaGFydFxuICovXG5cbnZhciBQaWVDaGFydCA9IGV4cG9ydHMuUGllQ2hhcnQgPSAoMCwgX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydC5nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQpKHtcbiAgY2hhcnROYW1lOiAnUGllQ2hhcnQnLFxuICBHcmFwaGljYWxDaGlsZDogX1BpZS5QaWUsXG4gIHZhbGlkYXRlVG9vbHRpcEV2ZW50VHlwZXM6IFsnaXRlbSddLFxuICBkZWZhdWx0VG9vbHRpcEV2ZW50VHlwZTogJ2l0ZW0nLFxuICBsZWdlbmRDb250ZW50OiAnY2hpbGRyZW4nLFxuICBheGlzQ29tcG9uZW50czogW3tcbiAgICBheGlzVHlwZTogJ2FuZ2xlQXhpcycsXG4gICAgQXhpc0NvbXA6IF9Qb2xhckFuZ2xlQXhpcy5Qb2xhckFuZ2xlQXhpc1xuICB9LCB7XG4gICAgYXhpc1R5cGU6ICdyYWRpdXNBeGlzJyxcbiAgICBBeGlzQ29tcDogX1BvbGFyUmFkaXVzQXhpcy5Qb2xhclJhZGl1c0F4aXNcbiAgfV0sXG4gIGZvcm1hdEF4aXNNYXA6IF9Qb2xhclV0aWxzLmZvcm1hdEF4aXNNYXAsXG4gIGRlZmF1bHRQcm9wczoge1xuICAgIGxheW91dDogJ2NlbnRyaWMnLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgZW5kQW5nbGU6IDM2MCxcbiAgICBjeDogJzUwJScsXG4gICAgY3k6ICc1MCUnLFxuICAgIGlubmVyUmFkaXVzOiAwLFxuICAgIG91dGVyUmFkaXVzOiAnODAlJ1xuICB9XG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQaWVDaGFydCIsIl9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQiLCJyZXF1aXJlIiwiX1BvbGFyQW5nbGVBeGlzIiwiX1BvbGFyUmFkaXVzQXhpcyIsIl9Qb2xhclV0aWxzIiwiX1BpZSIsImdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsImNoYXJ0TmFtZSIsIkdyYXBoaWNhbENoaWxkIiwiUGllIiwidmFsaWRhdGVUb29sdGlwRXZlbnRUeXBlcyIsImRlZmF1bHRUb29sdGlwRXZlbnRUeXBlIiwibGVnZW5kQ29udGVudCIsImF4aXNDb21wb25lbnRzIiwiYXhpc1R5cGUiLCJBeGlzQ29tcCIsIlBvbGFyQW5nbGVBeGlzIiwiUG9sYXJSYWRpdXNBeGlzIiwiZm9ybWF0QXhpc01hcCIsImRlZmF1bHRQcm9wcyIsImxheW91dCIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsImN4IiwiY3kiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/chart/PieChart.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/chart/RadarChart.js":
/*!*******************************************************!*\
  !*** ./node_modules/recharts/lib/chart/RadarChart.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RadarChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _Radar = __webpack_require__(/*! ../polar/Radar */ \"./node_modules/recharts/lib/polar/Radar.js\");\nvar _PolarAngleAxis = __webpack_require__(/*! ../polar/PolarAngleAxis */ \"./node_modules/recharts/lib/polar/PolarAngleAxis.js\");\nvar _PolarRadiusAxis = __webpack_require__(/*! ../polar/PolarRadiusAxis */ \"./node_modules/recharts/lib/polar/PolarRadiusAxis.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"./node_modules/recharts/lib/util/PolarUtils.js\");\n/**\n * @fileOverview Radar Chart\n */ var RadarChart = exports.RadarChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: \"RadarChart\",\n    GraphicalChild: _Radar.Radar,\n    axisComponents: [\n        {\n            axisType: \"angleAxis\",\n            AxisComp: _PolarAngleAxis.PolarAngleAxis\n        },\n        {\n            axisType: \"radiusAxis\",\n            AxisComp: _PolarRadiusAxis.PolarRadiusAxis\n        }\n    ],\n    formatAxisMap: _PolarUtils.formatAxisMap,\n    defaultProps: {\n        layout: \"centric\",\n        startAngle: 90,\n        endAngle: -270,\n        cx: \"50%\",\n        cy: \"50%\",\n        innerRadius: 0,\n        outerRadius: \"80%\"\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L1JhZGFyQ2hhcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFrQixHQUFHLEtBQUs7QUFDMUIsSUFBSUcsNEJBQTRCQyxtQkFBT0EsQ0FBQyxpR0FBNEI7QUFDcEUsSUFBSUMsU0FBU0QsbUJBQU9BLENBQUMsa0VBQWdCO0FBQ3JDLElBQUlFLGtCQUFrQkYsbUJBQU9BLENBQUMsb0ZBQXlCO0FBQ3ZELElBQUlHLG1CQUFtQkgsbUJBQU9BLENBQUMsc0ZBQTBCO0FBQ3pELElBQUlJLGNBQWNKLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5Qzs7Q0FFQyxHQUVELElBQUlGLGFBQWFGLGtCQUFrQixHQUFHLENBQUMsR0FBR0csMEJBQTBCTSx3QkFBd0IsRUFBRTtJQUM1RkMsV0FBVztJQUNYQyxnQkFBZ0JOLE9BQU9PLEtBQUs7SUFDNUJDLGdCQUFnQjtRQUFDO1lBQ2ZDLFVBQVU7WUFDVkMsVUFBVVQsZ0JBQWdCVSxjQUFjO1FBQzFDO1FBQUc7WUFDREYsVUFBVTtZQUNWQyxVQUFVUixpQkFBaUJVLGVBQWU7UUFDNUM7S0FBRTtJQUNGQyxlQUFlVixZQUFZVSxhQUFhO0lBQ3hDQyxjQUFjO1FBQ1pDLFFBQVE7UUFDUkMsWUFBWTtRQUNaQyxVQUFVLENBQUM7UUFDWEMsSUFBSTtRQUNKQyxJQUFJO1FBQ0pDLGFBQWE7UUFDYkMsYUFBYTtJQUNmO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L1JhZGFyQ2hhcnQuanM/NzA0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUmFkYXJDaGFydCA9IHZvaWQgMDtcbnZhciBfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0ID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0XCIpO1xudmFyIF9SYWRhciA9IHJlcXVpcmUoXCIuLi9wb2xhci9SYWRhclwiKTtcbnZhciBfUG9sYXJBbmdsZUF4aXMgPSByZXF1aXJlKFwiLi4vcG9sYXIvUG9sYXJBbmdsZUF4aXNcIik7XG52YXIgX1BvbGFyUmFkaXVzQXhpcyA9IHJlcXVpcmUoXCIuLi9wb2xhci9Qb2xhclJhZGl1c0F4aXNcIik7XG52YXIgX1BvbGFyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Qb2xhclV0aWxzXCIpO1xuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFJhZGFyIENoYXJ0XG4gKi9cblxudmFyIFJhZGFyQ2hhcnQgPSBleHBvcnRzLlJhZGFyQ2hhcnQgPSAoMCwgX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydC5nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQpKHtcbiAgY2hhcnROYW1lOiAnUmFkYXJDaGFydCcsXG4gIEdyYXBoaWNhbENoaWxkOiBfUmFkYXIuUmFkYXIsXG4gIGF4aXNDb21wb25lbnRzOiBbe1xuICAgIGF4aXNUeXBlOiAnYW5nbGVBeGlzJyxcbiAgICBBeGlzQ29tcDogX1BvbGFyQW5nbGVBeGlzLlBvbGFyQW5nbGVBeGlzXG4gIH0sIHtcbiAgICBheGlzVHlwZTogJ3JhZGl1c0F4aXMnLFxuICAgIEF4aXNDb21wOiBfUG9sYXJSYWRpdXNBeGlzLlBvbGFyUmFkaXVzQXhpc1xuICB9XSxcbiAgZm9ybWF0QXhpc01hcDogX1BvbGFyVXRpbHMuZm9ybWF0QXhpc01hcCxcbiAgZGVmYXVsdFByb3BzOiB7XG4gICAgbGF5b3V0OiAnY2VudHJpYycsXG4gICAgc3RhcnRBbmdsZTogOTAsXG4gICAgZW5kQW5nbGU6IC0yNzAsXG4gICAgY3g6ICc1MCUnLFxuICAgIGN5OiAnNTAlJyxcbiAgICBpbm5lclJhZGl1czogMCxcbiAgICBvdXRlclJhZGl1czogJzgwJSdcbiAgfVxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUmFkYXJDaGFydCIsIl9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQiLCJyZXF1aXJlIiwiX1JhZGFyIiwiX1BvbGFyQW5nbGVBeGlzIiwiX1BvbGFyUmFkaXVzQXhpcyIsIl9Qb2xhclV0aWxzIiwiZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IiwiY2hhcnROYW1lIiwiR3JhcGhpY2FsQ2hpbGQiLCJSYWRhciIsImF4aXNDb21wb25lbnRzIiwiYXhpc1R5cGUiLCJBeGlzQ29tcCIsIlBvbGFyQW5nbGVBeGlzIiwiUG9sYXJSYWRpdXNBeGlzIiwiZm9ybWF0QXhpc01hcCIsImRlZmF1bHRQcm9wcyIsImxheW91dCIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsImN4IiwiY3kiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/chart/RadarChart.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/chart/RadialBarChart.js":
/*!***********************************************************!*\
  !*** ./node_modules/recharts/lib/chart/RadialBarChart.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RadialBarChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _PolarAngleAxis = __webpack_require__(/*! ../polar/PolarAngleAxis */ \"./node_modules/recharts/lib/polar/PolarAngleAxis.js\");\nvar _PolarRadiusAxis = __webpack_require__(/*! ../polar/PolarRadiusAxis */ \"./node_modules/recharts/lib/polar/PolarRadiusAxis.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _RadialBar = __webpack_require__(/*! ../polar/RadialBar */ \"./node_modules/recharts/lib/polar/RadialBar.js\");\n/**\n * @fileOverview Radar Bar Chart\n */ var RadialBarChart = exports.RadialBarChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: \"RadialBarChart\",\n    GraphicalChild: _RadialBar.RadialBar,\n    legendContent: \"children\",\n    defaultTooltipEventType: \"axis\",\n    validateTooltipEventTypes: [\n        \"axis\",\n        \"item\"\n    ],\n    axisComponents: [\n        {\n            axisType: \"angleAxis\",\n            AxisComp: _PolarAngleAxis.PolarAngleAxis\n        },\n        {\n            axisType: \"radiusAxis\",\n            AxisComp: _PolarRadiusAxis.PolarRadiusAxis\n        }\n    ],\n    formatAxisMap: _PolarUtils.formatAxisMap,\n    defaultProps: {\n        layout: \"radial\",\n        startAngle: 0,\n        endAngle: 360,\n        cx: \"50%\",\n        cy: \"50%\",\n        innerRadius: 0,\n        outerRadius: \"80%\"\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L1JhZGlhbEJhckNoYXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCLElBQUlHLDRCQUE0QkMsbUJBQU9BLENBQUMsaUdBQTRCO0FBQ3BFLElBQUlDLGtCQUFrQkQsbUJBQU9BLENBQUMsb0ZBQXlCO0FBQ3ZELElBQUlFLG1CQUFtQkYsbUJBQU9BLENBQUMsc0ZBQTBCO0FBQ3pELElBQUlHLGNBQWNILG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJSSxhQUFhSixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDN0M7O0NBRUMsR0FFRCxJQUFJRixpQkFBaUJGLHNCQUFzQixHQUFHLENBQUMsR0FBR0csMEJBQTBCTSx3QkFBd0IsRUFBRTtJQUNwR0MsV0FBVztJQUNYQyxnQkFBZ0JILFdBQVdJLFNBQVM7SUFDcENDLGVBQWU7SUFDZkMseUJBQXlCO0lBQ3pCQywyQkFBMkI7UUFBQztRQUFRO0tBQU87SUFDM0NDLGdCQUFnQjtRQUFDO1lBQ2ZDLFVBQVU7WUFDVkMsVUFBVWIsZ0JBQWdCYyxjQUFjO1FBQzFDO1FBQUc7WUFDREYsVUFBVTtZQUNWQyxVQUFVWixpQkFBaUJjLGVBQWU7UUFDNUM7S0FBRTtJQUNGQyxlQUFlZCxZQUFZYyxhQUFhO0lBQ3hDQyxjQUFjO1FBQ1pDLFFBQVE7UUFDUkMsWUFBWTtRQUNaQyxVQUFVO1FBQ1ZDLElBQUk7UUFDSkMsSUFBSTtRQUNKQyxhQUFhO1FBQ2JDLGFBQWE7SUFDZjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9jaGFydC9SYWRpYWxCYXJDaGFydC5qcz82YWE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5SYWRpYWxCYXJDaGFydCA9IHZvaWQgMDtcbnZhciBfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0ID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0XCIpO1xudmFyIF9Qb2xhckFuZ2xlQXhpcyA9IHJlcXVpcmUoXCIuLi9wb2xhci9Qb2xhckFuZ2xlQXhpc1wiKTtcbnZhciBfUG9sYXJSYWRpdXNBeGlzID0gcmVxdWlyZShcIi4uL3BvbGFyL1BvbGFyUmFkaXVzQXhpc1wiKTtcbnZhciBfUG9sYXJVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1BvbGFyVXRpbHNcIik7XG52YXIgX1JhZGlhbEJhciA9IHJlcXVpcmUoXCIuLi9wb2xhci9SYWRpYWxCYXJcIik7XG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgUmFkYXIgQmFyIENoYXJ0XG4gKi9cblxudmFyIFJhZGlhbEJhckNoYXJ0ID0gZXhwb3J0cy5SYWRpYWxCYXJDaGFydCA9ICgwLCBfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0LmdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCkoe1xuICBjaGFydE5hbWU6ICdSYWRpYWxCYXJDaGFydCcsXG4gIEdyYXBoaWNhbENoaWxkOiBfUmFkaWFsQmFyLlJhZGlhbEJhcixcbiAgbGVnZW5kQ29udGVudDogJ2NoaWxkcmVuJyxcbiAgZGVmYXVsdFRvb2x0aXBFdmVudFR5cGU6ICdheGlzJyxcbiAgdmFsaWRhdGVUb29sdGlwRXZlbnRUeXBlczogWydheGlzJywgJ2l0ZW0nXSxcbiAgYXhpc0NvbXBvbmVudHM6IFt7XG4gICAgYXhpc1R5cGU6ICdhbmdsZUF4aXMnLFxuICAgIEF4aXNDb21wOiBfUG9sYXJBbmdsZUF4aXMuUG9sYXJBbmdsZUF4aXNcbiAgfSwge1xuICAgIGF4aXNUeXBlOiAncmFkaXVzQXhpcycsXG4gICAgQXhpc0NvbXA6IF9Qb2xhclJhZGl1c0F4aXMuUG9sYXJSYWRpdXNBeGlzXG4gIH1dLFxuICBmb3JtYXRBeGlzTWFwOiBfUG9sYXJVdGlscy5mb3JtYXRBeGlzTWFwLFxuICBkZWZhdWx0UHJvcHM6IHtcbiAgICBsYXlvdXQ6ICdyYWRpYWwnLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgZW5kQW5nbGU6IDM2MCxcbiAgICBjeDogJzUwJScsXG4gICAgY3k6ICc1MCUnLFxuICAgIGlubmVyUmFkaXVzOiAwLFxuICAgIG91dGVyUmFkaXVzOiAnODAlJ1xuICB9XG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSYWRpYWxCYXJDaGFydCIsIl9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQiLCJyZXF1aXJlIiwiX1BvbGFyQW5nbGVBeGlzIiwiX1BvbGFyUmFkaXVzQXhpcyIsIl9Qb2xhclV0aWxzIiwiX1JhZGlhbEJhciIsImdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsImNoYXJ0TmFtZSIsIkdyYXBoaWNhbENoaWxkIiwiUmFkaWFsQmFyIiwibGVnZW5kQ29udGVudCIsImRlZmF1bHRUb29sdGlwRXZlbnRUeXBlIiwidmFsaWRhdGVUb29sdGlwRXZlbnRUeXBlcyIsImF4aXNDb21wb25lbnRzIiwiYXhpc1R5cGUiLCJBeGlzQ29tcCIsIlBvbGFyQW5nbGVBeGlzIiwiUG9sYXJSYWRpdXNBeGlzIiwiZm9ybWF0QXhpc01hcCIsImRlZmF1bHRQcm9wcyIsImxheW91dCIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsImN4IiwiY3kiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/chart/RadialBarChart.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/chart/Sankey.js":
/*!***************************************************!*\
  !*** ./node_modules/recharts/lib/chart/Sankey.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Sankey = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _maxBy = _interopRequireDefault(__webpack_require__(/*! lodash/maxBy */ \"lodash/maxBy\"));\nvar _min = _interopRequireDefault(__webpack_require__(/*! lodash/min */ \"lodash/min\"));\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _sumBy = _interopRequireDefault(__webpack_require__(/*! lodash/sumBy */ \"lodash/sumBy\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _Surface = __webpack_require__(/*! ../container/Surface */ \"./node_modules/recharts/lib/container/Surface.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _Tooltip = __webpack_require__(/*! ../component/Tooltip */ \"./node_modules/recharts/lib/component/Tooltip.js\");\nvar _Rectangle = __webpack_require__(/*! ../shape/Rectangle */ \"./node_modules/recharts/lib/shape/Rectangle.js\");\nvar _ShallowEqual = __webpack_require__(/*! ../util/ShallowEqual */ \"./node_modules/recharts/lib/util/ShallowEqual.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _excluded = [\n    \"width\",\n    \"height\",\n    \"className\",\n    \"style\",\n    \"children\"\n], _excluded2 = [\n    \"sourceX\",\n    \"sourceY\",\n    \"sourceControlX\",\n    \"targetX\",\n    \"targetY\",\n    \"targetControlX\",\n    \"linkWidth\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @file TreemapChart\n */ \nvar defaultCoordinateOfTooltip = {\n    x: 0,\n    y: 0\n};\nvar interpolationGenerator = function interpolationGenerator(a, b) {\n    var ka = +a;\n    var kb = b - ka;\n    return function(t) {\n        return ka + kb * t;\n    };\n};\nvar centerY = function centerY(node) {\n    return node.y + node.dy / 2;\n};\nvar getValue = function getValue(entry) {\n    return entry && entry.value || 0;\n};\nvar getSumOfIds = function getSumOfIds(links, ids) {\n    return ids.reduce(function(result, id) {\n        return result + getValue(links[id]);\n    }, 0);\n};\nvar getSumWithWeightedSource = function getSumWithWeightedSource(tree, links, ids) {\n    return ids.reduce(function(result, id) {\n        var link = links[id];\n        var sourceNode = tree[link.source];\n        return result + centerY(sourceNode) * getValue(links[id]);\n    }, 0);\n};\nvar getSumWithWeightedTarget = function getSumWithWeightedTarget(tree, links, ids) {\n    return ids.reduce(function(result, id) {\n        var link = links[id];\n        var targetNode = tree[link.target];\n        return result + centerY(targetNode) * getValue(links[id]);\n    }, 0);\n};\nvar ascendingY = function ascendingY(a, b) {\n    return a.y - b.y;\n};\nvar searchTargetsAndSources = function searchTargetsAndSources(links, id) {\n    var sourceNodes = [];\n    var sourceLinks = [];\n    var targetNodes = [];\n    var targetLinks = [];\n    for(var i = 0, len = links.length; i < len; i++){\n        var link = links[i];\n        if (link.source === id) {\n            targetNodes.push(link.target);\n            targetLinks.push(i);\n        }\n        if (link.target === id) {\n            sourceNodes.push(link.source);\n            sourceLinks.push(i);\n        }\n    }\n    return {\n        sourceNodes: sourceNodes,\n        sourceLinks: sourceLinks,\n        targetLinks: targetLinks,\n        targetNodes: targetNodes\n    };\n};\nvar updateDepthOfTargets = function updateDepthOfTargets(tree, curNode) {\n    var targetNodes = curNode.targetNodes;\n    for(var i = 0, len = targetNodes.length; i < len; i++){\n        var target = tree[targetNodes[i]];\n        if (target) {\n            target.depth = Math.max(curNode.depth + 1, target.depth);\n            updateDepthOfTargets(tree, target);\n        }\n    }\n};\nvar getNodesTree = function getNodesTree(_ref, width, nodeWidth) {\n    var nodes = _ref.nodes, links = _ref.links;\n    var tree = nodes.map(function(entry, index) {\n        var result = searchTargetsAndSources(links, index);\n        return _objectSpread(_objectSpread(_objectSpread({}, entry), result), {}, {\n            value: Math.max(getSumOfIds(links, result.sourceLinks), getSumOfIds(links, result.targetLinks)),\n            depth: 0\n        });\n    });\n    for(var i = 0, len = tree.length; i < len; i++){\n        var node = tree[i];\n        if (!node.sourceNodes.length) {\n            updateDepthOfTargets(tree, node);\n        }\n    }\n    var maxDepth = (0, _maxBy[\"default\"])(tree, function(entry) {\n        return entry.depth;\n    }).depth;\n    if (maxDepth >= 1) {\n        var childWidth = (width - nodeWidth) / maxDepth;\n        for(var _i = 0, _len = tree.length; _i < _len; _i++){\n            var _node = tree[_i];\n            if (!_node.targetNodes.length) {\n                _node.depth = maxDepth;\n            }\n            _node.x = _node.depth * childWidth;\n            _node.dx = nodeWidth;\n        }\n    }\n    return {\n        tree: tree,\n        maxDepth: maxDepth\n    };\n};\nvar getDepthTree = function getDepthTree(tree) {\n    var result = [];\n    for(var i = 0, len = tree.length; i < len; i++){\n        var node = tree[i];\n        if (!result[node.depth]) {\n            result[node.depth] = [];\n        }\n        result[node.depth].push(node);\n    }\n    return result;\n};\nvar updateYOfTree = function updateYOfTree(depthTree, height, nodePadding, links) {\n    var yRatio = (0, _min[\"default\"])(depthTree.map(function(nodes) {\n        return (height - (nodes.length - 1) * nodePadding) / (0, _sumBy[\"default\"])(nodes, getValue);\n    }));\n    for(var d = 0, maxDepth = depthTree.length; d < maxDepth; d++){\n        for(var i = 0, len = depthTree[d].length; i < len; i++){\n            var node = depthTree[d][i];\n            node.y = i;\n            node.dy = node.value * yRatio;\n        }\n    }\n    return links.map(function(link) {\n        return _objectSpread(_objectSpread({}, link), {}, {\n            dy: getValue(link) * yRatio\n        });\n    });\n};\nvar resolveCollisions = function resolveCollisions(depthTree, height, nodePadding) {\n    var sort = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    for(var i = 0, len = depthTree.length; i < len; i++){\n        var nodes = depthTree[i];\n        var n = nodes.length;\n        // Sort by the value of y\n        if (sort) {\n            nodes.sort(ascendingY);\n        }\n        var y0 = 0;\n        for(var j = 0; j < n; j++){\n            var node = nodes[j];\n            var dy = y0 - node.y;\n            if (dy > 0) {\n                node.y += dy;\n            }\n            y0 = node.y + node.dy + nodePadding;\n        }\n        y0 = height + nodePadding;\n        for(var _j = n - 1; _j >= 0; _j--){\n            var _node2 = nodes[_j];\n            var _dy = _node2.y + _node2.dy + nodePadding - y0;\n            if (_dy > 0) {\n                _node2.y -= _dy;\n                y0 = _node2.y;\n            } else {\n                break;\n            }\n        }\n    }\n};\nvar relaxLeftToRight = function relaxLeftToRight(tree, depthTree, links, alpha) {\n    for(var i = 0, maxDepth = depthTree.length; i < maxDepth; i++){\n        var nodes = depthTree[i];\n        for(var j = 0, len = nodes.length; j < len; j++){\n            var node = nodes[j];\n            if (node.sourceLinks.length) {\n                var sourceSum = getSumOfIds(links, node.sourceLinks);\n                var weightedSum = getSumWithWeightedSource(tree, links, node.sourceLinks);\n                var y = weightedSum / sourceSum;\n                node.y += (y - centerY(node)) * alpha;\n            }\n        }\n    }\n};\nvar relaxRightToLeft = function relaxRightToLeft(tree, depthTree, links, alpha) {\n    for(var i = depthTree.length - 1; i >= 0; i--){\n        var nodes = depthTree[i];\n        for(var j = 0, len = nodes.length; j < len; j++){\n            var node = nodes[j];\n            if (node.targetLinks.length) {\n                var targetSum = getSumOfIds(links, node.targetLinks);\n                var weightedSum = getSumWithWeightedTarget(tree, links, node.targetLinks);\n                var y = weightedSum / targetSum;\n                node.y += (y - centerY(node)) * alpha;\n            }\n        }\n    }\n};\nvar updateYOfLinks = function updateYOfLinks(tree, links) {\n    for(var i = 0, len = tree.length; i < len; i++){\n        var node = tree[i];\n        var sy = 0;\n        var ty = 0;\n        node.targetLinks.sort(function(a, b) {\n            return tree[links[a].target].y - tree[links[b].target].y;\n        });\n        node.sourceLinks.sort(function(a, b) {\n            return tree[links[a].source].y - tree[links[b].source].y;\n        });\n        for(var j = 0, tLen = node.targetLinks.length; j < tLen; j++){\n            var link = links[node.targetLinks[j]];\n            if (link) {\n                link.sy = sy;\n                sy += link.dy;\n            }\n        }\n        for(var _j2 = 0, sLen = node.sourceLinks.length; _j2 < sLen; _j2++){\n            var _link = links[node.sourceLinks[_j2]];\n            if (_link) {\n                _link.ty = ty;\n                ty += _link.dy;\n            }\n        }\n    }\n};\nvar computeData = function computeData(_ref2) {\n    var data = _ref2.data, width = _ref2.width, height = _ref2.height, iterations = _ref2.iterations, nodeWidth = _ref2.nodeWidth, nodePadding = _ref2.nodePadding, sort = _ref2.sort;\n    var links = data.links;\n    var _getNodesTree = getNodesTree(data, width, nodeWidth), tree = _getNodesTree.tree;\n    var depthTree = getDepthTree(tree);\n    var newLinks = updateYOfTree(depthTree, height, nodePadding, links);\n    resolveCollisions(depthTree, height, nodePadding, sort);\n    var alpha = 1;\n    for(var i = 1; i <= iterations; i++){\n        relaxRightToLeft(tree, depthTree, newLinks, alpha *= 0.99);\n        resolveCollisions(depthTree, height, nodePadding, sort);\n        relaxLeftToRight(tree, depthTree, newLinks, alpha);\n        resolveCollisions(depthTree, height, nodePadding, sort);\n    }\n    updateYOfLinks(tree, newLinks);\n    return {\n        nodes: tree,\n        links: newLinks\n    };\n};\nvar getCoordinateOfTooltip = function getCoordinateOfTooltip(el, type) {\n    if (type === \"node\") {\n        return {\n            x: el.x + el.width / 2,\n            y: el.y + el.height / 2\n        };\n    }\n    return {\n        x: (el.sourceX + el.targetX) / 2,\n        y: (el.sourceY + el.targetY) / 2\n    };\n};\nvar getPayloadOfTooltip = function getPayloadOfTooltip(el, type, nameKey) {\n    var payload = el.payload;\n    if (type === \"node\") {\n        return [\n            {\n                payload: el,\n                name: (0, _ChartUtils.getValueByDataKey)(payload, nameKey, \"\"),\n                value: (0, _ChartUtils.getValueByDataKey)(payload, \"value\")\n            }\n        ];\n    }\n    if (payload.source && payload.target) {\n        var sourceName = (0, _ChartUtils.getValueByDataKey)(payload.source, nameKey, \"\");\n        var targetName = (0, _ChartUtils.getValueByDataKey)(payload.target, nameKey, \"\");\n        return [\n            {\n                payload: el,\n                name: \"\".concat(sourceName, \" - \").concat(targetName),\n                value: (0, _ChartUtils.getValueByDataKey)(payload, \"value\")\n            }\n        ];\n    }\n    return [];\n};\nvar Sankey = exports.Sankey = /*#__PURE__*/ function(_PureComponent) {\n    function Sankey() {\n        var _this;\n        _classCallCheck(this, Sankey);\n        for(var _len2 = arguments.length, args = new Array(_len2), _key = 0; _key < _len2; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Sankey, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            activeElement: null,\n            activeElementType: null,\n            isTooltipActive: false,\n            nodes: [],\n            links: []\n        });\n        return _this;\n    }\n    _inherits(Sankey, _PureComponent);\n    return _createClass(Sankey, [\n        {\n            key: \"handleMouseEnter\",\n            value: function handleMouseEnter(el, type, e) {\n                var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, children = _this$props.children;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (tooltipItem) {\n                    this.setState(function(prev) {\n                        if (tooltipItem.props.trigger === \"hover\") {\n                            return _objectSpread(_objectSpread({}, prev), {}, {\n                                activeElement: el,\n                                activeElementType: type,\n                                isTooltipActive: true\n                            });\n                        }\n                        return prev;\n                    }, function() {\n                        if (onMouseEnter) {\n                            onMouseEnter(el, type, e);\n                        }\n                    });\n                } else if (onMouseEnter) {\n                    onMouseEnter(el, type, e);\n                }\n            }\n        },\n        {\n            key: \"handleMouseLeave\",\n            value: function handleMouseLeave(el, type, e) {\n                var _this$props2 = this.props, onMouseLeave = _this$props2.onMouseLeave, children = _this$props2.children;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (tooltipItem) {\n                    this.setState(function(prev) {\n                        if (tooltipItem.props.trigger === \"hover\") {\n                            return _objectSpread(_objectSpread({}, prev), {}, {\n                                activeElement: undefined,\n                                activeElementType: undefined,\n                                isTooltipActive: false\n                            });\n                        }\n                        return prev;\n                    }, function() {\n                        if (onMouseLeave) {\n                            onMouseLeave(el, type, e);\n                        }\n                    });\n                } else if (onMouseLeave) {\n                    onMouseLeave(el, type, e);\n                }\n            }\n        },\n        {\n            key: \"handleClick\",\n            value: function handleClick(el, type, e) {\n                var _this$props3 = this.props, onClick = _this$props3.onClick, children = _this$props3.children;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (tooltipItem && tooltipItem.props.trigger === \"click\") {\n                    if (this.state.isTooltipActive) {\n                        this.setState(function(prev) {\n                            return _objectSpread(_objectSpread({}, prev), {}, {\n                                activeElement: undefined,\n                                activeElementType: undefined,\n                                isTooltipActive: false\n                            });\n                        });\n                    } else {\n                        this.setState(function(prev) {\n                            return _objectSpread(_objectSpread({}, prev), {}, {\n                                activeElement: el,\n                                activeElementType: type,\n                                isTooltipActive: true\n                            });\n                        });\n                    }\n                }\n                if (onClick) onClick(el, type, e);\n            }\n        },\n        {\n            key: \"renderLinks\",\n            value: function renderLinks(links, nodes) {\n                var _this2 = this;\n                var _this$props4 = this.props, linkCurvature = _this$props4.linkCurvature, linkContent = _this$props4.link, margin = _this$props4.margin;\n                var top = (0, _get[\"default\"])(margin, \"top\") || 0;\n                var left = (0, _get[\"default\"])(margin, \"left\") || 0;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-sankey-links\",\n                    key: \"recharts-sankey-links\"\n                }, links.map(function(link, i) {\n                    var sourceRelativeY = link.sy, targetRelativeY = link.ty, linkWidth = link.dy;\n                    var source = nodes[link.source];\n                    var target = nodes[link.target];\n                    var sourceX = source.x + source.dx + left;\n                    var targetX = target.x + left;\n                    var interpolationFunc = interpolationGenerator(sourceX, targetX);\n                    var sourceControlX = interpolationFunc(linkCurvature);\n                    var targetControlX = interpolationFunc(1 - linkCurvature);\n                    var sourceY = source.y + sourceRelativeY + linkWidth / 2 + top;\n                    var targetY = target.y + targetRelativeY + linkWidth / 2 + top;\n                    var linkProps = _objectSpread({\n                        sourceX: sourceX,\n                        targetX: targetX,\n                        sourceY: sourceY,\n                        targetY: targetY,\n                        sourceControlX: sourceControlX,\n                        targetControlX: targetControlX,\n                        sourceRelativeY: sourceRelativeY,\n                        targetRelativeY: targetRelativeY,\n                        linkWidth: linkWidth,\n                        index: i,\n                        payload: _objectSpread(_objectSpread({}, link), {}, {\n                            source: source,\n                            target: target\n                        })\n                    }, (0, _ReactUtils.filterProps)(linkContent, false));\n                    var events = {\n                        onMouseEnter: _this2.handleMouseEnter.bind(_this2, linkProps, \"link\"),\n                        onMouseLeave: _this2.handleMouseLeave.bind(_this2, linkProps, \"link\"),\n                        onClick: _this2.handleClick.bind(_this2, linkProps, \"link\")\n                    };\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        key: \"link-\".concat(link.source, \"-\").concat(link.target, \"-\").concat(link.value)\n                    }, events), _this2.constructor.renderLinkItem(linkContent, linkProps));\n                }));\n            }\n        },\n        {\n            key: \"renderNodes\",\n            value: function renderNodes(nodes) {\n                var _this3 = this;\n                var _this$props5 = this.props, nodeContent = _this$props5.node, margin = _this$props5.margin;\n                var top = (0, _get[\"default\"])(margin, \"top\") || 0;\n                var left = (0, _get[\"default\"])(margin, \"left\") || 0;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-sankey-nodes\",\n                    key: \"recharts-sankey-nodes\"\n                }, nodes.map(function(node, i) {\n                    var x = node.x, y = node.y, dx = node.dx, dy = node.dy;\n                    var nodeProps = _objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(nodeContent, false)), {}, {\n                        x: x + left,\n                        y: y + top,\n                        width: dx,\n                        height: dy,\n                        index: i,\n                        payload: node\n                    });\n                    var events = {\n                        onMouseEnter: _this3.handleMouseEnter.bind(_this3, nodeProps, \"node\"),\n                        onMouseLeave: _this3.handleMouseLeave.bind(_this3, nodeProps, \"node\"),\n                        onClick: _this3.handleClick.bind(_this3, nodeProps, \"node\")\n                    };\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        key: \"node-\".concat(node.x, \"-\").concat(node.y, \"-\").concat(node.value)\n                    }, events), _this3.constructor.renderNodeItem(nodeContent, nodeProps));\n                }));\n            }\n        },\n        {\n            key: \"renderTooltip\",\n            value: function renderTooltip() {\n                var _this$props6 = this.props, children = _this$props6.children, width = _this$props6.width, height = _this$props6.height, nameKey = _this$props6.nameKey;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (!tooltipItem) {\n                    return null;\n                }\n                var _this$state = this.state, isTooltipActive = _this$state.isTooltipActive, activeElement = _this$state.activeElement, activeElementType = _this$state.activeElementType;\n                var viewBox = {\n                    x: 0,\n                    y: 0,\n                    width: width,\n                    height: height\n                };\n                var coordinate = activeElement ? getCoordinateOfTooltip(activeElement, activeElementType) : defaultCoordinateOfTooltip;\n                var payload = activeElement ? getPayloadOfTooltip(activeElement, activeElementType, nameKey) : [];\n                return /*#__PURE__*/ _react[\"default\"].cloneElement(tooltipItem, {\n                    viewBox: viewBox,\n                    active: isTooltipActive,\n                    coordinate: coordinate,\n                    label: \"\",\n                    payload: payload\n                });\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                if (!(0, _ReactUtils.validateWidthHeight)(this)) {\n                    return null;\n                }\n                var _this$props7 = this.props, width = _this$props7.width, height = _this$props7.height, className = _this$props7.className, style = _this$props7.style, children = _this$props7.children, others = _objectWithoutProperties(_this$props7, _excluded);\n                var _this$state2 = this.state, links = _this$state2.links, nodes = _this$state2.nodes;\n                var attrs = (0, _ReactUtils.filterProps)(others, false);\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                    className: (0, _clsx[\"default\"])(\"recharts-wrapper\", className),\n                    style: _objectSpread(_objectSpread({}, style), {}, {\n                        position: \"relative\",\n                        cursor: \"default\",\n                        width: width,\n                        height: height\n                    }),\n                    role: \"region\"\n                }, /*#__PURE__*/ _react[\"default\"].createElement(_Surface.Surface, _extends({}, attrs, {\n                    width: width,\n                    height: height\n                }), (0, _ReactUtils.filterSvgElements)(children), this.renderLinks(links, nodes), this.renderNodes(nodes)), this.renderTooltip());\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                var data = nextProps.data, width = nextProps.width, height = nextProps.height, margin = nextProps.margin, iterations = nextProps.iterations, nodeWidth = nextProps.nodeWidth, nodePadding = nextProps.nodePadding, sort = nextProps.sort;\n                if (data !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || !(0, _ShallowEqual.shallowEqual)(margin, prevState.prevMargin) || iterations !== prevState.prevIterations || nodeWidth !== prevState.prevNodeWidth || nodePadding !== prevState.prevNodePadding || sort !== prevState.sort) {\n                    var contentWidth = width - (margin && margin.left || 0) - (margin && margin.right || 0);\n                    var contentHeight = height - (margin && margin.top || 0) - (margin && margin.bottom || 0);\n                    var _computeData = computeData({\n                        data: data,\n                        width: contentWidth,\n                        height: contentHeight,\n                        iterations: iterations,\n                        nodeWidth: nodeWidth,\n                        nodePadding: nodePadding,\n                        sort: sort\n                    }), links = _computeData.links, nodes = _computeData.nodes;\n                    return _objectSpread(_objectSpread({}, prevState), {}, {\n                        nodes: nodes,\n                        links: links,\n                        prevData: data,\n                        prevWidth: iterations,\n                        prevHeight: height,\n                        prevMargin: margin,\n                        prevNodePadding: nodePadding,\n                        prevNodeWidth: nodeWidth,\n                        prevIterations: iterations,\n                        prevSort: sort\n                    });\n                }\n                return null;\n            }\n        },\n        {\n            key: \"renderLinkItem\",\n            value: function renderLinkItem(option, props) {\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                }\n                if ((0, _isFunction[\"default\"])(option)) {\n                    return option(props);\n                }\n                var sourceX = props.sourceX, sourceY = props.sourceY, sourceControlX = props.sourceControlX, targetX = props.targetX, targetY = props.targetY, targetControlX = props.targetControlX, linkWidth = props.linkWidth, others = _objectWithoutProperties(props, _excluded2);\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({\n                    className: \"recharts-sankey-link\",\n                    d: \"\\n          M\".concat(sourceX, \",\").concat(sourceY, \"\\n          C\").concat(sourceControlX, \",\").concat(sourceY, \" \").concat(targetControlX, \",\").concat(targetY, \" \").concat(targetX, \",\").concat(targetY, \"\\n        \"),\n                    fill: \"none\",\n                    stroke: \"#333\",\n                    strokeWidth: linkWidth,\n                    strokeOpacity: \"0.2\"\n                }, (0, _ReactUtils.filterProps)(others, false)));\n            }\n        },\n        {\n            key: \"renderNodeItem\",\n            value: function renderNodeItem(option, props) {\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                }\n                if ((0, _isFunction[\"default\"])(option)) {\n                    return option(props);\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Rectangle.Rectangle, _extends({\n                    className: \"recharts-sankey-node\",\n                    fill: \"#0088fe\",\n                    fillOpacity: \"0.8\"\n                }, (0, _ReactUtils.filterProps)(props, false), {\n                    role: \"img\"\n                }));\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(Sankey, \"displayName\", \"Sankey\");\n_defineProperty(Sankey, \"defaultProps\", {\n    nameKey: \"name\",\n    dataKey: \"value\",\n    nodePadding: 10,\n    nodeWidth: 10,\n    linkCurvature: 0.5,\n    iterations: 32,\n    margin: {\n        top: 5,\n        right: 5,\n        bottom: 5,\n        left: 5\n    },\n    sort: true\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L1NhbmtleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsSUFBSUcsU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyxTQUFTQyx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlHLE9BQU9ELHVCQUF1QkYsbUJBQU9BLENBQUMsOEJBQVk7QUFDdEQsSUFBSUksT0FBT0YsdUJBQXVCRixtQkFBT0EsQ0FBQyw4QkFBWTtBQUN0RCxJQUFJSyxTQUFTSCx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlNLGNBQWNKLHVCQUF1QkYsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlPLFFBQVFMLHVCQUF1QkYsbUJBQU9BLENBQUMsa0JBQU07QUFDakQsSUFBSVEsV0FBV1IsbUJBQU9BLENBQUMsOEVBQXNCO0FBQzdDLElBQUlTLFNBQVNULG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJVSxXQUFXVixtQkFBT0EsQ0FBQyw4RUFBc0I7QUFDN0MsSUFBSVcsYUFBYVgsbUJBQU9BLENBQUMsMEVBQW9CO0FBQzdDLElBQUlZLGdCQUFnQlosbUJBQU9BLENBQUMsOEVBQXNCO0FBQ2xELElBQUlhLGNBQWNiLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJYyxjQUFjZCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSWUsWUFBWTtJQUFDO0lBQVM7SUFBVTtJQUFhO0lBQVM7Q0FBVyxFQUNuRUMsYUFBYTtJQUFDO0lBQVc7SUFBVztJQUFrQjtJQUFXO0lBQVc7SUFBa0I7Q0FBWTtBQUM1RyxTQUFTZCx1QkFBdUJlLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7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QUNqQixHQUFHLENBQUMsR0FBRzNSLFlBQVl3TyxXQUFXLEVBQUVxQixRQUFRO1lBQzFDO1FBQ0Y7UUFBRztZQUNENU4sS0FBSztZQUNMbEQsT0FBTyxTQUFTaVEsZUFBZXNDLE1BQU0sRUFBRXJPLEtBQUs7Z0JBQzFDLElBQUssV0FBVyxHQUFFaEUsTUFBTSxDQUFDLFVBQVUsQ0FBQ3NTLGNBQWMsQ0FBQ0QsU0FBUztvQkFDMUQsT0FBTyxXQUFXLEdBQUVyUyxNQUFNLENBQUMsVUFBVSxDQUFDcVEsWUFBWSxDQUFDZ0MsUUFBUXJPO2dCQUM3RDtnQkFDQSxJQUFJLENBQUMsR0FBR3hELFdBQVcsQ0FBQyxVQUFVLEVBQUU2UixTQUFTO29CQUN2QyxPQUFPQSxPQUFPck87Z0JBQ2hCO2dCQUNBLE9BQU8sV0FBVyxHQUFFaEUsTUFBTSxDQUFDLFVBQVUsQ0FBQzZPLGFBQWEsQ0FBQ2hPLFdBQVc4UixTQUFTLEVBQUVyUCxTQUFTO29CQUNqRnlMLFdBQVc7b0JBQ1h3RCxNQUFNO29CQUNOSyxhQUFhO2dCQUNmLEdBQUcsQ0FBQyxHQUFHN1IsWUFBWXdPLFdBQVcsRUFBRXZMLE9BQU8sUUFBUTtvQkFDN0NpTixNQUFNO2dCQUNSO1lBQ0Y7UUFDRjtLQUFFO0FBQ0osRUFBRWpSLE9BQU82UyxhQUFhO0FBQ3RCM00sZ0JBQWdCbkcsUUFBUSxlQUFlO0FBQ3ZDbUcsZ0JBQWdCbkcsUUFBUSxnQkFBZ0I7SUFDdENxTSxTQUFTO0lBQ1QwRyxTQUFTO0lBQ1RoSixhQUFhO0lBQ2JkLFdBQVc7SUFDWHdGLGVBQWU7SUFDZi9DLFlBQVk7SUFDWmlELFFBQVE7UUFDTkMsS0FBSztRQUNMcUQsT0FBTztRQUNQRSxRQUFRO1FBQ1J0RCxNQUFNO0lBQ1I7SUFDQTFFLE1BQU07QUFDUiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvU2Fua2V5LmpzPzlkZjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlNhbmtleSA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9tYXhCeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9tYXhCeVwiKSk7XG52YXIgX21pbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9taW5cIikpO1xudmFyIF9nZXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZ2V0XCIpKTtcbnZhciBfc3VtQnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvc3VtQnlcIikpO1xudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX1N1cmZhY2UgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL1N1cmZhY2VcIik7XG52YXIgX0xheWVyID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9MYXllclwiKTtcbnZhciBfVG9vbHRpcCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvVG9vbHRpcFwiKTtcbnZhciBfUmVjdGFuZ2xlID0gcmVxdWlyZShcIi4uL3NoYXBlL1JlY3RhbmdsZVwiKTtcbnZhciBfU2hhbGxvd0VxdWFsID0gcmVxdWlyZShcIi4uL3V0aWwvU2hhbGxvd0VxdWFsXCIpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XG52YXIgX2V4Y2x1ZGVkID0gW1wid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiLCBcImNoaWxkcmVuXCJdLFxuICBfZXhjbHVkZWQyID0gW1wic291cmNlWFwiLCBcInNvdXJjZVlcIiwgXCJzb3VyY2VDb250cm9sWFwiLCBcInRhcmdldFhcIiwgXCJ0YXJnZXRZXCIsIFwidGFyZ2V0Q29udHJvbFhcIiwgXCJsaW5rV2lkdGhcIl07XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxuICogQGZpbGUgVHJlZW1hcENoYXJ0XG4gKi9cbnZhciBkZWZhdWx0Q29vcmRpbmF0ZU9mVG9vbHRpcCA9IHtcbiAgeDogMCxcbiAgeTogMFxufTtcbnZhciBpbnRlcnBvbGF0aW9uR2VuZXJhdG9yID0gZnVuY3Rpb24gaW50ZXJwb2xhdGlvbkdlbmVyYXRvcihhLCBiKSB7XG4gIHZhciBrYSA9ICthO1xuICB2YXIga2IgPSBiIC0ga2E7XG4gIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBrYSArIGtiICogdDtcbiAgfTtcbn07XG52YXIgY2VudGVyWSA9IGZ1bmN0aW9uIGNlbnRlclkobm9kZSkge1xuICByZXR1cm4gbm9kZS55ICsgbm9kZS5keSAvIDI7XG59O1xudmFyIGdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoZW50cnkpIHtcbiAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnZhbHVlIHx8IDA7XG59O1xudmFyIGdldFN1bU9mSWRzID0gZnVuY3Rpb24gZ2V0U3VtT2ZJZHMobGlua3MsIGlkcykge1xuICByZXR1cm4gaWRzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBpZCkge1xuICAgIHJldHVybiByZXN1bHQgKyBnZXRWYWx1ZShsaW5rc1tpZF0pO1xuICB9LCAwKTtcbn07XG52YXIgZ2V0U3VtV2l0aFdlaWdodGVkU291cmNlID0gZnVuY3Rpb24gZ2V0U3VtV2l0aFdlaWdodGVkU291cmNlKHRyZWUsIGxpbmtzLCBpZHMpIHtcbiAgcmV0dXJuIGlkcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgaWQpIHtcbiAgICB2YXIgbGluayA9IGxpbmtzW2lkXTtcbiAgICB2YXIgc291cmNlTm9kZSA9IHRyZWVbbGluay5zb3VyY2VdO1xuICAgIHJldHVybiByZXN1bHQgKyBjZW50ZXJZKHNvdXJjZU5vZGUpICogZ2V0VmFsdWUobGlua3NbaWRdKTtcbiAgfSwgMCk7XG59O1xudmFyIGdldFN1bVdpdGhXZWlnaHRlZFRhcmdldCA9IGZ1bmN0aW9uIGdldFN1bVdpdGhXZWlnaHRlZFRhcmdldCh0cmVlLCBsaW5rcywgaWRzKSB7XG4gIHJldHVybiBpZHMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGlkKSB7XG4gICAgdmFyIGxpbmsgPSBsaW5rc1tpZF07XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0cmVlW2xpbmsudGFyZ2V0XTtcbiAgICByZXR1cm4gcmVzdWx0ICsgY2VudGVyWSh0YXJnZXROb2RlKSAqIGdldFZhbHVlKGxpbmtzW2lkXSk7XG4gIH0sIDApO1xufTtcbnZhciBhc2NlbmRpbmdZID0gZnVuY3Rpb24gYXNjZW5kaW5nWShhLCBiKSB7XG4gIHJldHVybiBhLnkgLSBiLnk7XG59O1xudmFyIHNlYXJjaFRhcmdldHNBbmRTb3VyY2VzID0gZnVuY3Rpb24gc2VhcmNoVGFyZ2V0c0FuZFNvdXJjZXMobGlua3MsIGlkKSB7XG4gIHZhciBzb3VyY2VOb2RlcyA9IFtdO1xuICB2YXIgc291cmNlTGlua3MgPSBbXTtcbiAgdmFyIHRhcmdldE5vZGVzID0gW107XG4gIHZhciB0YXJnZXRMaW5rcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlua3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgbGluayA9IGxpbmtzW2ldO1xuICAgIGlmIChsaW5rLnNvdXJjZSA9PT0gaWQpIHtcbiAgICAgIHRhcmdldE5vZGVzLnB1c2gobGluay50YXJnZXQpO1xuICAgICAgdGFyZ2V0TGlua3MucHVzaChpKTtcbiAgICB9XG4gICAgaWYgKGxpbmsudGFyZ2V0ID09PSBpZCkge1xuICAgICAgc291cmNlTm9kZXMucHVzaChsaW5rLnNvdXJjZSk7XG4gICAgICBzb3VyY2VMaW5rcy5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNvdXJjZU5vZGVzOiBzb3VyY2VOb2RlcyxcbiAgICBzb3VyY2VMaW5rczogc291cmNlTGlua3MsXG4gICAgdGFyZ2V0TGlua3M6IHRhcmdldExpbmtzLFxuICAgIHRhcmdldE5vZGVzOiB0YXJnZXROb2Rlc1xuICB9O1xufTtcbnZhciB1cGRhdGVEZXB0aE9mVGFyZ2V0cyA9IGZ1bmN0aW9uIHVwZGF0ZURlcHRoT2ZUYXJnZXRzKHRyZWUsIGN1ck5vZGUpIHtcbiAgdmFyIHRhcmdldE5vZGVzID0gY3VyTm9kZS50YXJnZXROb2RlcztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHRhcmdldCA9IHRyZWVbdGFyZ2V0Tm9kZXNbaV1dO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRhcmdldC5kZXB0aCA9IE1hdGgubWF4KGN1ck5vZGUuZGVwdGggKyAxLCB0YXJnZXQuZGVwdGgpO1xuICAgICAgdXBkYXRlRGVwdGhPZlRhcmdldHModHJlZSwgdGFyZ2V0KTtcbiAgICB9XG4gIH1cbn07XG52YXIgZ2V0Tm9kZXNUcmVlID0gZnVuY3Rpb24gZ2V0Tm9kZXNUcmVlKF9yZWYsIHdpZHRoLCBub2RlV2lkdGgpIHtcbiAgdmFyIG5vZGVzID0gX3JlZi5ub2RlcyxcbiAgICBsaW5rcyA9IF9yZWYubGlua3M7XG4gIHZhciB0cmVlID0gbm9kZXMubWFwKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcbiAgICB2YXIgcmVzdWx0ID0gc2VhcmNoVGFyZ2V0c0FuZFNvdXJjZXMobGlua3MsIGluZGV4KTtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwgcmVzdWx0KSwge30sIHtcbiAgICAgIHZhbHVlOiBNYXRoLm1heChnZXRTdW1PZklkcyhsaW5rcywgcmVzdWx0LnNvdXJjZUxpbmtzKSwgZ2V0U3VtT2ZJZHMobGlua3MsIHJlc3VsdC50YXJnZXRMaW5rcykpLFxuICAgICAgZGVwdGg6IDBcbiAgICB9KTtcbiAgfSk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0cmVlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSB0cmVlW2ldO1xuICAgIGlmICghbm9kZS5zb3VyY2VOb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHVwZGF0ZURlcHRoT2ZUYXJnZXRzKHRyZWUsIG5vZGUpO1xuICAgIH1cbiAgfVxuICB2YXIgbWF4RGVwdGggPSAoMCwgX21heEJ5W1wiZGVmYXVsdFwiXSkodHJlZSwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LmRlcHRoO1xuICB9KS5kZXB0aDtcbiAgaWYgKG1heERlcHRoID49IDEpIHtcbiAgICB2YXIgY2hpbGRXaWR0aCA9ICh3aWR0aCAtIG5vZGVXaWR0aCkgLyBtYXhEZXB0aDtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9sZW4gPSB0cmVlLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICB2YXIgX25vZGUgPSB0cmVlW19pXTtcbiAgICAgIGlmICghX25vZGUudGFyZ2V0Tm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIF9ub2RlLmRlcHRoID0gbWF4RGVwdGg7XG4gICAgICB9XG4gICAgICBfbm9kZS54ID0gX25vZGUuZGVwdGggKiBjaGlsZFdpZHRoO1xuICAgICAgX25vZGUuZHggPSBub2RlV2lkdGg7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdHJlZTogdHJlZSxcbiAgICBtYXhEZXB0aDogbWF4RGVwdGhcbiAgfTtcbn07XG52YXIgZ2V0RGVwdGhUcmVlID0gZnVuY3Rpb24gZ2V0RGVwdGhUcmVlKHRyZWUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdHJlZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBub2RlID0gdHJlZVtpXTtcbiAgICBpZiAoIXJlc3VsdFtub2RlLmRlcHRoXSkge1xuICAgICAgcmVzdWx0W25vZGUuZGVwdGhdID0gW107XG4gICAgfVxuICAgIHJlc3VsdFtub2RlLmRlcHRoXS5wdXNoKG5vZGUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIHVwZGF0ZVlPZlRyZWUgPSBmdW5jdGlvbiB1cGRhdGVZT2ZUcmVlKGRlcHRoVHJlZSwgaGVpZ2h0LCBub2RlUGFkZGluZywgbGlua3MpIHtcbiAgdmFyIHlSYXRpbyA9ICgwLCBfbWluW1wiZGVmYXVsdFwiXSkoZGVwdGhUcmVlLm1hcChmdW5jdGlvbiAobm9kZXMpIHtcbiAgICByZXR1cm4gKGhlaWdodCAtIChub2Rlcy5sZW5ndGggLSAxKSAqIG5vZGVQYWRkaW5nKSAvICgwLCBfc3VtQnlbXCJkZWZhdWx0XCJdKShub2RlcywgZ2V0VmFsdWUpO1xuICB9KSk7XG4gIGZvciAodmFyIGQgPSAwLCBtYXhEZXB0aCA9IGRlcHRoVHJlZS5sZW5ndGg7IGQgPCBtYXhEZXB0aDsgZCsrKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRlcHRoVHJlZVtkXS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBkZXB0aFRyZWVbZF1baV07XG4gICAgICBub2RlLnkgPSBpO1xuICAgICAgbm9kZS5keSA9IG5vZGUudmFsdWUgKiB5UmF0aW87XG4gICAgfVxuICB9XG4gIHJldHVybiBsaW5rcy5tYXAoZnVuY3Rpb24gKGxpbmspIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBsaW5rKSwge30sIHtcbiAgICAgIGR5OiBnZXRWYWx1ZShsaW5rKSAqIHlSYXRpb1xuICAgIH0pO1xuICB9KTtcbn07XG52YXIgcmVzb2x2ZUNvbGxpc2lvbnMgPSBmdW5jdGlvbiByZXNvbHZlQ29sbGlzaW9ucyhkZXB0aFRyZWUsIGhlaWdodCwgbm9kZVBhZGRpbmcpIHtcbiAgdmFyIHNvcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkZXB0aFRyZWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgbm9kZXMgPSBkZXB0aFRyZWVbaV07XG4gICAgdmFyIG4gPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAvLyBTb3J0IGJ5IHRoZSB2YWx1ZSBvZiB5XG4gICAgaWYgKHNvcnQpIHtcbiAgICAgIG5vZGVzLnNvcnQoYXNjZW5kaW5nWSk7XG4gICAgfVxuICAgIHZhciB5MCA9IDA7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbal07XG4gICAgICB2YXIgZHkgPSB5MCAtIG5vZGUueTtcbiAgICAgIGlmIChkeSA+IDApIHtcbiAgICAgICAgbm9kZS55ICs9IGR5O1xuICAgICAgfVxuICAgICAgeTAgPSBub2RlLnkgKyBub2RlLmR5ICsgbm9kZVBhZGRpbmc7XG4gICAgfVxuICAgIHkwID0gaGVpZ2h0ICsgbm9kZVBhZGRpbmc7XG4gICAgZm9yICh2YXIgX2ogPSBuIC0gMTsgX2ogPj0gMDsgX2otLSkge1xuICAgICAgdmFyIF9ub2RlMiA9IG5vZGVzW19qXTtcbiAgICAgIHZhciBfZHkgPSBfbm9kZTIueSArIF9ub2RlMi5keSArIG5vZGVQYWRkaW5nIC0geTA7XG4gICAgICBpZiAoX2R5ID4gMCkge1xuICAgICAgICBfbm9kZTIueSAtPSBfZHk7XG4gICAgICAgIHkwID0gX25vZGUyLnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgcmVsYXhMZWZ0VG9SaWdodCA9IGZ1bmN0aW9uIHJlbGF4TGVmdFRvUmlnaHQodHJlZSwgZGVwdGhUcmVlLCBsaW5rcywgYWxwaGEpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG1heERlcHRoID0gZGVwdGhUcmVlLmxlbmd0aDsgaSA8IG1heERlcHRoOyBpKyspIHtcbiAgICB2YXIgbm9kZXMgPSBkZXB0aFRyZWVbaV07XG4gICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2pdO1xuICAgICAgaWYgKG5vZGUuc291cmNlTGlua3MubGVuZ3RoKSB7XG4gICAgICAgIHZhciBzb3VyY2VTdW0gPSBnZXRTdW1PZklkcyhsaW5rcywgbm9kZS5zb3VyY2VMaW5rcyk7XG4gICAgICAgIHZhciB3ZWlnaHRlZFN1bSA9IGdldFN1bVdpdGhXZWlnaHRlZFNvdXJjZSh0cmVlLCBsaW5rcywgbm9kZS5zb3VyY2VMaW5rcyk7XG4gICAgICAgIHZhciB5ID0gd2VpZ2h0ZWRTdW0gLyBzb3VyY2VTdW07XG4gICAgICAgIG5vZGUueSArPSAoeSAtIGNlbnRlclkobm9kZSkpICogYWxwaGE7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIHJlbGF4UmlnaHRUb0xlZnQgPSBmdW5jdGlvbiByZWxheFJpZ2h0VG9MZWZ0KHRyZWUsIGRlcHRoVHJlZSwgbGlua3MsIGFscGhhKSB7XG4gIGZvciAodmFyIGkgPSBkZXB0aFRyZWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbm9kZXMgPSBkZXB0aFRyZWVbaV07XG4gICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2pdO1xuICAgICAgaWYgKG5vZGUudGFyZ2V0TGlua3MubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0YXJnZXRTdW0gPSBnZXRTdW1PZklkcyhsaW5rcywgbm9kZS50YXJnZXRMaW5rcyk7XG4gICAgICAgIHZhciB3ZWlnaHRlZFN1bSA9IGdldFN1bVdpdGhXZWlnaHRlZFRhcmdldCh0cmVlLCBsaW5rcywgbm9kZS50YXJnZXRMaW5rcyk7XG4gICAgICAgIHZhciB5ID0gd2VpZ2h0ZWRTdW0gLyB0YXJnZXRTdW07XG4gICAgICAgIG5vZGUueSArPSAoeSAtIGNlbnRlclkobm9kZSkpICogYWxwaGE7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIHVwZGF0ZVlPZkxpbmtzID0gZnVuY3Rpb24gdXBkYXRlWU9mTGlua3ModHJlZSwgbGlua3MpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRyZWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHRyZWVbaV07XG4gICAgdmFyIHN5ID0gMDtcbiAgICB2YXIgdHkgPSAwO1xuICAgIG5vZGUudGFyZ2V0TGlua3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIHRyZWVbbGlua3NbYV0udGFyZ2V0XS55IC0gdHJlZVtsaW5rc1tiXS50YXJnZXRdLnk7XG4gICAgfSk7XG4gICAgbm9kZS5zb3VyY2VMaW5rcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gdHJlZVtsaW5rc1thXS5zb3VyY2VdLnkgLSB0cmVlW2xpbmtzW2JdLnNvdXJjZV0ueTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBqID0gMCwgdExlbiA9IG5vZGUudGFyZ2V0TGlua3MubGVuZ3RoOyBqIDwgdExlbjsgaisrKSB7XG4gICAgICB2YXIgbGluayA9IGxpbmtzW25vZGUudGFyZ2V0TGlua3Nbal1dO1xuICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgbGluay5zeSA9IHN5O1xuICAgICAgICBzeSArPSBsaW5rLmR5O1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfajIgPSAwLCBzTGVuID0gbm9kZS5zb3VyY2VMaW5rcy5sZW5ndGg7IF9qMiA8IHNMZW47IF9qMisrKSB7XG4gICAgICB2YXIgX2xpbmsgPSBsaW5rc1tub2RlLnNvdXJjZUxpbmtzW19qMl1dO1xuICAgICAgaWYgKF9saW5rKSB7XG4gICAgICAgIF9saW5rLnR5ID0gdHk7XG4gICAgICAgIHR5ICs9IF9saW5rLmR5O1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBjb21wdXRlRGF0YSA9IGZ1bmN0aW9uIGNvbXB1dGVEYXRhKF9yZWYyKSB7XG4gIHZhciBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICB3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodCxcbiAgICBpdGVyYXRpb25zID0gX3JlZjIuaXRlcmF0aW9ucyxcbiAgICBub2RlV2lkdGggPSBfcmVmMi5ub2RlV2lkdGgsXG4gICAgbm9kZVBhZGRpbmcgPSBfcmVmMi5ub2RlUGFkZGluZyxcbiAgICBzb3J0ID0gX3JlZjIuc29ydDtcbiAgdmFyIGxpbmtzID0gZGF0YS5saW5rcztcbiAgdmFyIF9nZXROb2Rlc1RyZWUgPSBnZXROb2Rlc1RyZWUoZGF0YSwgd2lkdGgsIG5vZGVXaWR0aCksXG4gICAgdHJlZSA9IF9nZXROb2Rlc1RyZWUudHJlZTtcbiAgdmFyIGRlcHRoVHJlZSA9IGdldERlcHRoVHJlZSh0cmVlKTtcbiAgdmFyIG5ld0xpbmtzID0gdXBkYXRlWU9mVHJlZShkZXB0aFRyZWUsIGhlaWdodCwgbm9kZVBhZGRpbmcsIGxpbmtzKTtcbiAgcmVzb2x2ZUNvbGxpc2lvbnMoZGVwdGhUcmVlLCBoZWlnaHQsIG5vZGVQYWRkaW5nLCBzb3J0KTtcbiAgdmFyIGFscGhhID0gMTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgcmVsYXhSaWdodFRvTGVmdCh0cmVlLCBkZXB0aFRyZWUsIG5ld0xpbmtzLCBhbHBoYSAqPSAwLjk5KTtcbiAgICByZXNvbHZlQ29sbGlzaW9ucyhkZXB0aFRyZWUsIGhlaWdodCwgbm9kZVBhZGRpbmcsIHNvcnQpO1xuICAgIHJlbGF4TGVmdFRvUmlnaHQodHJlZSwgZGVwdGhUcmVlLCBuZXdMaW5rcywgYWxwaGEpO1xuICAgIHJlc29sdmVDb2xsaXNpb25zKGRlcHRoVHJlZSwgaGVpZ2h0LCBub2RlUGFkZGluZywgc29ydCk7XG4gIH1cbiAgdXBkYXRlWU9mTGlua3ModHJlZSwgbmV3TGlua3MpO1xuICByZXR1cm4ge1xuICAgIG5vZGVzOiB0cmVlLFxuICAgIGxpbmtzOiBuZXdMaW5rc1xuICB9O1xufTtcbnZhciBnZXRDb29yZGluYXRlT2ZUb29sdGlwID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZU9mVG9vbHRpcChlbCwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGVsLnggKyBlbC53aWR0aCAvIDIsXG4gICAgICB5OiBlbC55ICsgZWwuaGVpZ2h0IC8gMlxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiAoZWwuc291cmNlWCArIGVsLnRhcmdldFgpIC8gMixcbiAgICB5OiAoZWwuc291cmNlWSArIGVsLnRhcmdldFkpIC8gMlxuICB9O1xufTtcbnZhciBnZXRQYXlsb2FkT2ZUb29sdGlwID0gZnVuY3Rpb24gZ2V0UGF5bG9hZE9mVG9vbHRpcChlbCwgdHlwZSwgbmFtZUtleSkge1xuICB2YXIgcGF5bG9hZCA9IGVsLnBheWxvYWQ7XG4gIGlmICh0eXBlID09PSAnbm9kZScpIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIHBheWxvYWQ6IGVsLFxuICAgICAgbmFtZTogKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShwYXlsb2FkLCBuYW1lS2V5LCAnJyksXG4gICAgICB2YWx1ZTogKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShwYXlsb2FkLCAndmFsdWUnKVxuICAgIH1dO1xuICB9XG4gIGlmIChwYXlsb2FkLnNvdXJjZSAmJiBwYXlsb2FkLnRhcmdldCkge1xuICAgIHZhciBzb3VyY2VOYW1lID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShwYXlsb2FkLnNvdXJjZSwgbmFtZUtleSwgJycpO1xuICAgIHZhciB0YXJnZXROYW1lID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShwYXlsb2FkLnRhcmdldCwgbmFtZUtleSwgJycpO1xuICAgIHJldHVybiBbe1xuICAgICAgcGF5bG9hZDogZWwsXG4gICAgICBuYW1lOiBcIlwiLmNvbmNhdChzb3VyY2VOYW1lLCBcIiAtIFwiKS5jb25jYXQodGFyZ2V0TmFtZSksXG4gICAgICB2YWx1ZTogKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShwYXlsb2FkLCAndmFsdWUnKVxuICAgIH1dO1xuICB9XG4gIHJldHVybiBbXTtcbn07XG52YXIgU2Fua2V5ID0gZXhwb3J0cy5TYW5rZXkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIFNhbmtleSgpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNhbmtleSk7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuMjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgU2Fua2V5LCBbXS5jb25jYXQoYXJncykpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBhY3RpdmVFbGVtZW50OiBudWxsLFxuICAgICAgYWN0aXZlRWxlbWVudFR5cGU6IG51bGwsXG4gICAgICBpc1Rvb2x0aXBBY3RpdmU6IGZhbHNlLFxuICAgICAgbm9kZXM6IFtdLFxuICAgICAgbGlua3M6IFtdXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhTYW5rZXksIF9QdXJlQ29tcG9uZW50KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhTYW5rZXksIFt7XG4gICAga2V5OiBcImhhbmRsZU1vdXNlRW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTW91c2VFbnRlcihlbCwgdHlwZSwgZSkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgb25Nb3VzZUVudGVyID0gX3RoaXMkcHJvcHMub25Nb3VzZUVudGVyLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuO1xuICAgICAgdmFyIHRvb2x0aXBJdGVtID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRDaGlsZEJ5VHlwZSkoY2hpbGRyZW4sIF9Ub29sdGlwLlRvb2x0aXApO1xuICAgICAgaWYgKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgICBpZiAodG9vbHRpcEl0ZW0ucHJvcHMudHJpZ2dlciA9PT0gJ2hvdmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJldiksIHt9LCB7XG4gICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQ6IGVsLFxuICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50VHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgaXNUb29sdGlwQWN0aXZlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAob25Nb3VzZUVudGVyKSB7XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXIoZWwsIHR5cGUsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG9uTW91c2VFbnRlcikge1xuICAgICAgICBvbk1vdXNlRW50ZXIoZWwsIHR5cGUsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVNb3VzZUxlYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTGVhdmUoZWwsIHR5cGUsIGUpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBvbk1vdXNlTGVhdmUgPSBfdGhpcyRwcm9wczIub25Nb3VzZUxlYXZlLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzMi5jaGlsZHJlbjtcbiAgICAgIHZhciB0b29sdGlwSXRlbSA9ICgwLCBfUmVhY3RVdGlscy5maW5kQ2hpbGRCeVR5cGUpKGNoaWxkcmVuLCBfVG9vbHRpcC5Ub29sdGlwKTtcbiAgICAgIGlmICh0b29sdGlwSXRlbSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChwcmV2KSB7XG4gICAgICAgICAgaWYgKHRvb2x0aXBJdGVtLnByb3BzLnRyaWdnZXIgPT09ICdob3ZlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByZXYpLCB7fSwge1xuICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRUeXBlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvbk1vdXNlTGVhdmUpIHtcbiAgICAgICAgICAgIG9uTW91c2VMZWF2ZShlbCwgdHlwZSwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob25Nb3VzZUxlYXZlKSB7XG4gICAgICAgIG9uTW91c2VMZWF2ZShlbCwgdHlwZSwgZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUNsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGVsLCB0eXBlLCBlKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgb25DbGljayA9IF90aGlzJHByb3BzMy5vbkNsaWNrLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzMy5jaGlsZHJlbjtcbiAgICAgIHZhciB0b29sdGlwSXRlbSA9ICgwLCBfUmVhY3RVdGlscy5maW5kQ2hpbGRCeVR5cGUpKGNoaWxkcmVuLCBfVG9vbHRpcC5Ub29sdGlwKTtcbiAgICAgIGlmICh0b29sdGlwSXRlbSAmJiB0b29sdGlwSXRlbS5wcm9wcy50cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmlzVG9vbHRpcEFjdGl2ZSkge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByZXYpLCB7fSwge1xuICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRUeXBlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByZXYpLCB7fSwge1xuICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50OiBlbCxcbiAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudFR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvbkNsaWNrKSBvbkNsaWNrKGVsLCB0eXBlLCBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyTGlua3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTGlua3MobGlua3MsIG5vZGVzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICBsaW5rQ3VydmF0dXJlID0gX3RoaXMkcHJvcHM0LmxpbmtDdXJ2YXR1cmUsXG4gICAgICAgIGxpbmtDb250ZW50ID0gX3RoaXMkcHJvcHM0LmxpbmssXG4gICAgICAgIG1hcmdpbiA9IF90aGlzJHByb3BzNC5tYXJnaW47XG4gICAgICB2YXIgdG9wID0gKDAsIF9nZXRbXCJkZWZhdWx0XCJdKShtYXJnaW4sICd0b3AnKSB8fCAwO1xuICAgICAgdmFyIGxlZnQgPSAoMCwgX2dldFtcImRlZmF1bHRcIl0pKG1hcmdpbiwgJ2xlZnQnKSB8fCAwO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1zYW5rZXktbGlua3NcIixcbiAgICAgICAga2V5OiBcInJlY2hhcnRzLXNhbmtleS1saW5rc1wiXG4gICAgICB9LCBsaW5rcy5tYXAoZnVuY3Rpb24gKGxpbmssIGkpIHtcbiAgICAgICAgdmFyIHNvdXJjZVJlbGF0aXZlWSA9IGxpbmsuc3ksXG4gICAgICAgICAgdGFyZ2V0UmVsYXRpdmVZID0gbGluay50eSxcbiAgICAgICAgICBsaW5rV2lkdGggPSBsaW5rLmR5O1xuICAgICAgICB2YXIgc291cmNlID0gbm9kZXNbbGluay5zb3VyY2VdO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gbm9kZXNbbGluay50YXJnZXRdO1xuICAgICAgICB2YXIgc291cmNlWCA9IHNvdXJjZS54ICsgc291cmNlLmR4ICsgbGVmdDtcbiAgICAgICAgdmFyIHRhcmdldFggPSB0YXJnZXQueCArIGxlZnQ7XG4gICAgICAgIHZhciBpbnRlcnBvbGF0aW9uRnVuYyA9IGludGVycG9sYXRpb25HZW5lcmF0b3Ioc291cmNlWCwgdGFyZ2V0WCk7XG4gICAgICAgIHZhciBzb3VyY2VDb250cm9sWCA9IGludGVycG9sYXRpb25GdW5jKGxpbmtDdXJ2YXR1cmUpO1xuICAgICAgICB2YXIgdGFyZ2V0Q29udHJvbFggPSBpbnRlcnBvbGF0aW9uRnVuYygxIC0gbGlua0N1cnZhdHVyZSk7XG4gICAgICAgIHZhciBzb3VyY2VZID0gc291cmNlLnkgKyBzb3VyY2VSZWxhdGl2ZVkgKyBsaW5rV2lkdGggLyAyICsgdG9wO1xuICAgICAgICB2YXIgdGFyZ2V0WSA9IHRhcmdldC55ICsgdGFyZ2V0UmVsYXRpdmVZICsgbGlua1dpZHRoIC8gMiArIHRvcDtcbiAgICAgICAgdmFyIGxpbmtQcm9wcyA9IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIHNvdXJjZVg6IHNvdXJjZVgsXG4gICAgICAgICAgdGFyZ2V0WDogdGFyZ2V0WCxcbiAgICAgICAgICBzb3VyY2VZOiBzb3VyY2VZLFxuICAgICAgICAgIHRhcmdldFk6IHRhcmdldFksXG4gICAgICAgICAgc291cmNlQ29udHJvbFg6IHNvdXJjZUNvbnRyb2xYLFxuICAgICAgICAgIHRhcmdldENvbnRyb2xYOiB0YXJnZXRDb250cm9sWCxcbiAgICAgICAgICBzb3VyY2VSZWxhdGl2ZVk6IHNvdXJjZVJlbGF0aXZlWSxcbiAgICAgICAgICB0YXJnZXRSZWxhdGl2ZVk6IHRhcmdldFJlbGF0aXZlWSxcbiAgICAgICAgICBsaW5rV2lkdGg6IGxpbmtXaWR0aCxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBwYXlsb2FkOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGxpbmspLCB7fSwge1xuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgICAgIH0pXG4gICAgICAgIH0sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykobGlua0NvbnRlbnQsIGZhbHNlKSk7XG4gICAgICAgIHZhciBldmVudHMgPSB7XG4gICAgICAgICAgb25Nb3VzZUVudGVyOiBfdGhpczIuaGFuZGxlTW91c2VFbnRlci5iaW5kKF90aGlzMiwgbGlua1Byb3BzLCAnbGluaycpLFxuICAgICAgICAgIG9uTW91c2VMZWF2ZTogX3RoaXMyLmhhbmRsZU1vdXNlTGVhdmUuYmluZChfdGhpczIsIGxpbmtQcm9wcywgJ2xpbmsnKSxcbiAgICAgICAgICBvbkNsaWNrOiBfdGhpczIuaGFuZGxlQ2xpY2suYmluZChfdGhpczIsIGxpbmtQcm9wcywgJ2xpbmsnKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIF9leHRlbmRzKHtcbiAgICAgICAgICBrZXk6IFwibGluay1cIi5jb25jYXQobGluay5zb3VyY2UsIFwiLVwiKS5jb25jYXQobGluay50YXJnZXQsIFwiLVwiKS5jb25jYXQobGluay52YWx1ZSlcbiAgICAgICAgfSwgZXZlbnRzKSwgX3RoaXMyLmNvbnN0cnVjdG9yLnJlbmRlckxpbmtJdGVtKGxpbmtDb250ZW50LCBsaW5rUHJvcHMpKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTm9kZXMobm9kZXMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXG4gICAgICAgIG5vZGVDb250ZW50ID0gX3RoaXMkcHJvcHM1Lm5vZGUsXG4gICAgICAgIG1hcmdpbiA9IF90aGlzJHByb3BzNS5tYXJnaW47XG4gICAgICB2YXIgdG9wID0gKDAsIF9nZXRbXCJkZWZhdWx0XCJdKShtYXJnaW4sICd0b3AnKSB8fCAwO1xuICAgICAgdmFyIGxlZnQgPSAoMCwgX2dldFtcImRlZmF1bHRcIl0pKG1hcmdpbiwgJ2xlZnQnKSB8fCAwO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1zYW5rZXktbm9kZXNcIixcbiAgICAgICAga2V5OiBcInJlY2hhcnRzLXNhbmtleS1ub2Rlc1wiXG4gICAgICB9LCBub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgICAgdmFyIHggPSBub2RlLngsXG4gICAgICAgICAgeSA9IG5vZGUueSxcbiAgICAgICAgICBkeCA9IG5vZGUuZHgsXG4gICAgICAgICAgZHkgPSBub2RlLmR5O1xuICAgICAgICB2YXIgbm9kZVByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKG5vZGVDb250ZW50LCBmYWxzZSkpLCB7fSwge1xuICAgICAgICAgIHg6IHggKyBsZWZ0LFxuICAgICAgICAgIHk6IHkgKyB0b3AsXG4gICAgICAgICAgd2lkdGg6IGR4LFxuICAgICAgICAgIGhlaWdodDogZHksXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgcGF5bG9hZDogbm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHtcbiAgICAgICAgICBvbk1vdXNlRW50ZXI6IF90aGlzMy5oYW5kbGVNb3VzZUVudGVyLmJpbmQoX3RoaXMzLCBub2RlUHJvcHMsICdub2RlJyksXG4gICAgICAgICAgb25Nb3VzZUxlYXZlOiBfdGhpczMuaGFuZGxlTW91c2VMZWF2ZS5iaW5kKF90aGlzMywgbm9kZVByb3BzLCAnbm9kZScpLFxuICAgICAgICAgIG9uQ2xpY2s6IF90aGlzMy5oYW5kbGVDbGljay5iaW5kKF90aGlzMywgbm9kZVByb3BzLCAnbm9kZScpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwgX2V4dGVuZHMoe1xuICAgICAgICAgIGtleTogXCJub2RlLVwiLmNvbmNhdChub2RlLngsIFwiLVwiKS5jb25jYXQobm9kZS55LCBcIi1cIikuY29uY2F0KG5vZGUudmFsdWUpXG4gICAgICAgIH0sIGV2ZW50cyksIF90aGlzMy5jb25zdHJ1Y3Rvci5yZW5kZXJOb2RlSXRlbShub2RlQ29udGVudCwgbm9kZVByb3BzKSk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclRvb2x0aXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVG9vbHRpcCgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczYgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzNi5jaGlsZHJlbixcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczYud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzNi5oZWlnaHQsXG4gICAgICAgIG5hbWVLZXkgPSBfdGhpcyRwcm9wczYubmFtZUtleTtcbiAgICAgIHZhciB0b29sdGlwSXRlbSA9ICgwLCBfUmVhY3RVdGlscy5maW5kQ2hpbGRCeVR5cGUpKGNoaWxkcmVuLCBfVG9vbHRpcC5Ub29sdGlwKTtcbiAgICAgIGlmICghdG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICBpc1Rvb2x0aXBBY3RpdmUgPSBfdGhpcyRzdGF0ZS5pc1Rvb2x0aXBBY3RpdmUsXG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBfdGhpcyRzdGF0ZS5hY3RpdmVFbGVtZW50LFxuICAgICAgICBhY3RpdmVFbGVtZW50VHlwZSA9IF90aGlzJHN0YXRlLmFjdGl2ZUVsZW1lbnRUeXBlO1xuICAgICAgdmFyIHZpZXdCb3ggPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH07XG4gICAgICB2YXIgY29vcmRpbmF0ZSA9IGFjdGl2ZUVsZW1lbnQgPyBnZXRDb29yZGluYXRlT2ZUb29sdGlwKGFjdGl2ZUVsZW1lbnQsIGFjdGl2ZUVsZW1lbnRUeXBlKSA6IGRlZmF1bHRDb29yZGluYXRlT2ZUb29sdGlwO1xuICAgICAgdmFyIHBheWxvYWQgPSBhY3RpdmVFbGVtZW50ID8gZ2V0UGF5bG9hZE9mVG9vbHRpcChhY3RpdmVFbGVtZW50LCBhY3RpdmVFbGVtZW50VHlwZSwgbmFtZUtleSkgOiBbXTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQodG9vbHRpcEl0ZW0sIHtcbiAgICAgICAgdmlld0JveDogdmlld0JveCxcbiAgICAgICAgYWN0aXZlOiBpc1Rvb2x0aXBBY3RpdmUsXG4gICAgICAgIGNvb3JkaW5hdGU6IGNvb3JkaW5hdGUsXG4gICAgICAgIGxhYmVsOiAnJyxcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICBpZiAoISgwLCBfUmVhY3RVdGlscy52YWxpZGF0ZVdpZHRoSGVpZ2h0KSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBfdGhpcyRwcm9wczcgPSB0aGlzLnByb3BzLFxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM3LmhlaWdodCxcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHM3LmNsYXNzTmFtZSxcbiAgICAgICAgc3R5bGUgPSBfdGhpcyRwcm9wczcuc3R5bGUsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHM3LmNoaWxkcmVuLFxuICAgICAgICBvdGhlcnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHM3LCBfZXhjbHVkZWQpO1xuICAgICAgdmFyIF90aGlzJHN0YXRlMiA9IHRoaXMuc3RhdGUsXG4gICAgICAgIGxpbmtzID0gX3RoaXMkc3RhdGUyLmxpbmtzLFxuICAgICAgICBub2RlcyA9IF90aGlzJHN0YXRlMi5ub2RlcztcbiAgICAgIHZhciBhdHRycyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykob3RoZXJzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXdyYXBwZXInLCBjbGFzc05hbWUpLFxuICAgICAgICBzdHlsZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdHlsZSksIHt9LCB7XG4gICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCcsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0pLFxuICAgICAgICByb2xlOiBcInJlZ2lvblwiXG4gICAgICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9TdXJmYWNlLlN1cmZhY2UsIF9leHRlbmRzKHt9LCBhdHRycywge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9KSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclN2Z0VsZW1lbnRzKShjaGlsZHJlbiksIHRoaXMucmVuZGVyTGlua3MobGlua3MsIG5vZGVzKSwgdGhpcy5yZW5kZXJOb2Rlcyhub2RlcykpLCB0aGlzLnJlbmRlclRvb2x0aXAoKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgdmFyIGRhdGEgPSBuZXh0UHJvcHMuZGF0YSxcbiAgICAgICAgd2lkdGggPSBuZXh0UHJvcHMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IG5leHRQcm9wcy5oZWlnaHQsXG4gICAgICAgIG1hcmdpbiA9IG5leHRQcm9wcy5tYXJnaW4sXG4gICAgICAgIGl0ZXJhdGlvbnMgPSBuZXh0UHJvcHMuaXRlcmF0aW9ucyxcbiAgICAgICAgbm9kZVdpZHRoID0gbmV4dFByb3BzLm5vZGVXaWR0aCxcbiAgICAgICAgbm9kZVBhZGRpbmcgPSBuZXh0UHJvcHMubm9kZVBhZGRpbmcsXG4gICAgICAgIHNvcnQgPSBuZXh0UHJvcHMuc29ydDtcbiAgICAgIGlmIChkYXRhICE9PSBwcmV2U3RhdGUucHJldkRhdGEgfHwgd2lkdGggIT09IHByZXZTdGF0ZS5wcmV2V2lkdGggfHwgaGVpZ2h0ICE9PSBwcmV2U3RhdGUucHJldkhlaWdodCB8fCAhKDAsIF9TaGFsbG93RXF1YWwuc2hhbGxvd0VxdWFsKShtYXJnaW4sIHByZXZTdGF0ZS5wcmV2TWFyZ2luKSB8fCBpdGVyYXRpb25zICE9PSBwcmV2U3RhdGUucHJldkl0ZXJhdGlvbnMgfHwgbm9kZVdpZHRoICE9PSBwcmV2U3RhdGUucHJldk5vZGVXaWR0aCB8fCBub2RlUGFkZGluZyAhPT0gcHJldlN0YXRlLnByZXZOb2RlUGFkZGluZyB8fCBzb3J0ICE9PSBwcmV2U3RhdGUuc29ydCkge1xuICAgICAgICB2YXIgY29udGVudFdpZHRoID0gd2lkdGggLSAobWFyZ2luICYmIG1hcmdpbi5sZWZ0IHx8IDApIC0gKG1hcmdpbiAmJiBtYXJnaW4ucmlnaHQgfHwgMCk7XG4gICAgICAgIHZhciBjb250ZW50SGVpZ2h0ID0gaGVpZ2h0IC0gKG1hcmdpbiAmJiBtYXJnaW4udG9wIHx8IDApIC0gKG1hcmdpbiAmJiBtYXJnaW4uYm90dG9tIHx8IDApO1xuICAgICAgICB2YXIgX2NvbXB1dGVEYXRhID0gY29tcHV0ZURhdGEoe1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHdpZHRoOiBjb250ZW50V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNvbnRlbnRIZWlnaHQsXG4gICAgICAgICAgICBpdGVyYXRpb25zOiBpdGVyYXRpb25zLFxuICAgICAgICAgICAgbm9kZVdpZHRoOiBub2RlV2lkdGgsXG4gICAgICAgICAgICBub2RlUGFkZGluZzogbm9kZVBhZGRpbmcsXG4gICAgICAgICAgICBzb3J0OiBzb3J0XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbGlua3MgPSBfY29tcHV0ZURhdGEubGlua3MsXG4gICAgICAgICAgbm9kZXMgPSBfY29tcHV0ZURhdGEubm9kZXM7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByZXZTdGF0ZSksIHt9LCB7XG4gICAgICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgICAgIGxpbmtzOiBsaW5rcyxcbiAgICAgICAgICBwcmV2RGF0YTogZGF0YSxcbiAgICAgICAgICBwcmV2V2lkdGg6IGl0ZXJhdGlvbnMsXG4gICAgICAgICAgcHJldkhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgIHByZXZNYXJnaW46IG1hcmdpbixcbiAgICAgICAgICBwcmV2Tm9kZVBhZGRpbmc6IG5vZGVQYWRkaW5nLFxuICAgICAgICAgIHByZXZOb2RlV2lkdGg6IG5vZGVXaWR0aCxcbiAgICAgICAgICBwcmV2SXRlcmF0aW9uczogaXRlcmF0aW9ucyxcbiAgICAgICAgICBwcmV2U29ydDogc29ydFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJMaW5rSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJMaW5rSXRlbShvcHRpb24sIHByb3BzKSB7XG4gICAgICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KG9wdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChvcHRpb24sIHByb3BzKTtcbiAgICAgIH1cbiAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvcHRpb24pKSB7XG4gICAgICAgIHJldHVybiBvcHRpb24ocHJvcHMpO1xuICAgICAgfVxuICAgICAgdmFyIHNvdXJjZVggPSBwcm9wcy5zb3VyY2VYLFxuICAgICAgICBzb3VyY2VZID0gcHJvcHMuc291cmNlWSxcbiAgICAgICAgc291cmNlQ29udHJvbFggPSBwcm9wcy5zb3VyY2VDb250cm9sWCxcbiAgICAgICAgdGFyZ2V0WCA9IHByb3BzLnRhcmdldFgsXG4gICAgICAgIHRhcmdldFkgPSBwcm9wcy50YXJnZXRZLFxuICAgICAgICB0YXJnZXRDb250cm9sWCA9IHByb3BzLnRhcmdldENvbnRyb2xYLFxuICAgICAgICBsaW5rV2lkdGggPSBwcm9wcy5saW5rV2lkdGgsXG4gICAgICAgIG90aGVycyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkMik7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBhdGhcIiwgX2V4dGVuZHMoe1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtc2Fua2V5LWxpbmtcIixcbiAgICAgICAgZDogXCJcXG4gICAgICAgICAgTVwiLmNvbmNhdChzb3VyY2VYLCBcIixcIikuY29uY2F0KHNvdXJjZVksIFwiXFxuICAgICAgICAgIENcIikuY29uY2F0KHNvdXJjZUNvbnRyb2xYLCBcIixcIikuY29uY2F0KHNvdXJjZVksIFwiIFwiKS5jb25jYXQodGFyZ2V0Q29udHJvbFgsIFwiLFwiKS5jb25jYXQodGFyZ2V0WSwgXCIgXCIpLmNvbmNhdCh0YXJnZXRYLCBcIixcIikuY29uY2F0KHRhcmdldFksIFwiXFxuICAgICAgICBcIiksXG4gICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICBzdHJva2U6IFwiIzMzM1wiLFxuICAgICAgICBzdHJva2VXaWR0aDogbGlua1dpZHRoLFxuICAgICAgICBzdHJva2VPcGFjaXR5OiBcIjAuMlwiXG4gICAgICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKG90aGVycywgZmFsc2UpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlck5vZGVJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlck5vZGVJdGVtKG9wdGlvbiwgcHJvcHMpIHtcbiAgICAgIGlmICggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQob3B0aW9uKSkge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KG9wdGlvbiwgcHJvcHMpO1xuICAgICAgfVxuICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9wdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbihwcm9wcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfUmVjdGFuZ2xlLlJlY3RhbmdsZSwgX2V4dGVuZHMoe1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtc2Fua2V5LW5vZGVcIixcbiAgICAgICAgZmlsbDogXCIjMDA4OGZlXCIsXG4gICAgICAgIGZpbGxPcGFjaXR5OiBcIjAuOFwiXG4gICAgICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHByb3BzLCBmYWxzZSksIHtcbiAgICAgICAgcm9sZTogXCJpbWdcIlxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xufShfcmVhY3QuUHVyZUNvbXBvbmVudCk7XG5fZGVmaW5lUHJvcGVydHkoU2Fua2V5LCBcImRpc3BsYXlOYW1lXCIsICdTYW5rZXknKTtcbl9kZWZpbmVQcm9wZXJ0eShTYW5rZXksIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgbmFtZUtleTogJ25hbWUnLFxuICBkYXRhS2V5OiAndmFsdWUnLFxuICBub2RlUGFkZGluZzogMTAsXG4gIG5vZGVXaWR0aDogMTAsXG4gIGxpbmtDdXJ2YXR1cmU6IDAuNSxcbiAgaXRlcmF0aW9uczogMzIsXG4gIG1hcmdpbjoge1xuICAgIHRvcDogNSxcbiAgICByaWdodDogNSxcbiAgICBib3R0b206IDUsXG4gICAgbGVmdDogNVxuICB9LFxuICBzb3J0OiB0cnVlXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTYW5rZXkiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfbWF4QnkiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX21pbiIsIl9nZXQiLCJfc3VtQnkiLCJfaXNGdW5jdGlvbiIsIl9jbHN4IiwiX1N1cmZhY2UiLCJfTGF5ZXIiLCJfVG9vbHRpcCIsIl9SZWN0YW5nbGUiLCJfU2hhbGxvd0VxdWFsIiwiX1JlYWN0VXRpbHMiLCJfQ2hhcnRVdGlscyIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2UiLCJleGNsdWRlZCIsInRhcmdldCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwia2V5IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImxlbmd0aCIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsImFyZ3VtZW50cyIsImFwcGx5IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwib3duS2V5cyIsImtleXMiLCJmaWx0ZXIiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiZGVmYXVsdENvb3JkaW5hdGVPZlRvb2x0aXAiLCJ4IiwieSIsImludGVycG9sYXRpb25HZW5lcmF0b3IiLCJiIiwia2EiLCJrYiIsImNlbnRlclkiLCJub2RlIiwiZHkiLCJnZXRWYWx1ZSIsImVudHJ5IiwiZ2V0U3VtT2ZJZHMiLCJsaW5rcyIsImlkcyIsInJlZHVjZSIsInJlc3VsdCIsImlkIiwiZ2V0U3VtV2l0aFdlaWdodGVkU291cmNlIiwidHJlZSIsImxpbmsiLCJzb3VyY2VOb2RlIiwiZ2V0U3VtV2l0aFdlaWdodGVkVGFyZ2V0IiwidGFyZ2V0Tm9kZSIsImFzY2VuZGluZ1kiLCJzZWFyY2hUYXJnZXRzQW5kU291cmNlcyIsInNvdXJjZU5vZGVzIiwic291cmNlTGlua3MiLCJ0YXJnZXROb2RlcyIsInRhcmdldExpbmtzIiwibGVuIiwidXBkYXRlRGVwdGhPZlRhcmdldHMiLCJjdXJOb2RlIiwiZGVwdGgiLCJNYXRoIiwibWF4IiwiZ2V0Tm9kZXNUcmVlIiwiX3JlZiIsIndpZHRoIiwibm9kZVdpZHRoIiwibm9kZXMiLCJtYXAiLCJpbmRleCIsIm1heERlcHRoIiwiY2hpbGRXaWR0aCIsIl9pIiwiX2xlbiIsIl9ub2RlIiwiZHgiLCJnZXREZXB0aFRyZWUiLCJ1cGRhdGVZT2ZUcmVlIiwiZGVwdGhUcmVlIiwiaGVpZ2h0Iiwibm9kZVBhZGRpbmciLCJ5UmF0aW8iLCJkIiwicmVzb2x2ZUNvbGxpc2lvbnMiLCJzb3J0IiwidW5kZWZpbmVkIiwieTAiLCJqIiwiX2oiLCJfbm9kZTIiLCJfZHkiLCJyZWxheExlZnRUb1JpZ2h0IiwiYWxwaGEiLCJzb3VyY2VTdW0iLCJ3ZWlnaHRlZFN1bSIsInJlbGF4UmlnaHRUb0xlZnQiLCJ0YXJnZXRTdW0iLCJ1cGRhdGVZT2ZMaW5rcyIsInN5IiwidHkiLCJ0TGVuIiwiX2oyIiwic0xlbiIsIl9saW5rIiwiY29tcHV0ZURhdGEiLCJfcmVmMiIsImRhdGEiLCJpdGVyYXRpb25zIiwiX2dldE5vZGVzVHJlZSIsIm5ld0xpbmtzIiwiZ2V0Q29vcmRpbmF0ZU9mVG9vbHRpcCIsImVsIiwidHlwZSIsInNvdXJjZVgiLCJ0YXJnZXRYIiwic291cmNlWSIsInRhcmdldFkiLCJnZXRQYXlsb2FkT2ZUb29sdGlwIiwibmFtZUtleSIsInBheWxvYWQiLCJuYW1lIiwiZ2V0VmFsdWVCeURhdGFLZXkiLCJzb3VyY2VOYW1lIiwidGFyZ2V0TmFtZSIsImNvbmNhdCIsIl9QdXJlQ29tcG9uZW50IiwiX3RoaXMiLCJfbGVuMiIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJhY3RpdmVFbGVtZW50IiwiYWN0aXZlRWxlbWVudFR5cGUiLCJpc1Rvb2x0aXBBY3RpdmUiLCJoYW5kbGVNb3VzZUVudGVyIiwiX3RoaXMkcHJvcHMiLCJvbk1vdXNlRW50ZXIiLCJjaGlsZHJlbiIsInRvb2x0aXBJdGVtIiwiZmluZENoaWxkQnlUeXBlIiwiVG9vbHRpcCIsInNldFN0YXRlIiwicHJldiIsInRyaWdnZXIiLCJoYW5kbGVNb3VzZUxlYXZlIiwiX3RoaXMkcHJvcHMyIiwib25Nb3VzZUxlYXZlIiwiaGFuZGxlQ2xpY2siLCJfdGhpcyRwcm9wczMiLCJvbkNsaWNrIiwic3RhdGUiLCJyZW5kZXJMaW5rcyIsIl90aGlzMiIsIl90aGlzJHByb3BzNCIsImxpbmtDdXJ2YXR1cmUiLCJsaW5rQ29udGVudCIsIm1hcmdpbiIsInRvcCIsImxlZnQiLCJjcmVhdGVFbGVtZW50IiwiTGF5ZXIiLCJjbGFzc05hbWUiLCJzb3VyY2VSZWxhdGl2ZVkiLCJ0YXJnZXRSZWxhdGl2ZVkiLCJsaW5rV2lkdGgiLCJpbnRlcnBvbGF0aW9uRnVuYyIsInNvdXJjZUNvbnRyb2xYIiwidGFyZ2V0Q29udHJvbFgiLCJsaW5rUHJvcHMiLCJmaWx0ZXJQcm9wcyIsImV2ZW50cyIsInJlbmRlckxpbmtJdGVtIiwicmVuZGVyTm9kZXMiLCJfdGhpczMiLCJfdGhpcyRwcm9wczUiLCJub2RlQ29udGVudCIsIm5vZGVQcm9wcyIsInJlbmRlck5vZGVJdGVtIiwicmVuZGVyVG9vbHRpcCIsIl90aGlzJHByb3BzNiIsIl90aGlzJHN0YXRlIiwidmlld0JveCIsImNvb3JkaW5hdGUiLCJjbG9uZUVsZW1lbnQiLCJhY3RpdmUiLCJsYWJlbCIsInJlbmRlciIsInZhbGlkYXRlV2lkdGhIZWlnaHQiLCJfdGhpcyRwcm9wczciLCJzdHlsZSIsIm90aGVycyIsIl90aGlzJHN0YXRlMiIsImF0dHJzIiwicG9zaXRpb24iLCJjdXJzb3IiLCJyb2xlIiwiU3VyZmFjZSIsImZpbHRlclN2Z0VsZW1lbnRzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibmV4dFByb3BzIiwicHJldlN0YXRlIiwicHJldkRhdGEiLCJwcmV2V2lkdGgiLCJwcmV2SGVpZ2h0Iiwic2hhbGxvd0VxdWFsIiwicHJldk1hcmdpbiIsInByZXZJdGVyYXRpb25zIiwicHJldk5vZGVXaWR0aCIsInByZXZOb2RlUGFkZGluZyIsImNvbnRlbnRXaWR0aCIsInJpZ2h0IiwiY29udGVudEhlaWdodCIsImJvdHRvbSIsIl9jb21wdXRlRGF0YSIsInByZXZTb3J0Iiwib3B0aW9uIiwiaXNWYWxpZEVsZW1lbnQiLCJmaWxsIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VPcGFjaXR5IiwiUmVjdGFuZ2xlIiwiZmlsbE9wYWNpdHkiLCJQdXJlQ29tcG9uZW50IiwiZGF0YUtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/chart/Sankey.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/chart/ScatterChart.js":
/*!*********************************************************!*\
  !*** ./node_modules/recharts/lib/chart/ScatterChart.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ScatterChart = void 0;\nvar _generateCategoricalChart = __webpack_require__(/*! ./generateCategoricalChart */ \"./node_modules/recharts/lib/chart/generateCategoricalChart.js\");\nvar _Scatter = __webpack_require__(/*! ../cartesian/Scatter */ \"./node_modules/recharts/lib/cartesian/Scatter.js\");\nvar _XAxis = __webpack_require__(/*! ../cartesian/XAxis */ \"./node_modules/recharts/lib/cartesian/XAxis.js\");\nvar _YAxis = __webpack_require__(/*! ../cartesian/YAxis */ \"./node_modules/recharts/lib/cartesian/YAxis.js\");\nvar _ZAxis = __webpack_require__(/*! ../cartesian/ZAxis */ \"./node_modules/recharts/lib/cartesian/ZAxis.js\");\nvar _CartesianUtils = __webpack_require__(/*! ../util/CartesianUtils */ \"./node_modules/recharts/lib/util/CartesianUtils.js\");\n/**\n * @fileOverview Scatter Chart\n */ var ScatterChart = exports.ScatterChart = (0, _generateCategoricalChart.generateCategoricalChart)({\n    chartName: \"ScatterChart\",\n    GraphicalChild: _Scatter.Scatter,\n    defaultTooltipEventType: \"item\",\n    validateTooltipEventTypes: [\n        \"item\"\n    ],\n    axisComponents: [\n        {\n            axisType: \"xAxis\",\n            AxisComp: _XAxis.XAxis\n        },\n        {\n            axisType: \"yAxis\",\n            AxisComp: _YAxis.YAxis\n        },\n        {\n            axisType: \"zAxis\",\n            AxisComp: _ZAxis.ZAxis\n        }\n    ],\n    formatAxisMap: _CartesianUtils.formatAxisMap\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L1NjYXR0ZXJDaGFydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsb0JBQW9CLEdBQUcsS0FBSztBQUM1QixJQUFJRyw0QkFBNEJDLG1CQUFPQSxDQUFDLGlHQUE0QjtBQUNwRSxJQUFJQyxXQUFXRCxtQkFBT0EsQ0FBQyw4RUFBc0I7QUFDN0MsSUFBSUUsU0FBU0YsbUJBQU9BLENBQUMsMEVBQW9CO0FBQ3pDLElBQUlHLFNBQVNILG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJSSxTQUFTSixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDekMsSUFBSUssa0JBQWtCTCxtQkFBT0EsQ0FBQyxrRkFBd0I7QUFDdEQ7O0NBRUMsR0FFRCxJQUFJRixlQUFlRixvQkFBb0IsR0FBRyxDQUFDLEdBQUdHLDBCQUEwQk8sd0JBQXdCLEVBQUU7SUFDaEdDLFdBQVc7SUFDWEMsZ0JBQWdCUCxTQUFTUSxPQUFPO0lBQ2hDQyx5QkFBeUI7SUFDekJDLDJCQUEyQjtRQUFDO0tBQU87SUFDbkNDLGdCQUFnQjtRQUFDO1lBQ2ZDLFVBQVU7WUFDVkMsVUFBVVosT0FBT2EsS0FBSztRQUN4QjtRQUFHO1lBQ0RGLFVBQVU7WUFDVkMsVUFBVVgsT0FBT2EsS0FBSztRQUN4QjtRQUFHO1lBQ0RILFVBQVU7WUFDVkMsVUFBVVYsT0FBT2EsS0FBSztRQUN4QjtLQUFFO0lBQ0ZDLGVBQWViLGdCQUFnQmEsYUFBYTtBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvU2NhdHRlckNoYXJ0LmpzPzcwY2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlNjYXR0ZXJDaGFydCA9IHZvaWQgMDtcbnZhciBfZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0ID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0XCIpO1xudmFyIF9TY2F0dGVyID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9TY2F0dGVyXCIpO1xudmFyIF9YQXhpcyA9IHJlcXVpcmUoXCIuLi9jYXJ0ZXNpYW4vWEF4aXNcIik7XG52YXIgX1lBeGlzID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9ZQXhpc1wiKTtcbnZhciBfWkF4aXMgPSByZXF1aXJlKFwiLi4vY2FydGVzaWFuL1pBeGlzXCIpO1xudmFyIF9DYXJ0ZXNpYW5VdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NhcnRlc2lhblV0aWxzXCIpO1xuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFNjYXR0ZXIgQ2hhcnRcbiAqL1xuXG52YXIgU2NhdHRlckNoYXJ0ID0gZXhwb3J0cy5TY2F0dGVyQ2hhcnQgPSAoMCwgX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydC5nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQpKHtcbiAgY2hhcnROYW1lOiAnU2NhdHRlckNoYXJ0JyxcbiAgR3JhcGhpY2FsQ2hpbGQ6IF9TY2F0dGVyLlNjYXR0ZXIsXG4gIGRlZmF1bHRUb29sdGlwRXZlbnRUeXBlOiAnaXRlbScsXG4gIHZhbGlkYXRlVG9vbHRpcEV2ZW50VHlwZXM6IFsnaXRlbSddLFxuICBheGlzQ29tcG9uZW50czogW3tcbiAgICBheGlzVHlwZTogJ3hBeGlzJyxcbiAgICBBeGlzQ29tcDogX1hBeGlzLlhBeGlzXG4gIH0sIHtcbiAgICBheGlzVHlwZTogJ3lBeGlzJyxcbiAgICBBeGlzQ29tcDogX1lBeGlzLllBeGlzXG4gIH0sIHtcbiAgICBheGlzVHlwZTogJ3pBeGlzJyxcbiAgICBBeGlzQ29tcDogX1pBeGlzLlpBeGlzXG4gIH1dLFxuICBmb3JtYXRBeGlzTWFwOiBfQ2FydGVzaWFuVXRpbHMuZm9ybWF0QXhpc01hcFxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU2NhdHRlckNoYXJ0IiwiX2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsInJlcXVpcmUiLCJfU2NhdHRlciIsIl9YQXhpcyIsIl9ZQXhpcyIsIl9aQXhpcyIsIl9DYXJ0ZXNpYW5VdGlscyIsImdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCIsImNoYXJ0TmFtZSIsIkdyYXBoaWNhbENoaWxkIiwiU2NhdHRlciIsImRlZmF1bHRUb29sdGlwRXZlbnRUeXBlIiwidmFsaWRhdGVUb29sdGlwRXZlbnRUeXBlcyIsImF4aXNDb21wb25lbnRzIiwiYXhpc1R5cGUiLCJBeGlzQ29tcCIsIlhBeGlzIiwiWUF4aXMiLCJaQXhpcyIsImZvcm1hdEF4aXNNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/chart/ScatterChart.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/chart/SunburstChart.js":
/*!**********************************************************!*\
  !*** ./node_modules/recharts/lib/chart/SunburstChart.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SunburstChart = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _d3Scale = __webpack_require__(/*! victory-vendor/d3-scale */ \"victory-vendor/d3-scale\");\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Surface = __webpack_require__(/*! ../container/Surface */ \"./node_modules/recharts/lib/container/Surface.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _Sector = __webpack_require__(/*! ../shape/Sector */ \"./node_modules/recharts/lib/shape/Sector.js\");\nvar _Text = __webpack_require__(/*! ../component/Text */ \"./node_modules/recharts/lib/component/Text.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _Tooltip = __webpack_require__(/*! ../component/Tooltip */ \"./node_modules/recharts/lib/component/Tooltip.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nvar defaultTextProps = {\n    fontWeight: \"bold\",\n    paintOrder: \"stroke fill\",\n    fontSize: \".75rem\",\n    stroke: \"#FFF\",\n    fill: \"black\",\n    pointerEvents: \"none\"\n};\nfunction getMaxDepthOf(node) {\n    if (!node.children || node.children.length === 0) return 1;\n    // Calculate depth for each child and find the maximum\n    var childDepths = node.children.map(function(d) {\n        return getMaxDepthOf(d);\n    });\n    return 1 + Math.max.apply(Math, _toConsumableArray(childDepths));\n}\nvar SunburstChart = exports.SunburstChart = function SunburstChart(_ref) {\n    var className = _ref.className, data = _ref.data, children = _ref.children, width = _ref.width, height = _ref.height, _ref$padding = _ref.padding, padding = _ref$padding === void 0 ? 2 : _ref$padding, _ref$dataKey = _ref.dataKey, dataKey = _ref$dataKey === void 0 ? \"value\" : _ref$dataKey, _ref$ringPadding = _ref.ringPadding, ringPadding = _ref$ringPadding === void 0 ? 2 : _ref$ringPadding, _ref$innerRadius = _ref.innerRadius, innerRadius = _ref$innerRadius === void 0 ? 50 : _ref$innerRadius, _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? \"#333\" : _ref$fill, _ref$stroke = _ref.stroke, stroke = _ref$stroke === void 0 ? \"#FFF\" : _ref$stroke, _ref$textOptions = _ref.textOptions, textOptions = _ref$textOptions === void 0 ? defaultTextProps : _ref$textOptions, _ref$outerRadius = _ref.outerRadius, outerRadius = _ref$outerRadius === void 0 ? Math.min(width, height) / 2 : _ref$outerRadius, _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? width / 2 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? height / 2 : _ref$cy, _ref$startAngle = _ref.startAngle, startAngle = _ref$startAngle === void 0 ? 0 : _ref$startAngle, _ref$endAngle = _ref.endAngle, endAngle = _ref$endAngle === void 0 ? 360 : _ref$endAngle, onClick = _ref.onClick, onMouseEnter = _ref.onMouseEnter, onMouseLeave = _ref.onMouseLeave;\n    var _useState = (0, _react.useState)(false), _useState2 = _slicedToArray(_useState, 2), isTooltipActive = _useState2[0], setIsTooltipActive = _useState2[1];\n    var _useState3 = (0, _react.useState)(null), _useState4 = _slicedToArray(_useState3, 2), activeNode = _useState4[0], setActiveNode = _useState4[1];\n    var rScale = (0, _d3Scale.scaleLinear)([\n        0,\n        data[dataKey]\n    ], [\n        0,\n        endAngle\n    ]);\n    var treeDepth = getMaxDepthOf(data);\n    var thickness = (outerRadius - innerRadius) / treeDepth;\n    var sectors = [];\n    var positions = new Map([]);\n    // event handlers\n    function handleMouseEnter(node, e) {\n        if (onMouseEnter) onMouseEnter(node, e);\n        setActiveNode(node);\n        setIsTooltipActive(true);\n    }\n    function handleMouseLeave(node, e) {\n        if (onMouseLeave) onMouseLeave(node, e);\n        setActiveNode(null);\n        setIsTooltipActive(false);\n    }\n    function handleClick(node) {\n        if (onClick) onClick(node);\n    }\n    // recursively add nodes for each data point and its children\n    function drawArcs(childNodes, options) {\n        var radius = options.radius, innerR = options.innerR, initialAngle = options.initialAngle, childColor = options.childColor;\n        var currentAngle = initialAngle;\n        if (!childNodes) return; // base case: no children of this node\n        childNodes.forEach(function(d) {\n            var _ref2, _d$fill;\n            var arcLength = rScale(d[dataKey]);\n            var start = currentAngle;\n            // color priority - if there's a color on the individual point use that, otherwise use parent color or default\n            var fillColor = (_ref2 = (_d$fill = d === null || d === void 0 ? void 0 : d.fill) !== null && _d$fill !== void 0 ? _d$fill : childColor) !== null && _ref2 !== void 0 ? _ref2 : fill;\n            var _polarToCartesian = (0, _PolarUtils.polarToCartesian)(0, 0, innerR + radius / 2, -(start + arcLength - arcLength / 2)), textX = _polarToCartesian.x, textY = _polarToCartesian.y;\n            currentAngle += arcLength;\n            sectors.push(/*#__PURE__*/ // TODO: Missing key warning. Can we use `key={d.name}`?\n            _react[\"default\"].createElement(\"g\", {\n                \"aria-label\": d.name,\n                tabIndex: 0\n            }, /*#__PURE__*/ _react[\"default\"].createElement(_Sector.Sector, {\n                onClick: function onClick() {\n                    return handleClick(d);\n                },\n                onMouseEnter: function onMouseEnter(e) {\n                    return handleMouseEnter(d, e);\n                },\n                onMouseLeave: function onMouseLeave(e) {\n                    return handleMouseLeave(d, e);\n                },\n                fill: fillColor,\n                stroke: stroke,\n                strokeWidth: padding,\n                startAngle: start,\n                endAngle: start + arcLength,\n                innerRadius: innerR,\n                outerRadius: innerR + radius,\n                cx: cx,\n                cy: cy\n            }), /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({}, textOptions, {\n                alignmentBaseline: \"middle\",\n                textAnchor: \"middle\",\n                x: textX + cx,\n                y: cy - textY\n            }), d[dataKey])));\n            var _polarToCartesian2 = (0, _PolarUtils.polarToCartesian)(cx, cy, innerR + radius / 2, start), tooltipX = _polarToCartesian2.x, tooltipY = _polarToCartesian2.y;\n            positions.set(d.name, {\n                x: tooltipX,\n                y: tooltipY\n            });\n            return drawArcs(d.children, {\n                radius: radius,\n                innerR: innerR + radius + ringPadding,\n                initialAngle: start,\n                childColor: fillColor\n            });\n        });\n    }\n    drawArcs(data.children, {\n        radius: thickness,\n        innerR: innerRadius,\n        initialAngle: startAngle\n    });\n    var layerClass = (0, _clsx[\"default\"])(\"recharts-sunburst\", className);\n    function renderTooltip() {\n        var tooltipComponent = (0, _ReactUtils.findChildByType)([\n            children\n        ], _Tooltip.Tooltip);\n        if (!tooltipComponent || !activeNode) return null;\n        var viewBox = {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n        };\n        return /*#__PURE__*/ _react[\"default\"].cloneElement(tooltipComponent, {\n            viewBox: viewBox,\n            coordinate: positions.get(activeNode.name),\n            payload: [\n                activeNode\n            ],\n            active: isTooltipActive\n        });\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n        className: (0, _clsx[\"default\"])(\"recharts-wrapper\", className),\n        style: {\n            position: \"relative\",\n            width: width,\n            height: height\n        },\n        role: \"region\"\n    }, /*#__PURE__*/ _react[\"default\"].createElement(_Surface.Surface, {\n        width: width,\n        height: height\n    }, children, /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n        className: layerClass\n    }, sectors)), renderTooltip());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L1N1bmJ1cnN0Q2hhcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1RLLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxxQkFBcUIsR0FBRyxLQUFLO0FBQzdCLElBQUlHLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsV0FBV0QsbUJBQU9BLENBQUMsd0RBQXlCO0FBQ2hELElBQUlFLFFBQVFDLHVCQUF1QkgsbUJBQU9BLENBQUMsa0JBQU07QUFDakQsSUFBSUksY0FBY0osbUJBQU9BLENBQUMsMEVBQW9CO0FBQzlDLElBQUlLLFdBQVdMLG1CQUFPQSxDQUFDLDhFQUFzQjtBQUM3QyxJQUFJTSxTQUFTTixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDekMsSUFBSU8sVUFBVVAsbUJBQU9BLENBQUMsb0VBQWlCO0FBQ3ZDLElBQUlRLFFBQVFSLG1CQUFPQSxDQUFDLHdFQUFtQjtBQUN2QyxJQUFJUyxjQUFjVCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSVUsV0FBV1YsbUJBQU9BLENBQUMsOEVBQXNCO0FBQzdDLFNBQVNHLHVCQUF1QlEsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSx5QkFBeUJDLENBQUM7SUFBSSxJ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VSxFQUFFLHFCQUFxQmdGO0lBQzVELFNBQVNnRjtRQUNQLElBQUlDLG1CQUFtQixDQUFDLEdBQUcvSixZQUFZZ0ssZUFBZSxFQUFFO1lBQUN6RjtTQUFTLEVBQUVqRSxTQUFTMkosT0FBTztRQUNwRixJQUFJLENBQUNGLG9CQUFvQixDQUFDNUMsWUFBWSxPQUFPO1FBQzdDLElBQUkrQyxVQUFVO1lBQ1psQixHQUFHO1lBQ0hFLEdBQUc7WUFDSGxFLE9BQU9BO1lBQ1BDLFFBQVFBO1FBQ1Y7UUFDQSxPQUFPLFdBQVcsR0FBRXZGLE1BQU0sQ0FBQyxVQUFVLENBQUN5SyxZQUFZLENBQUNKLGtCQUFrQjtZQUNuRUcsU0FBU0E7WUFDVEUsWUFBWTFDLFVBQVUzRyxHQUFHLENBQUNvRyxXQUFXM0QsSUFBSTtZQUN6QzZHLFNBQVM7Z0JBQUNsRDthQUFXO1lBQ3JCbUQsUUFBUXZEO1FBQ1Y7SUFDRjtJQUNBLE9BQU8sV0FBVyxHQUFFckgsTUFBTSxDQUFDLFVBQVUsQ0FBQ3lKLGFBQWEsQ0FBQyxPQUFPO1FBQ3pEckUsV0FBVyxDQUFDLEdBQUdoRixLQUFLLENBQUMsVUFBVSxFQUFFLG9CQUFvQmdGO1FBQ3JEeUYsT0FBTztZQUNMQyxVQUFVO1lBQ1Z4RixPQUFPQTtZQUNQQyxRQUFRQTtRQUNWO1FBQ0F3RixNQUFNO0lBQ1IsR0FBRyxXQUFXLEdBQUUvSyxNQUFNLENBQUMsVUFBVSxDQUFDeUosYUFBYSxDQUFDbEosU0FBU3lLLE9BQU8sRUFBRTtRQUNoRTFGLE9BQU9BO1FBQ1BDLFFBQVFBO0lBQ1YsR0FBR1YsVUFBVSxXQUFXLEdBQUU3RSxNQUFNLENBQUMsVUFBVSxDQUFDeUosYUFBYSxDQUFDakosT0FBT3lLLEtBQUssRUFBRTtRQUN0RTdGLFdBQVcrRTtJQUNiLEdBQUdwQyxXQUFXcUM7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L1N1bmJ1cnN0Q2hhcnQuanM/YTk0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU3VuYnVyc3RDaGFydCA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9kM1NjYWxlID0gcmVxdWlyZShcInZpY3RvcnktdmVuZG9yL2QzLXNjYWxlXCIpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xudmFyIF9TdXJmYWNlID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9TdXJmYWNlXCIpO1xudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XG52YXIgX1NlY3RvciA9IHJlcXVpcmUoXCIuLi9zaGFwZS9TZWN0b3JcIik7XG52YXIgX1RleHQgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L1RleHRcIik7XG52YXIgX1BvbGFyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Qb2xhclV0aWxzXCIpO1xudmFyIF9Ub29sdGlwID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9Ub29sdGlwXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxudmFyIGRlZmF1bHRUZXh0UHJvcHMgPSB7XG4gIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgcGFpbnRPcmRlcjogJ3N0cm9rZSBmaWxsJyxcbiAgZm9udFNpemU6ICcuNzVyZW0nLFxuICBzdHJva2U6ICcjRkZGJyxcbiAgZmlsbDogJ2JsYWNrJyxcbiAgcG9pbnRlckV2ZW50czogJ25vbmUnXG59O1xuZnVuY3Rpb24gZ2V0TWF4RGVwdGhPZihub2RlKSB7XG4gIGlmICghbm9kZS5jaGlsZHJlbiB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDE7XG5cbiAgLy8gQ2FsY3VsYXRlIGRlcHRoIGZvciBlYWNoIGNoaWxkIGFuZCBmaW5kIHRoZSBtYXhpbXVtXG4gIHZhciBjaGlsZERlcHRocyA9IG5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGdldE1heERlcHRoT2YoZCk7XG4gIH0pO1xuICByZXR1cm4gMSArIE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShjaGlsZERlcHRocykpO1xufVxudmFyIFN1bmJ1cnN0Q2hhcnQgPSBleHBvcnRzLlN1bmJ1cnN0Q2hhcnQgPSBmdW5jdGlvbiBTdW5idXJzdENoYXJ0KF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICBoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICBfcmVmJHBhZGRpbmcgPSBfcmVmLnBhZGRpbmcsXG4gICAgcGFkZGluZyA9IF9yZWYkcGFkZGluZyA9PT0gdm9pZCAwID8gMiA6IF9yZWYkcGFkZGluZyxcbiAgICBfcmVmJGRhdGFLZXkgPSBfcmVmLmRhdGFLZXksXG4gICAgZGF0YUtleSA9IF9yZWYkZGF0YUtleSA9PT0gdm9pZCAwID8gJ3ZhbHVlJyA6IF9yZWYkZGF0YUtleSxcbiAgICBfcmVmJHJpbmdQYWRkaW5nID0gX3JlZi5yaW5nUGFkZGluZyxcbiAgICByaW5nUGFkZGluZyA9IF9yZWYkcmluZ1BhZGRpbmcgPT09IHZvaWQgMCA/IDIgOiBfcmVmJHJpbmdQYWRkaW5nLFxuICAgIF9yZWYkaW5uZXJSYWRpdXMgPSBfcmVmLmlubmVyUmFkaXVzLFxuICAgIGlubmVyUmFkaXVzID0gX3JlZiRpbm5lclJhZGl1cyA9PT0gdm9pZCAwID8gNTAgOiBfcmVmJGlubmVyUmFkaXVzLFxuICAgIF9yZWYkZmlsbCA9IF9yZWYuZmlsbCxcbiAgICBmaWxsID0gX3JlZiRmaWxsID09PSB2b2lkIDAgPyAnIzMzMycgOiBfcmVmJGZpbGwsXG4gICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICBzdHJva2UgPSBfcmVmJHN0cm9rZSA9PT0gdm9pZCAwID8gJyNGRkYnIDogX3JlZiRzdHJva2UsXG4gICAgX3JlZiR0ZXh0T3B0aW9ucyA9IF9yZWYudGV4dE9wdGlvbnMsXG4gICAgdGV4dE9wdGlvbnMgPSBfcmVmJHRleHRPcHRpb25zID09PSB2b2lkIDAgPyBkZWZhdWx0VGV4dFByb3BzIDogX3JlZiR0ZXh0T3B0aW9ucyxcbiAgICBfcmVmJG91dGVyUmFkaXVzID0gX3JlZi5vdXRlclJhZGl1cyxcbiAgICBvdXRlclJhZGl1cyA9IF9yZWYkb3V0ZXJSYWRpdXMgPT09IHZvaWQgMCA/IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpIC8gMiA6IF9yZWYkb3V0ZXJSYWRpdXMsXG4gICAgX3JlZiRjeCA9IF9yZWYuY3gsXG4gICAgY3ggPSBfcmVmJGN4ID09PSB2b2lkIDAgPyB3aWR0aCAvIDIgOiBfcmVmJGN4LFxuICAgIF9yZWYkY3kgPSBfcmVmLmN5LFxuICAgIGN5ID0gX3JlZiRjeSA9PT0gdm9pZCAwID8gaGVpZ2h0IC8gMiA6IF9yZWYkY3ksXG4gICAgX3JlZiRzdGFydEFuZ2xlID0gX3JlZi5zdGFydEFuZ2xlLFxuICAgIHN0YXJ0QW5nbGUgPSBfcmVmJHN0YXJ0QW5nbGUgPT09IHZvaWQgMCA/IDAgOiBfcmVmJHN0YXJ0QW5nbGUsXG4gICAgX3JlZiRlbmRBbmdsZSA9IF9yZWYuZW5kQW5nbGUsXG4gICAgZW5kQW5nbGUgPSBfcmVmJGVuZEFuZ2xlID09PSB2b2lkIDAgPyAzNjAgOiBfcmVmJGVuZEFuZ2xlLFxuICAgIG9uQ2xpY2sgPSBfcmVmLm9uQ2xpY2ssXG4gICAgb25Nb3VzZUVudGVyID0gX3JlZi5vbk1vdXNlRW50ZXIsXG4gICAgb25Nb3VzZUxlYXZlID0gX3JlZi5vbk1vdXNlTGVhdmU7XG4gIHZhciBfdXNlU3RhdGUgPSAoMCwgX3JlYWN0LnVzZVN0YXRlKShmYWxzZSksXG4gICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgaXNUb29sdGlwQWN0aXZlID0gX3VzZVN0YXRlMlswXSxcbiAgICBzZXRJc1Rvb2x0aXBBY3RpdmUgPSBfdXNlU3RhdGUyWzFdO1xuICB2YXIgX3VzZVN0YXRlMyA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKG51bGwpLFxuICAgIF91c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUzLCAyKSxcbiAgICBhY3RpdmVOb2RlID0gX3VzZVN0YXRlNFswXSxcbiAgICBzZXRBY3RpdmVOb2RlID0gX3VzZVN0YXRlNFsxXTtcbiAgdmFyIHJTY2FsZSA9ICgwLCBfZDNTY2FsZS5zY2FsZUxpbmVhcikoWzAsIGRhdGFbZGF0YUtleV1dLCBbMCwgZW5kQW5nbGVdKTtcbiAgdmFyIHRyZWVEZXB0aCA9IGdldE1heERlcHRoT2YoZGF0YSk7XG4gIHZhciB0aGlja25lc3MgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyB0cmVlRGVwdGg7XG4gIHZhciBzZWN0b3JzID0gW107XG4gIHZhciBwb3NpdGlvbnMgPSBuZXcgTWFwKFtdKTtcblxuICAvLyBldmVudCBoYW5kbGVyc1xuICBmdW5jdGlvbiBoYW5kbGVNb3VzZUVudGVyKG5vZGUsIGUpIHtcbiAgICBpZiAob25Nb3VzZUVudGVyKSBvbk1vdXNlRW50ZXIobm9kZSwgZSk7XG4gICAgc2V0QWN0aXZlTm9kZShub2RlKTtcbiAgICBzZXRJc1Rvb2x0aXBBY3RpdmUodHJ1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VMZWF2ZShub2RlLCBlKSB7XG4gICAgaWYgKG9uTW91c2VMZWF2ZSkgb25Nb3VzZUxlYXZlKG5vZGUsIGUpO1xuICAgIHNldEFjdGl2ZU5vZGUobnVsbCk7XG4gICAgc2V0SXNUb29sdGlwQWN0aXZlKGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVDbGljayhub2RlKSB7XG4gICAgaWYgKG9uQ2xpY2spIG9uQ2xpY2sobm9kZSk7XG4gIH1cblxuICAvLyByZWN1cnNpdmVseSBhZGQgbm9kZXMgZm9yIGVhY2ggZGF0YSBwb2ludCBhbmQgaXRzIGNoaWxkcmVuXG4gIGZ1bmN0aW9uIGRyYXdBcmNzKGNoaWxkTm9kZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMsXG4gICAgICBpbm5lclIgPSBvcHRpb25zLmlubmVyUixcbiAgICAgIGluaXRpYWxBbmdsZSA9IG9wdGlvbnMuaW5pdGlhbEFuZ2xlLFxuICAgICAgY2hpbGRDb2xvciA9IG9wdGlvbnMuY2hpbGRDb2xvcjtcbiAgICB2YXIgY3VycmVudEFuZ2xlID0gaW5pdGlhbEFuZ2xlO1xuICAgIGlmICghY2hpbGROb2RlcykgcmV0dXJuOyAvLyBiYXNlIGNhc2U6IG5vIGNoaWxkcmVuIG9mIHRoaXMgbm9kZVxuXG4gICAgY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgX3JlZjIsIF9kJGZpbGw7XG4gICAgICB2YXIgYXJjTGVuZ3RoID0gclNjYWxlKGRbZGF0YUtleV0pO1xuICAgICAgdmFyIHN0YXJ0ID0gY3VycmVudEFuZ2xlO1xuICAgICAgLy8gY29sb3IgcHJpb3JpdHkgLSBpZiB0aGVyZSdzIGEgY29sb3Igb24gdGhlIGluZGl2aWR1YWwgcG9pbnQgdXNlIHRoYXQsIG90aGVyd2lzZSB1c2UgcGFyZW50IGNvbG9yIG9yIGRlZmF1bHRcbiAgICAgIHZhciBmaWxsQ29sb3IgPSAoX3JlZjIgPSAoX2QkZmlsbCA9IGQgPT09IG51bGwgfHwgZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZC5maWxsKSAhPT0gbnVsbCAmJiBfZCRmaWxsICE9PSB2b2lkIDAgPyBfZCRmaWxsIDogY2hpbGRDb2xvcikgIT09IG51bGwgJiYgX3JlZjIgIT09IHZvaWQgMCA/IF9yZWYyIDogZmlsbDtcbiAgICAgIHZhciBfcG9sYXJUb0NhcnRlc2lhbiA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKSgwLCAwLCBpbm5lclIgKyByYWRpdXMgLyAyLCAtKHN0YXJ0ICsgYXJjTGVuZ3RoIC0gYXJjTGVuZ3RoIC8gMikpLFxuICAgICAgICB0ZXh0WCA9IF9wb2xhclRvQ2FydGVzaWFuLngsXG4gICAgICAgIHRleHRZID0gX3BvbGFyVG9DYXJ0ZXNpYW4ueTtcbiAgICAgIGN1cnJlbnRBbmdsZSArPSBhcmNMZW5ndGg7XG4gICAgICBzZWN0b3JzLnB1c2goXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAvLyBUT0RPOiBNaXNzaW5nIGtleSB3YXJuaW5nLiBDYW4gd2UgdXNlIGBrZXk9e2QubmFtZX1gP1xuICAgICAgX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBkLm5hbWUsXG4gICAgICAgIHRhYkluZGV4OiAwXG4gICAgICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9TZWN0b3IuU2VjdG9yLCB7XG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUNsaWNrKGQpO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uIG9uTW91c2VFbnRlcihlKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZU1vdXNlRW50ZXIoZCwgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VMZWF2ZTogZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGUpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlTW91c2VMZWF2ZShkLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDogZmlsbENvbG9yLFxuICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHBhZGRpbmcsXG4gICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0LFxuICAgICAgICBlbmRBbmdsZTogc3RhcnQgKyBhcmNMZW5ndGgsXG4gICAgICAgIGlubmVyUmFkaXVzOiBpbm5lclIsXG4gICAgICAgIG91dGVyUmFkaXVzOiBpbm5lclIgKyByYWRpdXMsXG4gICAgICAgIGN4OiBjeCxcbiAgICAgICAgY3k6IGN5XG4gICAgICB9KSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfVGV4dC5UZXh0LCBfZXh0ZW5kcyh7fSwgdGV4dE9wdGlvbnMsIHtcbiAgICAgICAgYWxpZ25tZW50QmFzZWxpbmU6IFwibWlkZGxlXCIsXG4gICAgICAgIHRleHRBbmNob3I6IFwibWlkZGxlXCIsXG4gICAgICAgIHg6IHRleHRYICsgY3gsXG4gICAgICAgIHk6IGN5IC0gdGV4dFlcbiAgICAgIH0pLCBkW2RhdGFLZXldKSkpO1xuICAgICAgdmFyIF9wb2xhclRvQ2FydGVzaWFuMiA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIGlubmVyUiArIHJhZGl1cyAvIDIsIHN0YXJ0KSxcbiAgICAgICAgdG9vbHRpcFggPSBfcG9sYXJUb0NhcnRlc2lhbjIueCxcbiAgICAgICAgdG9vbHRpcFkgPSBfcG9sYXJUb0NhcnRlc2lhbjIueTtcbiAgICAgIHBvc2l0aW9ucy5zZXQoZC5uYW1lLCB7XG4gICAgICAgIHg6IHRvb2x0aXBYLFxuICAgICAgICB5OiB0b29sdGlwWVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZHJhd0FyY3MoZC5jaGlsZHJlbiwge1xuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgaW5uZXJSOiBpbm5lclIgKyByYWRpdXMgKyByaW5nUGFkZGluZyxcbiAgICAgICAgaW5pdGlhbEFuZ2xlOiBzdGFydCxcbiAgICAgICAgY2hpbGRDb2xvcjogZmlsbENvbG9yXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBkcmF3QXJjcyhkYXRhLmNoaWxkcmVuLCB7XG4gICAgcmFkaXVzOiB0aGlja25lc3MsXG4gICAgaW5uZXJSOiBpbm5lclJhZGl1cyxcbiAgICBpbml0aWFsQW5nbGU6IHN0YXJ0QW5nbGVcbiAgfSk7XG4gIHZhciBsYXllckNsYXNzID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXN1bmJ1cnN0JywgY2xhc3NOYW1lKTtcbiAgZnVuY3Rpb24gcmVuZGVyVG9vbHRpcCgpIHtcbiAgICB2YXIgdG9vbHRpcENvbXBvbmVudCA9ICgwLCBfUmVhY3RVdGlscy5maW5kQ2hpbGRCeVR5cGUpKFtjaGlsZHJlbl0sIF9Ub29sdGlwLlRvb2x0aXApO1xuICAgIGlmICghdG9vbHRpcENvbXBvbmVudCB8fCAhYWN0aXZlTm9kZSkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHZpZXdCb3ggPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KHRvb2x0aXBDb21wb25lbnQsIHtcbiAgICAgIHZpZXdCb3g6IHZpZXdCb3gsXG4gICAgICBjb29yZGluYXRlOiBwb3NpdGlvbnMuZ2V0KGFjdGl2ZU5vZGUubmFtZSksXG4gICAgICBwYXlsb2FkOiBbYWN0aXZlTm9kZV0sXG4gICAgICBhY3RpdmU6IGlzVG9vbHRpcEFjdGl2ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy13cmFwcGVyJywgY2xhc3NOYW1lKSxcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH0sXG4gICAgcm9sZTogXCJyZWdpb25cIlxuICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9TdXJmYWNlLlN1cmZhY2UsIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfSwgY2hpbGRyZW4sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XG4gICAgY2xhc3NOYW1lOiBsYXllckNsYXNzXG4gIH0sIHNlY3RvcnMpKSwgcmVuZGVyVG9vbHRpcCgpKTtcbn07Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU3VuYnVyc3RDaGFydCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9kM1NjYWxlIiwiX2Nsc3giLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX1JlYWN0VXRpbHMiLCJfU3VyZmFjZSIsIl9MYXllciIsIl9TZWN0b3IiLCJfVGV4dCIsIl9Qb2xhclV0aWxzIiwiX1Rvb2x0aXAiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJhcHBseSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIlR5cGVFcnJvciIsImwiLCJmIiwibmV4dCIsImRvbmUiLCJwdXNoIiwiQXJyYXkiLCJpc0FycmF5IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJmcm9tIiwidGVzdCIsIml0ZXIiLCJsZW4iLCJhcnIyIiwiZGVmYXVsdFRleHRQcm9wcyIsImZvbnRXZWlnaHQiLCJwYWludE9yZGVyIiwiZm9udFNpemUiLCJzdHJva2UiLCJmaWxsIiwicG9pbnRlckV2ZW50cyIsImdldE1heERlcHRoT2YiLCJub2RlIiwiY2hpbGRyZW4iLCJjaGlsZERlcHRocyIsIm1hcCIsImQiLCJNYXRoIiwibWF4IiwiX3JlZiIsImNsYXNzTmFtZSIsImRhdGEiLCJ3aWR0aCIsImhlaWdodCIsIl9yZWYkcGFkZGluZyIsInBhZGRpbmciLCJfcmVmJGRhdGFLZXkiLCJkYXRhS2V5IiwiX3JlZiRyaW5nUGFkZGluZyIsInJpbmdQYWRkaW5nIiwiX3JlZiRpbm5lclJhZGl1cyIsImlubmVyUmFkaXVzIiwiX3JlZiRmaWxsIiwiX3JlZiRzdHJva2UiLCJfcmVmJHRleHRPcHRpb25zIiwidGV4dE9wdGlvbnMiLCJfcmVmJG91dGVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJtaW4iLCJfcmVmJGN4IiwiY3giLCJfcmVmJGN5IiwiY3kiLCJfcmVmJHN0YXJ0QW5nbGUiLCJzdGFydEFuZ2xlIiwiX3JlZiRlbmRBbmdsZSIsImVuZEFuZ2xlIiwib25DbGljayIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VMZWF2ZSIsIl91c2VTdGF0ZSIsInVzZVN0YXRlIiwiX3VzZVN0YXRlMiIsImlzVG9vbHRpcEFjdGl2ZSIsInNldElzVG9vbHRpcEFjdGl2ZSIsIl91c2VTdGF0ZTMiLCJfdXNlU3RhdGU0IiwiYWN0aXZlTm9kZSIsInNldEFjdGl2ZU5vZGUiLCJyU2NhbGUiLCJzY2FsZUxpbmVhciIsInRyZWVEZXB0aCIsInRoaWNrbmVzcyIsInNlY3RvcnMiLCJwb3NpdGlvbnMiLCJNYXAiLCJoYW5kbGVNb3VzZUVudGVyIiwiaGFuZGxlTW91c2VMZWF2ZSIsImhhbmRsZUNsaWNrIiwiZHJhd0FyY3MiLCJjaGlsZE5vZGVzIiwib3B0aW9ucyIsInJhZGl1cyIsImlubmVyUiIsImluaXRpYWxBbmdsZSIsImNoaWxkQ29sb3IiLCJjdXJyZW50QW5nbGUiLCJmb3JFYWNoIiwiX3JlZjIiLCJfZCRmaWxsIiwiYXJjTGVuZ3RoIiwic3RhcnQiLCJmaWxsQ29sb3IiLCJfcG9sYXJUb0NhcnRlc2lhbiIsInBvbGFyVG9DYXJ0ZXNpYW4iLCJ0ZXh0WCIsIngiLCJ0ZXh0WSIsInkiLCJjcmVhdGVFbGVtZW50IiwidGFiSW5kZXgiLCJTZWN0b3IiLCJzdHJva2VXaWR0aCIsIlRleHQiLCJhbGlnbm1lbnRCYXNlbGluZSIsInRleHRBbmNob3IiLCJfcG9sYXJUb0NhcnRlc2lhbjIiLCJ0b29sdGlwWCIsInRvb2x0aXBZIiwibGF5ZXJDbGFzcyIsInJlbmRlclRvb2x0aXAiLCJ0b29sdGlwQ29tcG9uZW50IiwiZmluZENoaWxkQnlUeXBlIiwiVG9vbHRpcCIsInZpZXdCb3giLCJjbG9uZUVsZW1lbnQiLCJjb29yZGluYXRlIiwicGF5bG9hZCIsImFjdGl2ZSIsInN0eWxlIiwicG9zaXRpb24iLCJyb2xlIiwiU3VyZmFjZSIsIkxheWVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/chart/SunburstChart.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/chart/Treemap.js":
/*!****************************************************!*\
  !*** ./node_modules/recharts/lib/chart/Treemap.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Treemap = void 0;\nvar _isNaN = _interopRequireDefault(__webpack_require__(/*! lodash/isNaN */ \"lodash/isNaN\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _omit = _interopRequireDefault(__webpack_require__(/*! lodash/omit */ \"lodash/omit\"));\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _Tooltip = __webpack_require__(/*! ../component/Tooltip */ \"./node_modules/recharts/lib/component/Tooltip.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _Surface = __webpack_require__(/*! ../container/Surface */ \"./node_modules/recharts/lib/container/Surface.js\");\nvar _Polygon = __webpack_require__(/*! ../shape/Polygon */ \"./node_modules/recharts/lib/shape/Polygon.js\");\nvar _Rectangle = __webpack_require__(/*! ../shape/Rectangle */ \"./node_modules/recharts/lib/shape/Rectangle.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _Constants = __webpack_require__(/*! ../util/Constants */ \"./node_modules/recharts/lib/util/Constants.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _DOMUtils = __webpack_require__(/*! ../util/DOMUtils */ \"./node_modules/recharts/lib/util/DOMUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"./node_modules/recharts/lib/util/Global.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"width\",\n    \"height\",\n    \"className\",\n    \"style\",\n    \"children\",\n    \"type\"\n];\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview TreemapChart\n */ \nvar NODE_VALUE_KEY = \"value\";\nvar computeNode = function computeNode(_ref) {\n    var depth = _ref.depth, node = _ref.node, index = _ref.index, valueKey = _ref.valueKey;\n    var children = node.children;\n    var childDepth = depth + 1;\n    var computedChildren = children && children.length ? children.map(function(child, i) {\n        return computeNode({\n            depth: childDepth,\n            node: child,\n            index: i,\n            valueKey: valueKey\n        });\n    }) : null;\n    var nodeValue;\n    if (children && children.length) {\n        nodeValue = computedChildren.reduce(function(result, child) {\n            return result + child[NODE_VALUE_KEY];\n        }, 0);\n    } else {\n        // TODO need to verify valueKey\n        nodeValue = (0, _isNaN[\"default\"])(node[valueKey]) || node[valueKey] <= 0 ? 0 : node[valueKey];\n    }\n    return _objectSpread(_objectSpread({}, node), {}, _defineProperty(_defineProperty(_defineProperty({\n        children: computedChildren\n    }, NODE_VALUE_KEY, nodeValue), \"depth\", depth), \"index\", index));\n};\nvar filterRect = function filterRect(node) {\n    return {\n        x: node.x,\n        y: node.y,\n        width: node.width,\n        height: node.height\n    };\n};\n// Compute the area for each child based on value & scale.\nvar getAreaOfChildren = function getAreaOfChildren(children, areaValueRatio) {\n    var ratio = areaValueRatio < 0 ? 0 : areaValueRatio;\n    return children.map(function(child) {\n        var area = child[NODE_VALUE_KEY] * ratio;\n        return _objectSpread(_objectSpread({}, child), {}, {\n            area: (0, _isNaN[\"default\"])(area) || area <= 0 ? 0 : area\n        });\n    });\n};\n// Computes the score for the specified row, as the worst aspect ratio.\nvar getWorstScore = function getWorstScore(row, parentSize, aspectRatio) {\n    var parentArea = parentSize * parentSize;\n    var rowArea = row.area * row.area;\n    var _row$reduce = row.reduce(function(result, child) {\n        return {\n            min: Math.min(result.min, child.area),\n            max: Math.max(result.max, child.area)\n        };\n    }, {\n        min: Infinity,\n        max: 0\n    }), min = _row$reduce.min, max = _row$reduce.max;\n    return rowArea ? Math.max(parentArea * max * aspectRatio / rowArea, rowArea / (parentArea * min * aspectRatio)) : Infinity;\n};\nvar horizontalPosition = function horizontalPosition(row, parentSize, parentRect, isFlush) {\n    var rowHeight = parentSize ? Math.round(row.area / parentSize) : 0;\n    if (isFlush || rowHeight > parentRect.height) {\n        rowHeight = parentRect.height;\n    }\n    var curX = parentRect.x;\n    var child;\n    for(var i = 0, len = row.length; i < len; i++){\n        child = row[i];\n        child.x = curX;\n        child.y = parentRect.y;\n        child.height = rowHeight;\n        child.width = Math.min(rowHeight ? Math.round(child.area / rowHeight) : 0, parentRect.x + parentRect.width - curX);\n        curX += child.width;\n    }\n    // add the remain x to the last one of row\n    child.width += parentRect.x + parentRect.width - curX;\n    return _objectSpread(_objectSpread({}, parentRect), {}, {\n        y: parentRect.y + rowHeight,\n        height: parentRect.height - rowHeight\n    });\n};\nvar verticalPosition = function verticalPosition(row, parentSize, parentRect, isFlush) {\n    var rowWidth = parentSize ? Math.round(row.area / parentSize) : 0;\n    if (isFlush || rowWidth > parentRect.width) {\n        rowWidth = parentRect.width;\n    }\n    var curY = parentRect.y;\n    var child;\n    for(var i = 0, len = row.length; i < len; i++){\n        child = row[i];\n        child.x = parentRect.x;\n        child.y = curY;\n        child.width = rowWidth;\n        child.height = Math.min(rowWidth ? Math.round(child.area / rowWidth) : 0, parentRect.y + parentRect.height - curY);\n        curY += child.height;\n    }\n    if (child) {\n        child.height += parentRect.y + parentRect.height - curY;\n    }\n    return _objectSpread(_objectSpread({}, parentRect), {}, {\n        x: parentRect.x + rowWidth,\n        width: parentRect.width - rowWidth\n    });\n};\nvar position = function position(row, parentSize, parentRect, isFlush) {\n    if (parentSize === parentRect.width) {\n        return horizontalPosition(row, parentSize, parentRect, isFlush);\n    }\n    return verticalPosition(row, parentSize, parentRect, isFlush);\n};\n// Recursively arranges the specified node's children into squarified rows.\nvar squarify = function squarify(node, aspectRatio) {\n    var children = node.children;\n    if (children && children.length) {\n        var rect = filterRect(node);\n        // maybe a bug\n        var row = [];\n        var best = Infinity; // the best row score so far\n        var child, score; // the current row score\n        var size = Math.min(rect.width, rect.height); // initial orientation\n        var scaleChildren = getAreaOfChildren(children, rect.width * rect.height / node[NODE_VALUE_KEY]);\n        var tempChildren = scaleChildren.slice();\n        row.area = 0;\n        while(tempChildren.length > 0){\n            // row first\n            // eslint-disable-next-line prefer-destructuring\n            row.push(child = tempChildren[0]);\n            row.area += child.area;\n            score = getWorstScore(row, size, aspectRatio);\n            if (score <= best) {\n                // continue with this orientation\n                tempChildren.shift();\n                best = score;\n            } else {\n                // abort, and try a different orientation\n                row.area -= row.pop().area;\n                rect = position(row, size, rect, false);\n                size = Math.min(rect.width, rect.height);\n                row.length = row.area = 0;\n                best = Infinity;\n            }\n        }\n        if (row.length) {\n            rect = position(row, size, rect, true);\n            row.length = row.area = 0;\n        }\n        return _objectSpread(_objectSpread({}, node), {}, {\n            children: scaleChildren.map(function(c) {\n                return squarify(c, aspectRatio);\n            })\n        });\n    }\n    return node;\n};\nvar defaultState = {\n    isTooltipActive: false,\n    isAnimationFinished: false,\n    activeNode: null,\n    formatRoot: null,\n    currentRoot: null,\n    nestIndex: []\n};\nvar Treemap = exports.Treemap = /*#__PURE__*/ function(_PureComponent) {\n    function Treemap() {\n        var _this;\n        _classCallCheck(this, Treemap);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Treemap, [].concat(args));\n        _defineProperty(_this, \"state\", _objectSpread({}, defaultState));\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            var onAnimationEnd = _this.props.onAnimationEnd;\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationEnd)) {\n                onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            var onAnimationStart = _this.props.onAnimationStart;\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationStart)) {\n                onAnimationStart();\n            }\n        });\n        return _this;\n    }\n    _inherits(Treemap, _PureComponent);\n    return _createClass(Treemap, [\n        {\n            key: \"handleMouseEnter\",\n            value: function handleMouseEnter(node, e) {\n                e.persist();\n                var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, children = _this$props.children;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (tooltipItem) {\n                    this.setState({\n                        isTooltipActive: true,\n                        activeNode: node\n                    }, function() {\n                        if (onMouseEnter) {\n                            onMouseEnter(node, e);\n                        }\n                    });\n                } else if (onMouseEnter) {\n                    onMouseEnter(node, e);\n                }\n            }\n        },\n        {\n            key: \"handleMouseLeave\",\n            value: function handleMouseLeave(node, e) {\n                e.persist();\n                var _this$props2 = this.props, onMouseLeave = _this$props2.onMouseLeave, children = _this$props2.children;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (tooltipItem) {\n                    this.setState({\n                        isTooltipActive: false,\n                        activeNode: null\n                    }, function() {\n                        if (onMouseLeave) {\n                            onMouseLeave(node, e);\n                        }\n                    });\n                } else if (onMouseLeave) {\n                    onMouseLeave(node, e);\n                }\n            }\n        },\n        {\n            key: \"handleClick\",\n            value: function handleClick(node) {\n                var _this$props3 = this.props, onClick = _this$props3.onClick, type = _this$props3.type;\n                if (type === \"nest\" && node.children) {\n                    var _this$props4 = this.props, width = _this$props4.width, height = _this$props4.height, dataKey = _this$props4.dataKey, aspectRatio = _this$props4.aspectRatio;\n                    var root = computeNode({\n                        depth: 0,\n                        node: _objectSpread(_objectSpread({}, node), {}, {\n                            x: 0,\n                            y: 0,\n                            width: width,\n                            height: height\n                        }),\n                        index: 0,\n                        valueKey: dataKey\n                    });\n                    var formatRoot = squarify(root, aspectRatio);\n                    var nestIndex = this.state.nestIndex;\n                    nestIndex.push(node);\n                    this.setState({\n                        formatRoot: formatRoot,\n                        currentRoot: root,\n                        nestIndex: nestIndex\n                    });\n                }\n                if (onClick) {\n                    onClick(node);\n                }\n            }\n        },\n        {\n            key: \"handleNestIndex\",\n            value: function handleNestIndex(node, i) {\n                var nestIndex = this.state.nestIndex;\n                var _this$props5 = this.props, width = _this$props5.width, height = _this$props5.height, dataKey = _this$props5.dataKey, aspectRatio = _this$props5.aspectRatio;\n                var root = computeNode({\n                    depth: 0,\n                    node: _objectSpread(_objectSpread({}, node), {}, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    }),\n                    index: 0,\n                    valueKey: dataKey\n                });\n                var formatRoot = squarify(root, aspectRatio);\n                nestIndex = nestIndex.slice(0, i + 1);\n                this.setState({\n                    formatRoot: formatRoot,\n                    currentRoot: node,\n                    nestIndex: nestIndex\n                });\n            }\n        },\n        {\n            key: \"renderItem\",\n            value: function renderItem(content, nodeProps, isLeaf) {\n                var _this2 = this;\n                var _this$props6 = this.props, isAnimationActive = _this$props6.isAnimationActive, animationBegin = _this$props6.animationBegin, animationDuration = _this$props6.animationDuration, animationEasing = _this$props6.animationEasing, isUpdateAnimationActive = _this$props6.isUpdateAnimationActive, type = _this$props6.type, animationId = _this$props6.animationId, colorPanel = _this$props6.colorPanel;\n                var isAnimationFinished = this.state.isAnimationFinished;\n                var width = nodeProps.width, height = nodeProps.height, x = nodeProps.x, y = nodeProps.y, depth = nodeProps.depth;\n                var translateX = parseInt(\"\".concat((Math.random() * 2 - 1) * width), 10);\n                var event = {};\n                if (isLeaf || type === \"nest\") {\n                    event = {\n                        onMouseEnter: this.handleMouseEnter.bind(this, nodeProps),\n                        onMouseLeave: this.handleMouseLeave.bind(this, nodeProps),\n                        onClick: this.handleClick.bind(this, nodeProps)\n                    };\n                }\n                if (!isAnimationActive) {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, event, this.constructor.renderContentItem(content, _objectSpread(_objectSpread({}, nodeProps), {}, {\n                        isAnimationActive: false,\n                        isUpdateAnimationActive: false,\n                        width: width,\n                        height: height,\n                        x: x,\n                        y: y\n                    }), type, colorPanel));\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    key: \"treemap-\".concat(animationId),\n                    from: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    to: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    onAnimationStart: this.handleAnimationStart,\n                    onAnimationEnd: this.handleAnimationEnd\n                }, function(_ref2) {\n                    var currX = _ref2.x, currY = _ref2.y, currWidth = _ref2.width, currHeight = _ref2.height;\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                        from: \"translate(\".concat(translateX, \"px, \").concat(translateX, \"px)\"),\n                        to: \"translate(0, 0)\",\n                        attributeName: \"transform\",\n                        begin: animationBegin,\n                        easing: animationEasing,\n                        isActive: isAnimationActive,\n                        duration: animationDuration\n                    }, /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, event, function() {\n                        // when animation Duration , only render depth=1 nodes\n                        if (depth > 2 && !isAnimationFinished) {\n                            return null;\n                        }\n                        return _this2.constructor.renderContentItem(content, _objectSpread(_objectSpread({}, nodeProps), {}, {\n                            isAnimationActive: isAnimationActive,\n                            isUpdateAnimationActive: !isUpdateAnimationActive,\n                            width: currWidth,\n                            height: currHeight,\n                            x: currX,\n                            y: currY\n                        }), type, colorPanel);\n                    }()));\n                });\n            }\n        },\n        {\n            key: \"renderNode\",\n            value: function renderNode(root, node) {\n                var _this3 = this;\n                var _this$props7 = this.props, content = _this$props7.content, type = _this$props7.type;\n                var nodeProps = _objectSpread(_objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(this.props, false)), node), {}, {\n                    root: root\n                });\n                var isLeaf = !node.children || !node.children.length;\n                var currentRoot = this.state.currentRoot;\n                var isCurrentRootChild = (currentRoot.children || []).filter(function(item) {\n                    return item.depth === node.depth && item.name === node.name;\n                });\n                if (!isCurrentRootChild.length && root.depth && type === \"nest\") {\n                    return null;\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    key: \"recharts-treemap-node-\".concat(nodeProps.x, \"-\").concat(nodeProps.y, \"-\").concat(nodeProps.name),\n                    className: \"recharts-treemap-depth-\".concat(node.depth)\n                }, this.renderItem(content, nodeProps, isLeaf), node.children && node.children.length ? node.children.map(function(child) {\n                    return _this3.renderNode(node, child);\n                }) : null);\n            }\n        },\n        {\n            key: \"renderAllNodes\",\n            value: function renderAllNodes() {\n                var formatRoot = this.state.formatRoot;\n                if (!formatRoot) {\n                    return null;\n                }\n                return this.renderNode(formatRoot, formatRoot);\n            }\n        },\n        {\n            key: \"renderTooltip\",\n            value: function renderTooltip() {\n                var _this$props8 = this.props, children = _this$props8.children, nameKey = _this$props8.nameKey;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (!tooltipItem) {\n                    return null;\n                }\n                var _this$props9 = this.props, width = _this$props9.width, height = _this$props9.height;\n                var _this$state = this.state, isTooltipActive = _this$state.isTooltipActive, activeNode = _this$state.activeNode;\n                var viewBox = {\n                    x: 0,\n                    y: 0,\n                    width: width,\n                    height: height\n                };\n                var coordinate = activeNode ? {\n                    x: activeNode.x + activeNode.width / 2,\n                    y: activeNode.y + activeNode.height / 2\n                } : null;\n                var payload = isTooltipActive && activeNode ? [\n                    {\n                        payload: activeNode,\n                        name: (0, _ChartUtils.getValueByDataKey)(activeNode, nameKey, \"\"),\n                        value: (0, _ChartUtils.getValueByDataKey)(activeNode, NODE_VALUE_KEY)\n                    }\n                ] : [];\n                return /*#__PURE__*/ _react[\"default\"].cloneElement(tooltipItem, {\n                    viewBox: viewBox,\n                    active: isTooltipActive,\n                    coordinate: coordinate,\n                    label: \"\",\n                    payload: payload\n                });\n            }\n        },\n        {\n            key: \"renderNestIndex\",\n            value: function renderNestIndex() {\n                var _this4 = this;\n                var _this$props10 = this.props, nameKey = _this$props10.nameKey, nestIndexContent = _this$props10.nestIndexContent;\n                var nestIndex = this.state.nestIndex;\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                    className: \"recharts-treemap-nest-index-wrapper\",\n                    style: {\n                        marginTop: \"8px\",\n                        textAlign: \"center\"\n                    }\n                }, nestIndex.map(function(item, i) {\n                    // TODO need to verify nameKey type\n                    var name = (0, _get[\"default\"])(item, nameKey, \"root\");\n                    var content = null;\n                    if (/*#__PURE__*/ _react[\"default\"].isValidElement(nestIndexContent)) {\n                        content = /*#__PURE__*/ _react[\"default\"].cloneElement(nestIndexContent, item, i);\n                    }\n                    if ((0, _isFunction[\"default\"])(nestIndexContent)) {\n                        content = nestIndexContent(item, i);\n                    } else {\n                        content = name;\n                    }\n                    return(/*#__PURE__*/ // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions\n                    _react[\"default\"].createElement(\"div\", {\n                        onClick: _this4.handleNestIndex.bind(_this4, item, i),\n                        key: \"nest-index-\".concat((0, _DataUtils.uniqueId)()),\n                        className: \"recharts-treemap-nest-index-box\",\n                        style: {\n                            cursor: \"pointer\",\n                            display: \"inline-block\",\n                            padding: \"0 7px\",\n                            background: \"#000\",\n                            color: \"#fff\",\n                            marginRight: \"3px\"\n                        }\n                    }, content));\n                }));\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                if (!(0, _ReactUtils.validateWidthHeight)(this)) {\n                    return null;\n                }\n                var _this$props11 = this.props, width = _this$props11.width, height = _this$props11.height, className = _this$props11.className, style = _this$props11.style, children = _this$props11.children, type = _this$props11.type, others = _objectWithoutProperties(_this$props11, _excluded);\n                var attrs = (0, _ReactUtils.filterProps)(others, false);\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                    className: (0, _clsx[\"default\"])(\"recharts-wrapper\", className),\n                    style: _objectSpread(_objectSpread({}, style), {}, {\n                        position: \"relative\",\n                        cursor: \"default\",\n                        width: width,\n                        height: height\n                    }),\n                    role: \"region\"\n                }, /*#__PURE__*/ _react[\"default\"].createElement(_Surface.Surface, _extends({}, attrs, {\n                    width: width,\n                    height: type === \"nest\" ? height - 30 : height\n                }), this.renderAllNodes(), (0, _ReactUtils.filterSvgElements)(children)), this.renderTooltip(), type === \"nest\" && this.renderNestIndex());\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.data !== prevState.prevData || nextProps.type !== prevState.prevType || nextProps.width !== prevState.prevWidth || nextProps.height !== prevState.prevHeight || nextProps.dataKey !== prevState.prevDataKey || nextProps.aspectRatio !== prevState.prevAspectRatio) {\n                    var root = computeNode({\n                        depth: 0,\n                        node: {\n                            children: nextProps.data,\n                            x: 0,\n                            y: 0,\n                            width: nextProps.width,\n                            height: nextProps.height\n                        },\n                        index: 0,\n                        valueKey: nextProps.dataKey\n                    });\n                    var formatRoot = squarify(root, nextProps.aspectRatio);\n                    return _objectSpread(_objectSpread({}, prevState), {}, {\n                        formatRoot: formatRoot,\n                        currentRoot: root,\n                        nestIndex: [\n                            root\n                        ],\n                        prevAspectRatio: nextProps.aspectRatio,\n                        prevData: nextProps.data,\n                        prevWidth: nextProps.width,\n                        prevHeight: nextProps.height,\n                        prevDataKey: nextProps.dataKey,\n                        prevType: nextProps.type\n                    });\n                }\n                return null;\n            }\n        },\n        {\n            key: \"renderContentItem\",\n            value: function renderContentItem(content, nodeProps, type, colorPanel) {\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(content)) {\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(content, nodeProps);\n                }\n                if ((0, _isFunction[\"default\"])(content)) {\n                    return content(nodeProps);\n                }\n                // optimize default shape\n                var x = nodeProps.x, y = nodeProps.y, width = nodeProps.width, height = nodeProps.height, index = nodeProps.index;\n                var arrow = null;\n                if (width > 10 && height > 10 && nodeProps.children && type === \"nest\") {\n                    arrow = /*#__PURE__*/ _react[\"default\"].createElement(_Polygon.Polygon, {\n                        points: [\n                            {\n                                x: x + 2,\n                                y: y + height / 2\n                            },\n                            {\n                                x: x + 6,\n                                y: y + height / 2 + 3\n                            },\n                            {\n                                x: x + 2,\n                                y: y + height / 2 + 6\n                            }\n                        ]\n                    });\n                }\n                var text = null;\n                var nameSize = (0, _DOMUtils.getStringSize)(nodeProps.name);\n                if (width > 20 && height > 20 && nameSize.width < width && nameSize.height < height) {\n                    text = /*#__PURE__*/ _react[\"default\"].createElement(\"text\", {\n                        x: x + 8,\n                        y: y + height / 2 + 7,\n                        fontSize: 14\n                    }, nodeProps.name);\n                }\n                var colors = colorPanel || _Constants.COLOR_PANEL;\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", null, /*#__PURE__*/ _react[\"default\"].createElement(_Rectangle.Rectangle, _extends({\n                    fill: nodeProps.depth < 2 ? colors[index % colors.length] : \"rgba(255,255,255,0)\",\n                    stroke: \"#fff\"\n                }, (0, _omit[\"default\"])(nodeProps, \"children\"), {\n                    role: \"img\"\n                })), arrow, text);\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(Treemap, \"displayName\", \"Treemap\");\n_defineProperty(Treemap, \"defaultProps\", {\n    aspectRatio: 0.5 * (1 + Math.sqrt(5)),\n    dataKey: \"value\",\n    type: \"flat\",\n    isAnimationActive: !_Global.Global.isSsr,\n    isUpdateAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 0,\n    animationDuration: 1500,\n    animationEasing: \"linear\"\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L1RyZWVtYXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCLElBQUlHLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsa0NBQWM7QUFDMUQsSUFBSUMsY0FBY0YsdUJBQXVCQyxtQkFBT0EsQ0FBQyw0Q0FBbUI7QUFDcEUsSUFBSUUsUUFBUUgsdUJBQXVCQyxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUN4RCxJQUFJRyxPQUFPSix1QkFBdUJDLG1CQUFPQSxDQUFDLDhCQUFZO0FBQ3RELElBQUlJLFFBQVFMLHVCQUF1QkMsbUJBQU9BLENBQUMsa0JBQU07QUFDakQsSUFBSUssU0FBU0Msd0JBQXdCTixtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJTyxlQUFlUix1QkFBdUJDLG1CQUFPQSxDQUFDLGtDQUFjO0FBQ2hFLElBQUlRLFdBQVdSLG1CQUFPQSxDQUFDLDhFQUFzQjtBQUM3QyxJQUFJUyxTQUFTVCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDekMsSUFBSVUsV0FBV1YsbUJBQU9BLENBQUMsOEVBQXNCO0FBQzdDLElBQUlXLFdBQVdYLG1CQUFPQSxDQUFDLHNFQUFrQjtBQUN6QyxJQUFJWSxhQUFhWixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDN0MsSUFBSWEsY0FBY2IsbUJBQU9BLENBQUMsMEVBQW9CO0FBQzlDLElBQUljLGFBQWFkLG1CQUFPQSxDQUFDLHdFQUFtQjtBQUM1QyxJQUFJZSxhQUFhZixtQkFBT0EsQ0FBQyx3RUFBbUI7QUFDNUMsSUFBSWdCLFlBQVloQixtQkFBT0EsQ0FBQyxzRUFBa0I7QUFDMUMsSUFBSWlCLFVBQVVqQixtQkFBT0EsQ0FBQyxrRUFBZ0I7QUFDdEMsSUFBSWtCLGNBQWNsQixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSW1CLFlBQVk7SUFBQztJQUFTO0lBQVU7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VSxFQUFFd00sV0FBVyxhQUFhO29CQUMvQ3lFLE1BQU07Z0JBQ1IsS0FBS2EsT0FBT0c7WUFDZDtRQUNGO0tBQUU7QUFDSixFQUFFOVIsT0FBT3VTLGFBQWE7QUFDdEJ6TSxnQkFBZ0J0RyxTQUFTLGVBQWU7QUFDeENzRyxnQkFBZ0J0RyxTQUFTLGdCQUFnQjtJQUN2Q3dJLGFBQWEsTUFBTyxLQUFJSyxLQUFLbUssSUFBSSxDQUFDLEVBQUM7SUFDbkMxRyxTQUFTO0lBQ1RGLE1BQU07SUFDTmEsbUJBQW1CLENBQUM3TCxRQUFRNlIsTUFBTSxDQUFDQyxLQUFLO0lBQ3hDN0YseUJBQXlCLENBQUNqTSxRQUFRNlIsTUFBTSxDQUFDQyxLQUFLO0lBQzlDaEcsZ0JBQWdCO0lBQ2hCQyxtQkFBbUI7SUFDbkJDLGlCQUFpQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY2hhcnQvVHJlZW1hcC5qcz9iZjA2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5UcmVlbWFwID0gdm9pZCAwO1xudmFyIF9pc05hTiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc05hTlwiKSk7XG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XG52YXIgX29taXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvb21pdFwiKSk7XG52YXIgX2dldCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9nZXRcIikpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcmVhY3RTbW9vdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1zbW9vdGhcIikpO1xudmFyIF9Ub29sdGlwID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9Ub29sdGlwXCIpO1xudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XG52YXIgX1N1cmZhY2UgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL1N1cmZhY2VcIik7XG52YXIgX1BvbHlnb24gPSByZXF1aXJlKFwiLi4vc2hhcGUvUG9seWdvblwiKTtcbnZhciBfUmVjdGFuZ2xlID0gcmVxdWlyZShcIi4uL3NoYXBlL1JlY3RhbmdsZVwiKTtcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XG52YXIgX0NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi91dGlsL0NvbnN0YW50c1wiKTtcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RPTVV0aWxzXCIpO1xudmFyIF9HbG9iYWwgPSByZXF1aXJlKFwiLi4vdXRpbC9HbG9iYWxcIik7XG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xudmFyIF9leGNsdWRlZCA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwiY2xhc3NOYW1lXCIsIFwic3R5bGVcIiwgXCJjaGlsZHJlblwiLCBcInR5cGVcIl07XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxuICogQGZpbGVPdmVydmlldyBUcmVlbWFwQ2hhcnRcbiAqL1xudmFyIE5PREVfVkFMVUVfS0VZID0gJ3ZhbHVlJztcbnZhciBjb21wdXRlTm9kZSA9IGZ1bmN0aW9uIGNvbXB1dGVOb2RlKF9yZWYpIHtcbiAgdmFyIGRlcHRoID0gX3JlZi5kZXB0aCxcbiAgICBub2RlID0gX3JlZi5ub2RlLFxuICAgIGluZGV4ID0gX3JlZi5pbmRleCxcbiAgICB2YWx1ZUtleSA9IF9yZWYudmFsdWVLZXk7XG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gIHZhciBjaGlsZERlcHRoID0gZGVwdGggKyAxO1xuICB2YXIgY29tcHV0ZWRDaGlsZHJlbiA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICByZXR1cm4gY29tcHV0ZU5vZGUoe1xuICAgICAgZGVwdGg6IGNoaWxkRGVwdGgsXG4gICAgICBub2RlOiBjaGlsZCxcbiAgICAgIGluZGV4OiBpLFxuICAgICAgdmFsdWVLZXk6IHZhbHVlS2V5XG4gICAgfSk7XG4gIH0pIDogbnVsbDtcbiAgdmFyIG5vZGVWYWx1ZTtcbiAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIG5vZGVWYWx1ZSA9IGNvbXB1dGVkQ2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGNoaWxkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgY2hpbGRbTk9ERV9WQUxVRV9LRVldO1xuICAgIH0sIDApO1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8gbmVlZCB0byB2ZXJpZnkgdmFsdWVLZXlcbiAgICBub2RlVmFsdWUgPSAoMCwgX2lzTmFOW1wiZGVmYXVsdFwiXSkobm9kZVt2YWx1ZUtleV0pIHx8IG5vZGVbdmFsdWVLZXldIDw9IDAgPyAwIDogbm9kZVt2YWx1ZUtleV07XG4gIH1cbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbm9kZSksIHt9LCBfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eSh7XG4gICAgY2hpbGRyZW46IGNvbXB1dGVkQ2hpbGRyZW5cbiAgfSwgTk9ERV9WQUxVRV9LRVksIG5vZGVWYWx1ZSksIFwiZGVwdGhcIiwgZGVwdGgpLCBcImluZGV4XCIsIGluZGV4KSk7XG59O1xudmFyIGZpbHRlclJlY3QgPSBmdW5jdGlvbiBmaWx0ZXJSZWN0KG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBub2RlLngsXG4gICAgeTogbm9kZS55LFxuICAgIHdpZHRoOiBub2RlLndpZHRoLFxuICAgIGhlaWdodDogbm9kZS5oZWlnaHRcbiAgfTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIGFyZWEgZm9yIGVhY2ggY2hpbGQgYmFzZWQgb24gdmFsdWUgJiBzY2FsZS5cbnZhciBnZXRBcmVhT2ZDaGlsZHJlbiA9IGZ1bmN0aW9uIGdldEFyZWFPZkNoaWxkcmVuKGNoaWxkcmVuLCBhcmVhVmFsdWVSYXRpbykge1xuICB2YXIgcmF0aW8gPSBhcmVhVmFsdWVSYXRpbyA8IDAgPyAwIDogYXJlYVZhbHVlUmF0aW87XG4gIHJldHVybiBjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdmFyIGFyZWEgPSBjaGlsZFtOT0RFX1ZBTFVFX0tFWV0gKiByYXRpbztcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjaGlsZCksIHt9LCB7XG4gICAgICBhcmVhOiAoMCwgX2lzTmFOW1wiZGVmYXVsdFwiXSkoYXJlYSkgfHwgYXJlYSA8PSAwID8gMCA6IGFyZWFcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vLyBDb21wdXRlcyB0aGUgc2NvcmUgZm9yIHRoZSBzcGVjaWZpZWQgcm93LCBhcyB0aGUgd29yc3QgYXNwZWN0IHJhdGlvLlxudmFyIGdldFdvcnN0U2NvcmUgPSBmdW5jdGlvbiBnZXRXb3JzdFNjb3JlKHJvdywgcGFyZW50U2l6ZSwgYXNwZWN0UmF0aW8pIHtcbiAgdmFyIHBhcmVudEFyZWEgPSBwYXJlbnRTaXplICogcGFyZW50U2l6ZTtcbiAgdmFyIHJvd0FyZWEgPSByb3cuYXJlYSAqIHJvdy5hcmVhO1xuICB2YXIgX3JvdyRyZWR1Y2UgPSByb3cucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGNoaWxkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW46IE1hdGgubWluKHJlc3VsdC5taW4sIGNoaWxkLmFyZWEpLFxuICAgICAgICBtYXg6IE1hdGgubWF4KHJlc3VsdC5tYXgsIGNoaWxkLmFyZWEpXG4gICAgICB9O1xuICAgIH0sIHtcbiAgICAgIG1pbjogSW5maW5pdHksXG4gICAgICBtYXg6IDBcbiAgICB9KSxcbiAgICBtaW4gPSBfcm93JHJlZHVjZS5taW4sXG4gICAgbWF4ID0gX3JvdyRyZWR1Y2UubWF4O1xuICByZXR1cm4gcm93QXJlYSA/IE1hdGgubWF4KHBhcmVudEFyZWEgKiBtYXggKiBhc3BlY3RSYXRpbyAvIHJvd0FyZWEsIHJvd0FyZWEgLyAocGFyZW50QXJlYSAqIG1pbiAqIGFzcGVjdFJhdGlvKSkgOiBJbmZpbml0eTtcbn07XG52YXIgaG9yaXpvbnRhbFBvc2l0aW9uID0gZnVuY3Rpb24gaG9yaXpvbnRhbFBvc2l0aW9uKHJvdywgcGFyZW50U2l6ZSwgcGFyZW50UmVjdCwgaXNGbHVzaCkge1xuICB2YXIgcm93SGVpZ2h0ID0gcGFyZW50U2l6ZSA/IE1hdGgucm91bmQocm93LmFyZWEgLyBwYXJlbnRTaXplKSA6IDA7XG4gIGlmIChpc0ZsdXNoIHx8IHJvd0hlaWdodCA+IHBhcmVudFJlY3QuaGVpZ2h0KSB7XG4gICAgcm93SGVpZ2h0ID0gcGFyZW50UmVjdC5oZWlnaHQ7XG4gIH1cbiAgdmFyIGN1clggPSBwYXJlbnRSZWN0Lng7XG4gIHZhciBjaGlsZDtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvdy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNoaWxkID0gcm93W2ldO1xuICAgIGNoaWxkLnggPSBjdXJYO1xuICAgIGNoaWxkLnkgPSBwYXJlbnRSZWN0Lnk7XG4gICAgY2hpbGQuaGVpZ2h0ID0gcm93SGVpZ2h0O1xuICAgIGNoaWxkLndpZHRoID0gTWF0aC5taW4ocm93SGVpZ2h0ID8gTWF0aC5yb3VuZChjaGlsZC5hcmVhIC8gcm93SGVpZ2h0KSA6IDAsIHBhcmVudFJlY3QueCArIHBhcmVudFJlY3Qud2lkdGggLSBjdXJYKTtcbiAgICBjdXJYICs9IGNoaWxkLndpZHRoO1xuICB9XG4gIC8vIGFkZCB0aGUgcmVtYWluIHggdG8gdGhlIGxhc3Qgb25lIG9mIHJvd1xuICBjaGlsZC53aWR0aCArPSBwYXJlbnRSZWN0LnggKyBwYXJlbnRSZWN0LndpZHRoIC0gY3VyWDtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGFyZW50UmVjdCksIHt9LCB7XG4gICAgeTogcGFyZW50UmVjdC55ICsgcm93SGVpZ2h0LFxuICAgIGhlaWdodDogcGFyZW50UmVjdC5oZWlnaHQgLSByb3dIZWlnaHRcbiAgfSk7XG59O1xudmFyIHZlcnRpY2FsUG9zaXRpb24gPSBmdW5jdGlvbiB2ZXJ0aWNhbFBvc2l0aW9uKHJvdywgcGFyZW50U2l6ZSwgcGFyZW50UmVjdCwgaXNGbHVzaCkge1xuICB2YXIgcm93V2lkdGggPSBwYXJlbnRTaXplID8gTWF0aC5yb3VuZChyb3cuYXJlYSAvIHBhcmVudFNpemUpIDogMDtcbiAgaWYgKGlzRmx1c2ggfHwgcm93V2lkdGggPiBwYXJlbnRSZWN0LndpZHRoKSB7XG4gICAgcm93V2lkdGggPSBwYXJlbnRSZWN0LndpZHRoO1xuICB9XG4gIHZhciBjdXJZID0gcGFyZW50UmVjdC55O1xuICB2YXIgY2hpbGQ7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb3cubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaGlsZCA9IHJvd1tpXTtcbiAgICBjaGlsZC54ID0gcGFyZW50UmVjdC54O1xuICAgIGNoaWxkLnkgPSBjdXJZO1xuICAgIGNoaWxkLndpZHRoID0gcm93V2lkdGg7XG4gICAgY2hpbGQuaGVpZ2h0ID0gTWF0aC5taW4ocm93V2lkdGggPyBNYXRoLnJvdW5kKGNoaWxkLmFyZWEgLyByb3dXaWR0aCkgOiAwLCBwYXJlbnRSZWN0LnkgKyBwYXJlbnRSZWN0LmhlaWdodCAtIGN1clkpO1xuICAgIGN1clkgKz0gY2hpbGQuaGVpZ2h0O1xuICB9XG4gIGlmIChjaGlsZCkge1xuICAgIGNoaWxkLmhlaWdodCArPSBwYXJlbnRSZWN0LnkgKyBwYXJlbnRSZWN0LmhlaWdodCAtIGN1clk7XG4gIH1cbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGFyZW50UmVjdCksIHt9LCB7XG4gICAgeDogcGFyZW50UmVjdC54ICsgcm93V2lkdGgsXG4gICAgd2lkdGg6IHBhcmVudFJlY3Qud2lkdGggLSByb3dXaWR0aFxuICB9KTtcbn07XG52YXIgcG9zaXRpb24gPSBmdW5jdGlvbiBwb3NpdGlvbihyb3csIHBhcmVudFNpemUsIHBhcmVudFJlY3QsIGlzRmx1c2gpIHtcbiAgaWYgKHBhcmVudFNpemUgPT09IHBhcmVudFJlY3Qud2lkdGgpIHtcbiAgICByZXR1cm4gaG9yaXpvbnRhbFBvc2l0aW9uKHJvdywgcGFyZW50U2l6ZSwgcGFyZW50UmVjdCwgaXNGbHVzaCk7XG4gIH1cbiAgcmV0dXJuIHZlcnRpY2FsUG9zaXRpb24ocm93LCBwYXJlbnRTaXplLCBwYXJlbnRSZWN0LCBpc0ZsdXNoKTtcbn07XG5cbi8vIFJlY3Vyc2l2ZWx5IGFycmFuZ2VzIHRoZSBzcGVjaWZpZWQgbm9kZSdzIGNoaWxkcmVuIGludG8gc3F1YXJpZmllZCByb3dzLlxudmFyIHNxdWFyaWZ5ID0gZnVuY3Rpb24gc3F1YXJpZnkobm9kZSwgYXNwZWN0UmF0aW8pIHtcbiAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciByZWN0ID0gZmlsdGVyUmVjdChub2RlKTtcbiAgICAvLyBtYXliZSBhIGJ1Z1xuICAgIHZhciByb3cgPSBbXTtcbiAgICB2YXIgYmVzdCA9IEluZmluaXR5OyAvLyB0aGUgYmVzdCByb3cgc2NvcmUgc28gZmFyXG4gICAgdmFyIGNoaWxkLCBzY29yZTsgLy8gdGhlIGN1cnJlbnQgcm93IHNjb3JlXG4gICAgdmFyIHNpemUgPSBNYXRoLm1pbihyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7IC8vIGluaXRpYWwgb3JpZW50YXRpb25cbiAgICB2YXIgc2NhbGVDaGlsZHJlbiA9IGdldEFyZWFPZkNoaWxkcmVuKGNoaWxkcmVuLCByZWN0LndpZHRoICogcmVjdC5oZWlnaHQgLyBub2RlW05PREVfVkFMVUVfS0VZXSk7XG4gICAgdmFyIHRlbXBDaGlsZHJlbiA9IHNjYWxlQ2hpbGRyZW4uc2xpY2UoKTtcbiAgICByb3cuYXJlYSA9IDA7XG4gICAgd2hpbGUgKHRlbXBDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAvLyByb3cgZmlyc3RcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgcm93LnB1c2goY2hpbGQgPSB0ZW1wQ2hpbGRyZW5bMF0pO1xuICAgICAgcm93LmFyZWEgKz0gY2hpbGQuYXJlYTtcbiAgICAgIHNjb3JlID0gZ2V0V29yc3RTY29yZShyb3csIHNpemUsIGFzcGVjdFJhdGlvKTtcbiAgICAgIGlmIChzY29yZSA8PSBiZXN0KSB7XG4gICAgICAgIC8vIGNvbnRpbnVlIHdpdGggdGhpcyBvcmllbnRhdGlvblxuICAgICAgICB0ZW1wQ2hpbGRyZW4uc2hpZnQoKTtcbiAgICAgICAgYmVzdCA9IHNjb3JlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWJvcnQsIGFuZCB0cnkgYSBkaWZmZXJlbnQgb3JpZW50YXRpb25cbiAgICAgICAgcm93LmFyZWEgLT0gcm93LnBvcCgpLmFyZWE7XG4gICAgICAgIHJlY3QgPSBwb3NpdGlvbihyb3csIHNpemUsIHJlY3QsIGZhbHNlKTtcbiAgICAgICAgc2l6ZSA9IE1hdGgubWluKHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgcm93Lmxlbmd0aCA9IHJvdy5hcmVhID0gMDtcbiAgICAgICAgYmVzdCA9IEluZmluaXR5O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocm93Lmxlbmd0aCkge1xuICAgICAgcmVjdCA9IHBvc2l0aW9uKHJvdywgc2l6ZSwgcmVjdCwgdHJ1ZSk7XG4gICAgICByb3cubGVuZ3RoID0gcm93LmFyZWEgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBub2RlKSwge30sIHtcbiAgICAgIGNoaWxkcmVuOiBzY2FsZUNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gc3F1YXJpZnkoYywgYXNwZWN0UmF0aW8pO1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn07XG52YXIgZGVmYXVsdFN0YXRlID0ge1xuICBpc1Rvb2x0aXBBY3RpdmU6IGZhbHNlLFxuICBpc0FuaW1hdGlvbkZpbmlzaGVkOiBmYWxzZSxcbiAgYWN0aXZlTm9kZTogbnVsbCxcbiAgZm9ybWF0Um9vdDogbnVsbCxcbiAgY3VycmVudFJvb3Q6IG51bGwsXG4gIG5lc3RJbmRleDogW11cbn07XG52YXIgVHJlZW1hcCA9IGV4cG9ydHMuVHJlZW1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcbiAgZnVuY3Rpb24gVHJlZW1hcCgpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyZWVtYXApO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIFRyZWVtYXAsIFtdLmNvbmNhdChhcmdzKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInN0YXRlXCIsIF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRTdGF0ZSkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25FbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9uQW5pbWF0aW9uRW5kID0gX3RoaXMucHJvcHMub25BbmltYXRpb25FbmQ7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9uQW5pbWF0aW9uRW5kKSkge1xuICAgICAgICBvbkFuaW1hdGlvbkVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25TdGFydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb25BbmltYXRpb25TdGFydCA9IF90aGlzLnByb3BzLm9uQW5pbWF0aW9uU3RhcnQ7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvbkFuaW1hdGlvblN0YXJ0KSkge1xuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhUcmVlbWFwLCBfUHVyZUNvbXBvbmVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVHJlZW1hcCwgW3tcbiAgICBrZXk6IFwiaGFuZGxlTW91c2VFbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3VzZUVudGVyKG5vZGUsIGUpIHtcbiAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgb25Nb3VzZUVudGVyID0gX3RoaXMkcHJvcHMub25Nb3VzZUVudGVyLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuO1xuICAgICAgdmFyIHRvb2x0aXBJdGVtID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRDaGlsZEJ5VHlwZSkoY2hpbGRyZW4sIF9Ub29sdGlwLlRvb2x0aXApO1xuICAgICAgaWYgKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICBhY3RpdmVOb2RlOiBub2RlXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAob25Nb3VzZUVudGVyKSB7XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXIobm9kZSwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob25Nb3VzZUVudGVyKSB7XG4gICAgICAgIG9uTW91c2VFbnRlcihub2RlLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlTW91c2VMZWF2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3VzZUxlYXZlKG5vZGUsIGUpIHtcbiAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIG9uTW91c2VMZWF2ZSA9IF90aGlzJHByb3BzMi5vbk1vdXNlTGVhdmUsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMyLmNoaWxkcmVuO1xuICAgICAgdmFyIHRvb2x0aXBJdGVtID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRDaGlsZEJ5VHlwZSkoY2hpbGRyZW4sIF9Ub29sdGlwLlRvb2x0aXApO1xuICAgICAgaWYgKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgYWN0aXZlTm9kZTogbnVsbFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG9uTW91c2VMZWF2ZSkge1xuICAgICAgICAgICAgb25Nb3VzZUxlYXZlKG5vZGUsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG9uTW91c2VMZWF2ZSkge1xuICAgICAgICBvbk1vdXNlTGVhdmUobm9kZSwgZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUNsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKG5vZGUpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICBvbkNsaWNrID0gX3RoaXMkcHJvcHMzLm9uQ2xpY2ssXG4gICAgICAgIHR5cGUgPSBfdGhpcyRwcm9wczMudHlwZTtcbiAgICAgIGlmICh0eXBlID09PSAnbmVzdCcgJiYgbm9kZS5jaGlsZHJlbikge1xuICAgICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczQuaGVpZ2h0LFxuICAgICAgICAgIGRhdGFLZXkgPSBfdGhpcyRwcm9wczQuZGF0YUtleSxcbiAgICAgICAgICBhc3BlY3RSYXRpbyA9IF90aGlzJHByb3BzNC5hc3BlY3RSYXRpbztcbiAgICAgICAgdmFyIHJvb3QgPSBjb21wdXRlTm9kZSh7XG4gICAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgICAgbm9kZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBub2RlKSwge30sIHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICB2YWx1ZUtleTogZGF0YUtleVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZvcm1hdFJvb3QgPSBzcXVhcmlmeShyb290LCBhc3BlY3RSYXRpbyk7XG4gICAgICAgIHZhciBuZXN0SW5kZXggPSB0aGlzLnN0YXRlLm5lc3RJbmRleDtcbiAgICAgICAgbmVzdEluZGV4LnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGZvcm1hdFJvb3Q6IGZvcm1hdFJvb3QsXG4gICAgICAgICAgY3VycmVudFJvb3Q6IHJvb3QsXG4gICAgICAgICAgbmVzdEluZGV4OiBuZXN0SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob25DbGljaykge1xuICAgICAgICBvbkNsaWNrKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVOZXN0SW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTmVzdEluZGV4KG5vZGUsIGkpIHtcbiAgICAgIHZhciBuZXN0SW5kZXggPSB0aGlzLnN0YXRlLm5lc3RJbmRleDtcbiAgICAgIHZhciBfdGhpcyRwcm9wczUgPSB0aGlzLnByb3BzLFxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM1LmhlaWdodCxcbiAgICAgICAgZGF0YUtleSA9IF90aGlzJHByb3BzNS5kYXRhS2V5LFxuICAgICAgICBhc3BlY3RSYXRpbyA9IF90aGlzJHByb3BzNS5hc3BlY3RSYXRpbztcbiAgICAgIHZhciByb290ID0gY29tcHV0ZU5vZGUoe1xuICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgbm9kZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBub2RlKSwge30sIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0pLFxuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgdmFsdWVLZXk6IGRhdGFLZXlcbiAgICAgIH0pO1xuICAgICAgdmFyIGZvcm1hdFJvb3QgPSBzcXVhcmlmeShyb290LCBhc3BlY3RSYXRpbyk7XG4gICAgICBuZXN0SW5kZXggPSBuZXN0SW5kZXguc2xpY2UoMCwgaSArIDEpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGZvcm1hdFJvb3Q6IGZvcm1hdFJvb3QsXG4gICAgICAgIGN1cnJlbnRSb290OiBub2RlLFxuICAgICAgICBuZXN0SW5kZXg6IG5lc3RJbmRleFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVySXRlbShjb250ZW50LCBub2RlUHJvcHMsIGlzTGVhZikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM2ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczYuaXNBbmltYXRpb25BY3RpdmUsXG4gICAgICAgIGFuaW1hdGlvbkJlZ2luID0gX3RoaXMkcHJvcHM2LmFuaW1hdGlvbkJlZ2luLFxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbiA9IF90aGlzJHByb3BzNi5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nID0gX3RoaXMkcHJvcHM2LmFuaW1hdGlvbkVhc2luZyxcbiAgICAgICAgaXNVcGRhdGVBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczYuaXNVcGRhdGVBbmltYXRpb25BY3RpdmUsXG4gICAgICAgIHR5cGUgPSBfdGhpcyRwcm9wczYudHlwZSxcbiAgICAgICAgYW5pbWF0aW9uSWQgPSBfdGhpcyRwcm9wczYuYW5pbWF0aW9uSWQsXG4gICAgICAgIGNvbG9yUGFuZWwgPSBfdGhpcyRwcm9wczYuY29sb3JQYW5lbDtcbiAgICAgIHZhciBpc0FuaW1hdGlvbkZpbmlzaGVkID0gdGhpcy5zdGF0ZS5pc0FuaW1hdGlvbkZpbmlzaGVkO1xuICAgICAgdmFyIHdpZHRoID0gbm9kZVByb3BzLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBub2RlUHJvcHMuaGVpZ2h0LFxuICAgICAgICB4ID0gbm9kZVByb3BzLngsXG4gICAgICAgIHkgPSBub2RlUHJvcHMueSxcbiAgICAgICAgZGVwdGggPSBub2RlUHJvcHMuZGVwdGg7XG4gICAgICB2YXIgdHJhbnNsYXRlWCA9IHBhcnNlSW50KFwiXCIuY29uY2F0KChNYXRoLnJhbmRvbSgpICogMiAtIDEpICogd2lkdGgpLCAxMCk7XG4gICAgICB2YXIgZXZlbnQgPSB7fTtcbiAgICAgIGlmIChpc0xlYWYgfHwgdHlwZSA9PT0gJ25lc3QnKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5oYW5kbGVNb3VzZUVudGVyLmJpbmQodGhpcywgbm9kZVByb3BzKSxcbiAgICAgICAgICBvbk1vdXNlTGVhdmU6IHRoaXMuaGFuZGxlTW91c2VMZWF2ZS5iaW5kKHRoaXMsIG5vZGVQcm9wcyksXG4gICAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVDbGljay5iaW5kKHRoaXMsIG5vZGVQcm9wcylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBbmltYXRpb25BY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBldmVudCwgdGhpcy5jb25zdHJ1Y3Rvci5yZW5kZXJDb250ZW50SXRlbShjb250ZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG5vZGVQcm9wcyksIHt9LCB7XG4gICAgICAgICAgaXNBbmltYXRpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICAgIGlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH0pLCB0eXBlLCBjb2xvclBhbmVsKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfcmVhY3RTbW9vdGhbXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgIGJlZ2luOiBhbmltYXRpb25CZWdpbixcbiAgICAgICAgZHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICBpc0FjdGl2ZTogaXNBbmltYXRpb25BY3RpdmUsXG4gICAgICAgIGVhc2luZzogYW5pbWF0aW9uRWFzaW5nLFxuICAgICAgICBrZXk6IFwidHJlZW1hcC1cIi5jb25jYXQoYW5pbWF0aW9uSWQpLFxuICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9LFxuICAgICAgICB0bzoge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgb25BbmltYXRpb25TdGFydDogdGhpcy5oYW5kbGVBbmltYXRpb25TdGFydCxcbiAgICAgICAgb25BbmltYXRpb25FbmQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uRW5kXG4gICAgICB9LCBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgdmFyIGN1cnJYID0gX3JlZjIueCxcbiAgICAgICAgICBjdXJyWSA9IF9yZWYyLnksXG4gICAgICAgICAgY3VycldpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgICAgY3VyckhlaWdodCA9IF9yZWYyLmhlaWdodDtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JlYWN0U21vb3RoW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgIGZyb206IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh0cmFuc2xhdGVYLCBcInB4LCBcIikuY29uY2F0KHRyYW5zbGF0ZVgsIFwicHgpXCIpLFxuICAgICAgICAgIHRvOiBcInRyYW5zbGF0ZSgwLCAwKVwiLFxuICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6IFwidHJhbnNmb3JtXCIsXG4gICAgICAgICAgYmVnaW46IGFuaW1hdGlvbkJlZ2luLFxuICAgICAgICAgIGVhc2luZzogYW5pbWF0aW9uRWFzaW5nLFxuICAgICAgICAgIGlzQWN0aXZlOiBpc0FuaW1hdGlvbkFjdGl2ZSxcbiAgICAgICAgICBkdXJhdGlvbjogYW5pbWF0aW9uRHVyYXRpb25cbiAgICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIGV2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gd2hlbiBhbmltYXRpb24gRHVyYXRpb24gLCBvbmx5IHJlbmRlciBkZXB0aD0xIG5vZGVzXG4gICAgICAgICAgaWYgKGRlcHRoID4gMiAmJiAhaXNBbmltYXRpb25GaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfdGhpczIuY29uc3RydWN0b3IucmVuZGVyQ29udGVudEl0ZW0oY29udGVudCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBub2RlUHJvcHMpLCB7fSwge1xuICAgICAgICAgICAgaXNBbmltYXRpb25BY3RpdmU6IGlzQW5pbWF0aW9uQWN0aXZlLFxuICAgICAgICAgICAgaXNVcGRhdGVBbmltYXRpb25BY3RpdmU6ICFpc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZSxcbiAgICAgICAgICAgIHdpZHRoOiBjdXJyV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGN1cnJIZWlnaHQsXG4gICAgICAgICAgICB4OiBjdXJyWCxcbiAgICAgICAgICAgIHk6IGN1cnJZXG4gICAgICAgICAgfSksIHR5cGUsIGNvbG9yUGFuZWwpO1xuICAgICAgICB9KCkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlck5vZGUocm9vdCwgbm9kZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM3ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY29udGVudCA9IF90aGlzJHByb3BzNy5jb250ZW50LFxuICAgICAgICB0eXBlID0gX3RoaXMkcHJvcHM3LnR5cGU7XG4gICAgICB2YXIgbm9kZVByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykodGhpcy5wcm9wcywgZmFsc2UpKSwgbm9kZSksIHt9LCB7XG4gICAgICAgIHJvb3Q6IHJvb3RcbiAgICAgIH0pO1xuICAgICAgdmFyIGlzTGVhZiA9ICFub2RlLmNoaWxkcmVuIHx8ICFub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIHZhciBjdXJyZW50Um9vdCA9IHRoaXMuc3RhdGUuY3VycmVudFJvb3Q7XG4gICAgICB2YXIgaXNDdXJyZW50Um9vdENoaWxkID0gKGN1cnJlbnRSb290LmNoaWxkcmVuIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uZGVwdGggPT09IG5vZGUuZGVwdGggJiYgaXRlbS5uYW1lID09PSBub2RlLm5hbWU7XG4gICAgICB9KTtcbiAgICAgIGlmICghaXNDdXJyZW50Um9vdENoaWxkLmxlbmd0aCAmJiByb290LmRlcHRoICYmIHR5cGUgPT09ICduZXN0Jykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xuICAgICAgICBrZXk6IFwicmVjaGFydHMtdHJlZW1hcC1ub2RlLVwiLmNvbmNhdChub2RlUHJvcHMueCwgXCItXCIpLmNvbmNhdChub2RlUHJvcHMueSwgXCItXCIpLmNvbmNhdChub2RlUHJvcHMubmFtZSksXG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy10cmVlbWFwLWRlcHRoLVwiLmNvbmNhdChub2RlLmRlcHRoKVxuICAgICAgfSwgdGhpcy5yZW5kZXJJdGVtKGNvbnRlbnQsIG5vZGVQcm9wcywgaXNMZWFmKSwgbm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA/IG5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLnJlbmRlck5vZGUobm9kZSwgY2hpbGQpO1xuICAgICAgfSkgOiBudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQWxsTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQWxsTm9kZXMoKSB7XG4gICAgICB2YXIgZm9ybWF0Um9vdCA9IHRoaXMuc3RhdGUuZm9ybWF0Um9vdDtcbiAgICAgIGlmICghZm9ybWF0Um9vdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlck5vZGUoZm9ybWF0Um9vdCwgZm9ybWF0Um9vdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclRvb2x0aXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVG9vbHRpcCgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczggPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzOC5jaGlsZHJlbixcbiAgICAgICAgbmFtZUtleSA9IF90aGlzJHByb3BzOC5uYW1lS2V5O1xuICAgICAgdmFyIHRvb2x0aXBJdGVtID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRDaGlsZEJ5VHlwZSkoY2hpbGRyZW4sIF9Ub29sdGlwLlRvb2x0aXApO1xuICAgICAgaWYgKCF0b29sdGlwSXRlbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBfdGhpcyRwcm9wczkgPSB0aGlzLnByb3BzLFxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzOS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM5LmhlaWdodDtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSA9IHRoaXMuc3RhdGUsXG4gICAgICAgIGlzVG9vbHRpcEFjdGl2ZSA9IF90aGlzJHN0YXRlLmlzVG9vbHRpcEFjdGl2ZSxcbiAgICAgICAgYWN0aXZlTm9kZSA9IF90aGlzJHN0YXRlLmFjdGl2ZU5vZGU7XG4gICAgICB2YXIgdmlld0JveCA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICAgIHZhciBjb29yZGluYXRlID0gYWN0aXZlTm9kZSA/IHtcbiAgICAgICAgeDogYWN0aXZlTm9kZS54ICsgYWN0aXZlTm9kZS53aWR0aCAvIDIsXG4gICAgICAgIHk6IGFjdGl2ZU5vZGUueSArIGFjdGl2ZU5vZGUuaGVpZ2h0IC8gMlxuICAgICAgfSA6IG51bGw7XG4gICAgICB2YXIgcGF5bG9hZCA9IGlzVG9vbHRpcEFjdGl2ZSAmJiBhY3RpdmVOb2RlID8gW3tcbiAgICAgICAgcGF5bG9hZDogYWN0aXZlTm9kZSxcbiAgICAgICAgbmFtZTogKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShhY3RpdmVOb2RlLCBuYW1lS2V5LCAnJyksXG4gICAgICAgIHZhbHVlOiAoMCwgX0NoYXJ0VXRpbHMuZ2V0VmFsdWVCeURhdGFLZXkpKGFjdGl2ZU5vZGUsIE5PREVfVkFMVUVfS0VZKVxuICAgICAgfV0gOiBbXTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQodG9vbHRpcEl0ZW0sIHtcbiAgICAgICAgdmlld0JveDogdmlld0JveCxcbiAgICAgICAgYWN0aXZlOiBpc1Rvb2x0aXBBY3RpdmUsXG4gICAgICAgIGNvb3JkaW5hdGU6IGNvb3JkaW5hdGUsXG4gICAgICAgIGxhYmVsOiAnJyxcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcmVuZGVyIG5lc3QgdHJlZW1hcFxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlck5lc3RJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJOZXN0SW5kZXgoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwcm9wczEwID0gdGhpcy5wcm9wcyxcbiAgICAgICAgbmFtZUtleSA9IF90aGlzJHByb3BzMTAubmFtZUtleSxcbiAgICAgICAgbmVzdEluZGV4Q29udGVudCA9IF90aGlzJHByb3BzMTAubmVzdEluZGV4Q29udGVudDtcbiAgICAgIHZhciBuZXN0SW5kZXggPSB0aGlzLnN0YXRlLm5lc3RJbmRleDtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXRyZWVtYXAtbmVzdC1pbmRleC13cmFwcGVyXCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgbWFyZ2luVG9wOiAnOHB4JyxcbiAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInXG4gICAgICAgIH1cbiAgICAgIH0sIG5lc3RJbmRleC5tYXAoZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgLy8gVE9ETyBuZWVkIHRvIHZlcmlmeSBuYW1lS2V5IHR5cGVcbiAgICAgICAgdmFyIG5hbWUgPSAoMCwgX2dldFtcImRlZmF1bHRcIl0pKGl0ZW0sIG5hbWVLZXksICdyb290Jyk7XG4gICAgICAgIHZhciBjb250ZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChuZXN0SW5kZXhDb250ZW50KSkge1xuICAgICAgICAgIGNvbnRlbnQgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQobmVzdEluZGV4Q29udGVudCwgaXRlbSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG5lc3RJbmRleENvbnRlbnQpKSB7XG4gICAgICAgICAgY29udGVudCA9IG5lc3RJbmRleENvbnRlbnQoaXRlbSwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudCA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2NsaWNrLWV2ZW50cy1oYXZlLWtleS1ldmVudHMsIGpzeC1hMTF5L25vLXN0YXRpYy1lbGVtZW50LWludGVyYWN0aW9uc1xuICAgICAgICAgIF9yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBvbkNsaWNrOiBfdGhpczQuaGFuZGxlTmVzdEluZGV4LmJpbmQoX3RoaXM0LCBpdGVtLCBpKSxcbiAgICAgICAgICAgIGtleTogXCJuZXN0LWluZGV4LVwiLmNvbmNhdCgoMCwgX0RhdGFVdGlscy51bmlxdWVJZCkoKSksXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtdHJlZW1hcC1uZXN0LWluZGV4LWJveFwiLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgICBwYWRkaW5nOiAnMCA3cHgnLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnIzAwMCcsXG4gICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAnM3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGNvbnRlbnQpXG4gICAgICAgICk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICBpZiAoISgwLCBfUmVhY3RVdGlscy52YWxpZGF0ZVdpZHRoSGVpZ2h0KSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBfdGhpcyRwcm9wczExID0gdGhpcy5wcm9wcyxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczExLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczExLmhlaWdodCxcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMxMS5jbGFzc05hbWUsXG4gICAgICAgIHN0eWxlID0gX3RoaXMkcHJvcHMxMS5zdHlsZSxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczExLmNoaWxkcmVuLFxuICAgICAgICB0eXBlID0gX3RoaXMkcHJvcHMxMS50eXBlLFxuICAgICAgICBvdGhlcnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHMxMSwgX2V4Y2x1ZGVkKTtcbiAgICAgIHZhciBhdHRycyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykob3RoZXJzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXdyYXBwZXInLCBjbGFzc05hbWUpLFxuICAgICAgICBzdHlsZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdHlsZSksIHt9LCB7XG4gICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCcsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0pLFxuICAgICAgICByb2xlOiBcInJlZ2lvblwiXG4gICAgICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9TdXJmYWNlLlN1cmZhY2UsIF9leHRlbmRzKHt9LCBhdHRycywge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogdHlwZSA9PT0gJ25lc3QnID8gaGVpZ2h0IC0gMzAgOiBoZWlnaHRcbiAgICAgIH0pLCB0aGlzLnJlbmRlckFsbE5vZGVzKCksICgwLCBfUmVhY3RVdGlscy5maWx0ZXJTdmdFbGVtZW50cykoY2hpbGRyZW4pKSwgdGhpcy5yZW5kZXJUb29sdGlwKCksIHR5cGUgPT09ICduZXN0JyAmJiB0aGlzLnJlbmRlck5lc3RJbmRleCgpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmRhdGEgIT09IHByZXZTdGF0ZS5wcmV2RGF0YSB8fCBuZXh0UHJvcHMudHlwZSAhPT0gcHJldlN0YXRlLnByZXZUeXBlIHx8IG5leHRQcm9wcy53aWR0aCAhPT0gcHJldlN0YXRlLnByZXZXaWR0aCB8fCBuZXh0UHJvcHMuaGVpZ2h0ICE9PSBwcmV2U3RhdGUucHJldkhlaWdodCB8fCBuZXh0UHJvcHMuZGF0YUtleSAhPT0gcHJldlN0YXRlLnByZXZEYXRhS2V5IHx8IG5leHRQcm9wcy5hc3BlY3RSYXRpbyAhPT0gcHJldlN0YXRlLnByZXZBc3BlY3RSYXRpbykge1xuICAgICAgICB2YXIgcm9vdCA9IGNvbXB1dGVOb2RlKHtcbiAgICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICBjaGlsZHJlbjogbmV4dFByb3BzLmRhdGEsXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiBuZXh0UHJvcHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IG5leHRQcm9wcy5oZWlnaHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgIHZhbHVlS2V5OiBuZXh0UHJvcHMuZGF0YUtleVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZvcm1hdFJvb3QgPSBzcXVhcmlmeShyb290LCBuZXh0UHJvcHMuYXNwZWN0UmF0aW8pO1xuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcmV2U3RhdGUpLCB7fSwge1xuICAgICAgICAgIGZvcm1hdFJvb3Q6IGZvcm1hdFJvb3QsXG4gICAgICAgICAgY3VycmVudFJvb3Q6IHJvb3QsXG4gICAgICAgICAgbmVzdEluZGV4OiBbcm9vdF0sXG4gICAgICAgICAgcHJldkFzcGVjdFJhdGlvOiBuZXh0UHJvcHMuYXNwZWN0UmF0aW8sXG4gICAgICAgICAgcHJldkRhdGE6IG5leHRQcm9wcy5kYXRhLFxuICAgICAgICAgIHByZXZXaWR0aDogbmV4dFByb3BzLndpZHRoLFxuICAgICAgICAgIHByZXZIZWlnaHQ6IG5leHRQcm9wcy5oZWlnaHQsXG4gICAgICAgICAgcHJldkRhdGFLZXk6IG5leHRQcm9wcy5kYXRhS2V5LFxuICAgICAgICAgIHByZXZUeXBlOiBuZXh0UHJvcHMudHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJDb250ZW50SXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDb250ZW50SXRlbShjb250ZW50LCBub2RlUHJvcHMsIHR5cGUsIGNvbG9yUGFuZWwpIHtcbiAgICAgIGlmICggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQoY29udGVudCkpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChjb250ZW50LCBub2RlUHJvcHMpO1xuICAgICAgfVxuICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKGNvbnRlbnQpKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50KG5vZGVQcm9wcyk7XG4gICAgICB9XG4gICAgICAvLyBvcHRpbWl6ZSBkZWZhdWx0IHNoYXBlXG4gICAgICB2YXIgeCA9IG5vZGVQcm9wcy54LFxuICAgICAgICB5ID0gbm9kZVByb3BzLnksXG4gICAgICAgIHdpZHRoID0gbm9kZVByb3BzLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBub2RlUHJvcHMuaGVpZ2h0LFxuICAgICAgICBpbmRleCA9IG5vZGVQcm9wcy5pbmRleDtcbiAgICAgIHZhciBhcnJvdyA9IG51bGw7XG4gICAgICBpZiAod2lkdGggPiAxMCAmJiBoZWlnaHQgPiAxMCAmJiBub2RlUHJvcHMuY2hpbGRyZW4gJiYgdHlwZSA9PT0gJ25lc3QnKSB7XG4gICAgICAgIGFycm93ID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfUG9seWdvbi5Qb2x5Z29uLCB7XG4gICAgICAgICAgcG9pbnRzOiBbe1xuICAgICAgICAgICAgeDogeCArIDIsXG4gICAgICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IHggKyA2LFxuICAgICAgICAgICAgeTogeSArIGhlaWdodCAvIDIgKyAzXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogeCArIDIsXG4gICAgICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMiArIDZcbiAgICAgICAgICB9XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciB0ZXh0ID0gbnVsbDtcbiAgICAgIHZhciBuYW1lU2l6ZSA9ICgwLCBfRE9NVXRpbHMuZ2V0U3RyaW5nU2l6ZSkobm9kZVByb3BzLm5hbWUpO1xuICAgICAgaWYgKHdpZHRoID4gMjAgJiYgaGVpZ2h0ID4gMjAgJiYgbmFtZVNpemUud2lkdGggPCB3aWR0aCAmJiBuYW1lU2l6ZS5oZWlnaHQgPCBoZWlnaHQpIHtcbiAgICAgICAgdGV4dCA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0XCIsIHtcbiAgICAgICAgICB4OiB4ICsgOCxcbiAgICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMiArIDcsXG4gICAgICAgICAgZm9udFNpemU6IDE0XG4gICAgICAgIH0sIG5vZGVQcm9wcy5uYW1lKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2xvcnMgPSBjb2xvclBhbmVsIHx8IF9Db25zdGFudHMuQ09MT1JfUEFORUw7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwgbnVsbCwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfUmVjdGFuZ2xlLlJlY3RhbmdsZSwgX2V4dGVuZHMoe1xuICAgICAgICBmaWxsOiBub2RlUHJvcHMuZGVwdGggPCAyID8gY29sb3JzW2luZGV4ICUgY29sb3JzLmxlbmd0aF0gOiAncmdiYSgyNTUsMjU1LDI1NSwwKScsXG4gICAgICAgIHN0cm9rZTogXCIjZmZmXCJcbiAgICAgIH0sICgwLCBfb21pdFtcImRlZmF1bHRcIl0pKG5vZGVQcm9wcywgJ2NoaWxkcmVuJyksIHtcbiAgICAgICAgcm9sZTogXCJpbWdcIlxuICAgICAgfSkpLCBhcnJvdywgdGV4dCk7XG4gICAgfVxuICB9XSk7XG59KF9yZWFjdC5QdXJlQ29tcG9uZW50KTtcbl9kZWZpbmVQcm9wZXJ0eShUcmVlbWFwLCBcImRpc3BsYXlOYW1lXCIsICdUcmVlbWFwJyk7XG5fZGVmaW5lUHJvcGVydHkoVHJlZW1hcCwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBhc3BlY3RSYXRpbzogMC41ICogKDEgKyBNYXRoLnNxcnQoNSkpLFxuICBkYXRhS2V5OiAndmFsdWUnLFxuICB0eXBlOiAnZmxhdCcsXG4gIGlzQW5pbWF0aW9uQWN0aXZlOiAhX0dsb2JhbC5HbG9iYWwuaXNTc3IsXG4gIGlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlOiAhX0dsb2JhbC5HbG9iYWwuaXNTc3IsXG4gIGFuaW1hdGlvbkJlZ2luOiAwLFxuICBhbmltYXRpb25EdXJhdGlvbjogMTUwMCxcbiAgYW5pbWF0aW9uRWFzaW5nOiAnbGluZWFyJ1xufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVHJlZW1hcCIsIl9pc05hTiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2lzRnVuY3Rpb24iLCJfb21pdCIsIl9nZXQiLCJfY2xzeCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiX3JlYWN0U21vb3RoIiwiX1Rvb2x0aXAiLCJfTGF5ZXIiLCJfU3VyZmFjZSIsIl9Qb2x5Z29uIiwiX1JlY3RhbmdsZSIsIl9DaGFydFV0aWxzIiwiX0NvbnN0YW50cyIsIl9EYXRhVXRpbHMiLCJfRE9NVXRpbHMiLCJfR2xvYmFsIiwiX1JlYWN0VXRpbHMiLCJfZXhjbHVkZWQiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0Iiwib2JqIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJhcHBseSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwib3duS2V5cyIsImtleXMiLCJmaWx0ZXIiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiTk9ERV9WQUxVRV9LRVkiLCJjb21wdXRlTm9kZSIsIl9yZWYiLCJkZXB0aCIsIm5vZGUiLCJpbmRleCIsInZhbHVlS2V5IiwiY2hpbGRyZW4iLCJjaGlsZERlcHRoIiwiY29tcHV0ZWRDaGlsZHJlbiIsIm1hcCIsImNoaWxkIiwibm9kZVZhbHVlIiwicmVkdWNlIiwicmVzdWx0IiwiZmlsdGVyUmVjdCIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJnZXRBcmVhT2ZDaGlsZHJlbiIsImFyZWFWYWx1ZVJhdGlvIiwicmF0aW8iLCJhcmVhIiwiZ2V0V29yc3RTY29yZSIsInJvdyIsInBhcmVudFNpemUiLCJhc3BlY3RSYXRpbyIsInBhcmVudEFyZWEiLCJyb3dBcmVhIiwiX3JvdyRyZWR1Y2UiLCJtaW4iLCJNYXRoIiwibWF4IiwiSW5maW5pdHkiLCJob3Jpem9udGFsUG9zaXRpb24iLCJwYXJlbnRSZWN0IiwiaXNGbHVzaCIsInJvd0hlaWdodCIsInJvdW5kIiwiY3VyWCIsImxlbiIsInZlcnRpY2FsUG9zaXRpb24iLCJyb3dXaWR0aCIsImN1clkiLCJwb3NpdGlvbiIsInNxdWFyaWZ5IiwicmVjdCIsImJlc3QiLCJzY29yZSIsInNpemUiLCJzY2FsZUNoaWxkcmVuIiwidGVtcENoaWxkcmVuIiwic2xpY2UiLCJzaGlmdCIsInBvcCIsImMiLCJkZWZhdWx0U3RhdGUiLCJpc1Rvb2x0aXBBY3RpdmUiLCJpc0FuaW1hdGlvbkZpbmlzaGVkIiwiYWN0aXZlTm9kZSIsImZvcm1hdFJvb3QiLCJjdXJyZW50Um9vdCIsIm5lc3RJbmRleCIsIl9QdXJlQ29tcG9uZW50IiwiX3RoaXMiLCJfbGVuIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImNvbmNhdCIsIm9uQW5pbWF0aW9uRW5kIiwic2V0U3RhdGUiLCJvbkFuaW1hdGlvblN0YXJ0IiwiaGFuZGxlTW91c2VFbnRlciIsInBlcnNpc3QiLCJfdGhpcyRwcm9wcyIsIm9uTW91c2VFbnRlciIsInRvb2x0aXBJdGVtIiwiZmluZENoaWxkQnlUeXBlIiwiVG9vbHRpcCIsImhhbmRsZU1vdXNlTGVhdmUiLCJfdGhpcyRwcm9wczIiLCJvbk1vdXNlTGVhdmUiLCJoYW5kbGVDbGljayIsIl90aGlzJHByb3BzMyIsIm9uQ2xpY2siLCJ0eXBlIiwiX3RoaXMkcHJvcHM0IiwiZGF0YUtleSIsInJvb3QiLCJzdGF0ZSIsImhhbmRsZU5lc3RJbmRleCIsIl90aGlzJHByb3BzNSIsInJlbmRlckl0ZW0iLCJjb250ZW50Iiwibm9kZVByb3BzIiwiaXNMZWFmIiwiX3RoaXMyIiwiX3RoaXMkcHJvcHM2IiwiaXNBbmltYXRpb25BY3RpdmUiLCJhbmltYXRpb25CZWdpbiIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRWFzaW5nIiwiaXNVcGRhdGVBbmltYXRpb25BY3RpdmUiLCJhbmltYXRpb25JZCIsImNvbG9yUGFuZWwiLCJ0cmFuc2xhdGVYIiwicGFyc2VJbnQiLCJyYW5kb20iLCJldmVudCIsImNyZWF0ZUVsZW1lbnQiLCJMYXllciIsInJlbmRlckNvbnRlbnRJdGVtIiwiYmVnaW4iLCJkdXJhdGlvbiIsImlzQWN0aXZlIiwiZWFzaW5nIiwiZnJvbSIsInRvIiwiaGFuZGxlQW5pbWF0aW9uU3RhcnQiLCJoYW5kbGVBbmltYXRpb25FbmQiLCJfcmVmMiIsImN1cnJYIiwiY3VyclkiLCJjdXJyV2lkdGgiLCJjdXJySGVpZ2h0IiwiYXR0cmlidXRlTmFtZSIsInJlbmRlck5vZGUiLCJfdGhpczMiLCJfdGhpcyRwcm9wczciLCJmaWx0ZXJQcm9wcyIsImlzQ3VycmVudFJvb3RDaGlsZCIsIml0ZW0iLCJuYW1lIiwiY2xhc3NOYW1lIiwicmVuZGVyQWxsTm9kZXMiLCJyZW5kZXJUb29sdGlwIiwiX3RoaXMkcHJvcHM4IiwibmFtZUtleSIsIl90aGlzJHByb3BzOSIsIl90aGlzJHN0YXRlIiwidmlld0JveCIsImNvb3JkaW5hdGUiLCJwYXlsb2FkIiwiZ2V0VmFsdWVCeURhdGFLZXkiLCJjbG9uZUVsZW1lbnQiLCJhY3RpdmUiLCJsYWJlbCIsInJlbmRlck5lc3RJbmRleCIsIl90aGlzNCIsIl90aGlzJHByb3BzMTAiLCJuZXN0SW5kZXhDb250ZW50Iiwic3R5bGUiLCJtYXJnaW5Ub3AiLCJ0ZXh0QWxpZ24iLCJpc1ZhbGlkRWxlbWVudCIsInVuaXF1ZUlkIiwiY3Vyc29yIiwiZGlzcGxheSIsInBhZGRpbmciLCJiYWNrZ3JvdW5kIiwiY29sb3IiLCJtYXJnaW5SaWdodCIsInJlbmRlciIsInZhbGlkYXRlV2lkdGhIZWlnaHQiLCJfdGhpcyRwcm9wczExIiwib3RoZXJzIiwiYXR0cnMiLCJyb2xlIiwiU3VyZmFjZSIsImZpbHRlclN2Z0VsZW1lbnRzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibmV4dFByb3BzIiwicHJldlN0YXRlIiwiZGF0YSIsInByZXZEYXRhIiwicHJldlR5cGUiLCJwcmV2V2lkdGgiLCJwcmV2SGVpZ2h0IiwicHJldkRhdGFLZXkiLCJwcmV2QXNwZWN0UmF0aW8iLCJhcnJvdyIsIlBvbHlnb24iLCJwb2ludHMiLCJ0ZXh0IiwibmFtZVNpemUiLCJnZXRTdHJpbmdTaXplIiwiZm9udFNpemUiLCJjb2xvcnMiLCJDT0xPUl9QQU5FTCIsIlJlY3RhbmdsZSIsImZpbGwiLCJzdHJva2UiLCJQdXJlQ29tcG9uZW50Iiwic3FydCIsIkdsb2JhbCIsImlzU3NyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/chart/Treemap.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/chart/generateCategoricalChart.js":
/*!*********************************************************************!*\
  !*** ./node_modules/recharts/lib/chart/generateCategoricalChart.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getAxisMapByAxes = exports.generateCategoricalChart = exports.createDefaultState = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _range = _interopRequireDefault(__webpack_require__(/*! lodash/range */ \"lodash/range\"));\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _sortBy = _interopRequireDefault(__webpack_require__(/*! lodash/sortBy */ \"lodash/sortBy\"));\nvar _throttle = _interopRequireDefault(__webpack_require__(/*! lodash/throttle */ \"lodash/throttle\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _tinyInvariant = _interopRequireDefault(__webpack_require__(/*! tiny-invariant */ \"tiny-invariant\"));\nvar _Surface = __webpack_require__(/*! ../container/Surface */ \"./node_modules/recharts/lib/container/Surface.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _Tooltip = __webpack_require__(/*! ../component/Tooltip */ \"./node_modules/recharts/lib/component/Tooltip.js\");\nvar _Legend = __webpack_require__(/*! ../component/Legend */ \"./node_modules/recharts/lib/component/Legend.js\");\nvar _Dot = __webpack_require__(/*! ../shape/Dot */ \"./node_modules/recharts/lib/shape/Dot.js\");\nvar _Rectangle = __webpack_require__(/*! ../shape/Rectangle */ \"./node_modules/recharts/lib/shape/Rectangle.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Brush = __webpack_require__(/*! ../cartesian/Brush */ \"./node_modules/recharts/lib/cartesian/Brush.js\");\nvar _DOMUtils = __webpack_require__(/*! ../util/DOMUtils */ \"./node_modules/recharts/lib/util/DOMUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _DetectReferenceElementsDomain = __webpack_require__(/*! ../util/DetectReferenceElementsDomain */ \"./node_modules/recharts/lib/util/DetectReferenceElementsDomain.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _ShallowEqual = __webpack_require__(/*! ../util/ShallowEqual */ \"./node_modules/recharts/lib/util/ShallowEqual.js\");\nvar _Events = __webpack_require__(/*! ../util/Events */ \"./node_modules/recharts/lib/util/Events.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"./node_modules/recharts/lib/util/types.js\");\nvar _AccessibilityManager = __webpack_require__(/*! ./AccessibilityManager */ \"./node_modules/recharts/lib/chart/AccessibilityManager.js\");\nvar _isDomainSpecifiedByUser = __webpack_require__(/*! ../util/isDomainSpecifiedByUser */ \"./node_modules/recharts/lib/util/isDomainSpecifiedByUser.js\");\nvar _ActiveShapeUtils = __webpack_require__(/*! ../util/ActiveShapeUtils */ \"./node_modules/recharts/lib/util/ActiveShapeUtils.js\");\nvar _Cursor = __webpack_require__(/*! ../component/Cursor */ \"./node_modules/recharts/lib/component/Cursor.js\");\nvar _chartLayoutContext = __webpack_require__(/*! ../context/chartLayoutContext */ \"./node_modules/recharts/lib/context/chartLayoutContext.js\");\nvar _excluded = [\n    \"item\"\n], _excluded2 = [\n    \"children\",\n    \"className\",\n    \"width\",\n    \"height\",\n    \"style\",\n    \"compact\",\n    \"title\",\n    \"desc\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} // eslint-disable-next-line no-restricted-imports\nvar ORIENT_MAP = {\n    xAxis: [\n        \"bottom\",\n        \"top\"\n    ],\n    yAxis: [\n        \"left\",\n        \"right\"\n    ]\n};\nvar FULL_WIDTH_AND_HEIGHT = {\n    width: \"100%\",\n    height: \"100%\"\n};\nvar originCoordinate = {\n    x: 0,\n    y: 0\n};\n/**\n * This function exists as a temporary workaround.\n *\n * Why? generateCategoricalChart does not render `{children}` directly;\n * instead it passes them through `renderByOrder` function which reads their handlers.\n *\n * So, this is a handler that does nothing.\n * Once we get rid of `renderByOrder` and switch to JSX only, we can get rid of this handler too.\n *\n * @param {JSX} element as is in JSX\n * @returns {JSX} the same element\n */ function renderAsIs(element) {\n    return element;\n}\nvar calculateTooltipPos = function calculateTooltipPos(rangeObj, layout) {\n    if (layout === \"horizontal\") {\n        return rangeObj.x;\n    }\n    if (layout === \"vertical\") {\n        return rangeObj.y;\n    }\n    if (layout === \"centric\") {\n        return rangeObj.angle;\n    }\n    return rangeObj.radius;\n};\nvar getActiveCoordinate = function getActiveCoordinate(layout, tooltipTicks, activeIndex, rangeObj) {\n    var entry = tooltipTicks.find(function(tick) {\n        return tick && tick.index === activeIndex;\n    });\n    if (entry) {\n        if (layout === \"horizontal\") {\n            return {\n                x: entry.coordinate,\n                y: rangeObj.y\n            };\n        }\n        if (layout === \"vertical\") {\n            return {\n                x: rangeObj.x,\n                y: entry.coordinate\n            };\n        }\n        if (layout === \"centric\") {\n            var _angle = entry.coordinate;\n            var _radius = rangeObj.radius;\n            return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), (0, _PolarUtils.polarToCartesian)(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {\n                angle: _angle,\n                radius: _radius\n            });\n        }\n        var radius = entry.coordinate;\n        var angle = rangeObj.angle;\n        return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), (0, _PolarUtils.polarToCartesian)(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {\n            angle: angle,\n            radius: radius\n        });\n    }\n    return originCoordinate;\n};\nvar getDisplayedData = function getDisplayedData(data, _ref) {\n    var graphicalItems = _ref.graphicalItems, dataStartIndex = _ref.dataStartIndex, dataEndIndex = _ref.dataEndIndex;\n    var itemsData = (graphicalItems !== null && graphicalItems !== void 0 ? graphicalItems : []).reduce(function(result, child) {\n        var itemData = child.props.data;\n        if (itemData && itemData.length) {\n            return [].concat(_toConsumableArray(result), _toConsumableArray(itemData));\n        }\n        return result;\n    }, []);\n    if (itemsData.length > 0) {\n        return itemsData;\n    }\n    if (data && data.length && (0, _DataUtils.isNumber)(dataStartIndex) && (0, _DataUtils.isNumber)(dataEndIndex)) {\n        return data.slice(dataStartIndex, dataEndIndex + 1);\n    }\n    return [];\n};\nfunction getDefaultDomainByAxisType(axisType) {\n    return axisType === \"number\" ? [\n        0,\n        \"auto\"\n    ] : undefined;\n}\n/**\n * Get the content to be displayed in the tooltip\n * @param  {Object} state          Current state\n * @param  {Array}  chartData      The data defined in chart\n * @param  {Number} activeIndex    Active index of data\n * @param  {String} activeLabel    Active label of data\n * @return {Array}                 The content of tooltip\n */ var getTooltipContent = function getTooltipContent(state, chartData, activeIndex, activeLabel) {\n    var graphicalItems = state.graphicalItems, tooltipAxis = state.tooltipAxis;\n    var displayedData = getDisplayedData(chartData, state);\n    if (activeIndex < 0 || !graphicalItems || !graphicalItems.length || activeIndex >= displayedData.length) {\n        return null;\n    }\n    // get data by activeIndex when the axis don't allow duplicated category\n    return graphicalItems.reduce(function(result, child) {\n        var _child$props$data;\n        /**\n     * Fixes: https://github.com/recharts/recharts/issues/3669\n     * Defaulting to chartData below to fix an edge case where the tooltip does not include data from all charts\n     * when a separate dataset is passed to chart prop data and specified on Line/Area/etc prop data\n     */ var data = (_child$props$data = child.props.data) !== null && _child$props$data !== void 0 ? _child$props$data : chartData;\n        if (data && state.dataStartIndex + state.dataEndIndex !== 0 && // https://github.com/recharts/recharts/issues/4717\n        // The data is sliced only when the active index is within the start/end index range.\n        state.dataEndIndex - state.dataStartIndex >= activeIndex) {\n            data = data.slice(state.dataStartIndex, state.dataEndIndex + 1);\n        }\n        var payload;\n        if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {\n            // graphic child has data props\n            var entries = data === undefined ? displayedData : data;\n            payload = (0, _DataUtils.findEntryInArray)(entries, tooltipAxis.dataKey, activeLabel);\n        } else {\n            payload = data && data[activeIndex] || displayedData[activeIndex];\n        }\n        if (!payload) {\n            return result;\n        }\n        return [].concat(_toConsumableArray(result), [\n            (0, _ChartUtils.getTooltipItem)(child, payload)\n        ]);\n    }, []);\n};\n/**\n * Returns tooltip data based on a mouse position (as a parameter or in state)\n * @param  {Object} state     current state\n * @param  {Array}  chartData the data defined in chart\n * @param  {String} layout     The layout type of chart\n * @param  {Object} rangeObj  { x, y } coordinates\n * @return {Object}           Tooltip data data\n */ var getTooltipData = function getTooltipData(state, chartData, layout, rangeObj) {\n    var rangeData = rangeObj || {\n        x: state.chartX,\n        y: state.chartY\n    };\n    var pos = calculateTooltipPos(rangeData, layout);\n    var ticks = state.orderedTooltipTicks, axis = state.tooltipAxis, tooltipTicks = state.tooltipTicks;\n    var activeIndex = (0, _ChartUtils.calculateActiveTickIndex)(pos, ticks, tooltipTicks, axis);\n    if (activeIndex >= 0 && tooltipTicks) {\n        var activeLabel = tooltipTicks[activeIndex] && tooltipTicks[activeIndex].value;\n        var activePayload = getTooltipContent(state, chartData, activeIndex, activeLabel);\n        var activeCoordinate = getActiveCoordinate(layout, ticks, activeIndex, rangeData);\n        return {\n            activeTooltipIndex: activeIndex,\n            activeLabel: activeLabel,\n            activePayload: activePayload,\n            activeCoordinate: activeCoordinate\n        };\n    }\n    return null;\n};\n/**\n * Get the configuration of axis by the options of axis instance\n * @param  {Object} props         Latest props\n * @param {Array}  axes           The instance of axes\n * @param  {Array} graphicalItems The instances of item\n * @param  {String} axisType      The type of axis, xAxis - x-axis, yAxis - y-axis\n * @param  {String} axisIdKey     The unique id of an axis\n * @param  {Object} stackGroups   The items grouped by axisId and stackId\n * @param {Number} dataStartIndex The start index of the data series when a brush is applied\n * @param {Number} dataEndIndex   The end index of the data series when a brush is applied\n * @return {Object}      Configuration\n */ var getAxisMapByAxes = exports.getAxisMapByAxes = function getAxisMapByAxes(props, _ref2) {\n    var axes = _ref2.axes, graphicalItems = _ref2.graphicalItems, axisType = _ref2.axisType, axisIdKey = _ref2.axisIdKey, stackGroups = _ref2.stackGroups, dataStartIndex = _ref2.dataStartIndex, dataEndIndex = _ref2.dataEndIndex;\n    var layout = props.layout, children = props.children, stackOffset = props.stackOffset;\n    var isCategorical = (0, _ChartUtils.isCategoricalAxis)(layout, axisType);\n    // Eliminate duplicated axes\n    return axes.reduce(function(result, child) {\n        var _childProps$domain2;\n        var childProps = child.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, child.type.defaultProps), child.props) : child.props;\n        var type = childProps.type, dataKey = childProps.dataKey, allowDataOverflow = childProps.allowDataOverflow, allowDuplicatedCategory = childProps.allowDuplicatedCategory, scale = childProps.scale, ticks = childProps.ticks, includeHidden = childProps.includeHidden;\n        var axisId = childProps[axisIdKey];\n        if (result[axisId]) {\n            return result;\n        }\n        var displayedData = getDisplayedData(props.data, {\n            graphicalItems: graphicalItems.filter(function(item) {\n                var _defaultProps;\n                var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps = item.type.defaultProps) === null || _defaultProps === void 0 ? void 0 : _defaultProps[axisIdKey];\n                return itemAxisId === axisId;\n            }),\n            dataStartIndex: dataStartIndex,\n            dataEndIndex: dataEndIndex\n        });\n        var len = displayedData.length;\n        var domain, duplicateDomain, categoricalDomain;\n        /*\n     * This is a hack to short-circuit the domain creation here to enhance performance.\n     * Usually, the data is used to determine the domain, but when the user specifies\n     * a domain upfront (via props), there is no need to calculate the domain start and end,\n     * which is very expensive for a larger amount of data.\n     * The only thing that would prohibit short-circuiting is when the user doesn't allow data overflow,\n     * because the axis is supposed to ignore the specified domain that way.\n     */ if ((0, _isDomainSpecifiedByUser.isDomainSpecifiedByUser)(childProps.domain, allowDataOverflow, type)) {\n            domain = (0, _ChartUtils.parseSpecifiedDomain)(childProps.domain, null, allowDataOverflow);\n            /* The chart can be categorical and have the domain specified in numbers\n       * we still need to calculate the categorical domain\n       * TODO: refactor this more\n       */ if (isCategorical && (type === \"number\" || scale !== \"auto\")) {\n                categoricalDomain = (0, _ChartUtils.getDomainOfDataByKey)(displayedData, dataKey, \"category\");\n            }\n        }\n        // if the domain is defaulted we need this for `originalDomain` as well\n        var defaultDomain = getDefaultDomainByAxisType(type);\n        // we didn't create the domain from user's props above, so we need to calculate it\n        if (!domain || domain.length === 0) {\n            var _childProps$domain;\n            var childDomain = (_childProps$domain = childProps.domain) !== null && _childProps$domain !== void 0 ? _childProps$domain : defaultDomain;\n            if (dataKey) {\n                // has dataKey in <Axis />\n                domain = (0, _ChartUtils.getDomainOfDataByKey)(displayedData, dataKey, type);\n                if (type === \"category\" && isCategorical) {\n                    // the field type is category data and this axis is categorical axis\n                    var duplicate = (0, _DataUtils.hasDuplicate)(domain);\n                    if (allowDuplicatedCategory && duplicate) {\n                        duplicateDomain = domain;\n                        // When category axis has duplicated text, serial numbers are used to generate scale\n                        domain = (0, _range[\"default\"])(0, len);\n                    } else if (!allowDuplicatedCategory) {\n                        // remove duplicated category\n                        domain = (0, _ChartUtils.parseDomainOfCategoryAxis)(childDomain, domain, child).reduce(function(finalDomain, entry) {\n                            return finalDomain.indexOf(entry) >= 0 ? finalDomain : [].concat(_toConsumableArray(finalDomain), [\n                                entry\n                            ]);\n                        }, []);\n                    }\n                } else if (type === \"category\") {\n                    // the field type is category data and this axis is numerical axis\n                    if (!allowDuplicatedCategory) {\n                        domain = (0, _ChartUtils.parseDomainOfCategoryAxis)(childDomain, domain, child).reduce(function(finalDomain, entry) {\n                            return finalDomain.indexOf(entry) >= 0 || entry === \"\" || (0, _isNil[\"default\"])(entry) ? finalDomain : [].concat(_toConsumableArray(finalDomain), [\n                                entry\n                            ]);\n                        }, []);\n                    } else {\n                        // eliminate undefined or null or empty string\n                        domain = domain.filter(function(entry) {\n                            return entry !== \"\" && !(0, _isNil[\"default\"])(entry);\n                        });\n                    }\n                } else if (type === \"number\") {\n                    // the field type is numerical\n                    var errorBarsDomain = (0, _ChartUtils.parseErrorBarsOfAxis)(displayedData, graphicalItems.filter(function(item) {\n                        var _defaultProps2, _defaultProps3;\n                        var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps2 = item.type.defaultProps) === null || _defaultProps2 === void 0 ? void 0 : _defaultProps2[axisIdKey];\n                        var itemHide = \"hide\" in item.props ? item.props.hide : (_defaultProps3 = item.type.defaultProps) === null || _defaultProps3 === void 0 ? void 0 : _defaultProps3.hide;\n                        return itemAxisId === axisId && (includeHidden || !itemHide);\n                    }), dataKey, axisType, layout);\n                    if (errorBarsDomain) {\n                        domain = errorBarsDomain;\n                    }\n                }\n                if (isCategorical && (type === \"number\" || scale !== \"auto\")) {\n                    categoricalDomain = (0, _ChartUtils.getDomainOfDataByKey)(displayedData, dataKey, \"category\");\n                }\n            } else if (isCategorical) {\n                // the axis is a categorical axis\n                domain = (0, _range[\"default\"])(0, len);\n            } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack && type === \"number\") {\n                // when stackOffset is 'expand', the domain may be calculated as [0, 1.000000000002]\n                domain = stackOffset === \"expand\" ? [\n                    0,\n                    1\n                ] : (0, _ChartUtils.getDomainOfStackGroups)(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);\n            } else {\n                domain = (0, _ChartUtils.getDomainOfItemsWithSameAxis)(displayedData, graphicalItems.filter(function(item) {\n                    var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : item.type.defaultProps[axisIdKey];\n                    var itemHide = \"hide\" in item.props ? item.props.hide : item.type.defaultProps.hide;\n                    return itemAxisId === axisId && (includeHidden || !itemHide);\n                }), type, layout, true);\n            }\n            if (type === \"number\") {\n                // To detect wether there is any reference lines whose props alwaysShow is true\n                domain = (0, _DetectReferenceElementsDomain.detectReferenceElementsDomain)(children, domain, axisId, axisType, ticks);\n                if (childDomain) {\n                    domain = (0, _ChartUtils.parseSpecifiedDomain)(childDomain, domain, allowDataOverflow);\n                }\n            } else if (type === \"category\" && childDomain) {\n                var axisDomain = childDomain;\n                var isDomainValid = domain.every(function(entry) {\n                    return axisDomain.indexOf(entry) >= 0;\n                });\n                if (isDomainValid) {\n                    domain = axisDomain;\n                }\n            }\n        }\n        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({}, childProps), {}, {\n            axisType: axisType,\n            domain: domain,\n            categoricalDomain: categoricalDomain,\n            duplicateDomain: duplicateDomain,\n            originalDomain: (_childProps$domain2 = childProps.domain) !== null && _childProps$domain2 !== void 0 ? _childProps$domain2 : defaultDomain,\n            isCategorical: isCategorical,\n            layout: layout\n        })));\n    }, {});\n};\n/**\n * Get the configuration of axis by the options of item,\n * this kind of axis does not display in chart\n * @param  {Object} props         Latest props\n * @param  {Array} graphicalItems The instances of item\n * @param  {ReactElement} Axis    Axis Component\n * @param  {String} axisType      The type of axis, xAxis - x-axis, yAxis - y-axis\n * @param  {String} axisIdKey     The unique id of an axis\n * @param  {Object} stackGroups   The items grouped by axisId and stackId\n * @param {Number} dataStartIndex The start index of the data series when a brush is applied\n * @param {Number} dataEndIndex   The end index of the data series when a brush is applied\n * @return {Object}               Configuration\n */ var getAxisMapByItems = function getAxisMapByItems(props, _ref3) {\n    var graphicalItems = _ref3.graphicalItems, Axis = _ref3.Axis, axisType = _ref3.axisType, axisIdKey = _ref3.axisIdKey, stackGroups = _ref3.stackGroups, dataStartIndex = _ref3.dataStartIndex, dataEndIndex = _ref3.dataEndIndex;\n    var layout = props.layout, children = props.children;\n    var displayedData = getDisplayedData(props.data, {\n        graphicalItems: graphicalItems,\n        dataStartIndex: dataStartIndex,\n        dataEndIndex: dataEndIndex\n    });\n    var len = displayedData.length;\n    var isCategorical = (0, _ChartUtils.isCategoricalAxis)(layout, axisType);\n    var index = -1;\n    // The default type of x-axis is category axis,\n    // The default contents of x-axis is the serial numbers of data\n    // The default type of y-axis is number axis\n    // The default contents of y-axis is the domain of data\n    return graphicalItems.reduce(function(result, child) {\n        var childProps = child.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, child.type.defaultProps), child.props) : child.props;\n        var axisId = childProps[axisIdKey];\n        var originalDomain = getDefaultDomainByAxisType(\"number\");\n        if (!result[axisId]) {\n            index++;\n            var domain;\n            if (isCategorical) {\n                domain = (0, _range[\"default\"])(0, len);\n            } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack) {\n                domain = (0, _ChartUtils.getDomainOfStackGroups)(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);\n                domain = (0, _DetectReferenceElementsDomain.detectReferenceElementsDomain)(children, domain, axisId, axisType);\n            } else {\n                domain = (0, _ChartUtils.parseSpecifiedDomain)(originalDomain, (0, _ChartUtils.getDomainOfItemsWithSameAxis)(displayedData, graphicalItems.filter(function(item) {\n                    var _defaultProps4, _defaultProps5;\n                    var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps4 = item.type.defaultProps) === null || _defaultProps4 === void 0 ? void 0 : _defaultProps4[axisIdKey];\n                    var itemHide = \"hide\" in item.props ? item.props.hide : (_defaultProps5 = item.type.defaultProps) === null || _defaultProps5 === void 0 ? void 0 : _defaultProps5.hide;\n                    return itemAxisId === axisId && !itemHide;\n                }), \"number\", layout), Axis.defaultProps.allowDataOverflow);\n                domain = (0, _DetectReferenceElementsDomain.detectReferenceElementsDomain)(children, domain, axisId, axisType);\n            }\n            return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({\n                axisType: axisType\n            }, Axis.defaultProps), {}, {\n                hide: true,\n                orientation: (0, _get[\"default\"])(ORIENT_MAP, \"\".concat(axisType, \".\").concat(index % 2), null),\n                domain: domain,\n                originalDomain: originalDomain,\n                isCategorical: isCategorical,\n                layout: layout\n            })));\n        }\n        return result;\n    }, {});\n};\n/**\n * Get the configuration of all x-axis or y-axis\n * @param  {Object} props          Latest props\n * @param  {String} axisType       The type of axis\n * @param  {React.ComponentType}  [AxisComp]      Axis Component\n * @param  {Array}  graphicalItems The instances of item\n * @param  {Object} stackGroups    The items grouped by axisId and stackId\n * @param {Number} dataStartIndex  The start index of the data series when a brush is applied\n * @param {Number} dataEndIndex    The end index of the data series when a brush is applied\n * @return {Object}          Configuration\n */ var getAxisMap = function getAxisMap(props, _ref4) {\n    var _ref4$axisType = _ref4.axisType, axisType = _ref4$axisType === void 0 ? \"xAxis\" : _ref4$axisType, AxisComp = _ref4.AxisComp, graphicalItems = _ref4.graphicalItems, stackGroups = _ref4.stackGroups, dataStartIndex = _ref4.dataStartIndex, dataEndIndex = _ref4.dataEndIndex;\n    var children = props.children;\n    var axisIdKey = \"\".concat(axisType, \"Id\");\n    // Get all the instance of Axis\n    var axes = (0, _ReactUtils.findAllByType)(children, AxisComp);\n    var axisMap = {};\n    if (axes && axes.length) {\n        axisMap = getAxisMapByAxes(props, {\n            axes: axes,\n            graphicalItems: graphicalItems,\n            axisType: axisType,\n            axisIdKey: axisIdKey,\n            stackGroups: stackGroups,\n            dataStartIndex: dataStartIndex,\n            dataEndIndex: dataEndIndex\n        });\n    } else if (graphicalItems && graphicalItems.length) {\n        axisMap = getAxisMapByItems(props, {\n            Axis: AxisComp,\n            graphicalItems: graphicalItems,\n            axisType: axisType,\n            axisIdKey: axisIdKey,\n            stackGroups: stackGroups,\n            dataStartIndex: dataStartIndex,\n            dataEndIndex: dataEndIndex\n        });\n    }\n    return axisMap;\n};\nvar tooltipTicksGenerator = function tooltipTicksGenerator(axisMap) {\n    var axis = (0, _DataUtils.getAnyElementOfObject)(axisMap);\n    var tooltipTicks = (0, _ChartUtils.getTicksOfAxis)(axis, false, true);\n    return {\n        tooltipTicks: tooltipTicks,\n        orderedTooltipTicks: (0, _sortBy[\"default\"])(tooltipTicks, function(o) {\n            return o.coordinate;\n        }),\n        tooltipAxis: axis,\n        tooltipAxisBandSize: (0, _ChartUtils.getBandSizeOfAxis)(axis, tooltipTicks)\n    };\n};\n/**\n * Returns default, reset state for the categorical chart.\n * @param {Object} props Props object to use when creating the default state\n * @return {Object} Whole new state\n */ var createDefaultState = exports.createDefaultState = function createDefaultState(props) {\n    var children = props.children, defaultShowTooltip = props.defaultShowTooltip;\n    var brushItem = (0, _ReactUtils.findChildByType)(children, _Brush.Brush);\n    var startIndex = 0;\n    var endIndex = 0;\n    if (props.data && props.data.length !== 0) {\n        endIndex = props.data.length - 1;\n    }\n    if (brushItem && brushItem.props) {\n        if (brushItem.props.startIndex >= 0) {\n            startIndex = brushItem.props.startIndex;\n        }\n        if (brushItem.props.endIndex >= 0) {\n            endIndex = brushItem.props.endIndex;\n        }\n    }\n    return {\n        chartX: 0,\n        chartY: 0,\n        dataStartIndex: startIndex,\n        dataEndIndex: endIndex,\n        activeTooltipIndex: -1,\n        isTooltipActive: Boolean(defaultShowTooltip)\n    };\n};\nvar hasGraphicalBarItem = function hasGraphicalBarItem(graphicalItems) {\n    if (!graphicalItems || !graphicalItems.length) {\n        return false;\n    }\n    return graphicalItems.some(function(item) {\n        var name = (0, _ReactUtils.getDisplayName)(item && item.type);\n        return name && name.indexOf(\"Bar\") >= 0;\n    });\n};\nvar getAxisNameByLayout = function getAxisNameByLayout(layout) {\n    if (layout === \"horizontal\") {\n        return {\n            numericAxisName: \"yAxis\",\n            cateAxisName: \"xAxis\"\n        };\n    }\n    if (layout === \"vertical\") {\n        return {\n            numericAxisName: \"xAxis\",\n            cateAxisName: \"yAxis\"\n        };\n    }\n    if (layout === \"centric\") {\n        return {\n            numericAxisName: \"radiusAxis\",\n            cateAxisName: \"angleAxis\"\n        };\n    }\n    return {\n        numericAxisName: \"angleAxis\",\n        cateAxisName: \"radiusAxis\"\n    };\n};\n/**\n * Calculate the offset of main part in the svg element\n * @param  {Object} params.props          Latest props\n * @param  {Array}  params.graphicalItems The instances of item\n * @param  {Object} params.xAxisMap       The configuration of x-axis\n * @param  {Object} params.yAxisMap       The configuration of y-axis\n * @param  {Object} prevLegendBBox        The boundary box of legend\n * @return {Object} The offset of main part in the svg element\n */ var calculateOffset = function calculateOffset(_ref5, prevLegendBBox) {\n    var props = _ref5.props, graphicalItems = _ref5.graphicalItems, _ref5$xAxisMap = _ref5.xAxisMap, xAxisMap = _ref5$xAxisMap === void 0 ? {} : _ref5$xAxisMap, _ref5$yAxisMap = _ref5.yAxisMap, yAxisMap = _ref5$yAxisMap === void 0 ? {} : _ref5$yAxisMap;\n    var width = props.width, height = props.height, children = props.children;\n    var margin = props.margin || {};\n    var brushItem = (0, _ReactUtils.findChildByType)(children, _Brush.Brush);\n    var legendItem = (0, _ReactUtils.findChildByType)(children, _Legend.Legend);\n    var offsetH = Object.keys(yAxisMap).reduce(function(result, id) {\n        var entry = yAxisMap[id];\n        var orientation = entry.orientation;\n        if (!entry.mirror && !entry.hide) {\n            return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, result[orientation] + entry.width));\n        }\n        return result;\n    }, {\n        left: margin.left || 0,\n        right: margin.right || 0\n    });\n    var offsetV = Object.keys(xAxisMap).reduce(function(result, id) {\n        var entry = xAxisMap[id];\n        var orientation = entry.orientation;\n        if (!entry.mirror && !entry.hide) {\n            return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, (0, _get[\"default\"])(result, \"\".concat(orientation)) + entry.height));\n        }\n        return result;\n    }, {\n        top: margin.top || 0,\n        bottom: margin.bottom || 0\n    });\n    var offset = _objectSpread(_objectSpread({}, offsetV), offsetH);\n    var brushBottom = offset.bottom;\n    if (brushItem) {\n        offset.bottom += brushItem.props.height || _Brush.Brush.defaultProps.height;\n    }\n    if (legendItem && prevLegendBBox) {\n        // @ts-expect-error margin is optional in props but required in appendOffsetOfLegend\n        offset = (0, _ChartUtils.appendOffsetOfLegend)(offset, graphicalItems, props, prevLegendBBox);\n    }\n    var offsetWidth = width - offset.left - offset.right;\n    var offsetHeight = height - offset.top - offset.bottom;\n    return _objectSpread(_objectSpread({\n        brushBottom: brushBottom\n    }, offset), {}, {\n        // never return negative values for height and width\n        width: Math.max(offsetWidth, 0),\n        height: Math.max(offsetHeight, 0)\n    });\n};\n// Determine the size of the axis, used for calculation of relative bar sizes\nvar getCartesianAxisSize = function getCartesianAxisSize(axisObj, axisName) {\n    if (axisName === \"xAxis\") {\n        return axisObj[axisName].width;\n    }\n    if (axisName === \"yAxis\") {\n        return axisObj[axisName].height;\n    }\n    // This is only supported for Bar charts (i.e. charts with cartesian axes), so we should never get here\n    return undefined;\n};\nvar generateCategoricalChart = exports.generateCategoricalChart = function generateCategoricalChart(_ref6) {\n    var chartName = _ref6.chartName, GraphicalChild = _ref6.GraphicalChild, _ref6$defaultTooltipE = _ref6.defaultTooltipEventType, defaultTooltipEventType = _ref6$defaultTooltipE === void 0 ? \"axis\" : _ref6$defaultTooltipE, _ref6$validateTooltip = _ref6.validateTooltipEventTypes, validateTooltipEventTypes = _ref6$validateTooltip === void 0 ? [\n        \"axis\"\n    ] : _ref6$validateTooltip, axisComponents = _ref6.axisComponents, legendContent = _ref6.legendContent, formatAxisMap = _ref6.formatAxisMap, defaultProps = _ref6.defaultProps;\n    var getFormatItems = function getFormatItems(props, currentState) {\n        var graphicalItems = currentState.graphicalItems, stackGroups = currentState.stackGroups, offset = currentState.offset, updateId = currentState.updateId, dataStartIndex = currentState.dataStartIndex, dataEndIndex = currentState.dataEndIndex;\n        var barSize = props.barSize, layout = props.layout, barGap = props.barGap, barCategoryGap = props.barCategoryGap, globalMaxBarSize = props.maxBarSize;\n        var _getAxisNameByLayout = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout.numericAxisName, cateAxisName = _getAxisNameByLayout.cateAxisName;\n        var hasBar = hasGraphicalBarItem(graphicalItems);\n        var formattedItems = [];\n        graphicalItems.forEach(function(item, index) {\n            var displayedData = getDisplayedData(props.data, {\n                graphicalItems: [\n                    item\n                ],\n                dataStartIndex: dataStartIndex,\n                dataEndIndex: dataEndIndex\n            });\n            var itemProps = item.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n            var dataKey = itemProps.dataKey, childMaxBarSize = itemProps.maxBarSize;\n            // axisId of the numerical axis\n            var numericAxisId = itemProps[\"\".concat(numericAxisName, \"Id\")];\n            // axisId of the categorical axis\n            var cateAxisId = itemProps[\"\".concat(cateAxisName, \"Id\")];\n            var axisObjInitialValue = {};\n            var axisObj = axisComponents.reduce(function(result, entry) {\n                var _item$type$displayNam, _item$type;\n                // map of axisId to axis for a specific axis type\n                var axisMap = currentState[\"\".concat(entry.axisType, \"Map\")];\n                // axisId of axis we are currently computing\n                var id = itemProps[\"\".concat(entry.axisType, \"Id\")];\n                /**\n         * tell the user in dev mode that their configuration is incorrect if we cannot find a match between\n         * axisId on the chart and axisId on the axis. zAxis does not get passed in the map for ComposedChart,\n         * leave it out of the check for now.\n         */ !(axisMap && axisMap[id] || entry.axisType === \"zAxis\") ?  true ? (0, _tinyInvariant[\"default\"])(false, \"Specifying a(n) \".concat(entry.axisType, \"Id requires a corresponding \").concat(entry.axisType, \"Id on the targeted graphical component \").concat((_item$type$displayNam = item === null || item === void 0 || (_item$type = item.type) === null || _item$type === void 0 ? void 0 : _item$type.displayName) !== null && _item$type$displayNam !== void 0 ? _item$type$displayNam : \"\")) : 0 : void 0;\n                // the axis we are currently formatting\n                var axis = axisMap[id];\n                return _objectSpread(_objectSpread({}, result), {}, _defineProperty(_defineProperty({}, entry.axisType, axis), \"\".concat(entry.axisType, \"Ticks\"), (0, _ChartUtils.getTicksOfAxis)(axis)));\n            }, axisObjInitialValue);\n            var cateAxis = axisObj[cateAxisName];\n            var cateTicks = axisObj[\"\".concat(cateAxisName, \"Ticks\")];\n            var stackedData = stackGroups && stackGroups[numericAxisId] && stackGroups[numericAxisId].hasStack && (0, _ChartUtils.getStackedDataOfItem)(item, stackGroups[numericAxisId].stackGroups);\n            var itemIsBar = (0, _ReactUtils.getDisplayName)(item.type).indexOf(\"Bar\") >= 0;\n            var bandSize = (0, _ChartUtils.getBandSizeOfAxis)(cateAxis, cateTicks);\n            var barPosition = [];\n            var sizeList = hasBar && (0, _ChartUtils.getBarSizeList)({\n                barSize: barSize,\n                stackGroups: stackGroups,\n                totalSize: getCartesianAxisSize(axisObj, cateAxisName)\n            });\n            if (itemIsBar) {\n                var _ref7, _getBandSizeOfAxis;\n                // If it is bar, calculate the position of bar\n                var maxBarSize = (0, _isNil[\"default\"])(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;\n                var barBandSize = (_ref7 = (_getBandSizeOfAxis = (0, _ChartUtils.getBandSizeOfAxis)(cateAxis, cateTicks, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref7 !== void 0 ? _ref7 : 0;\n                barPosition = (0, _ChartUtils.getBarPosition)({\n                    barGap: barGap,\n                    barCategoryGap: barCategoryGap,\n                    bandSize: barBandSize !== bandSize ? barBandSize : bandSize,\n                    sizeList: sizeList[cateAxisId],\n                    maxBarSize: maxBarSize\n                });\n                if (barBandSize !== bandSize) {\n                    barPosition = barPosition.map(function(pos) {\n                        return _objectSpread(_objectSpread({}, pos), {}, {\n                            position: _objectSpread(_objectSpread({}, pos.position), {}, {\n                                offset: pos.position.offset - barBandSize / 2\n                            })\n                        });\n                    });\n                }\n            }\n            // @ts-expect-error we should stop reading data from ReactElements\n            var composedFn = item && item.type && item.type.getComposedData;\n            if (composedFn) {\n                formattedItems.push({\n                    props: _objectSpread(_objectSpread({}, composedFn(_objectSpread(_objectSpread({}, axisObj), {}, {\n                        displayedData: displayedData,\n                        props: props,\n                        dataKey: dataKey,\n                        item: item,\n                        bandSize: bandSize,\n                        barPosition: barPosition,\n                        offset: offset,\n                        stackedData: stackedData,\n                        layout: layout,\n                        dataStartIndex: dataStartIndex,\n                        dataEndIndex: dataEndIndex\n                    }))), {}, _defineProperty(_defineProperty(_defineProperty({\n                        key: item.key || \"item-\".concat(index)\n                    }, numericAxisName, axisObj[numericAxisName]), cateAxisName, axisObj[cateAxisName]), \"animationId\", updateId)),\n                    childIndex: (0, _ReactUtils.parseChildIndex)(item, props.children),\n                    item: item\n                });\n            }\n        });\n        return formattedItems;\n    };\n    /**\n   * The AxisMaps are expensive to render on large data sets\n   * so provide the ability to store them in state and only update them when necessary\n   * they are dependent upon the start and end index of\n   * the brush so it's important that this method is called _after_\n   * the state is updated with any new start/end indices\n   *\n   * @param {Object} props          The props object to be used for updating the axismaps\n   * dataStartIndex: The start index of the data series when a brush is applied\n   * dataEndIndex: The end index of the data series when a brush is applied\n   * updateId: The update id\n   * @param {Object} prevState      Prev state\n   * @return {Object} state New state to set\n   */ var updateStateOfAxisMapsOffsetAndStackGroups = function updateStateOfAxisMapsOffsetAndStackGroups(_ref8, prevState) {\n        var props = _ref8.props, dataStartIndex = _ref8.dataStartIndex, dataEndIndex = _ref8.dataEndIndex, updateId = _ref8.updateId;\n        if (!(0, _ReactUtils.validateWidthHeight)({\n            props: props\n        })) {\n            return null;\n        }\n        var children = props.children, layout = props.layout, stackOffset = props.stackOffset, data = props.data, reverseStackOrder = props.reverseStackOrder;\n        var _getAxisNameByLayout2 = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout2.numericAxisName, cateAxisName = _getAxisNameByLayout2.cateAxisName;\n        var graphicalItems = (0, _ReactUtils.findAllByType)(children, GraphicalChild);\n        var stackGroups = (0, _ChartUtils.getStackGroupsByAxisId)(data, graphicalItems, \"\".concat(numericAxisName, \"Id\"), \"\".concat(cateAxisName, \"Id\"), stackOffset, reverseStackOrder);\n        var axisObj = axisComponents.reduce(function(result, entry) {\n            var name = \"\".concat(entry.axisType, \"Map\");\n            return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, name, getAxisMap(props, _objectSpread(_objectSpread({}, entry), {}, {\n                graphicalItems: graphicalItems,\n                stackGroups: entry.axisType === numericAxisName && stackGroups,\n                dataStartIndex: dataStartIndex,\n                dataEndIndex: dataEndIndex\n            }))));\n        }, {});\n        var offset = calculateOffset(_objectSpread(_objectSpread({}, axisObj), {}, {\n            props: props,\n            graphicalItems: graphicalItems\n        }), prevState === null || prevState === void 0 ? void 0 : prevState.legendBBox);\n        Object.keys(axisObj).forEach(function(key) {\n            axisObj[key] = formatAxisMap(props, axisObj[key], offset, key.replace(\"Map\", \"\"), chartName);\n        });\n        var cateAxisMap = axisObj[\"\".concat(cateAxisName, \"Map\")];\n        var ticksObj = tooltipTicksGenerator(cateAxisMap);\n        var formattedGraphicalItems = getFormatItems(props, _objectSpread(_objectSpread({}, axisObj), {}, {\n            dataStartIndex: dataStartIndex,\n            dataEndIndex: dataEndIndex,\n            updateId: updateId,\n            graphicalItems: graphicalItems,\n            stackGroups: stackGroups,\n            offset: offset\n        }));\n        return _objectSpread(_objectSpread({\n            formattedGraphicalItems: formattedGraphicalItems,\n            graphicalItems: graphicalItems,\n            offset: offset,\n            stackGroups: stackGroups\n        }, ticksObj), axisObj);\n    };\n    var CategoricalChartWrapper = /*#__PURE__*/ function(_Component) {\n        function CategoricalChartWrapper(_props) {\n            var _props$id, _props$throttleDelay;\n            var _this;\n            _classCallCheck(this, CategoricalChartWrapper);\n            _this = _callSuper(this, CategoricalChartWrapper, [\n                _props\n            ]);\n            _defineProperty(_this, \"eventEmitterSymbol\", Symbol(\"rechartsEventEmitter\"));\n            _defineProperty(_this, \"accessibilityManager\", new _AccessibilityManager.AccessibilityManager());\n            _defineProperty(_this, \"handleLegendBBoxUpdate\", function(box) {\n                if (box) {\n                    var _this$state = _this.state, dataStartIndex = _this$state.dataStartIndex, dataEndIndex = _this$state.dataEndIndex, updateId = _this$state.updateId;\n                    _this.setState(_objectSpread({\n                        legendBBox: box\n                    }, updateStateOfAxisMapsOffsetAndStackGroups({\n                        props: _this.props,\n                        dataStartIndex: dataStartIndex,\n                        dataEndIndex: dataEndIndex,\n                        updateId: updateId\n                    }, _objectSpread(_objectSpread({}, _this.state), {}, {\n                        legendBBox: box\n                    }))));\n                }\n            });\n            _defineProperty(_this, \"handleReceiveSyncEvent\", function(cId, data, emitter) {\n                if (_this.props.syncId === cId) {\n                    if (emitter === _this.eventEmitterSymbol && typeof _this.props.syncMethod !== \"function\") {\n                        return;\n                    }\n                    _this.applySyncEvent(data);\n                }\n            });\n            _defineProperty(_this, \"handleBrushChange\", function(_ref9) {\n                var startIndex = _ref9.startIndex, endIndex = _ref9.endIndex;\n                // Only trigger changes if the extents of the brush have actually changed\n                if (startIndex !== _this.state.dataStartIndex || endIndex !== _this.state.dataEndIndex) {\n                    var updateId = _this.state.updateId;\n                    _this.setState(function() {\n                        return _objectSpread({\n                            dataStartIndex: startIndex,\n                            dataEndIndex: endIndex\n                        }, updateStateOfAxisMapsOffsetAndStackGroups({\n                            props: _this.props,\n                            dataStartIndex: startIndex,\n                            dataEndIndex: endIndex,\n                            updateId: updateId\n                        }, _this.state));\n                    });\n                    _this.triggerSyncEvent({\n                        dataStartIndex: startIndex,\n                        dataEndIndex: endIndex\n                    });\n                }\n            });\n            /**\n       * The handler of mouse entering chart\n       * @param  {Object} e              Event object\n       * @return {Null}                  null\n       */ _defineProperty(_this, \"handleMouseEnter\", function(e) {\n                var mouse = _this.getMouseInfo(e);\n                if (mouse) {\n                    var _nextState = _objectSpread(_objectSpread({}, mouse), {}, {\n                        isTooltipActive: true\n                    });\n                    _this.setState(_nextState);\n                    _this.triggerSyncEvent(_nextState);\n                    var onMouseEnter = _this.props.onMouseEnter;\n                    if ((0, _isFunction[\"default\"])(onMouseEnter)) {\n                        onMouseEnter(_nextState, e);\n                    }\n                }\n            });\n            _defineProperty(_this, \"triggeredAfterMouseMove\", function(e) {\n                var mouse = _this.getMouseInfo(e);\n                var nextState = mouse ? _objectSpread(_objectSpread({}, mouse), {}, {\n                    isTooltipActive: true\n                }) : {\n                    isTooltipActive: false\n                };\n                _this.setState(nextState);\n                _this.triggerSyncEvent(nextState);\n                var onMouseMove = _this.props.onMouseMove;\n                if ((0, _isFunction[\"default\"])(onMouseMove)) {\n                    onMouseMove(nextState, e);\n                }\n            });\n            /**\n       * The handler of mouse entering a scatter\n       * @param {Object} el The active scatter\n       * @return {Object} no return\n       */ _defineProperty(_this, \"handleItemMouseEnter\", function(el) {\n                _this.setState(function() {\n                    return {\n                        isTooltipActive: true,\n                        activeItem: el,\n                        activePayload: el.tooltipPayload,\n                        activeCoordinate: el.tooltipPosition || {\n                            x: el.cx,\n                            y: el.cy\n                        }\n                    };\n                });\n            });\n            /**\n       * The handler of mouse leaving a scatter\n       * @return {Object} no return\n       */ _defineProperty(_this, \"handleItemMouseLeave\", function() {\n                _this.setState(function() {\n                    return {\n                        isTooltipActive: false\n                    };\n                });\n            });\n            /**\n       * The handler of mouse moving in chart\n       * @param  {React.MouseEvent} e        Event object\n       * @return {void} no return\n       */ _defineProperty(_this, \"handleMouseMove\", function(e) {\n                e.persist();\n                _this.throttleTriggeredAfterMouseMove(e);\n            });\n            /**\n       * The handler if mouse leaving chart\n       * @param {Object} e Event object\n       * @return {Null} no return\n       */ _defineProperty(_this, \"handleMouseLeave\", function(e) {\n                _this.throttleTriggeredAfterMouseMove.cancel();\n                var nextState = {\n                    isTooltipActive: false\n                };\n                _this.setState(nextState);\n                _this.triggerSyncEvent(nextState);\n                var onMouseLeave = _this.props.onMouseLeave;\n                if ((0, _isFunction[\"default\"])(onMouseLeave)) {\n                    onMouseLeave(nextState, e);\n                }\n            });\n            _defineProperty(_this, \"handleOuterEvent\", function(e) {\n                var eventName = (0, _ReactUtils.getReactEventByType)(e);\n                var event = (0, _get[\"default\"])(_this.props, \"\".concat(eventName));\n                if (eventName && (0, _isFunction[\"default\"])(event)) {\n                    var _mouse;\n                    var mouse;\n                    if (/.*touch.*/i.test(eventName)) {\n                        mouse = _this.getMouseInfo(e.changedTouches[0]);\n                    } else {\n                        mouse = _this.getMouseInfo(e);\n                    }\n                    event((_mouse = mouse) !== null && _mouse !== void 0 ? _mouse : {}, e);\n                }\n            });\n            _defineProperty(_this, \"handleClick\", function(e) {\n                var mouse = _this.getMouseInfo(e);\n                if (mouse) {\n                    var _nextState2 = _objectSpread(_objectSpread({}, mouse), {}, {\n                        isTooltipActive: true\n                    });\n                    _this.setState(_nextState2);\n                    _this.triggerSyncEvent(_nextState2);\n                    var onClick = _this.props.onClick;\n                    if ((0, _isFunction[\"default\"])(onClick)) {\n                        onClick(_nextState2, e);\n                    }\n                }\n            });\n            _defineProperty(_this, \"handleMouseDown\", function(e) {\n                var onMouseDown = _this.props.onMouseDown;\n                if ((0, _isFunction[\"default\"])(onMouseDown)) {\n                    var _nextState3 = _this.getMouseInfo(e);\n                    onMouseDown(_nextState3, e);\n                }\n            });\n            _defineProperty(_this, \"handleMouseUp\", function(e) {\n                var onMouseUp = _this.props.onMouseUp;\n                if ((0, _isFunction[\"default\"])(onMouseUp)) {\n                    var _nextState4 = _this.getMouseInfo(e);\n                    onMouseUp(_nextState4, e);\n                }\n            });\n            _defineProperty(_this, \"handleTouchMove\", function(e) {\n                if (e.changedTouches != null && e.changedTouches.length > 0) {\n                    _this.throttleTriggeredAfterMouseMove(e.changedTouches[0]);\n                }\n            });\n            _defineProperty(_this, \"handleTouchStart\", function(e) {\n                if (e.changedTouches != null && e.changedTouches.length > 0) {\n                    _this.handleMouseDown(e.changedTouches[0]);\n                }\n            });\n            _defineProperty(_this, \"handleTouchEnd\", function(e) {\n                if (e.changedTouches != null && e.changedTouches.length > 0) {\n                    _this.handleMouseUp(e.changedTouches[0]);\n                }\n            });\n            _defineProperty(_this, \"handleDoubleClick\", function(e) {\n                var onDoubleClick = _this.props.onDoubleClick;\n                if ((0, _isFunction[\"default\"])(onDoubleClick)) {\n                    var _nextState5 = _this.getMouseInfo(e);\n                    onDoubleClick(_nextState5, e);\n                }\n            });\n            _defineProperty(_this, \"handleContextMenu\", function(e) {\n                var onContextMenu = _this.props.onContextMenu;\n                if ((0, _isFunction[\"default\"])(onContextMenu)) {\n                    var _nextState6 = _this.getMouseInfo(e);\n                    onContextMenu(_nextState6, e);\n                }\n            });\n            _defineProperty(_this, \"triggerSyncEvent\", function(data) {\n                if (_this.props.syncId !== undefined) {\n                    _Events.eventCenter.emit(_Events.SYNC_EVENT, _this.props.syncId, data, _this.eventEmitterSymbol);\n                }\n            });\n            _defineProperty(_this, \"applySyncEvent\", function(data) {\n                var _this$props = _this.props, layout = _this$props.layout, syncMethod = _this$props.syncMethod;\n                var updateId = _this.state.updateId;\n                var dataStartIndex = data.dataStartIndex, dataEndIndex = data.dataEndIndex;\n                if (data.dataStartIndex !== undefined || data.dataEndIndex !== undefined) {\n                    _this.setState(_objectSpread({\n                        dataStartIndex: dataStartIndex,\n                        dataEndIndex: dataEndIndex\n                    }, updateStateOfAxisMapsOffsetAndStackGroups({\n                        props: _this.props,\n                        dataStartIndex: dataStartIndex,\n                        dataEndIndex: dataEndIndex,\n                        updateId: updateId\n                    }, _this.state)));\n                } else if (data.activeTooltipIndex !== undefined) {\n                    var chartX = data.chartX, chartY = data.chartY;\n                    var activeTooltipIndex = data.activeTooltipIndex;\n                    var _this$state2 = _this.state, offset = _this$state2.offset, tooltipTicks = _this$state2.tooltipTicks;\n                    if (!offset) {\n                        return;\n                    }\n                    if (typeof syncMethod === \"function\") {\n                        // Call a callback function. If there is an application specific algorithm\n                        activeTooltipIndex = syncMethod(tooltipTicks, data);\n                    } else if (syncMethod === \"value\") {\n                        // Set activeTooltipIndex to the index with the same value as data.activeLabel\n                        // For loop instead of findIndex because the latter is very slow in some browsers\n                        activeTooltipIndex = -1; // in case we cannot find the element\n                        for(var i = 0; i < tooltipTicks.length; i++){\n                            if (tooltipTicks[i].value === data.activeLabel) {\n                                activeTooltipIndex = i;\n                                break;\n                            }\n                        }\n                    }\n                    var viewBox = _objectSpread(_objectSpread({}, offset), {}, {\n                        x: offset.left,\n                        y: offset.top\n                    });\n                    // When a categorical chart is combined with another chart, the value of chartX\n                    // and chartY may beyond the boundaries.\n                    var validateChartX = Math.min(chartX, viewBox.x + viewBox.width);\n                    var validateChartY = Math.min(chartY, viewBox.y + viewBox.height);\n                    var activeLabel = tooltipTicks[activeTooltipIndex] && tooltipTicks[activeTooltipIndex].value;\n                    var activePayload = getTooltipContent(_this.state, _this.props.data, activeTooltipIndex);\n                    var activeCoordinate = tooltipTicks[activeTooltipIndex] ? {\n                        x: layout === \"horizontal\" ? tooltipTicks[activeTooltipIndex].coordinate : validateChartX,\n                        y: layout === \"horizontal\" ? validateChartY : tooltipTicks[activeTooltipIndex].coordinate\n                    } : originCoordinate;\n                    _this.setState(_objectSpread(_objectSpread({}, data), {}, {\n                        activeLabel: activeLabel,\n                        activeCoordinate: activeCoordinate,\n                        activePayload: activePayload,\n                        activeTooltipIndex: activeTooltipIndex\n                    }));\n                } else {\n                    _this.setState(data);\n                }\n            });\n            _defineProperty(_this, \"renderCursor\", function(element) {\n                var _element$props$active;\n                var _this$state3 = _this.state, isTooltipActive = _this$state3.isTooltipActive, activeCoordinate = _this$state3.activeCoordinate, activePayload = _this$state3.activePayload, offset = _this$state3.offset, activeTooltipIndex = _this$state3.activeTooltipIndex, tooltipAxisBandSize = _this$state3.tooltipAxisBandSize;\n                var tooltipEventType = _this.getTooltipEventType();\n                // The cursor is a part of the Tooltip, and it should be shown (by default) when the Tooltip is active.\n                var isActive = (_element$props$active = element.props.active) !== null && _element$props$active !== void 0 ? _element$props$active : isTooltipActive;\n                var layout = _this.props.layout;\n                var key = element.key || \"_recharts-cursor\";\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Cursor.Cursor, {\n                    key: key,\n                    activeCoordinate: activeCoordinate,\n                    activePayload: activePayload,\n                    activeTooltipIndex: activeTooltipIndex,\n                    chartName: chartName,\n                    element: element,\n                    isActive: isActive,\n                    layout: layout,\n                    offset: offset,\n                    tooltipAxisBandSize: tooltipAxisBandSize,\n                    tooltipEventType: tooltipEventType\n                });\n            });\n            _defineProperty(_this, \"renderPolarAxis\", function(element, displayName, index) {\n                var axisType = (0, _get[\"default\"])(element, \"type.axisType\");\n                var axisMap = (0, _get[\"default\"])(_this.state, \"\".concat(axisType, \"Map\"));\n                var elementDefaultProps = element.type.defaultProps;\n                var elementProps = elementDefaultProps !== undefined ? _objectSpread(_objectSpread({}, elementDefaultProps), element.props) : element.props;\n                var axisOption = axisMap && axisMap[elementProps[\"\".concat(axisType, \"Id\")]];\n                return /*#__PURE__*/ (0, _react.cloneElement)(element, _objectSpread(_objectSpread({}, axisOption), {}, {\n                    className: (0, _clsx[\"default\"])(axisType, axisOption.className),\n                    key: element.key || \"\".concat(displayName, \"-\").concat(index),\n                    ticks: (0, _ChartUtils.getTicksOfAxis)(axisOption, true)\n                }));\n            });\n            _defineProperty(_this, \"renderPolarGrid\", function(element) {\n                var _element$props = element.props, radialLines = _element$props.radialLines, polarAngles = _element$props.polarAngles, polarRadius = _element$props.polarRadius;\n                var _this$state4 = _this.state, radiusAxisMap = _this$state4.radiusAxisMap, angleAxisMap = _this$state4.angleAxisMap;\n                var radiusAxis = (0, _DataUtils.getAnyElementOfObject)(radiusAxisMap);\n                var angleAxis = (0, _DataUtils.getAnyElementOfObject)(angleAxisMap);\n                var cx = angleAxis.cx, cy = angleAxis.cy, innerRadius = angleAxis.innerRadius, outerRadius = angleAxis.outerRadius;\n                return /*#__PURE__*/ (0, _react.cloneElement)(element, {\n                    polarAngles: Array.isArray(polarAngles) ? polarAngles : (0, _ChartUtils.getTicksOfAxis)(angleAxis, true).map(function(entry) {\n                        return entry.coordinate;\n                    }),\n                    polarRadius: Array.isArray(polarRadius) ? polarRadius : (0, _ChartUtils.getTicksOfAxis)(radiusAxis, true).map(function(entry) {\n                        return entry.coordinate;\n                    }),\n                    cx: cx,\n                    cy: cy,\n                    innerRadius: innerRadius,\n                    outerRadius: outerRadius,\n                    key: element.key || \"polar-grid\",\n                    radialLines: radialLines\n                });\n            });\n            /**\n       * Draw legend\n       * @return {ReactElement}            The instance of Legend\n       */ _defineProperty(_this, \"renderLegend\", function() {\n                var formattedGraphicalItems = _this.state.formattedGraphicalItems;\n                var _this$props2 = _this.props, children = _this$props2.children, width = _this$props2.width, height = _this$props2.height;\n                var margin = _this.props.margin || {};\n                var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n                var props = (0, _ChartUtils.getLegendProps)({\n                    children: children,\n                    formattedGraphicalItems: formattedGraphicalItems,\n                    legendWidth: legendWidth,\n                    legendContent: legendContent\n                });\n                if (!props) {\n                    return null;\n                }\n                var item = props.item, otherProps = _objectWithoutProperties(props, _excluded);\n                return /*#__PURE__*/ (0, _react.cloneElement)(item, _objectSpread(_objectSpread({}, otherProps), {}, {\n                    chartWidth: width,\n                    chartHeight: height,\n                    margin: margin,\n                    onBBoxUpdate: _this.handleLegendBBoxUpdate\n                }));\n            });\n            /**\n       * Draw Tooltip\n       * @return {ReactElement}  The instance of Tooltip\n       */ _defineProperty(_this, \"renderTooltip\", function() {\n                var _tooltipItem$props$ac;\n                var _this$props3 = _this.props, children = _this$props3.children, accessibilityLayer = _this$props3.accessibilityLayer;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                if (!tooltipItem) {\n                    return null;\n                }\n                var _this$state5 = _this.state, isTooltipActive = _this$state5.isTooltipActive, activeCoordinate = _this$state5.activeCoordinate, activePayload = _this$state5.activePayload, activeLabel = _this$state5.activeLabel, offset = _this$state5.offset;\n                // The user can set isActive on the Tooltip,\n                // and we respect the user to enable customisation.\n                // The Tooltip is active if the user has set isActive, or if the tooltip is active due to a mouse event.\n                var isActive = (_tooltipItem$props$ac = tooltipItem.props.active) !== null && _tooltipItem$props$ac !== void 0 ? _tooltipItem$props$ac : isTooltipActive;\n                return /*#__PURE__*/ (0, _react.cloneElement)(tooltipItem, {\n                    viewBox: _objectSpread(_objectSpread({}, offset), {}, {\n                        x: offset.left,\n                        y: offset.top\n                    }),\n                    active: isActive,\n                    label: activeLabel,\n                    payload: isActive ? activePayload : [],\n                    coordinate: activeCoordinate,\n                    accessibilityLayer: accessibilityLayer\n                });\n            });\n            _defineProperty(_this, \"renderBrush\", function(element) {\n                var _this$props4 = _this.props, margin = _this$props4.margin, data = _this$props4.data;\n                var _this$state6 = _this.state, offset = _this$state6.offset, dataStartIndex = _this$state6.dataStartIndex, dataEndIndex = _this$state6.dataEndIndex, updateId = _this$state6.updateId;\n                // TODO: update brush when children update\n                return /*#__PURE__*/ (0, _react.cloneElement)(element, {\n                    key: element.key || \"_recharts-brush\",\n                    onChange: (0, _ChartUtils.combineEventHandlers)(_this.handleBrushChange, element.props.onChange),\n                    data: data,\n                    x: (0, _DataUtils.isNumber)(element.props.x) ? element.props.x : offset.left,\n                    y: (0, _DataUtils.isNumber)(element.props.y) ? element.props.y : offset.top + offset.height + offset.brushBottom - (margin.bottom || 0),\n                    width: (0, _DataUtils.isNumber)(element.props.width) ? element.props.width : offset.width,\n                    startIndex: dataStartIndex,\n                    endIndex: dataEndIndex,\n                    updateId: \"brush-\".concat(updateId)\n                });\n            });\n            _defineProperty(_this, \"renderReferenceElement\", function(element, displayName, index) {\n                if (!element) {\n                    return null;\n                }\n                var _this2 = _this, clipPathId = _this2.clipPathId;\n                var _this$state7 = _this.state, xAxisMap = _this$state7.xAxisMap, yAxisMap = _this$state7.yAxisMap, offset = _this$state7.offset;\n                var elementDefaultProps = element.type.defaultProps || {};\n                var _element$props2 = element.props, _element$props2$xAxis = _element$props2.xAxisId, xAxisId = _element$props2$xAxis === void 0 ? elementDefaultProps.xAxisId : _element$props2$xAxis, _element$props2$yAxis = _element$props2.yAxisId, yAxisId = _element$props2$yAxis === void 0 ? elementDefaultProps.yAxisId : _element$props2$yAxis;\n                return /*#__PURE__*/ (0, _react.cloneElement)(element, {\n                    key: element.key || \"\".concat(displayName, \"-\").concat(index),\n                    xAxis: xAxisMap[xAxisId],\n                    yAxis: yAxisMap[yAxisId],\n                    viewBox: {\n                        x: offset.left,\n                        y: offset.top,\n                        width: offset.width,\n                        height: offset.height\n                    },\n                    clipPathId: clipPathId\n                });\n            });\n            _defineProperty(_this, \"renderActivePoints\", function(_ref10) {\n                var item = _ref10.item, activePoint = _ref10.activePoint, basePoint = _ref10.basePoint, childIndex = _ref10.childIndex, isRange = _ref10.isRange;\n                var result = [];\n                // item is not a React Element so we don't need to resolve defaultProps.\n                var key = item.props.key;\n                var itemItemProps = item.item.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, item.item.type.defaultProps), item.item.props) : item.item.props;\n                var activeDot = itemItemProps.activeDot, dataKey = itemItemProps.dataKey;\n                var dotProps = _objectSpread(_objectSpread({\n                    index: childIndex,\n                    dataKey: dataKey,\n                    cx: activePoint.x,\n                    cy: activePoint.y,\n                    r: 4,\n                    fill: (0, _ChartUtils.getMainColorOfGraphicItem)(item.item),\n                    strokeWidth: 2,\n                    stroke: \"#fff\",\n                    payload: activePoint.payload,\n                    value: activePoint.value\n                }, (0, _ReactUtils.filterProps)(activeDot, false)), (0, _types.adaptEventHandlers)(activeDot));\n                result.push(CategoricalChartWrapper.renderActiveDot(activeDot, dotProps, \"\".concat(key, \"-activePoint-\").concat(childIndex)));\n                if (basePoint) {\n                    result.push(CategoricalChartWrapper.renderActiveDot(activeDot, _objectSpread(_objectSpread({}, dotProps), {}, {\n                        cx: basePoint.x,\n                        cy: basePoint.y\n                    }), \"\".concat(key, \"-basePoint-\").concat(childIndex)));\n                } else if (isRange) {\n                    result.push(null);\n                }\n                return result;\n            });\n            _defineProperty(_this, \"renderGraphicChild\", function(element, displayName, index) {\n                var item = _this.filterFormatItem(element, displayName, index);\n                if (!item) {\n                    return null;\n                }\n                var tooltipEventType = _this.getTooltipEventType();\n                var _this$state8 = _this.state, isTooltipActive = _this$state8.isTooltipActive, tooltipAxis = _this$state8.tooltipAxis, activeTooltipIndex = _this$state8.activeTooltipIndex, activeLabel = _this$state8.activeLabel;\n                var children = _this.props.children;\n                var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                // item is not a React Element so we don't need to resolve defaultProps\n                var _item$props = item.props, points = _item$props.points, isRange = _item$props.isRange, baseLine = _item$props.baseLine;\n                var itemItemProps = item.item.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, item.item.type.defaultProps), item.item.props) : item.item.props;\n                var activeDot = itemItemProps.activeDot, hide = itemItemProps.hide, activeBar = itemItemProps.activeBar, activeShape = itemItemProps.activeShape;\n                var hasActive = Boolean(!hide && isTooltipActive && tooltipItem && (activeDot || activeBar || activeShape));\n                var itemEvents = {};\n                if (tooltipEventType !== \"axis\" && tooltipItem && tooltipItem.props.trigger === \"click\") {\n                    itemEvents = {\n                        onClick: (0, _ChartUtils.combineEventHandlers)(_this.handleItemMouseEnter, element.props.onClick)\n                    };\n                } else if (tooltipEventType !== \"axis\") {\n                    itemEvents = {\n                        onMouseLeave: (0, _ChartUtils.combineEventHandlers)(_this.handleItemMouseLeave, element.props.onMouseLeave),\n                        onMouseEnter: (0, _ChartUtils.combineEventHandlers)(_this.handleItemMouseEnter, element.props.onMouseEnter)\n                    };\n                }\n                var graphicalItem = /*#__PURE__*/ (0, _react.cloneElement)(element, _objectSpread(_objectSpread({}, item.props), itemEvents));\n                function findWithPayload(entry) {\n                    // TODO needs to verify dataKey is Function\n                    return typeof tooltipAxis.dataKey === \"function\" ? tooltipAxis.dataKey(entry.payload) : null;\n                }\n                if (hasActive) {\n                    if (activeTooltipIndex >= 0) {\n                        var activePoint, basePoint;\n                        if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {\n                            // number transform to string\n                            var specifiedKey = typeof tooltipAxis.dataKey === \"function\" ? findWithPayload : \"payload.\".concat(tooltipAxis.dataKey.toString());\n                            activePoint = (0, _DataUtils.findEntryInArray)(points, specifiedKey, activeLabel);\n                            basePoint = isRange && baseLine && (0, _DataUtils.findEntryInArray)(baseLine, specifiedKey, activeLabel);\n                        } else {\n                            activePoint = points === null || points === void 0 ? void 0 : points[activeTooltipIndex];\n                            basePoint = isRange && baseLine && baseLine[activeTooltipIndex];\n                        }\n                        if (activeShape || activeBar) {\n                            var activeIndex = element.props.activeIndex !== undefined ? element.props.activeIndex : activeTooltipIndex;\n                            return [\n                                /*#__PURE__*/ (0, _react.cloneElement)(element, _objectSpread(_objectSpread(_objectSpread({}, item.props), itemEvents), {}, {\n                                    activeIndex: activeIndex\n                                })),\n                                null,\n                                null\n                            ];\n                        }\n                        if (!(0, _isNil[\"default\"])(activePoint)) {\n                            return [\n                                graphicalItem\n                            ].concat(_toConsumableArray(_this.renderActivePoints({\n                                item: item,\n                                activePoint: activePoint,\n                                basePoint: basePoint,\n                                childIndex: activeTooltipIndex,\n                                isRange: isRange\n                            })));\n                        }\n                    } else {\n                        var _this$getItemByXY;\n                        /**\n             * We hit this block if consumer uses a Tooltip without XAxis and/or YAxis.\n             * In which case, this.state.activeTooltipIndex never gets set\n             * because the mouse events that trigger that value getting set never get trigged without the axis components.\n             *\n             * An example usage case is a FunnelChart\n             */ var _ref11 = (_this$getItemByXY = _this.getItemByXY(_this.state.activeCoordinate)) !== null && _this$getItemByXY !== void 0 ? _this$getItemByXY : {\n                            graphicalItem: graphicalItem\n                        }, _ref11$graphicalItem = _ref11.graphicalItem, _ref11$graphicalItem$ = _ref11$graphicalItem.item, xyItem = _ref11$graphicalItem$ === void 0 ? element : _ref11$graphicalItem$, childIndex = _ref11$graphicalItem.childIndex;\n                        var elementProps = _objectSpread(_objectSpread(_objectSpread({}, item.props), itemEvents), {}, {\n                            activeIndex: childIndex\n                        });\n                        return [\n                            /*#__PURE__*/ (0, _react.cloneElement)(xyItem, elementProps),\n                            null,\n                            null\n                        ];\n                    }\n                }\n                if (isRange) {\n                    return [\n                        graphicalItem,\n                        null,\n                        null\n                    ];\n                }\n                return [\n                    graphicalItem,\n                    null\n                ];\n            });\n            _defineProperty(_this, \"renderCustomized\", function(element, displayName, index) {\n                return /*#__PURE__*/ (0, _react.cloneElement)(element, _objectSpread(_objectSpread({\n                    key: \"recharts-customized-\".concat(index)\n                }, _this.props), _this.state));\n            });\n            _defineProperty(_this, \"renderMap\", {\n                CartesianGrid: {\n                    handler: renderAsIs,\n                    once: true\n                },\n                ReferenceArea: {\n                    handler: _this.renderReferenceElement\n                },\n                ReferenceLine: {\n                    handler: renderAsIs\n                },\n                ReferenceDot: {\n                    handler: _this.renderReferenceElement\n                },\n                XAxis: {\n                    handler: renderAsIs\n                },\n                YAxis: {\n                    handler: renderAsIs\n                },\n                Brush: {\n                    handler: _this.renderBrush,\n                    once: true\n                },\n                Bar: {\n                    handler: _this.renderGraphicChild\n                },\n                Line: {\n                    handler: _this.renderGraphicChild\n                },\n                Area: {\n                    handler: _this.renderGraphicChild\n                },\n                Radar: {\n                    handler: _this.renderGraphicChild\n                },\n                RadialBar: {\n                    handler: _this.renderGraphicChild\n                },\n                Scatter: {\n                    handler: _this.renderGraphicChild\n                },\n                Pie: {\n                    handler: _this.renderGraphicChild\n                },\n                Funnel: {\n                    handler: _this.renderGraphicChild\n                },\n                Tooltip: {\n                    handler: _this.renderCursor,\n                    once: true\n                },\n                PolarGrid: {\n                    handler: _this.renderPolarGrid,\n                    once: true\n                },\n                PolarAngleAxis: {\n                    handler: _this.renderPolarAxis\n                },\n                PolarRadiusAxis: {\n                    handler: _this.renderPolarAxis\n                },\n                Customized: {\n                    handler: _this.renderCustomized\n                }\n            });\n            _this.clipPathId = \"\".concat((_props$id = _props.id) !== null && _props$id !== void 0 ? _props$id : (0, _DataUtils.uniqueId)(\"recharts\"), \"-clip\");\n            // trigger 60fps\n            _this.throttleTriggeredAfterMouseMove = (0, _throttle[\"default\"])(_this.triggeredAfterMouseMove, (_props$throttleDelay = _props.throttleDelay) !== null && _props$throttleDelay !== void 0 ? _props$throttleDelay : 1000 / 60);\n            _this.state = {};\n            return _this;\n        }\n        _inherits(CategoricalChartWrapper, _Component);\n        return _createClass(CategoricalChartWrapper, [\n            {\n                key: \"componentDidMount\",\n                value: function componentDidMount() {\n                    var _this$props$margin$le, _this$props$margin$to;\n                    this.addListener();\n                    this.accessibilityManager.setDetails({\n                        container: this.container,\n                        offset: {\n                            left: (_this$props$margin$le = this.props.margin.left) !== null && _this$props$margin$le !== void 0 ? _this$props$margin$le : 0,\n                            top: (_this$props$margin$to = this.props.margin.top) !== null && _this$props$margin$to !== void 0 ? _this$props$margin$to : 0\n                        },\n                        coordinateList: this.state.tooltipTicks,\n                        mouseHandlerCallback: this.triggeredAfterMouseMove,\n                        layout: this.props.layout\n                    });\n                    this.displayDefaultTooltip();\n                }\n            },\n            {\n                key: \"displayDefaultTooltip\",\n                value: function displayDefaultTooltip() {\n                    var _this$props5 = this.props, children = _this$props5.children, data = _this$props5.data, height = _this$props5.height, layout = _this$props5.layout;\n                    var tooltipElem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                    // If the chart doesn't include a <Tooltip /> element, there's no tooltip to display\n                    if (!tooltipElem) {\n                        return;\n                    }\n                    var defaultIndex = tooltipElem.props.defaultIndex;\n                    // Protect against runtime errors\n                    if (typeof defaultIndex !== \"number\" || defaultIndex < 0 || defaultIndex > this.state.tooltipTicks.length - 1) {\n                        return;\n                    }\n                    var activeLabel = this.state.tooltipTicks[defaultIndex] && this.state.tooltipTicks[defaultIndex].value;\n                    var activePayload = getTooltipContent(this.state, data, defaultIndex, activeLabel);\n                    var independentAxisCoord = this.state.tooltipTicks[defaultIndex].coordinate;\n                    var dependentAxisCoord = (this.state.offset.top + height) / 2;\n                    var isHorizontal = layout === \"horizontal\";\n                    var activeCoordinate = isHorizontal ? {\n                        x: independentAxisCoord,\n                        y: dependentAxisCoord\n                    } : {\n                        y: independentAxisCoord,\n                        x: dependentAxisCoord\n                    };\n                    // Unlike other chart types, scatter plot's tooltip positions rely on both X and Y coordinates. Only the scatter plot\n                    // element knows its own Y coordinates.\n                    // If there's a scatter plot, we'll want to grab that element for an interrogation.\n                    var scatterPlotElement = this.state.formattedGraphicalItems.find(function(_ref12) {\n                        var item = _ref12.item;\n                        return item.type.name === \"Scatter\";\n                    });\n                    if (scatterPlotElement) {\n                        activeCoordinate = _objectSpread(_objectSpread({}, activeCoordinate), scatterPlotElement.props.points[defaultIndex].tooltipPosition);\n                        activePayload = scatterPlotElement.props.points[defaultIndex].tooltipPayload;\n                    }\n                    var nextState = {\n                        activeTooltipIndex: defaultIndex,\n                        isTooltipActive: true,\n                        activeLabel: activeLabel,\n                        activePayload: activePayload,\n                        activeCoordinate: activeCoordinate\n                    };\n                    this.setState(nextState);\n                    this.renderCursor(tooltipElem);\n                    // Make sure that anyone who keyboard-only users who tab to the chart will start their\n                    // cursors at defaultIndex\n                    this.accessibilityManager.setIndex(defaultIndex);\n                }\n            },\n            {\n                key: \"getSnapshotBeforeUpdate\",\n                value: function getSnapshotBeforeUpdate(prevProps, prevState) {\n                    if (!this.props.accessibilityLayer) {\n                        return null;\n                    }\n                    if (this.state.tooltipTicks !== prevState.tooltipTicks) {\n                        this.accessibilityManager.setDetails({\n                            coordinateList: this.state.tooltipTicks\n                        });\n                    }\n                    if (this.props.layout !== prevProps.layout) {\n                        this.accessibilityManager.setDetails({\n                            layout: this.props.layout\n                        });\n                    }\n                    if (this.props.margin !== prevProps.margin) {\n                        var _this$props$margin$le2, _this$props$margin$to2;\n                        this.accessibilityManager.setDetails({\n                            offset: {\n                                left: (_this$props$margin$le2 = this.props.margin.left) !== null && _this$props$margin$le2 !== void 0 ? _this$props$margin$le2 : 0,\n                                top: (_this$props$margin$to2 = this.props.margin.top) !== null && _this$props$margin$to2 !== void 0 ? _this$props$margin$to2 : 0\n                            }\n                        });\n                    }\n                    // Something has to be returned for getSnapshotBeforeUpdate\n                    return null;\n                }\n            },\n            {\n                key: \"componentDidUpdate\",\n                value: function componentDidUpdate(prevProps) {\n                    // Check to see if the Tooltip updated. If so, re-check default tooltip position\n                    if (!(0, _ReactUtils.isChildrenEqual)([\n                        (0, _ReactUtils.findChildByType)(prevProps.children, _Tooltip.Tooltip)\n                    ], [\n                        (0, _ReactUtils.findChildByType)(this.props.children, _Tooltip.Tooltip)\n                    ])) {\n                        this.displayDefaultTooltip();\n                    }\n                }\n            },\n            {\n                key: \"componentWillUnmount\",\n                value: function componentWillUnmount() {\n                    this.removeListener();\n                    this.throttleTriggeredAfterMouseMove.cancel();\n                }\n            },\n            {\n                key: \"getTooltipEventType\",\n                value: function getTooltipEventType() {\n                    var tooltipItem = (0, _ReactUtils.findChildByType)(this.props.children, _Tooltip.Tooltip);\n                    if (tooltipItem && typeof tooltipItem.props.shared === \"boolean\") {\n                        var eventType = tooltipItem.props.shared ? \"axis\" : \"item\";\n                        return validateTooltipEventTypes.indexOf(eventType) >= 0 ? eventType : defaultTooltipEventType;\n                    }\n                    return defaultTooltipEventType;\n                }\n            },\n            {\n                key: \"getMouseInfo\",\n                value: function getMouseInfo(event) {\n                    if (!this.container) {\n                        return null;\n                    }\n                    var element = this.container;\n                    var boundingRect = element.getBoundingClientRect();\n                    var containerOffset = (0, _DOMUtils.getOffset)(boundingRect);\n                    var e = {\n                        chartX: Math.round(event.pageX - containerOffset.left),\n                        chartY: Math.round(event.pageY - containerOffset.top)\n                    };\n                    var scale = boundingRect.width / element.offsetWidth || 1;\n                    var rangeObj = this.inRange(e.chartX, e.chartY, scale);\n                    if (!rangeObj) {\n                        return null;\n                    }\n                    var _this$state9 = this.state, xAxisMap = _this$state9.xAxisMap, yAxisMap = _this$state9.yAxisMap;\n                    var tooltipEventType = this.getTooltipEventType();\n                    if (tooltipEventType !== \"axis\" && xAxisMap && yAxisMap) {\n                        var xScale = (0, _DataUtils.getAnyElementOfObject)(xAxisMap).scale;\n                        var yScale = (0, _DataUtils.getAnyElementOfObject)(yAxisMap).scale;\n                        var xValue = xScale && xScale.invert ? xScale.invert(e.chartX) : null;\n                        var yValue = yScale && yScale.invert ? yScale.invert(e.chartY) : null;\n                        return _objectSpread(_objectSpread({}, e), {}, {\n                            xValue: xValue,\n                            yValue: yValue\n                        });\n                    }\n                    var toolTipData = getTooltipData(this.state, this.props.data, this.props.layout, rangeObj);\n                    if (toolTipData) {\n                        return _objectSpread(_objectSpread({}, e), toolTipData);\n                    }\n                    return null;\n                }\n            },\n            {\n                key: \"inRange\",\n                value: function inRange(x, y) {\n                    var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n                    var layout = this.props.layout;\n                    var scaledX = x / scale, scaledY = y / scale;\n                    if (layout === \"horizontal\" || layout === \"vertical\") {\n                        var offset = this.state.offset;\n                        var isInRange = scaledX >= offset.left && scaledX <= offset.left + offset.width && scaledY >= offset.top && scaledY <= offset.top + offset.height;\n                        return isInRange ? {\n                            x: scaledX,\n                            y: scaledY\n                        } : null;\n                    }\n                    var _this$state10 = this.state, angleAxisMap = _this$state10.angleAxisMap, radiusAxisMap = _this$state10.radiusAxisMap;\n                    if (angleAxisMap && radiusAxisMap) {\n                        var angleAxis = (0, _DataUtils.getAnyElementOfObject)(angleAxisMap);\n                        return (0, _PolarUtils.inRangeOfSector)({\n                            x: scaledX,\n                            y: scaledY\n                        }, angleAxis);\n                    }\n                    return null;\n                }\n            },\n            {\n                key: \"parseEventsOfWrapper\",\n                value: function parseEventsOfWrapper() {\n                    var children = this.props.children;\n                    var tooltipEventType = this.getTooltipEventType();\n                    var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip);\n                    var tooltipEvents = {};\n                    if (tooltipItem && tooltipEventType === \"axis\") {\n                        if (tooltipItem.props.trigger === \"click\") {\n                            tooltipEvents = {\n                                onClick: this.handleClick\n                            };\n                        } else {\n                            tooltipEvents = {\n                                onMouseEnter: this.handleMouseEnter,\n                                onDoubleClick: this.handleDoubleClick,\n                                onMouseMove: this.handleMouseMove,\n                                onMouseLeave: this.handleMouseLeave,\n                                onTouchMove: this.handleTouchMove,\n                                onTouchStart: this.handleTouchStart,\n                                onTouchEnd: this.handleTouchEnd,\n                                onContextMenu: this.handleContextMenu\n                            };\n                        }\n                    }\n                    // @ts-expect-error adaptEventHandlers expects DOM Event but generateCategoricalChart works with React UIEvents\n                    var outerEvents = (0, _types.adaptEventHandlers)(this.props, this.handleOuterEvent);\n                    return _objectSpread(_objectSpread({}, outerEvents), tooltipEvents);\n                }\n            },\n            {\n                key: \"addListener\",\n                value: function addListener() {\n                    _Events.eventCenter.on(_Events.SYNC_EVENT, this.handleReceiveSyncEvent);\n                }\n            },\n            {\n                key: \"removeListener\",\n                value: function removeListener() {\n                    _Events.eventCenter.removeListener(_Events.SYNC_EVENT, this.handleReceiveSyncEvent);\n                }\n            },\n            {\n                key: \"filterFormatItem\",\n                value: function filterFormatItem(item, displayName, childIndex) {\n                    var formattedGraphicalItems = this.state.formattedGraphicalItems;\n                    for(var i = 0, len = formattedGraphicalItems.length; i < len; i++){\n                        var entry = formattedGraphicalItems[i];\n                        if (entry.item === item || entry.props.key === item.key || displayName === (0, _ReactUtils.getDisplayName)(entry.item.type) && childIndex === entry.childIndex) {\n                            return entry;\n                        }\n                    }\n                    return null;\n                }\n            },\n            {\n                key: \"renderClipPath\",\n                value: function renderClipPath() {\n                    var clipPathId = this.clipPathId;\n                    var _this$state$offset = this.state.offset, left = _this$state$offset.left, top = _this$state$offset.top, height = _this$state$offset.height, width = _this$state$offset.width;\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"defs\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"clipPath\", {\n                        id: clipPathId\n                    }, /*#__PURE__*/ _react[\"default\"].createElement(\"rect\", {\n                        x: left,\n                        y: top,\n                        height: height,\n                        width: width\n                    })));\n                }\n            },\n            {\n                key: \"getXScales\",\n                value: function getXScales() {\n                    var xAxisMap = this.state.xAxisMap;\n                    return xAxisMap ? Object.entries(xAxisMap).reduce(function(res, _ref13) {\n                        var _ref14 = _slicedToArray(_ref13, 2), axisId = _ref14[0], axisProps = _ref14[1];\n                        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));\n                    }, {}) : null;\n                }\n            },\n            {\n                key: \"getYScales\",\n                value: function getYScales() {\n                    var yAxisMap = this.state.yAxisMap;\n                    return yAxisMap ? Object.entries(yAxisMap).reduce(function(res, _ref15) {\n                        var _ref16 = _slicedToArray(_ref15, 2), axisId = _ref16[0], axisProps = _ref16[1];\n                        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));\n                    }, {}) : null;\n                }\n            },\n            {\n                key: \"getXScaleByAxisId\",\n                value: function getXScaleByAxisId(axisId) {\n                    var _this$state$xAxisMap;\n                    return (_this$state$xAxisMap = this.state.xAxisMap) === null || _this$state$xAxisMap === void 0 || (_this$state$xAxisMap = _this$state$xAxisMap[axisId]) === null || _this$state$xAxisMap === void 0 ? void 0 : _this$state$xAxisMap.scale;\n                }\n            },\n            {\n                key: \"getYScaleByAxisId\",\n                value: function getYScaleByAxisId(axisId) {\n                    var _this$state$yAxisMap;\n                    return (_this$state$yAxisMap = this.state.yAxisMap) === null || _this$state$yAxisMap === void 0 || (_this$state$yAxisMap = _this$state$yAxisMap[axisId]) === null || _this$state$yAxisMap === void 0 ? void 0 : _this$state$yAxisMap.scale;\n                }\n            },\n            {\n                key: \"getItemByXY\",\n                value: function getItemByXY(chartXY) {\n                    var _this$state11 = this.state, formattedGraphicalItems = _this$state11.formattedGraphicalItems, activeItem = _this$state11.activeItem;\n                    if (formattedGraphicalItems && formattedGraphicalItems.length) {\n                        for(var i = 0, len = formattedGraphicalItems.length; i < len; i++){\n                            var graphicalItem = formattedGraphicalItems[i];\n                            // graphicalItem is not a React Element so we don't need to resolve defaultProps\n                            var props = graphicalItem.props, item = graphicalItem.item;\n                            var itemProps = item.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n                            var itemDisplayName = (0, _ReactUtils.getDisplayName)(item.type);\n                            if (itemDisplayName === \"Bar\") {\n                                var activeBarItem = (props.data || []).find(function(entry) {\n                                    return (0, _Rectangle.isInRectangle)(chartXY, entry);\n                                });\n                                if (activeBarItem) {\n                                    return {\n                                        graphicalItem: graphicalItem,\n                                        payload: activeBarItem\n                                    };\n                                }\n                            } else if (itemDisplayName === \"RadialBar\") {\n                                var _activeBarItem = (props.data || []).find(function(entry) {\n                                    return (0, _PolarUtils.inRangeOfSector)(chartXY, entry);\n                                });\n                                if (_activeBarItem) {\n                                    return {\n                                        graphicalItem: graphicalItem,\n                                        payload: _activeBarItem\n                                    };\n                                }\n                            } else if ((0, _ActiveShapeUtils.isFunnel)(graphicalItem, activeItem) || (0, _ActiveShapeUtils.isPie)(graphicalItem, activeItem) || (0, _ActiveShapeUtils.isScatter)(graphicalItem, activeItem)) {\n                                var activeIndex = (0, _ActiveShapeUtils.getActiveShapeIndexForTooltip)({\n                                    graphicalItem: graphicalItem,\n                                    activeTooltipItem: activeItem,\n                                    itemData: itemProps.data\n                                });\n                                var childIndex = itemProps.activeIndex === undefined ? activeIndex : itemProps.activeIndex;\n                                return {\n                                    graphicalItem: _objectSpread(_objectSpread({}, graphicalItem), {}, {\n                                        childIndex: childIndex\n                                    }),\n                                    payload: (0, _ActiveShapeUtils.isScatter)(graphicalItem, activeItem) ? itemProps.data[activeIndex] : graphicalItem.props.data[activeIndex]\n                                };\n                            }\n                        }\n                    }\n                    return null;\n                }\n            },\n            {\n                key: \"render\",\n                value: function render() {\n                    var _this3 = this;\n                    if (!(0, _ReactUtils.validateWidthHeight)(this)) {\n                        return null;\n                    }\n                    var _this$props6 = this.props, children = _this$props6.children, className = _this$props6.className, width = _this$props6.width, height = _this$props6.height, style = _this$props6.style, compact = _this$props6.compact, title = _this$props6.title, desc = _this$props6.desc, others = _objectWithoutProperties(_this$props6, _excluded2);\n                    var attrs = (0, _ReactUtils.filterProps)(others, false);\n                    // The \"compact\" mode is mainly used as the panorama within Brush\n                    if (compact) {\n                        return /*#__PURE__*/ _react[\"default\"].createElement(_chartLayoutContext.ChartLayoutContextProvider, {\n                            state: this.state,\n                            width: this.props.width,\n                            height: this.props.height,\n                            clipPathId: this.clipPathId\n                        }, /*#__PURE__*/ _react[\"default\"].createElement(_Surface.Surface, _extends({}, attrs, {\n                            width: width,\n                            height: height,\n                            title: title,\n                            desc: desc\n                        }), this.renderClipPath(), (0, _ReactUtils.renderByOrder)(children, this.renderMap)));\n                    }\n                    if (this.props.accessibilityLayer) {\n                        var _this$props$tabIndex, _this$props$role;\n                        // Set tabIndex to 0 by default (can be overwritten)\n                        attrs.tabIndex = (_this$props$tabIndex = this.props.tabIndex) !== null && _this$props$tabIndex !== void 0 ? _this$props$tabIndex : 0;\n                        // Set role to img by default (can be overwritten)\n                        attrs.role = (_this$props$role = this.props.role) !== null && _this$props$role !== void 0 ? _this$props$role : \"application\";\n                        attrs.onKeyDown = function(e) {\n                            _this3.accessibilityManager.keyboardEvent(e);\n                        // 'onKeyDown' is not currently a supported prop that can be passed through\n                        // if it's added, this should be added: this.props.onKeyDown(e);\n                        };\n                        attrs.onFocus = function() {\n                            _this3.accessibilityManager.focus();\n                        // 'onFocus' is not currently a supported prop that can be passed through\n                        // if it's added, the focus event should be forwarded to the prop\n                        };\n                    }\n                    var events = this.parseEventsOfWrapper();\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_chartLayoutContext.ChartLayoutContextProvider, {\n                        state: this.state,\n                        width: this.props.width,\n                        height: this.props.height,\n                        clipPathId: this.clipPathId\n                    }, /*#__PURE__*/ _react[\"default\"].createElement(\"div\", _extends({\n                        className: (0, _clsx[\"default\"])(\"recharts-wrapper\", className),\n                        style: _objectSpread({\n                            position: \"relative\",\n                            cursor: \"default\",\n                            width: width,\n                            height: height\n                        }, style)\n                    }, events, {\n                        ref: function ref(node) {\n                            _this3.container = node;\n                        }\n                    }), /*#__PURE__*/ _react[\"default\"].createElement(_Surface.Surface, _extends({}, attrs, {\n                        width: width,\n                        height: height,\n                        title: title,\n                        desc: desc,\n                        style: FULL_WIDTH_AND_HEIGHT\n                    }), this.renderClipPath(), (0, _ReactUtils.renderByOrder)(children, this.renderMap)), this.renderLegend(), this.renderTooltip()));\n                }\n            }\n        ]);\n    }(_react.Component);\n    _defineProperty(CategoricalChartWrapper, \"displayName\", chartName);\n    // todo join specific chart propTypes\n    _defineProperty(CategoricalChartWrapper, \"defaultProps\", _objectSpread({\n        layout: \"horizontal\",\n        stackOffset: \"none\",\n        barCategoryGap: \"10%\",\n        barGap: 4,\n        margin: {\n            top: 5,\n            right: 5,\n            bottom: 5,\n            left: 5\n        },\n        reverseStackOrder: false,\n        syncMethod: \"index\"\n    }, defaultProps));\n    _defineProperty(CategoricalChartWrapper, \"getDerivedStateFromProps\", function(nextProps, prevState) {\n        var dataKey = nextProps.dataKey, data = nextProps.data, children = nextProps.children, width = nextProps.width, height = nextProps.height, layout = nextProps.layout, stackOffset = nextProps.stackOffset, margin = nextProps.margin;\n        var dataStartIndex = prevState.dataStartIndex, dataEndIndex = prevState.dataEndIndex;\n        if (prevState.updateId === undefined) {\n            var defaultState = createDefaultState(nextProps);\n            return _objectSpread(_objectSpread(_objectSpread({}, defaultState), {}, {\n                updateId: 0\n            }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({\n                props: nextProps\n            }, defaultState), {}, {\n                updateId: 0\n            }), prevState)), {}, {\n                prevDataKey: dataKey,\n                prevData: data,\n                prevWidth: width,\n                prevHeight: height,\n                prevLayout: layout,\n                prevStackOffset: stackOffset,\n                prevMargin: margin,\n                prevChildren: children\n            });\n        }\n        if (dataKey !== prevState.prevDataKey || data !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || layout !== prevState.prevLayout || stackOffset !== prevState.prevStackOffset || !(0, _ShallowEqual.shallowEqual)(margin, prevState.prevMargin)) {\n            var _defaultState = createDefaultState(nextProps);\n            // Fixes https://github.com/recharts/recharts/issues/2143\n            var keepFromPrevState = {\n                // (chartX, chartY) are (0,0) in default state, but we want to keep the last mouse position to avoid\n                // any flickering\n                chartX: prevState.chartX,\n                chartY: prevState.chartY,\n                // The tooltip should stay active when it was active in the previous render. If this is not\n                // the case, the tooltip disappears and immediately re-appears, causing a flickering effect\n                isTooltipActive: prevState.isTooltipActive\n            };\n            var updatesToState = _objectSpread(_objectSpread({}, getTooltipData(prevState, data, layout)), {}, {\n                updateId: prevState.updateId + 1\n            });\n            var newState = _objectSpread(_objectSpread(_objectSpread({}, _defaultState), keepFromPrevState), updatesToState);\n            return _objectSpread(_objectSpread(_objectSpread({}, newState), updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread({\n                props: nextProps\n            }, newState), prevState)), {}, {\n                prevDataKey: dataKey,\n                prevData: data,\n                prevWidth: width,\n                prevHeight: height,\n                prevLayout: layout,\n                prevStackOffset: stackOffset,\n                prevMargin: margin,\n                prevChildren: children\n            });\n        }\n        if (!(0, _ReactUtils.isChildrenEqual)(children, prevState.prevChildren)) {\n            var _brush$props$startInd, _brush$props, _brush$props$endIndex, _brush$props2;\n            // specifically check for Brush - if it exists and the start and end indexes are different, re-render with the new ones\n            var brush = (0, _ReactUtils.findChildByType)(children, _Brush.Brush);\n            var startIndex = brush ? (_brush$props$startInd = (_brush$props = brush.props) === null || _brush$props === void 0 ? void 0 : _brush$props.startIndex) !== null && _brush$props$startInd !== void 0 ? _brush$props$startInd : dataStartIndex : dataStartIndex;\n            var endIndex = brush ? (_brush$props$endIndex = (_brush$props2 = brush.props) === null || _brush$props2 === void 0 ? void 0 : _brush$props2.endIndex) !== null && _brush$props$endIndex !== void 0 ? _brush$props$endIndex : dataEndIndex : dataEndIndex;\n            var hasDifferentStartOrEndIndex = startIndex !== dataStartIndex || endIndex !== dataEndIndex;\n            // update configuration in children\n            var hasGlobalData = !(0, _isNil[\"default\"])(data);\n            var newUpdateId = hasGlobalData && !hasDifferentStartOrEndIndex ? prevState.updateId : prevState.updateId + 1;\n            return _objectSpread(_objectSpread({\n                updateId: newUpdateId\n            }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({\n                props: nextProps\n            }, prevState), {}, {\n                updateId: newUpdateId,\n                dataStartIndex: startIndex,\n                dataEndIndex: endIndex\n            }), prevState)), {}, {\n                prevChildren: children,\n                dataStartIndex: startIndex,\n                dataEndIndex: endIndex\n            });\n        }\n        return null;\n    });\n    _defineProperty(CategoricalChartWrapper, \"renderActiveDot\", function(option, props, key) {\n        var dot;\n        if (/*#__PURE__*/ (0, _react.isValidElement)(option)) {\n            dot = /*#__PURE__*/ (0, _react.cloneElement)(option, props);\n        } else if ((0, _isFunction[\"default\"])(option)) {\n            dot = option(props);\n        } else {\n            dot = /*#__PURE__*/ _react[\"default\"].createElement(_Dot.Dot, props);\n        }\n        return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n            className: \"recharts-active-dot\",\n            key: key\n        }, dot);\n    });\n    var CategoricalChart = /*#__PURE__*/ (0, _react.forwardRef)(function CategoricalChart(props, ref) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(CategoricalChartWrapper, _extends({}, props, {\n            ref: ref\n        }));\n    });\n    CategoricalChart.displayName = CategoricalChartWrapper.displayName;\n    return CategoricalChart;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NoYXJ0L2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsd0JBQXdCLEdBQUdBLGdDQUFnQyxHQUFHQSwwQkFBMEIsR0FBRyxLQUFLO0FBQ2hHLElBQUlLLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsU0FBU0MsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJRyxjQUFjRCx1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJSSxTQUFTRix1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlLLE9BQU9ILHVCQUF1QkYsbUJBQU9BLENBQUMsOEJBQVk7QUFDdEQsSUFBSU0sVUFBVUosdUJBQXVCRixtQkFBT0EsQ0FBQyxvQ0FBZTtBQUM1RCxJQUFJTyxZQUFZTCx1QkFBdUJGLG1CQUFPQSxDQUFDLHdDQUFpQjtBQUNoRSxJQUFJUSxRQUFRTix1QkFBdUJGLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlTLGlCQUFpQlAsdUJBQXVCRixtQkFBT0EsQ0FBQyxzQ0FBZ0I7QUFDcEUsSUFBSVUsV0FBV1YsbUJBQU9BLENBQUMsOEVBQXNCO0FBQzdDLElBQUlXLFNBQVNYLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJWSxXQUFXWixtQkFBT0EsQ0FBQyw4RUFBc0I7QUFDN0MsSUFBSWEsVUFBVWIsbUJBQU9BLENBQUMsNEVBQXFCO0FBQzNDLElBQUljLE9BQU9kLG1CQUFPQSxDQUFDLDhEQUFjO0FBQ2pDLElBQUllLGFBQWFmLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM3QyxJQUFJZ0IsY0FBY2hCLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJaUIsU0FBU2pCLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJ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cyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9jaGFydC9nZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQuanM/YjI5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0QXhpc01hcEJ5QXhlcyA9IGV4cG9ydHMuZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0ID0gZXhwb3J0cy5jcmVhdGVEZWZhdWx0U3RhdGUgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfaXNOaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNOaWxcIikpO1xudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xudmFyIF9yYW5nZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9yYW5nZVwiKSk7XG52YXIgX2dldCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9nZXRcIikpO1xudmFyIF9zb3J0QnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvc29ydEJ5XCIpKTtcbnZhciBfdGhyb3R0bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvdGhyb3R0bGVcIikpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX3RpbnlJbnZhcmlhbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJ0aW55LWludmFyaWFudFwiKSk7XG52YXIgX1N1cmZhY2UgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL1N1cmZhY2VcIik7XG52YXIgX0xheWVyID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9MYXllclwiKTtcbnZhciBfVG9vbHRpcCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvVG9vbHRpcFwiKTtcbnZhciBfTGVnZW5kID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MZWdlbmRcIik7XG52YXIgX0RvdCA9IHJlcXVpcmUoXCIuLi9zaGFwZS9Eb3RcIik7XG52YXIgX1JlY3RhbmdsZSA9IHJlcXVpcmUoXCIuLi9zaGFwZS9SZWN0YW5nbGVcIik7XG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xudmFyIF9CcnVzaCA9IHJlcXVpcmUoXCIuLi9jYXJ0ZXNpYW4vQnJ1c2hcIik7XG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRE9NVXRpbHNcIik7XG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XG52YXIgX0RldGVjdFJlZmVyZW5jZUVsZW1lbnRzRG9tYWluID0gcmVxdWlyZShcIi4uL3V0aWwvRGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW5cIik7XG52YXIgX1BvbGFyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Qb2xhclV0aWxzXCIpO1xudmFyIF9TaGFsbG93RXF1YWwgPSByZXF1aXJlKFwiLi4vdXRpbC9TaGFsbG93RXF1YWxcIik7XG52YXIgX0V2ZW50cyA9IHJlcXVpcmUoXCIuLi91dGlsL0V2ZW50c1wiKTtcbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi4vdXRpbC90eXBlc1wiKTtcbnZhciBfQWNjZXNzaWJpbGl0eU1hbmFnZXIgPSByZXF1aXJlKFwiLi9BY2Nlc3NpYmlsaXR5TWFuYWdlclwiKTtcbnZhciBfaXNEb21haW5TcGVjaWZpZWRCeVVzZXIgPSByZXF1aXJlKFwiLi4vdXRpbC9pc0RvbWFpblNwZWNpZmllZEJ5VXNlclwiKTtcbnZhciBfQWN0aXZlU2hhcGVVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0FjdGl2ZVNoYXBlVXRpbHNcIik7XG52YXIgX0N1cnNvciA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvQ3Vyc29yXCIpO1xudmFyIF9jaGFydExheW91dENvbnRleHQgPSByZXF1aXJlKFwiLi4vY29udGV4dC9jaGFydExheW91dENvbnRleHRcIik7XG52YXIgX2V4Y2x1ZGVkID0gW1wiaXRlbVwiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJzdHlsZVwiLCBcImNvbXBhY3RcIiwgXCJ0aXRsZVwiLCBcImRlc2NcIl07XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWltcG9ydHNcbnZhciBPUklFTlRfTUFQID0ge1xuICB4QXhpczogWydib3R0b20nLCAndG9wJ10sXG4gIHlBeGlzOiBbJ2xlZnQnLCAncmlnaHQnXVxufTtcbnZhciBGVUxMX1dJRFRIX0FORF9IRUlHSFQgPSB7XG4gIHdpZHRoOiAnMTAwJScsXG4gIGhlaWdodDogJzEwMCUnXG59O1xudmFyIG9yaWdpbkNvb3JkaW5hdGUgPSB7XG4gIHg6IDAsXG4gIHk6IDBcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBleGlzdHMgYXMgYSB0ZW1wb3Jhcnkgd29ya2Fyb3VuZC5cbiAqXG4gKiBXaHk/IGdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCBkb2VzIG5vdCByZW5kZXIgYHtjaGlsZHJlbn1gIGRpcmVjdGx5O1xuICogaW5zdGVhZCBpdCBwYXNzZXMgdGhlbSB0aHJvdWdoIGByZW5kZXJCeU9yZGVyYCBmdW5jdGlvbiB3aGljaCByZWFkcyB0aGVpciBoYW5kbGVycy5cbiAqXG4gKiBTbywgdGhpcyBpcyBhIGhhbmRsZXIgdGhhdCBkb2VzIG5vdGhpbmcuXG4gKiBPbmNlIHdlIGdldCByaWQgb2YgYHJlbmRlckJ5T3JkZXJgIGFuZCBzd2l0Y2ggdG8gSlNYIG9ubHksIHdlIGNhbiBnZXQgcmlkIG9mIHRoaXMgaGFuZGxlciB0b28uXG4gKlxuICogQHBhcmFtIHtKU1h9IGVsZW1lbnQgYXMgaXMgaW4gSlNYXG4gKiBAcmV0dXJucyB7SlNYfSB0aGUgc2FtZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHJlbmRlckFzSXMoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBjYWxjdWxhdGVUb29sdGlwUG9zID0gZnVuY3Rpb24gY2FsY3VsYXRlVG9vbHRpcFBvcyhyYW5nZU9iaiwgbGF5b3V0KSB7XG4gIGlmIChsYXlvdXQgPT09ICdob3Jpem9udGFsJykge1xuICAgIHJldHVybiByYW5nZU9iai54O1xuICB9XG4gIGlmIChsYXlvdXQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICByZXR1cm4gcmFuZ2VPYmoueTtcbiAgfVxuICBpZiAobGF5b3V0ID09PSAnY2VudHJpYycpIHtcbiAgICByZXR1cm4gcmFuZ2VPYmouYW5nbGU7XG4gIH1cbiAgcmV0dXJuIHJhbmdlT2JqLnJhZGl1cztcbn07XG52YXIgZ2V0QWN0aXZlQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldEFjdGl2ZUNvb3JkaW5hdGUobGF5b3V0LCB0b29sdGlwVGlja3MsIGFjdGl2ZUluZGV4LCByYW5nZU9iaikge1xuICB2YXIgZW50cnkgPSB0b29sdGlwVGlja3MuZmluZChmdW5jdGlvbiAodGljaykge1xuICAgIHJldHVybiB0aWNrICYmIHRpY2suaW5kZXggPT09IGFjdGl2ZUluZGV4O1xuICB9KTtcbiAgaWYgKGVudHJ5KSB7XG4gICAgaWYgKGxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBlbnRyeS5jb29yZGluYXRlLFxuICAgICAgICB5OiByYW5nZU9iai55XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobGF5b3V0ID09PSAndmVydGljYWwnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByYW5nZU9iai54LFxuICAgICAgICB5OiBlbnRyeS5jb29yZGluYXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobGF5b3V0ID09PSAnY2VudHJpYycpIHtcbiAgICAgIHZhciBfYW5nbGUgPSBlbnRyeS5jb29yZGluYXRlO1xuICAgICAgdmFyIF9yYWRpdXMgPSByYW5nZU9iai5yYWRpdXM7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJhbmdlT2JqKSwgKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKHJhbmdlT2JqLmN4LCByYW5nZU9iai5jeSwgX3JhZGl1cywgX2FuZ2xlKSksIHt9LCB7XG4gICAgICAgIGFuZ2xlOiBfYW5nbGUsXG4gICAgICAgIHJhZGl1czogX3JhZGl1c1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciByYWRpdXMgPSBlbnRyeS5jb29yZGluYXRlO1xuICAgIHZhciBhbmdsZSA9IHJhbmdlT2JqLmFuZ2xlO1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmFuZ2VPYmopLCAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikocmFuZ2VPYmouY3gsIHJhbmdlT2JqLmN5LCByYWRpdXMsIGFuZ2xlKSksIHt9LCB7XG4gICAgICBhbmdsZTogYW5nbGUsXG4gICAgICByYWRpdXM6IHJhZGl1c1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBvcmlnaW5Db29yZGluYXRlO1xufTtcbnZhciBnZXREaXNwbGF5ZWREYXRhID0gZnVuY3Rpb24gZ2V0RGlzcGxheWVkRGF0YShkYXRhLCBfcmVmKSB7XG4gIHZhciBncmFwaGljYWxJdGVtcyA9IF9yZWYuZ3JhcGhpY2FsSXRlbXMsXG4gICAgZGF0YVN0YXJ0SW5kZXggPSBfcmVmLmRhdGFTdGFydEluZGV4LFxuICAgIGRhdGFFbmRJbmRleCA9IF9yZWYuZGF0YUVuZEluZGV4O1xuICB2YXIgaXRlbXNEYXRhID0gKGdyYXBoaWNhbEl0ZW1zICE9PSBudWxsICYmIGdyYXBoaWNhbEl0ZW1zICE9PSB2b2lkIDAgPyBncmFwaGljYWxJdGVtcyA6IFtdKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgY2hpbGQpIHtcbiAgICB2YXIgaXRlbURhdGEgPSBjaGlsZC5wcm9wcy5kYXRhO1xuICAgIGlmIChpdGVtRGF0YSAmJiBpdGVtRGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlc3VsdCksIF90b0NvbnN1bWFibGVBcnJheShpdGVtRGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBbXSk7XG4gIGlmIChpdGVtc0RhdGEubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBpdGVtc0RhdGE7XG4gIH1cbiAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGRhdGFTdGFydEluZGV4KSAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoZGF0YUVuZEluZGV4KSkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKGRhdGFTdGFydEluZGV4LCBkYXRhRW5kSW5kZXggKyAxKTtcbiAgfVxuICByZXR1cm4gW107XG59O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdERvbWFpbkJ5QXhpc1R5cGUoYXhpc1R5cGUpIHtcbiAgcmV0dXJuIGF4aXNUeXBlID09PSAnbnVtYmVyJyA/IFswLCAnYXV0byddIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY29udGVudCB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIHRvb2x0aXBcbiAqIEBwYXJhbSAge09iamVjdH0gc3RhdGUgICAgICAgICAgQ3VycmVudCBzdGF0ZVxuICogQHBhcmFtICB7QXJyYXl9ICBjaGFydERhdGEgICAgICBUaGUgZGF0YSBkZWZpbmVkIGluIGNoYXJ0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFjdGl2ZUluZGV4ICAgIEFjdGl2ZSBpbmRleCBvZiBkYXRhXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGFjdGl2ZUxhYmVsICAgIEFjdGl2ZSBsYWJlbCBvZiBkYXRhXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgICAgIFRoZSBjb250ZW50IG9mIHRvb2x0aXBcbiAqL1xudmFyIGdldFRvb2x0aXBDb250ZW50ID0gZnVuY3Rpb24gZ2V0VG9vbHRpcENvbnRlbnQoc3RhdGUsIGNoYXJ0RGF0YSwgYWN0aXZlSW5kZXgsIGFjdGl2ZUxhYmVsKSB7XG4gIHZhciBncmFwaGljYWxJdGVtcyA9IHN0YXRlLmdyYXBoaWNhbEl0ZW1zLFxuICAgIHRvb2x0aXBBeGlzID0gc3RhdGUudG9vbHRpcEF4aXM7XG4gIHZhciBkaXNwbGF5ZWREYXRhID0gZ2V0RGlzcGxheWVkRGF0YShjaGFydERhdGEsIHN0YXRlKTtcbiAgaWYgKGFjdGl2ZUluZGV4IDwgMCB8fCAhZ3JhcGhpY2FsSXRlbXMgfHwgIWdyYXBoaWNhbEl0ZW1zLmxlbmd0aCB8fCBhY3RpdmVJbmRleCA+PSBkaXNwbGF5ZWREYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIGdldCBkYXRhIGJ5IGFjdGl2ZUluZGV4IHdoZW4gdGhlIGF4aXMgZG9uJ3QgYWxsb3cgZHVwbGljYXRlZCBjYXRlZ29yeVxuICByZXR1cm4gZ3JhcGhpY2FsSXRlbXMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGNoaWxkKSB7XG4gICAgdmFyIF9jaGlsZCRwcm9wcyRkYXRhO1xuICAgIC8qKlxuICAgICAqIEZpeGVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVjaGFydHMvcmVjaGFydHMvaXNzdWVzLzM2NjlcbiAgICAgKiBEZWZhdWx0aW5nIHRvIGNoYXJ0RGF0YSBiZWxvdyB0byBmaXggYW4gZWRnZSBjYXNlIHdoZXJlIHRoZSB0b29sdGlwIGRvZXMgbm90IGluY2x1ZGUgZGF0YSBmcm9tIGFsbCBjaGFydHNcbiAgICAgKiB3aGVuIGEgc2VwYXJhdGUgZGF0YXNldCBpcyBwYXNzZWQgdG8gY2hhcnQgcHJvcCBkYXRhIGFuZCBzcGVjaWZpZWQgb24gTGluZS9BcmVhL2V0YyBwcm9wIGRhdGFcbiAgICAgKi9cbiAgICB2YXIgZGF0YSA9IChfY2hpbGQkcHJvcHMkZGF0YSA9IGNoaWxkLnByb3BzLmRhdGEpICE9PSBudWxsICYmIF9jaGlsZCRwcm9wcyRkYXRhICE9PSB2b2lkIDAgPyBfY2hpbGQkcHJvcHMkZGF0YSA6IGNoYXJ0RGF0YTtcbiAgICBpZiAoZGF0YSAmJiBzdGF0ZS5kYXRhU3RhcnRJbmRleCArIHN0YXRlLmRhdGFFbmRJbmRleCAhPT0gMCAmJlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWNoYXJ0cy9yZWNoYXJ0cy9pc3N1ZXMvNDcxN1xuICAgIC8vIFRoZSBkYXRhIGlzIHNsaWNlZCBvbmx5IHdoZW4gdGhlIGFjdGl2ZSBpbmRleCBpcyB3aXRoaW4gdGhlIHN0YXJ0L2VuZCBpbmRleCByYW5nZS5cbiAgICBzdGF0ZS5kYXRhRW5kSW5kZXggLSBzdGF0ZS5kYXRhU3RhcnRJbmRleCA+PSBhY3RpdmVJbmRleCkge1xuICAgICAgZGF0YSA9IGRhdGEuc2xpY2Uoc3RhdGUuZGF0YVN0YXJ0SW5kZXgsIHN0YXRlLmRhdGFFbmRJbmRleCArIDEpO1xuICAgIH1cbiAgICB2YXIgcGF5bG9hZDtcbiAgICBpZiAodG9vbHRpcEF4aXMuZGF0YUtleSAmJiAhdG9vbHRpcEF4aXMuYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnkpIHtcbiAgICAgIC8vIGdyYXBoaWMgY2hpbGQgaGFzIGRhdGEgcHJvcHNcbiAgICAgIHZhciBlbnRyaWVzID0gZGF0YSA9PT0gdW5kZWZpbmVkID8gZGlzcGxheWVkRGF0YSA6IGRhdGE7XG4gICAgICBwYXlsb2FkID0gKDAsIF9EYXRhVXRpbHMuZmluZEVudHJ5SW5BcnJheSkoZW50cmllcywgdG9vbHRpcEF4aXMuZGF0YUtleSwgYWN0aXZlTGFiZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXlsb2FkID0gZGF0YSAmJiBkYXRhW2FjdGl2ZUluZGV4XSB8fCBkaXNwbGF5ZWREYXRhW2FjdGl2ZUluZGV4XTtcbiAgICB9XG4gICAgaWYgKCFwYXlsb2FkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXN1bHQpLCBbKDAsIF9DaGFydFV0aWxzLmdldFRvb2x0aXBJdGVtKShjaGlsZCwgcGF5bG9hZCldKTtcbiAgfSwgW10pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRvb2x0aXAgZGF0YSBiYXNlZCBvbiBhIG1vdXNlIHBvc2l0aW9uIChhcyBhIHBhcmFtZXRlciBvciBpbiBzdGF0ZSlcbiAqIEBwYXJhbSAge09iamVjdH0gc3RhdGUgICAgIGN1cnJlbnQgc3RhdGVcbiAqIEBwYXJhbSAge0FycmF5fSAgY2hhcnREYXRhIHRoZSBkYXRhIGRlZmluZWQgaW4gY2hhcnRcbiAqIEBwYXJhbSAge1N0cmluZ30gbGF5b3V0ICAgICBUaGUgbGF5b3V0IHR5cGUgb2YgY2hhcnRcbiAqIEBwYXJhbSAge09iamVjdH0gcmFuZ2VPYmogIHsgeCwgeSB9IGNvb3JkaW5hdGVzXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICBUb29sdGlwIGRhdGEgZGF0YVxuICovXG52YXIgZ2V0VG9vbHRpcERhdGEgPSBmdW5jdGlvbiBnZXRUb29sdGlwRGF0YShzdGF0ZSwgY2hhcnREYXRhLCBsYXlvdXQsIHJhbmdlT2JqKSB7XG4gIHZhciByYW5nZURhdGEgPSByYW5nZU9iaiB8fCB7XG4gICAgeDogc3RhdGUuY2hhcnRYLFxuICAgIHk6IHN0YXRlLmNoYXJ0WVxuICB9O1xuICB2YXIgcG9zID0gY2FsY3VsYXRlVG9vbHRpcFBvcyhyYW5nZURhdGEsIGxheW91dCk7XG4gIHZhciB0aWNrcyA9IHN0YXRlLm9yZGVyZWRUb29sdGlwVGlja3MsXG4gICAgYXhpcyA9IHN0YXRlLnRvb2x0aXBBeGlzLFxuICAgIHRvb2x0aXBUaWNrcyA9IHN0YXRlLnRvb2x0aXBUaWNrcztcbiAgdmFyIGFjdGl2ZUluZGV4ID0gKDAsIF9DaGFydFV0aWxzLmNhbGN1bGF0ZUFjdGl2ZVRpY2tJbmRleCkocG9zLCB0aWNrcywgdG9vbHRpcFRpY2tzLCBheGlzKTtcbiAgaWYgKGFjdGl2ZUluZGV4ID49IDAgJiYgdG9vbHRpcFRpY2tzKSB7XG4gICAgdmFyIGFjdGl2ZUxhYmVsID0gdG9vbHRpcFRpY2tzW2FjdGl2ZUluZGV4XSAmJiB0b29sdGlwVGlja3NbYWN0aXZlSW5kZXhdLnZhbHVlO1xuICAgIHZhciBhY3RpdmVQYXlsb2FkID0gZ2V0VG9vbHRpcENvbnRlbnQoc3RhdGUsIGNoYXJ0RGF0YSwgYWN0aXZlSW5kZXgsIGFjdGl2ZUxhYmVsKTtcbiAgICB2YXIgYWN0aXZlQ29vcmRpbmF0ZSA9IGdldEFjdGl2ZUNvb3JkaW5hdGUobGF5b3V0LCB0aWNrcywgYWN0aXZlSW5kZXgsIHJhbmdlRGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGl2ZVRvb2x0aXBJbmRleDogYWN0aXZlSW5kZXgsXG4gICAgICBhY3RpdmVMYWJlbDogYWN0aXZlTGFiZWwsXG4gICAgICBhY3RpdmVQYXlsb2FkOiBhY3RpdmVQYXlsb2FkLFxuICAgICAgYWN0aXZlQ29vcmRpbmF0ZTogYWN0aXZlQ29vcmRpbmF0ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY29uZmlndXJhdGlvbiBvZiBheGlzIGJ5IHRoZSBvcHRpb25zIG9mIGF4aXMgaW5zdGFuY2VcbiAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMgICAgICAgICBMYXRlc3QgcHJvcHNcbiAqIEBwYXJhbSB7QXJyYXl9ICBheGVzICAgICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgYXhlc1xuICogQHBhcmFtICB7QXJyYXl9IGdyYXBoaWNhbEl0ZW1zIFRoZSBpbnN0YW5jZXMgb2YgaXRlbVxuICogQHBhcmFtICB7U3RyaW5nfSBheGlzVHlwZSAgICAgIFRoZSB0eXBlIG9mIGF4aXMsIHhBeGlzIC0geC1heGlzLCB5QXhpcyAtIHktYXhpc1xuICogQHBhcmFtICB7U3RyaW5nfSBheGlzSWRLZXkgICAgIFRoZSB1bmlxdWUgaWQgb2YgYW4gYXhpc1xuICogQHBhcmFtICB7T2JqZWN0fSBzdGFja0dyb3VwcyAgIFRoZSBpdGVtcyBncm91cGVkIGJ5IGF4aXNJZCBhbmQgc3RhY2tJZFxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGFTdGFydEluZGV4IFRoZSBzdGFydCBpbmRleCBvZiB0aGUgZGF0YSBzZXJpZXMgd2hlbiBhIGJydXNoIGlzIGFwcGxpZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhRW5kSW5kZXggICBUaGUgZW5kIGluZGV4IG9mIHRoZSBkYXRhIHNlcmllcyB3aGVuIGEgYnJ1c2ggaXMgYXBwbGllZFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgIENvbmZpZ3VyYXRpb25cbiAqL1xudmFyIGdldEF4aXNNYXBCeUF4ZXMgPSBleHBvcnRzLmdldEF4aXNNYXBCeUF4ZXMgPSBmdW5jdGlvbiBnZXRBeGlzTWFwQnlBeGVzKHByb3BzLCBfcmVmMikge1xuICB2YXIgYXhlcyA9IF9yZWYyLmF4ZXMsXG4gICAgZ3JhcGhpY2FsSXRlbXMgPSBfcmVmMi5ncmFwaGljYWxJdGVtcyxcbiAgICBheGlzVHlwZSA9IF9yZWYyLmF4aXNUeXBlLFxuICAgIGF4aXNJZEtleSA9IF9yZWYyLmF4aXNJZEtleSxcbiAgICBzdGFja0dyb3VwcyA9IF9yZWYyLnN0YWNrR3JvdXBzLFxuICAgIGRhdGFTdGFydEluZGV4ID0gX3JlZjIuZGF0YVN0YXJ0SW5kZXgsXG4gICAgZGF0YUVuZEluZGV4ID0gX3JlZjIuZGF0YUVuZEluZGV4O1xuICB2YXIgbGF5b3V0ID0gcHJvcHMubGF5b3V0LFxuICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgc3RhY2tPZmZzZXQgPSBwcm9wcy5zdGFja09mZnNldDtcbiAgdmFyIGlzQ2F0ZWdvcmljYWwgPSAoMCwgX0NoYXJ0VXRpbHMuaXNDYXRlZ29yaWNhbEF4aXMpKGxheW91dCwgYXhpc1R5cGUpO1xuXG4gIC8vIEVsaW1pbmF0ZSBkdXBsaWNhdGVkIGF4ZXNcbiAgcmV0dXJuIGF4ZXMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGNoaWxkKSB7XG4gICAgdmFyIF9jaGlsZFByb3BzJGRvbWFpbjI7XG4gICAgdmFyIGNoaWxkUHJvcHMgPSBjaGlsZC50eXBlLmRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjaGlsZC50eXBlLmRlZmF1bHRQcm9wcyksIGNoaWxkLnByb3BzKSA6IGNoaWxkLnByb3BzO1xuICAgIHZhciB0eXBlID0gY2hpbGRQcm9wcy50eXBlLFxuICAgICAgZGF0YUtleSA9IGNoaWxkUHJvcHMuZGF0YUtleSxcbiAgICAgIGFsbG93RGF0YU92ZXJmbG93ID0gY2hpbGRQcm9wcy5hbGxvd0RhdGFPdmVyZmxvdyxcbiAgICAgIGFsbG93RHVwbGljYXRlZENhdGVnb3J5ID0gY2hpbGRQcm9wcy5hbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeSxcbiAgICAgIHNjYWxlID0gY2hpbGRQcm9wcy5zY2FsZSxcbiAgICAgIHRpY2tzID0gY2hpbGRQcm9wcy50aWNrcyxcbiAgICAgIGluY2x1ZGVIaWRkZW4gPSBjaGlsZFByb3BzLmluY2x1ZGVIaWRkZW47XG4gICAgdmFyIGF4aXNJZCA9IGNoaWxkUHJvcHNbYXhpc0lkS2V5XTtcbiAgICBpZiAocmVzdWx0W2F4aXNJZF0pIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciBkaXNwbGF5ZWREYXRhID0gZ2V0RGlzcGxheWVkRGF0YShwcm9wcy5kYXRhLCB7XG4gICAgICBncmFwaGljYWxJdGVtczogZ3JhcGhpY2FsSXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBfZGVmYXVsdFByb3BzO1xuICAgICAgICB2YXIgaXRlbUF4aXNJZCA9IGF4aXNJZEtleSBpbiBpdGVtLnByb3BzID8gaXRlbS5wcm9wc1theGlzSWRLZXldIDogKF9kZWZhdWx0UHJvcHMgPSBpdGVtLnR5cGUuZGVmYXVsdFByb3BzKSA9PT0gbnVsbCB8fCBfZGVmYXVsdFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGVmYXVsdFByb3BzW2F4aXNJZEtleV07XG4gICAgICAgIHJldHVybiBpdGVtQXhpc0lkID09PSBheGlzSWQ7XG4gICAgICB9KSxcbiAgICAgIGRhdGFTdGFydEluZGV4OiBkYXRhU3RhcnRJbmRleCxcbiAgICAgIGRhdGFFbmRJbmRleDogZGF0YUVuZEluZGV4XG4gICAgfSk7XG4gICAgdmFyIGxlbiA9IGRpc3BsYXllZERhdGEubGVuZ3RoO1xuICAgIHZhciBkb21haW4sIGR1cGxpY2F0ZURvbWFpbiwgY2F0ZWdvcmljYWxEb21haW47XG5cbiAgICAvKlxuICAgICAqIFRoaXMgaXMgYSBoYWNrIHRvIHNob3J0LWNpcmN1aXQgdGhlIGRvbWFpbiBjcmVhdGlvbiBoZXJlIHRvIGVuaGFuY2UgcGVyZm9ybWFuY2UuXG4gICAgICogVXN1YWxseSwgdGhlIGRhdGEgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGRvbWFpbiwgYnV0IHdoZW4gdGhlIHVzZXIgc3BlY2lmaWVzXG4gICAgICogYSBkb21haW4gdXBmcm9udCAodmlhIHByb3BzKSwgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxjdWxhdGUgdGhlIGRvbWFpbiBzdGFydCBhbmQgZW5kLFxuICAgICAqIHdoaWNoIGlzIHZlcnkgZXhwZW5zaXZlIGZvciBhIGxhcmdlciBhbW91bnQgb2YgZGF0YS5cbiAgICAgKiBUaGUgb25seSB0aGluZyB0aGF0IHdvdWxkIHByb2hpYml0IHNob3J0LWNpcmN1aXRpbmcgaXMgd2hlbiB0aGUgdXNlciBkb2Vzbid0IGFsbG93IGRhdGEgb3ZlcmZsb3csXG4gICAgICogYmVjYXVzZSB0aGUgYXhpcyBpcyBzdXBwb3NlZCB0byBpZ25vcmUgdGhlIHNwZWNpZmllZCBkb21haW4gdGhhdCB3YXkuXG4gICAgICovXG4gICAgaWYgKCgwLCBfaXNEb21haW5TcGVjaWZpZWRCeVVzZXIuaXNEb21haW5TcGVjaWZpZWRCeVVzZXIpKGNoaWxkUHJvcHMuZG9tYWluLCBhbGxvd0RhdGFPdmVyZmxvdywgdHlwZSkpIHtcbiAgICAgIGRvbWFpbiA9ICgwLCBfQ2hhcnRVdGlscy5wYXJzZVNwZWNpZmllZERvbWFpbikoY2hpbGRQcm9wcy5kb21haW4sIG51bGwsIGFsbG93RGF0YU92ZXJmbG93KTtcbiAgICAgIC8qIFRoZSBjaGFydCBjYW4gYmUgY2F0ZWdvcmljYWwgYW5kIGhhdmUgdGhlIGRvbWFpbiBzcGVjaWZpZWQgaW4gbnVtYmVyc1xuICAgICAgICogd2Ugc3RpbGwgbmVlZCB0byBjYWxjdWxhdGUgdGhlIGNhdGVnb3JpY2FsIGRvbWFpblxuICAgICAgICogVE9ETzogcmVmYWN0b3IgdGhpcyBtb3JlXG4gICAgICAgKi9cbiAgICAgIGlmIChpc0NhdGVnb3JpY2FsICYmICh0eXBlID09PSAnbnVtYmVyJyB8fCBzY2FsZSAhPT0gJ2F1dG8nKSkge1xuICAgICAgICBjYXRlZ29yaWNhbERvbWFpbiA9ICgwLCBfQ2hhcnRVdGlscy5nZXREb21haW5PZkRhdGFCeUtleSkoZGlzcGxheWVkRGF0YSwgZGF0YUtleSwgJ2NhdGVnb3J5Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGRvbWFpbiBpcyBkZWZhdWx0ZWQgd2UgbmVlZCB0aGlzIGZvciBgb3JpZ2luYWxEb21haW5gIGFzIHdlbGxcbiAgICB2YXIgZGVmYXVsdERvbWFpbiA9IGdldERlZmF1bHREb21haW5CeUF4aXNUeXBlKHR5cGUpO1xuXG4gICAgLy8gd2UgZGlkbid0IGNyZWF0ZSB0aGUgZG9tYWluIGZyb20gdXNlcidzIHByb3BzIGFib3ZlLCBzbyB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSBpdFxuICAgIGlmICghZG9tYWluIHx8IGRvbWFpbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBfY2hpbGRQcm9wcyRkb21haW47XG4gICAgICB2YXIgY2hpbGREb21haW4gPSAoX2NoaWxkUHJvcHMkZG9tYWluID0gY2hpbGRQcm9wcy5kb21haW4pICE9PSBudWxsICYmIF9jaGlsZFByb3BzJGRvbWFpbiAhPT0gdm9pZCAwID8gX2NoaWxkUHJvcHMkZG9tYWluIDogZGVmYXVsdERvbWFpbjtcbiAgICAgIGlmIChkYXRhS2V5KSB7XG4gICAgICAgIC8vIGhhcyBkYXRhS2V5IGluIDxBeGlzIC8+XG4gICAgICAgIGRvbWFpbiA9ICgwLCBfQ2hhcnRVdGlscy5nZXREb21haW5PZkRhdGFCeUtleSkoZGlzcGxheWVkRGF0YSwgZGF0YUtleSwgdHlwZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnY2F0ZWdvcnknICYmIGlzQ2F0ZWdvcmljYWwpIHtcbiAgICAgICAgICAvLyB0aGUgZmllbGQgdHlwZSBpcyBjYXRlZ29yeSBkYXRhIGFuZCB0aGlzIGF4aXMgaXMgY2F0ZWdvcmljYWwgYXhpc1xuICAgICAgICAgIHZhciBkdXBsaWNhdGUgPSAoMCwgX0RhdGFVdGlscy5oYXNEdXBsaWNhdGUpKGRvbWFpbik7XG4gICAgICAgICAgaWYgKGFsbG93RHVwbGljYXRlZENhdGVnb3J5ICYmIGR1cGxpY2F0ZSkge1xuICAgICAgICAgICAgZHVwbGljYXRlRG9tYWluID0gZG9tYWluO1xuICAgICAgICAgICAgLy8gV2hlbiBjYXRlZ29yeSBheGlzIGhhcyBkdXBsaWNhdGVkIHRleHQsIHNlcmlhbCBudW1iZXJzIGFyZSB1c2VkIHRvIGdlbmVyYXRlIHNjYWxlXG4gICAgICAgICAgICBkb21haW4gPSAoMCwgX3JhbmdlW1wiZGVmYXVsdFwiXSkoMCwgbGVuKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFhbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZWQgY2F0ZWdvcnlcbiAgICAgICAgICAgIGRvbWFpbiA9ICgwLCBfQ2hhcnRVdGlscy5wYXJzZURvbWFpbk9mQ2F0ZWdvcnlBeGlzKShjaGlsZERvbWFpbiwgZG9tYWluLCBjaGlsZCkucmVkdWNlKGZ1bmN0aW9uIChmaW5hbERvbWFpbiwgZW50cnkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsRG9tYWluLmluZGV4T2YoZW50cnkpID49IDAgPyBmaW5hbERvbWFpbiA6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZmluYWxEb21haW4pLCBbZW50cnldKTtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAgIC8vIHRoZSBmaWVsZCB0eXBlIGlzIGNhdGVnb3J5IGRhdGEgYW5kIHRoaXMgYXhpcyBpcyBudW1lcmljYWwgYXhpc1xuICAgICAgICAgIGlmICghYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIGRvbWFpbiA9ICgwLCBfQ2hhcnRVdGlscy5wYXJzZURvbWFpbk9mQ2F0ZWdvcnlBeGlzKShjaGlsZERvbWFpbiwgZG9tYWluLCBjaGlsZCkucmVkdWNlKGZ1bmN0aW9uIChmaW5hbERvbWFpbiwgZW50cnkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsRG9tYWluLmluZGV4T2YoZW50cnkpID49IDAgfHwgZW50cnkgPT09ICcnIHx8ICgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShlbnRyeSkgPyBmaW5hbERvbWFpbiA6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZmluYWxEb21haW4pLCBbZW50cnldKTtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZWxpbWluYXRlIHVuZGVmaW5lZCBvciBudWxsIG9yIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgZG9tYWluID0gZG9tYWluLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5ICE9PSAnJyAmJiAhKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIC8vIHRoZSBmaWVsZCB0eXBlIGlzIG51bWVyaWNhbFxuICAgICAgICAgIHZhciBlcnJvckJhcnNEb21haW4gPSAoMCwgX0NoYXJ0VXRpbHMucGFyc2VFcnJvckJhcnNPZkF4aXMpKGRpc3BsYXllZERhdGEsIGdyYXBoaWNhbEl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIF9kZWZhdWx0UHJvcHMyLCBfZGVmYXVsdFByb3BzMztcbiAgICAgICAgICAgIHZhciBpdGVtQXhpc0lkID0gYXhpc0lkS2V5IGluIGl0ZW0ucHJvcHMgPyBpdGVtLnByb3BzW2F4aXNJZEtleV0gOiAoX2RlZmF1bHRQcm9wczIgPSBpdGVtLnR5cGUuZGVmYXVsdFByb3BzKSA9PT0gbnVsbCB8fCBfZGVmYXVsdFByb3BzMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RlZmF1bHRQcm9wczJbYXhpc0lkS2V5XTtcbiAgICAgICAgICAgIHZhciBpdGVtSGlkZSA9ICdoaWRlJyBpbiBpdGVtLnByb3BzID8gaXRlbS5wcm9wcy5oaWRlIDogKF9kZWZhdWx0UHJvcHMzID0gaXRlbS50eXBlLmRlZmF1bHRQcm9wcykgPT09IG51bGwgfHwgX2RlZmF1bHRQcm9wczMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kZWZhdWx0UHJvcHMzLmhpZGU7XG4gICAgICAgICAgICByZXR1cm4gaXRlbUF4aXNJZCA9PT0gYXhpc0lkICYmIChpbmNsdWRlSGlkZGVuIHx8ICFpdGVtSGlkZSk7XG4gICAgICAgICAgfSksIGRhdGFLZXksIGF4aXNUeXBlLCBsYXlvdXQpO1xuICAgICAgICAgIGlmIChlcnJvckJhcnNEb21haW4pIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IGVycm9yQmFyc0RvbWFpbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2F0ZWdvcmljYWwgJiYgKHR5cGUgPT09ICdudW1iZXInIHx8IHNjYWxlICE9PSAnYXV0bycpKSB7XG4gICAgICAgICAgY2F0ZWdvcmljYWxEb21haW4gPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0RG9tYWluT2ZEYXRhQnlLZXkpKGRpc3BsYXllZERhdGEsIGRhdGFLZXksICdjYXRlZ29yeScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ2F0ZWdvcmljYWwpIHtcbiAgICAgICAgLy8gdGhlIGF4aXMgaXMgYSBjYXRlZ29yaWNhbCBheGlzXG4gICAgICAgIGRvbWFpbiA9ICgwLCBfcmFuZ2VbXCJkZWZhdWx0XCJdKSgwLCBsZW4pO1xuICAgICAgfSBlbHNlIGlmIChzdGFja0dyb3VwcyAmJiBzdGFja0dyb3Vwc1theGlzSWRdICYmIHN0YWNrR3JvdXBzW2F4aXNJZF0uaGFzU3RhY2sgJiYgdHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gd2hlbiBzdGFja09mZnNldCBpcyAnZXhwYW5kJywgdGhlIGRvbWFpbiBtYXkgYmUgY2FsY3VsYXRlZCBhcyBbMCwgMS4wMDAwMDAwMDAwMDJdXG4gICAgICAgIGRvbWFpbiA9IHN0YWNrT2Zmc2V0ID09PSAnZXhwYW5kJyA/IFswLCAxXSA6ICgwLCBfQ2hhcnRVdGlscy5nZXREb21haW5PZlN0YWNrR3JvdXBzKShzdGFja0dyb3Vwc1theGlzSWRdLnN0YWNrR3JvdXBzLCBkYXRhU3RhcnRJbmRleCwgZGF0YUVuZEluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbWFpbiA9ICgwLCBfQ2hhcnRVdGlscy5nZXREb21haW5PZkl0ZW1zV2l0aFNhbWVBeGlzKShkaXNwbGF5ZWREYXRhLCBncmFwaGljYWxJdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgaXRlbUF4aXNJZCA9IGF4aXNJZEtleSBpbiBpdGVtLnByb3BzID8gaXRlbS5wcm9wc1theGlzSWRLZXldIDogaXRlbS50eXBlLmRlZmF1bHRQcm9wc1theGlzSWRLZXldO1xuICAgICAgICAgIHZhciBpdGVtSGlkZSA9ICdoaWRlJyBpbiBpdGVtLnByb3BzID8gaXRlbS5wcm9wcy5oaWRlIDogaXRlbS50eXBlLmRlZmF1bHRQcm9wcy5oaWRlO1xuICAgICAgICAgIHJldHVybiBpdGVtQXhpc0lkID09PSBheGlzSWQgJiYgKGluY2x1ZGVIaWRkZW4gfHwgIWl0ZW1IaWRlKTtcbiAgICAgICAgfSksIHR5cGUsIGxheW91dCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gVG8gZGV0ZWN0IHdldGhlciB0aGVyZSBpcyBhbnkgcmVmZXJlbmNlIGxpbmVzIHdob3NlIHByb3BzIGFsd2F5c1Nob3cgaXMgdHJ1ZVxuICAgICAgICBkb21haW4gPSAoMCwgX0RldGVjdFJlZmVyZW5jZUVsZW1lbnRzRG9tYWluLmRldGVjdFJlZmVyZW5jZUVsZW1lbnRzRG9tYWluKShjaGlsZHJlbiwgZG9tYWluLCBheGlzSWQsIGF4aXNUeXBlLCB0aWNrcyk7XG4gICAgICAgIGlmIChjaGlsZERvbWFpbikge1xuICAgICAgICAgIGRvbWFpbiA9ICgwLCBfQ2hhcnRVdGlscy5wYXJzZVNwZWNpZmllZERvbWFpbikoY2hpbGREb21haW4sIGRvbWFpbiwgYWxsb3dEYXRhT3ZlcmZsb3cpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjYXRlZ29yeScgJiYgY2hpbGREb21haW4pIHtcbiAgICAgICAgdmFyIGF4aXNEb21haW4gPSBjaGlsZERvbWFpbjtcbiAgICAgICAgdmFyIGlzRG9tYWluVmFsaWQgPSBkb21haW4uZXZlcnkoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgcmV0dXJuIGF4aXNEb21haW4uaW5kZXhPZihlbnRyeSkgPj0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0RvbWFpblZhbGlkKSB7XG4gICAgICAgICAgZG9tYWluID0gYXhpc0RvbWFpbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXN1bHQpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBheGlzSWQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY2hpbGRQcm9wcyksIHt9LCB7XG4gICAgICBheGlzVHlwZTogYXhpc1R5cGUsXG4gICAgICBkb21haW46IGRvbWFpbixcbiAgICAgIGNhdGVnb3JpY2FsRG9tYWluOiBjYXRlZ29yaWNhbERvbWFpbixcbiAgICAgIGR1cGxpY2F0ZURvbWFpbjogZHVwbGljYXRlRG9tYWluLFxuICAgICAgb3JpZ2luYWxEb21haW46IChfY2hpbGRQcm9wcyRkb21haW4yID0gY2hpbGRQcm9wcy5kb21haW4pICE9PSBudWxsICYmIF9jaGlsZFByb3BzJGRvbWFpbjIgIT09IHZvaWQgMCA/IF9jaGlsZFByb3BzJGRvbWFpbjIgOiBkZWZhdWx0RG9tYWluLFxuICAgICAgaXNDYXRlZ29yaWNhbDogaXNDYXRlZ29yaWNhbCxcbiAgICAgIGxheW91dDogbGF5b3V0XG4gICAgfSkpKTtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYXhpcyBieSB0aGUgb3B0aW9ucyBvZiBpdGVtLFxuICogdGhpcyBraW5kIG9mIGF4aXMgZG9lcyBub3QgZGlzcGxheSBpbiBjaGFydFxuICogQHBhcmFtICB7T2JqZWN0fSBwcm9wcyAgICAgICAgIExhdGVzdCBwcm9wc1xuICogQHBhcmFtICB7QXJyYXl9IGdyYXBoaWNhbEl0ZW1zIFRoZSBpbnN0YW5jZXMgb2YgaXRlbVxuICogQHBhcmFtICB7UmVhY3RFbGVtZW50fSBBeGlzICAgIEF4aXMgQ29tcG9uZW50XG4gKiBAcGFyYW0gIHtTdHJpbmd9IGF4aXNUeXBlICAgICAgVGhlIHR5cGUgb2YgYXhpcywgeEF4aXMgLSB4LWF4aXMsIHlBeGlzIC0geS1heGlzXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGF4aXNJZEtleSAgICAgVGhlIHVuaXF1ZSBpZCBvZiBhbiBheGlzXG4gKiBAcGFyYW0gIHtPYmplY3R9IHN0YWNrR3JvdXBzICAgVGhlIGl0ZW1zIGdyb3VwZWQgYnkgYXhpc0lkIGFuZCBzdGFja0lkXG4gKiBAcGFyYW0ge051bWJlcn0gZGF0YVN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSBkYXRhIHNlcmllcyB3aGVuIGEgYnJ1c2ggaXMgYXBwbGllZFxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGFFbmRJbmRleCAgIFRoZSBlbmQgaW5kZXggb2YgdGhlIGRhdGEgc2VyaWVzIHdoZW4gYSBicnVzaCBpcyBhcHBsaWVkXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgQ29uZmlndXJhdGlvblxuICovXG52YXIgZ2V0QXhpc01hcEJ5SXRlbXMgPSBmdW5jdGlvbiBnZXRBeGlzTWFwQnlJdGVtcyhwcm9wcywgX3JlZjMpIHtcbiAgdmFyIGdyYXBoaWNhbEl0ZW1zID0gX3JlZjMuZ3JhcGhpY2FsSXRlbXMsXG4gICAgQXhpcyA9IF9yZWYzLkF4aXMsXG4gICAgYXhpc1R5cGUgPSBfcmVmMy5heGlzVHlwZSxcbiAgICBheGlzSWRLZXkgPSBfcmVmMy5heGlzSWRLZXksXG4gICAgc3RhY2tHcm91cHMgPSBfcmVmMy5zdGFja0dyb3VwcyxcbiAgICBkYXRhU3RhcnRJbmRleCA9IF9yZWYzLmRhdGFTdGFydEluZGV4LFxuICAgIGRhdGFFbmRJbmRleCA9IF9yZWYzLmRhdGFFbmRJbmRleDtcbiAgdmFyIGxheW91dCA9IHByb3BzLmxheW91dCxcbiAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICB2YXIgZGlzcGxheWVkRGF0YSA9IGdldERpc3BsYXllZERhdGEocHJvcHMuZGF0YSwge1xuICAgIGdyYXBoaWNhbEl0ZW1zOiBncmFwaGljYWxJdGVtcyxcbiAgICBkYXRhU3RhcnRJbmRleDogZGF0YVN0YXJ0SW5kZXgsXG4gICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXhcbiAgfSk7XG4gIHZhciBsZW4gPSBkaXNwbGF5ZWREYXRhLmxlbmd0aDtcbiAgdmFyIGlzQ2F0ZWdvcmljYWwgPSAoMCwgX0NoYXJ0VXRpbHMuaXNDYXRlZ29yaWNhbEF4aXMpKGxheW91dCwgYXhpc1R5cGUpO1xuICB2YXIgaW5kZXggPSAtMTtcblxuICAvLyBUaGUgZGVmYXVsdCB0eXBlIG9mIHgtYXhpcyBpcyBjYXRlZ29yeSBheGlzLFxuICAvLyBUaGUgZGVmYXVsdCBjb250ZW50cyBvZiB4LWF4aXMgaXMgdGhlIHNlcmlhbCBudW1iZXJzIG9mIGRhdGFcbiAgLy8gVGhlIGRlZmF1bHQgdHlwZSBvZiB5LWF4aXMgaXMgbnVtYmVyIGF4aXNcbiAgLy8gVGhlIGRlZmF1bHQgY29udGVudHMgb2YgeS1heGlzIGlzIHRoZSBkb21haW4gb2YgZGF0YVxuICByZXR1cm4gZ3JhcGhpY2FsSXRlbXMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGNoaWxkKSB7XG4gICAgdmFyIGNoaWxkUHJvcHMgPSBjaGlsZC50eXBlLmRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjaGlsZC50eXBlLmRlZmF1bHRQcm9wcyksIGNoaWxkLnByb3BzKSA6IGNoaWxkLnByb3BzO1xuICAgIHZhciBheGlzSWQgPSBjaGlsZFByb3BzW2F4aXNJZEtleV07XG4gICAgdmFyIG9yaWdpbmFsRG9tYWluID0gZ2V0RGVmYXVsdERvbWFpbkJ5QXhpc1R5cGUoJ251bWJlcicpO1xuICAgIGlmICghcmVzdWx0W2F4aXNJZF0pIHtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZG9tYWluO1xuICAgICAgaWYgKGlzQ2F0ZWdvcmljYWwpIHtcbiAgICAgICAgZG9tYWluID0gKDAsIF9yYW5nZVtcImRlZmF1bHRcIl0pKDAsIGxlbik7XG4gICAgICB9IGVsc2UgaWYgKHN0YWNrR3JvdXBzICYmIHN0YWNrR3JvdXBzW2F4aXNJZF0gJiYgc3RhY2tHcm91cHNbYXhpc0lkXS5oYXNTdGFjaykge1xuICAgICAgICBkb21haW4gPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0RG9tYWluT2ZTdGFja0dyb3Vwcykoc3RhY2tHcm91cHNbYXhpc0lkXS5zdGFja0dyb3VwcywgZGF0YVN0YXJ0SW5kZXgsIGRhdGFFbmRJbmRleCk7XG4gICAgICAgIGRvbWFpbiA9ICgwLCBfRGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW4uZGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW4pKGNoaWxkcmVuLCBkb21haW4sIGF4aXNJZCwgYXhpc1R5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tYWluID0gKDAsIF9DaGFydFV0aWxzLnBhcnNlU3BlY2lmaWVkRG9tYWluKShvcmlnaW5hbERvbWFpbiwgKDAsIF9DaGFydFV0aWxzLmdldERvbWFpbk9mSXRlbXNXaXRoU2FtZUF4aXMpKGRpc3BsYXllZERhdGEsIGdyYXBoaWNhbEl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHZhciBfZGVmYXVsdFByb3BzNCwgX2RlZmF1bHRQcm9wczU7XG4gICAgICAgICAgdmFyIGl0ZW1BeGlzSWQgPSBheGlzSWRLZXkgaW4gaXRlbS5wcm9wcyA/IGl0ZW0ucHJvcHNbYXhpc0lkS2V5XSA6IChfZGVmYXVsdFByb3BzNCA9IGl0ZW0udHlwZS5kZWZhdWx0UHJvcHMpID09PSBudWxsIHx8IF9kZWZhdWx0UHJvcHM0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGVmYXVsdFByb3BzNFtheGlzSWRLZXldO1xuICAgICAgICAgIHZhciBpdGVtSGlkZSA9ICdoaWRlJyBpbiBpdGVtLnByb3BzID8gaXRlbS5wcm9wcy5oaWRlIDogKF9kZWZhdWx0UHJvcHM1ID0gaXRlbS50eXBlLmRlZmF1bHRQcm9wcykgPT09IG51bGwgfHwgX2RlZmF1bHRQcm9wczUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kZWZhdWx0UHJvcHM1LmhpZGU7XG4gICAgICAgICAgcmV0dXJuIGl0ZW1BeGlzSWQgPT09IGF4aXNJZCAmJiAhaXRlbUhpZGU7XG4gICAgICAgIH0pLCAnbnVtYmVyJywgbGF5b3V0KSwgQXhpcy5kZWZhdWx0UHJvcHMuYWxsb3dEYXRhT3ZlcmZsb3cpO1xuICAgICAgICBkb21haW4gPSAoMCwgX0RldGVjdFJlZmVyZW5jZUVsZW1lbnRzRG9tYWluLmRldGVjdFJlZmVyZW5jZUVsZW1lbnRzRG9tYWluKShjaGlsZHJlbiwgZG9tYWluLCBheGlzSWQsIGF4aXNUeXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGF4aXNJZCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgYXhpc1R5cGU6IGF4aXNUeXBlXG4gICAgICB9LCBBeGlzLmRlZmF1bHRQcm9wcyksIHt9LCB7XG4gICAgICAgIGhpZGU6IHRydWUsXG4gICAgICAgIG9yaWVudGF0aW9uOiAoMCwgX2dldFtcImRlZmF1bHRcIl0pKE9SSUVOVF9NQVAsIFwiXCIuY29uY2F0KGF4aXNUeXBlLCBcIi5cIikuY29uY2F0KGluZGV4ICUgMiksIG51bGwpLFxuICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgb3JpZ2luYWxEb21haW46IG9yaWdpbmFsRG9tYWluLFxuICAgICAgICBpc0NhdGVnb3JpY2FsOiBpc0NhdGVnb3JpY2FsLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgICAvLyBzcGVjaWZ5IHNjYWxlIHdoZW4gbm8gQXhpc1xuICAgICAgICAvLyBzY2FsZTogaXNDYXRlZ29yaWNhbCA/ICdiYW5kJyA6ICdsaW5lYXInLFxuICAgICAgfSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYWxsIHgtYXhpcyBvciB5LWF4aXNcbiAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMgICAgICAgICAgTGF0ZXN0IHByb3BzXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGF4aXNUeXBlICAgICAgIFRoZSB0eXBlIG9mIGF4aXNcbiAqIEBwYXJhbSAge1JlYWN0LkNvbXBvbmVudFR5cGV9ICBbQXhpc0NvbXBdICAgICAgQXhpcyBDb21wb25lbnRcbiAqIEBwYXJhbSAge0FycmF5fSAgZ3JhcGhpY2FsSXRlbXMgVGhlIGluc3RhbmNlcyBvZiBpdGVtXG4gKiBAcGFyYW0gIHtPYmplY3R9IHN0YWNrR3JvdXBzICAgIFRoZSBpdGVtcyBncm91cGVkIGJ5IGF4aXNJZCBhbmQgc3RhY2tJZFxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGFTdGFydEluZGV4ICBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIGRhdGEgc2VyaWVzIHdoZW4gYSBicnVzaCBpcyBhcHBsaWVkXG4gKiBAcGFyYW0ge051bWJlcn0gZGF0YUVuZEluZGV4ICAgIFRoZSBlbmQgaW5kZXggb2YgdGhlIGRhdGEgc2VyaWVzIHdoZW4gYSBicnVzaCBpcyBhcHBsaWVkXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgIENvbmZpZ3VyYXRpb25cbiAqL1xudmFyIGdldEF4aXNNYXAgPSBmdW5jdGlvbiBnZXRBeGlzTWFwKHByb3BzLCBfcmVmNCkge1xuICB2YXIgX3JlZjQkYXhpc1R5cGUgPSBfcmVmNC5heGlzVHlwZSxcbiAgICBheGlzVHlwZSA9IF9yZWY0JGF4aXNUeXBlID09PSB2b2lkIDAgPyAneEF4aXMnIDogX3JlZjQkYXhpc1R5cGUsXG4gICAgQXhpc0NvbXAgPSBfcmVmNC5BeGlzQ29tcCxcbiAgICBncmFwaGljYWxJdGVtcyA9IF9yZWY0LmdyYXBoaWNhbEl0ZW1zLFxuICAgIHN0YWNrR3JvdXBzID0gX3JlZjQuc3RhY2tHcm91cHMsXG4gICAgZGF0YVN0YXJ0SW5kZXggPSBfcmVmNC5kYXRhU3RhcnRJbmRleCxcbiAgICBkYXRhRW5kSW5kZXggPSBfcmVmNC5kYXRhRW5kSW5kZXg7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICB2YXIgYXhpc0lkS2V5ID0gXCJcIi5jb25jYXQoYXhpc1R5cGUsIFwiSWRcIik7XG4gIC8vIEdldCBhbGwgdGhlIGluc3RhbmNlIG9mIEF4aXNcbiAgdmFyIGF4ZXMgPSAoMCwgX1JlYWN0VXRpbHMuZmluZEFsbEJ5VHlwZSkoY2hpbGRyZW4sIEF4aXNDb21wKTtcbiAgdmFyIGF4aXNNYXAgPSB7fTtcbiAgaWYgKGF4ZXMgJiYgYXhlcy5sZW5ndGgpIHtcbiAgICBheGlzTWFwID0gZ2V0QXhpc01hcEJ5QXhlcyhwcm9wcywge1xuICAgICAgYXhlczogYXhlcyxcbiAgICAgIGdyYXBoaWNhbEl0ZW1zOiBncmFwaGljYWxJdGVtcyxcbiAgICAgIGF4aXNUeXBlOiBheGlzVHlwZSxcbiAgICAgIGF4aXNJZEtleTogYXhpc0lkS2V5LFxuICAgICAgc3RhY2tHcm91cHM6IHN0YWNrR3JvdXBzLFxuICAgICAgZGF0YVN0YXJ0SW5kZXg6IGRhdGFTdGFydEluZGV4LFxuICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXhcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChncmFwaGljYWxJdGVtcyAmJiBncmFwaGljYWxJdGVtcy5sZW5ndGgpIHtcbiAgICBheGlzTWFwID0gZ2V0QXhpc01hcEJ5SXRlbXMocHJvcHMsIHtcbiAgICAgIEF4aXM6IEF4aXNDb21wLFxuICAgICAgZ3JhcGhpY2FsSXRlbXM6IGdyYXBoaWNhbEl0ZW1zLFxuICAgICAgYXhpc1R5cGU6IGF4aXNUeXBlLFxuICAgICAgYXhpc0lkS2V5OiBheGlzSWRLZXksXG4gICAgICBzdGFja0dyb3Vwczogc3RhY2tHcm91cHMsXG4gICAgICBkYXRhU3RhcnRJbmRleDogZGF0YVN0YXJ0SW5kZXgsXG4gICAgICBkYXRhRW5kSW5kZXg6IGRhdGFFbmRJbmRleFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBheGlzTWFwO1xufTtcbnZhciB0b29sdGlwVGlja3NHZW5lcmF0b3IgPSBmdW5jdGlvbiB0b29sdGlwVGlja3NHZW5lcmF0b3IoYXhpc01hcCkge1xuICB2YXIgYXhpcyA9ICgwLCBfRGF0YVV0aWxzLmdldEFueUVsZW1lbnRPZk9iamVjdCkoYXhpc01hcCk7XG4gIHZhciB0b29sdGlwVGlja3MgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0VGlja3NPZkF4aXMpKGF4aXMsIGZhbHNlLCB0cnVlKTtcbiAgcmV0dXJuIHtcbiAgICB0b29sdGlwVGlja3M6IHRvb2x0aXBUaWNrcyxcbiAgICBvcmRlcmVkVG9vbHRpcFRpY2tzOiAoMCwgX3NvcnRCeVtcImRlZmF1bHRcIl0pKHRvb2x0aXBUaWNrcywgZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBvLmNvb3JkaW5hdGU7XG4gICAgfSksXG4gICAgdG9vbHRpcEF4aXM6IGF4aXMsXG4gICAgdG9vbHRpcEF4aXNCYW5kU2l6ZTogKDAsIF9DaGFydFV0aWxzLmdldEJhbmRTaXplT2ZBeGlzKShheGlzLCB0b29sdGlwVGlja3MpXG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgZGVmYXVsdCwgcmVzZXQgc3RhdGUgZm9yIHRoZSBjYXRlZ29yaWNhbCBjaGFydC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBQcm9wcyBvYmplY3QgdG8gdXNlIHdoZW4gY3JlYXRpbmcgdGhlIGRlZmF1bHQgc3RhdGVcbiAqIEByZXR1cm4ge09iamVjdH0gV2hvbGUgbmV3IHN0YXRlXG4gKi9cbnZhciBjcmVhdGVEZWZhdWx0U3RhdGUgPSBleHBvcnRzLmNyZWF0ZURlZmF1bHRTdGF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTdGF0ZShwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICBkZWZhdWx0U2hvd1Rvb2x0aXAgPSBwcm9wcy5kZWZhdWx0U2hvd1Rvb2x0aXA7XG4gIHZhciBicnVzaEl0ZW0gPSAoMCwgX1JlYWN0VXRpbHMuZmluZENoaWxkQnlUeXBlKShjaGlsZHJlbiwgX0JydXNoLkJydXNoKTtcbiAgdmFyIHN0YXJ0SW5kZXggPSAwO1xuICB2YXIgZW5kSW5kZXggPSAwO1xuICBpZiAocHJvcHMuZGF0YSAmJiBwcm9wcy5kYXRhLmxlbmd0aCAhPT0gMCkge1xuICAgIGVuZEluZGV4ID0gcHJvcHMuZGF0YS5sZW5ndGggLSAxO1xuICB9XG4gIGlmIChicnVzaEl0ZW0gJiYgYnJ1c2hJdGVtLnByb3BzKSB7XG4gICAgaWYgKGJydXNoSXRlbS5wcm9wcy5zdGFydEluZGV4ID49IDApIHtcbiAgICAgIHN0YXJ0SW5kZXggPSBicnVzaEl0ZW0ucHJvcHMuc3RhcnRJbmRleDtcbiAgICB9XG4gICAgaWYgKGJydXNoSXRlbS5wcm9wcy5lbmRJbmRleCA+PSAwKSB7XG4gICAgICBlbmRJbmRleCA9IGJydXNoSXRlbS5wcm9wcy5lbmRJbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjaGFydFg6IDAsXG4gICAgY2hhcnRZOiAwLFxuICAgIGRhdGFTdGFydEluZGV4OiBzdGFydEluZGV4LFxuICAgIGRhdGFFbmRJbmRleDogZW5kSW5kZXgsXG4gICAgYWN0aXZlVG9vbHRpcEluZGV4OiAtMSxcbiAgICBpc1Rvb2x0aXBBY3RpdmU6IEJvb2xlYW4oZGVmYXVsdFNob3dUb29sdGlwKVxuICB9O1xufTtcbnZhciBoYXNHcmFwaGljYWxCYXJJdGVtID0gZnVuY3Rpb24gaGFzR3JhcGhpY2FsQmFySXRlbShncmFwaGljYWxJdGVtcykge1xuICBpZiAoIWdyYXBoaWNhbEl0ZW1zIHx8ICFncmFwaGljYWxJdGVtcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGdyYXBoaWNhbEl0ZW1zLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgbmFtZSA9ICgwLCBfUmVhY3RVdGlscy5nZXREaXNwbGF5TmFtZSkoaXRlbSAmJiBpdGVtLnR5cGUpO1xuICAgIHJldHVybiBuYW1lICYmIG5hbWUuaW5kZXhPZignQmFyJykgPj0gMDtcbiAgfSk7XG59O1xudmFyIGdldEF4aXNOYW1lQnlMYXlvdXQgPSBmdW5jdGlvbiBnZXRBeGlzTmFtZUJ5TGF5b3V0KGxheW91dCkge1xuICBpZiAobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbnVtZXJpY0F4aXNOYW1lOiAneUF4aXMnLFxuICAgICAgY2F0ZUF4aXNOYW1lOiAneEF4aXMnXG4gICAgfTtcbiAgfVxuICBpZiAobGF5b3V0ID09PSAndmVydGljYWwnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWVyaWNBeGlzTmFtZTogJ3hBeGlzJyxcbiAgICAgIGNhdGVBeGlzTmFtZTogJ3lBeGlzJ1xuICAgIH07XG4gIH1cbiAgaWYgKGxheW91dCA9PT0gJ2NlbnRyaWMnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWVyaWNBeGlzTmFtZTogJ3JhZGl1c0F4aXMnLFxuICAgICAgY2F0ZUF4aXNOYW1lOiAnYW5nbGVBeGlzJ1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBudW1lcmljQXhpc05hbWU6ICdhbmdsZUF4aXMnLFxuICAgIGNhdGVBeGlzTmFtZTogJ3JhZGl1c0F4aXMnXG4gIH07XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgb2Zmc2V0IG9mIG1haW4gcGFydCBpbiB0aGUgc3ZnIGVsZW1lbnRcbiAqIEBwYXJhbSAge09iamVjdH0gcGFyYW1zLnByb3BzICAgICAgICAgIExhdGVzdCBwcm9wc1xuICogQHBhcmFtICB7QXJyYXl9ICBwYXJhbXMuZ3JhcGhpY2FsSXRlbXMgVGhlIGluc3RhbmNlcyBvZiBpdGVtXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBhcmFtcy54QXhpc01hcCAgICAgICBUaGUgY29uZmlndXJhdGlvbiBvZiB4LWF4aXNcbiAqIEBwYXJhbSAge09iamVjdH0gcGFyYW1zLnlBeGlzTWFwICAgICAgIFRoZSBjb25maWd1cmF0aW9uIG9mIHktYXhpc1xuICogQHBhcmFtICB7T2JqZWN0fSBwcmV2TGVnZW5kQkJveCAgICAgICAgVGhlIGJvdW5kYXJ5IGJveCBvZiBsZWdlbmRcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIG9mZnNldCBvZiBtYWluIHBhcnQgaW4gdGhlIHN2ZyBlbGVtZW50XG4gKi9cbnZhciBjYWxjdWxhdGVPZmZzZXQgPSBmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQoX3JlZjUsIHByZXZMZWdlbmRCQm94KSB7XG4gIHZhciBwcm9wcyA9IF9yZWY1LnByb3BzLFxuICAgIGdyYXBoaWNhbEl0ZW1zID0gX3JlZjUuZ3JhcGhpY2FsSXRlbXMsXG4gICAgX3JlZjUkeEF4aXNNYXAgPSBfcmVmNS54QXhpc01hcCxcbiAgICB4QXhpc01hcCA9IF9yZWY1JHhBeGlzTWFwID09PSB2b2lkIDAgPyB7fSA6IF9yZWY1JHhBeGlzTWFwLFxuICAgIF9yZWY1JHlBeGlzTWFwID0gX3JlZjUueUF4aXNNYXAsXG4gICAgeUF4aXNNYXAgPSBfcmVmNSR5QXhpc01hcCA9PT0gdm9pZCAwID8ge30gOiBfcmVmNSR5QXhpc01hcDtcbiAgdmFyIHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxuICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gIHZhciBtYXJnaW4gPSBwcm9wcy5tYXJnaW4gfHwge307XG4gIHZhciBicnVzaEl0ZW0gPSAoMCwgX1JlYWN0VXRpbHMuZmluZENoaWxkQnlUeXBlKShjaGlsZHJlbiwgX0JydXNoLkJydXNoKTtcbiAgdmFyIGxlZ2VuZEl0ZW0gPSAoMCwgX1JlYWN0VXRpbHMuZmluZENoaWxkQnlUeXBlKShjaGlsZHJlbiwgX0xlZ2VuZC5MZWdlbmQpO1xuICB2YXIgb2Zmc2V0SCA9IE9iamVjdC5rZXlzKHlBeGlzTWFwKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgaWQpIHtcbiAgICB2YXIgZW50cnkgPSB5QXhpc01hcFtpZF07XG4gICAgdmFyIG9yaWVudGF0aW9uID0gZW50cnkub3JpZW50YXRpb247XG4gICAgaWYgKCFlbnRyeS5taXJyb3IgJiYgIWVudHJ5LmhpZGUpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIG9yaWVudGF0aW9uLCByZXN1bHRbb3JpZW50YXRpb25dICsgZW50cnkud2lkdGgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge1xuICAgIGxlZnQ6IG1hcmdpbi5sZWZ0IHx8IDAsXG4gICAgcmlnaHQ6IG1hcmdpbi5yaWdodCB8fCAwXG4gIH0pO1xuICB2YXIgb2Zmc2V0ViA9IE9iamVjdC5rZXlzKHhBeGlzTWFwKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgaWQpIHtcbiAgICB2YXIgZW50cnkgPSB4QXhpc01hcFtpZF07XG4gICAgdmFyIG9yaWVudGF0aW9uID0gZW50cnkub3JpZW50YXRpb247XG4gICAgaWYgKCFlbnRyeS5taXJyb3IgJiYgIWVudHJ5LmhpZGUpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIG9yaWVudGF0aW9uLCAoMCwgX2dldFtcImRlZmF1bHRcIl0pKHJlc3VsdCwgXCJcIi5jb25jYXQob3JpZW50YXRpb24pKSArIGVudHJ5LmhlaWdodCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7XG4gICAgdG9wOiBtYXJnaW4udG9wIHx8IDAsXG4gICAgYm90dG9tOiBtYXJnaW4uYm90dG9tIHx8IDBcbiAgfSk7XG4gIHZhciBvZmZzZXQgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9mZnNldFYpLCBvZmZzZXRIKTtcbiAgdmFyIGJydXNoQm90dG9tID0gb2Zmc2V0LmJvdHRvbTtcbiAgaWYgKGJydXNoSXRlbSkge1xuICAgIG9mZnNldC5ib3R0b20gKz0gYnJ1c2hJdGVtLnByb3BzLmhlaWdodCB8fCBfQnJ1c2guQnJ1c2guZGVmYXVsdFByb3BzLmhlaWdodDtcbiAgfVxuICBpZiAobGVnZW5kSXRlbSAmJiBwcmV2TGVnZW5kQkJveCkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbWFyZ2luIGlzIG9wdGlvbmFsIGluIHByb3BzIGJ1dCByZXF1aXJlZCBpbiBhcHBlbmRPZmZzZXRPZkxlZ2VuZFxuICAgIG9mZnNldCA9ICgwLCBfQ2hhcnRVdGlscy5hcHBlbmRPZmZzZXRPZkxlZ2VuZCkob2Zmc2V0LCBncmFwaGljYWxJdGVtcywgcHJvcHMsIHByZXZMZWdlbmRCQm94KTtcbiAgfVxuICB2YXIgb2Zmc2V0V2lkdGggPSB3aWR0aCAtIG9mZnNldC5sZWZ0IC0gb2Zmc2V0LnJpZ2h0O1xuICB2YXIgb2Zmc2V0SGVpZ2h0ID0gaGVpZ2h0IC0gb2Zmc2V0LnRvcCAtIG9mZnNldC5ib3R0b207XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgIGJydXNoQm90dG9tOiBicnVzaEJvdHRvbVxuICB9LCBvZmZzZXQpLCB7fSwge1xuICAgIC8vIG5ldmVyIHJldHVybiBuZWdhdGl2ZSB2YWx1ZXMgZm9yIGhlaWdodCBhbmQgd2lkdGhcbiAgICB3aWR0aDogTWF0aC5tYXgob2Zmc2V0V2lkdGgsIDApLFxuICAgIGhlaWdodDogTWF0aC5tYXgob2Zmc2V0SGVpZ2h0LCAwKVxuICB9KTtcbn07XG4vLyBEZXRlcm1pbmUgdGhlIHNpemUgb2YgdGhlIGF4aXMsIHVzZWQgZm9yIGNhbGN1bGF0aW9uIG9mIHJlbGF0aXZlIGJhciBzaXplc1xudmFyIGdldENhcnRlc2lhbkF4aXNTaXplID0gZnVuY3Rpb24gZ2V0Q2FydGVzaWFuQXhpc1NpemUoYXhpc09iaiwgYXhpc05hbWUpIHtcbiAgaWYgKGF4aXNOYW1lID09PSAneEF4aXMnKSB7XG4gICAgcmV0dXJuIGF4aXNPYmpbYXhpc05hbWVdLndpZHRoO1xuICB9XG4gIGlmIChheGlzTmFtZSA9PT0gJ3lBeGlzJykge1xuICAgIHJldHVybiBheGlzT2JqW2F4aXNOYW1lXS5oZWlnaHQ7XG4gIH1cbiAgLy8gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgQmFyIGNoYXJ0cyAoaS5lLiBjaGFydHMgd2l0aCBjYXJ0ZXNpYW4gYXhlcyksIHNvIHdlIHNob3VsZCBuZXZlciBnZXQgaGVyZVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbnZhciBnZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQgPSBleHBvcnRzLmdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCA9IGZ1bmN0aW9uIGdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydChfcmVmNikge1xuICB2YXIgY2hhcnROYW1lID0gX3JlZjYuY2hhcnROYW1lLFxuICAgIEdyYXBoaWNhbENoaWxkID0gX3JlZjYuR3JhcGhpY2FsQ2hpbGQsXG4gICAgX3JlZjYkZGVmYXVsdFRvb2x0aXBFID0gX3JlZjYuZGVmYXVsdFRvb2x0aXBFdmVudFR5cGUsXG4gICAgZGVmYXVsdFRvb2x0aXBFdmVudFR5cGUgPSBfcmVmNiRkZWZhdWx0VG9vbHRpcEUgPT09IHZvaWQgMCA/ICdheGlzJyA6IF9yZWY2JGRlZmF1bHRUb29sdGlwRSxcbiAgICBfcmVmNiR2YWxpZGF0ZVRvb2x0aXAgPSBfcmVmNi52YWxpZGF0ZVRvb2x0aXBFdmVudFR5cGVzLFxuICAgIHZhbGlkYXRlVG9vbHRpcEV2ZW50VHlwZXMgPSBfcmVmNiR2YWxpZGF0ZVRvb2x0aXAgPT09IHZvaWQgMCA/IFsnYXhpcyddIDogX3JlZjYkdmFsaWRhdGVUb29sdGlwLFxuICAgIGF4aXNDb21wb25lbnRzID0gX3JlZjYuYXhpc0NvbXBvbmVudHMsXG4gICAgbGVnZW5kQ29udGVudCA9IF9yZWY2LmxlZ2VuZENvbnRlbnQsXG4gICAgZm9ybWF0QXhpc01hcCA9IF9yZWY2LmZvcm1hdEF4aXNNYXAsXG4gICAgZGVmYXVsdFByb3BzID0gX3JlZjYuZGVmYXVsdFByb3BzO1xuICB2YXIgZ2V0Rm9ybWF0SXRlbXMgPSBmdW5jdGlvbiBnZXRGb3JtYXRJdGVtcyhwcm9wcywgY3VycmVudFN0YXRlKSB7XG4gICAgdmFyIGdyYXBoaWNhbEl0ZW1zID0gY3VycmVudFN0YXRlLmdyYXBoaWNhbEl0ZW1zLFxuICAgICAgc3RhY2tHcm91cHMgPSBjdXJyZW50U3RhdGUuc3RhY2tHcm91cHMsXG4gICAgICBvZmZzZXQgPSBjdXJyZW50U3RhdGUub2Zmc2V0LFxuICAgICAgdXBkYXRlSWQgPSBjdXJyZW50U3RhdGUudXBkYXRlSWQsXG4gICAgICBkYXRhU3RhcnRJbmRleCA9IGN1cnJlbnRTdGF0ZS5kYXRhU3RhcnRJbmRleCxcbiAgICAgIGRhdGFFbmRJbmRleCA9IGN1cnJlbnRTdGF0ZS5kYXRhRW5kSW5kZXg7XG4gICAgdmFyIGJhclNpemUgPSBwcm9wcy5iYXJTaXplLFxuICAgICAgbGF5b3V0ID0gcHJvcHMubGF5b3V0LFxuICAgICAgYmFyR2FwID0gcHJvcHMuYmFyR2FwLFxuICAgICAgYmFyQ2F0ZWdvcnlHYXAgPSBwcm9wcy5iYXJDYXRlZ29yeUdhcCxcbiAgICAgIGdsb2JhbE1heEJhclNpemUgPSBwcm9wcy5tYXhCYXJTaXplO1xuICAgIHZhciBfZ2V0QXhpc05hbWVCeUxheW91dCA9IGdldEF4aXNOYW1lQnlMYXlvdXQobGF5b3V0KSxcbiAgICAgIG51bWVyaWNBeGlzTmFtZSA9IF9nZXRBeGlzTmFtZUJ5TGF5b3V0Lm51bWVyaWNBeGlzTmFtZSxcbiAgICAgIGNhdGVBeGlzTmFtZSA9IF9nZXRBeGlzTmFtZUJ5TGF5b3V0LmNhdGVBeGlzTmFtZTtcbiAgICB2YXIgaGFzQmFyID0gaGFzR3JhcGhpY2FsQmFySXRlbShncmFwaGljYWxJdGVtcyk7XG4gICAgdmFyIGZvcm1hdHRlZEl0ZW1zID0gW107XG4gICAgZ3JhcGhpY2FsSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHZhciBkaXNwbGF5ZWREYXRhID0gZ2V0RGlzcGxheWVkRGF0YShwcm9wcy5kYXRhLCB7XG4gICAgICAgIGdyYXBoaWNhbEl0ZW1zOiBbaXRlbV0sXG4gICAgICAgIGRhdGFTdGFydEluZGV4OiBkYXRhU3RhcnRJbmRleCxcbiAgICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXhcbiAgICAgIH0pO1xuICAgICAgdmFyIGl0ZW1Qcm9wcyA9IGl0ZW0udHlwZS5kZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbS50eXBlLmRlZmF1bHRQcm9wcyksIGl0ZW0ucHJvcHMpIDogaXRlbS5wcm9wcztcbiAgICAgIHZhciBkYXRhS2V5ID0gaXRlbVByb3BzLmRhdGFLZXksXG4gICAgICAgIGNoaWxkTWF4QmFyU2l6ZSA9IGl0ZW1Qcm9wcy5tYXhCYXJTaXplO1xuICAgICAgLy8gYXhpc0lkIG9mIHRoZSBudW1lcmljYWwgYXhpc1xuICAgICAgdmFyIG51bWVyaWNBeGlzSWQgPSBpdGVtUHJvcHNbXCJcIi5jb25jYXQobnVtZXJpY0F4aXNOYW1lLCBcIklkXCIpXTtcbiAgICAgIC8vIGF4aXNJZCBvZiB0aGUgY2F0ZWdvcmljYWwgYXhpc1xuICAgICAgdmFyIGNhdGVBeGlzSWQgPSBpdGVtUHJvcHNbXCJcIi5jb25jYXQoY2F0ZUF4aXNOYW1lLCBcIklkXCIpXTtcbiAgICAgIHZhciBheGlzT2JqSW5pdGlhbFZhbHVlID0ge307XG4gICAgICB2YXIgYXhpc09iaiA9IGF4aXNDb21wb25lbnRzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBlbnRyeSkge1xuICAgICAgICB2YXIgX2l0ZW0kdHlwZSRkaXNwbGF5TmFtLCBfaXRlbSR0eXBlO1xuICAgICAgICAvLyBtYXAgb2YgYXhpc0lkIHRvIGF4aXMgZm9yIGEgc3BlY2lmaWMgYXhpcyB0eXBlXG4gICAgICAgIHZhciBheGlzTWFwID0gY3VycmVudFN0YXRlW1wiXCIuY29uY2F0KGVudHJ5LmF4aXNUeXBlLCBcIk1hcFwiKV07XG4gICAgICAgIC8vIGF4aXNJZCBvZiBheGlzIHdlIGFyZSBjdXJyZW50bHkgY29tcHV0aW5nXG4gICAgICAgIHZhciBpZCA9IGl0ZW1Qcm9wc1tcIlwiLmNvbmNhdChlbnRyeS5heGlzVHlwZSwgXCJJZFwiKV07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRlbGwgdGhlIHVzZXIgaW4gZGV2IG1vZGUgdGhhdCB0aGVpciBjb25maWd1cmF0aW9uIGlzIGluY29ycmVjdCBpZiB3ZSBjYW5ub3QgZmluZCBhIG1hdGNoIGJldHdlZW5cbiAgICAgICAgICogYXhpc0lkIG9uIHRoZSBjaGFydCBhbmQgYXhpc0lkIG9uIHRoZSBheGlzLiB6QXhpcyBkb2VzIG5vdCBnZXQgcGFzc2VkIGluIHRoZSBtYXAgZm9yIENvbXBvc2VkQ2hhcnQsXG4gICAgICAgICAqIGxlYXZlIGl0IG91dCBvZiB0aGUgY2hlY2sgZm9yIG5vdy5cbiAgICAgICAgICovXG4gICAgICAgICEoYXhpc01hcCAmJiBheGlzTWFwW2lkXSB8fCBlbnRyeS5heGlzVHlwZSA9PT0gJ3pBeGlzJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAoMCwgX3RpbnlJbnZhcmlhbnRbXCJkZWZhdWx0XCJdKShmYWxzZSwgXCJTcGVjaWZ5aW5nIGEobikgXCIuY29uY2F0KGVudHJ5LmF4aXNUeXBlLCBcIklkIHJlcXVpcmVzIGEgY29ycmVzcG9uZGluZyBcIikuY29uY2F0KGVudHJ5LmF4aXNUeXBlXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igd2Ugc2hvdWxkIHN0b3AgcmVhZGluZyBkYXRhIGZyb20gUmVhY3RFbGVtZW50c1xuICAgICAgICAsIFwiSWQgb24gdGhlIHRhcmdldGVkIGdyYXBoaWNhbCBjb21wb25lbnQgXCIpLmNvbmNhdCgoX2l0ZW0kdHlwZSRkaXNwbGF5TmFtID0gaXRlbSA9PT0gbnVsbCB8fCBpdGVtID09PSB2b2lkIDAgfHwgKF9pdGVtJHR5cGUgPSBpdGVtLnR5cGUpID09PSBudWxsIHx8IF9pdGVtJHR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pdGVtJHR5cGUuZGlzcGxheU5hbWUpICE9PSBudWxsICYmIF9pdGVtJHR5cGUkZGlzcGxheU5hbSAhPT0gdm9pZCAwID8gX2l0ZW0kdHlwZSRkaXNwbGF5TmFtIDogJycpKSA6ICgwLCBfdGlueUludmFyaWFudFtcImRlZmF1bHRcIl0pKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgICAgICAvLyB0aGUgYXhpcyB3ZSBhcmUgY3VycmVudGx5IGZvcm1hdHRpbmdcbiAgICAgICAgdmFyIGF4aXMgPSBheGlzTWFwW2lkXTtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVzdWx0KSwge30sIF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoe30sIGVudHJ5LmF4aXNUeXBlLCBheGlzKSwgXCJcIi5jb25jYXQoZW50cnkuYXhpc1R5cGUsIFwiVGlja3NcIiksICgwLCBfQ2hhcnRVdGlscy5nZXRUaWNrc09mQXhpcykoYXhpcykpKTtcbiAgICAgIH0sIGF4aXNPYmpJbml0aWFsVmFsdWUpO1xuICAgICAgdmFyIGNhdGVBeGlzID0gYXhpc09ialtjYXRlQXhpc05hbWVdO1xuICAgICAgdmFyIGNhdGVUaWNrcyA9IGF4aXNPYmpbXCJcIi5jb25jYXQoY2F0ZUF4aXNOYW1lLCBcIlRpY2tzXCIpXTtcbiAgICAgIHZhciBzdGFja2VkRGF0YSA9IHN0YWNrR3JvdXBzICYmIHN0YWNrR3JvdXBzW251bWVyaWNBeGlzSWRdICYmIHN0YWNrR3JvdXBzW251bWVyaWNBeGlzSWRdLmhhc1N0YWNrICYmICgwLCBfQ2hhcnRVdGlscy5nZXRTdGFja2VkRGF0YU9mSXRlbSkoaXRlbSwgc3RhY2tHcm91cHNbbnVtZXJpY0F4aXNJZF0uc3RhY2tHcm91cHMpO1xuICAgICAgdmFyIGl0ZW1Jc0JhciA9ICgwLCBfUmVhY3RVdGlscy5nZXREaXNwbGF5TmFtZSkoaXRlbS50eXBlKS5pbmRleE9mKCdCYXInKSA+PSAwO1xuICAgICAgdmFyIGJhbmRTaXplID0gKDAsIF9DaGFydFV0aWxzLmdldEJhbmRTaXplT2ZBeGlzKShjYXRlQXhpcywgY2F0ZVRpY2tzKTtcbiAgICAgIHZhciBiYXJQb3NpdGlvbiA9IFtdO1xuICAgICAgdmFyIHNpemVMaXN0ID0gaGFzQmFyICYmICgwLCBfQ2hhcnRVdGlscy5nZXRCYXJTaXplTGlzdCkoe1xuICAgICAgICBiYXJTaXplOiBiYXJTaXplLFxuICAgICAgICBzdGFja0dyb3Vwczogc3RhY2tHcm91cHMsXG4gICAgICAgIHRvdGFsU2l6ZTogZ2V0Q2FydGVzaWFuQXhpc1NpemUoYXhpc09iaiwgY2F0ZUF4aXNOYW1lKVxuICAgICAgfSk7XG4gICAgICBpZiAoaXRlbUlzQmFyKSB7XG4gICAgICAgIHZhciBfcmVmNywgX2dldEJhbmRTaXplT2ZBeGlzO1xuICAgICAgICAvLyBJZiBpdCBpcyBiYXIsIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb2YgYmFyXG4gICAgICAgIHZhciBtYXhCYXJTaXplID0gKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGNoaWxkTWF4QmFyU2l6ZSkgPyBnbG9iYWxNYXhCYXJTaXplIDogY2hpbGRNYXhCYXJTaXplO1xuICAgICAgICB2YXIgYmFyQmFuZFNpemUgPSAoX3JlZjcgPSAoX2dldEJhbmRTaXplT2ZBeGlzID0gKDAsIF9DaGFydFV0aWxzLmdldEJhbmRTaXplT2ZBeGlzKShjYXRlQXhpcywgY2F0ZVRpY2tzLCB0cnVlKSkgIT09IG51bGwgJiYgX2dldEJhbmRTaXplT2ZBeGlzICE9PSB2b2lkIDAgPyBfZ2V0QmFuZFNpemVPZkF4aXMgOiBtYXhCYXJTaXplKSAhPT0gbnVsbCAmJiBfcmVmNyAhPT0gdm9pZCAwID8gX3JlZjcgOiAwO1xuICAgICAgICBiYXJQb3NpdGlvbiA9ICgwLCBfQ2hhcnRVdGlscy5nZXRCYXJQb3NpdGlvbikoe1xuICAgICAgICAgIGJhckdhcDogYmFyR2FwLFxuICAgICAgICAgIGJhckNhdGVnb3J5R2FwOiBiYXJDYXRlZ29yeUdhcCxcbiAgICAgICAgICBiYW5kU2l6ZTogYmFyQmFuZFNpemUgIT09IGJhbmRTaXplID8gYmFyQmFuZFNpemUgOiBiYW5kU2l6ZSxcbiAgICAgICAgICBzaXplTGlzdDogc2l6ZUxpc3RbY2F0ZUF4aXNJZF0sXG4gICAgICAgICAgbWF4QmFyU2l6ZTogbWF4QmFyU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGJhckJhbmRTaXplICE9PSBiYW5kU2l6ZSkge1xuICAgICAgICAgIGJhclBvc2l0aW9uID0gYmFyUG9zaXRpb24ubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBvcyksIHt9LCB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBvcy5wb3NpdGlvbiksIHt9LCB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBwb3MucG9zaXRpb24ub2Zmc2V0IC0gYmFyQmFuZFNpemUgLyAyXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB3ZSBzaG91bGQgc3RvcCByZWFkaW5nIGRhdGEgZnJvbSBSZWFjdEVsZW1lbnRzXG4gICAgICB2YXIgY29tcG9zZWRGbiA9IGl0ZW0gJiYgaXRlbS50eXBlICYmIGl0ZW0udHlwZS5nZXRDb21wb3NlZERhdGE7XG4gICAgICBpZiAoY29tcG9zZWRGbikge1xuICAgICAgICBmb3JtYXR0ZWRJdGVtcy5wdXNoKHtcbiAgICAgICAgICBwcm9wczogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjb21wb3NlZEZuKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYXhpc09iaiksIHt9LCB7XG4gICAgICAgICAgICBkaXNwbGF5ZWREYXRhOiBkaXNwbGF5ZWREYXRhLFxuICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgZGF0YUtleTogZGF0YUtleSxcbiAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICBiYW5kU2l6ZTogYmFuZFNpemUsXG4gICAgICAgICAgICBiYXJQb3NpdGlvbjogYmFyUG9zaXRpb24sXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgIHN0YWNrZWREYXRhOiBzdGFja2VkRGF0YSxcbiAgICAgICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICAgICAgZGF0YVN0YXJ0SW5kZXg6IGRhdGFTdGFydEluZGV4LFxuICAgICAgICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXhcbiAgICAgICAgICB9KSkpLCB7fSwgX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgICAga2V5OiBpdGVtLmtleSB8fCBcIml0ZW0tXCIuY29uY2F0KGluZGV4KVxuICAgICAgICAgIH0sIG51bWVyaWNBeGlzTmFtZSwgYXhpc09ialtudW1lcmljQXhpc05hbWVdKSwgY2F0ZUF4aXNOYW1lLCBheGlzT2JqW2NhdGVBeGlzTmFtZV0pLCBcImFuaW1hdGlvbklkXCIsIHVwZGF0ZUlkKSksXG4gICAgICAgICAgY2hpbGRJbmRleDogKDAsIF9SZWFjdFV0aWxzLnBhcnNlQ2hpbGRJbmRleCkoaXRlbSwgcHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICAgIGl0ZW06IGl0ZW1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvcm1hdHRlZEl0ZW1zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgQXhpc01hcHMgYXJlIGV4cGVuc2l2ZSB0byByZW5kZXIgb24gbGFyZ2UgZGF0YSBzZXRzXG4gICAqIHNvIHByb3ZpZGUgdGhlIGFiaWxpdHkgdG8gc3RvcmUgdGhlbSBpbiBzdGF0ZSBhbmQgb25seSB1cGRhdGUgdGhlbSB3aGVuIG5lY2Vzc2FyeVxuICAgKiB0aGV5IGFyZSBkZXBlbmRlbnQgdXBvbiB0aGUgc3RhcnQgYW5kIGVuZCBpbmRleCBvZlxuICAgKiB0aGUgYnJ1c2ggc28gaXQncyBpbXBvcnRhbnQgdGhhdCB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgX2FmdGVyX1xuICAgKiB0aGUgc3RhdGUgaXMgdXBkYXRlZCB3aXRoIGFueSBuZXcgc3RhcnQvZW5kIGluZGljZXNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzICAgICAgICAgIFRoZSBwcm9wcyBvYmplY3QgdG8gYmUgdXNlZCBmb3IgdXBkYXRpbmcgdGhlIGF4aXNtYXBzXG4gICAqIGRhdGFTdGFydEluZGV4OiBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIGRhdGEgc2VyaWVzIHdoZW4gYSBicnVzaCBpcyBhcHBsaWVkXG4gICAqIGRhdGFFbmRJbmRleDogVGhlIGVuZCBpbmRleCBvZiB0aGUgZGF0YSBzZXJpZXMgd2hlbiBhIGJydXNoIGlzIGFwcGxpZWRcbiAgICogdXBkYXRlSWQ6IFRoZSB1cGRhdGUgaWRcbiAgICogQHBhcmFtIHtPYmplY3R9IHByZXZTdGF0ZSAgICAgIFByZXYgc3RhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fSBzdGF0ZSBOZXcgc3RhdGUgdG8gc2V0XG4gICAqL1xuICB2YXIgdXBkYXRlU3RhdGVPZkF4aXNNYXBzT2Zmc2V0QW5kU3RhY2tHcm91cHMgPSBmdW5jdGlvbiB1cGRhdGVTdGF0ZU9mQXhpc01hcHNPZmZzZXRBbmRTdGFja0dyb3VwcyhfcmVmOCwgcHJldlN0YXRlKSB7XG4gICAgdmFyIHByb3BzID0gX3JlZjgucHJvcHMsXG4gICAgICBkYXRhU3RhcnRJbmRleCA9IF9yZWY4LmRhdGFTdGFydEluZGV4LFxuICAgICAgZGF0YUVuZEluZGV4ID0gX3JlZjguZGF0YUVuZEluZGV4LFxuICAgICAgdXBkYXRlSWQgPSBfcmVmOC51cGRhdGVJZDtcbiAgICBpZiAoISgwLCBfUmVhY3RVdGlscy52YWxpZGF0ZVdpZHRoSGVpZ2h0KSh7XG4gICAgICBwcm9wczogcHJvcHNcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgbGF5b3V0ID0gcHJvcHMubGF5b3V0LFxuICAgICAgc3RhY2tPZmZzZXQgPSBwcm9wcy5zdGFja09mZnNldCxcbiAgICAgIGRhdGEgPSBwcm9wcy5kYXRhLFxuICAgICAgcmV2ZXJzZVN0YWNrT3JkZXIgPSBwcm9wcy5yZXZlcnNlU3RhY2tPcmRlcjtcbiAgICB2YXIgX2dldEF4aXNOYW1lQnlMYXlvdXQyID0gZ2V0QXhpc05hbWVCeUxheW91dChsYXlvdXQpLFxuICAgICAgbnVtZXJpY0F4aXNOYW1lID0gX2dldEF4aXNOYW1lQnlMYXlvdXQyLm51bWVyaWNBeGlzTmFtZSxcbiAgICAgIGNhdGVBeGlzTmFtZSA9IF9nZXRBeGlzTmFtZUJ5TGF5b3V0Mi5jYXRlQXhpc05hbWU7XG4gICAgdmFyIGdyYXBoaWNhbEl0ZW1zID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRBbGxCeVR5cGUpKGNoaWxkcmVuLCBHcmFwaGljYWxDaGlsZCk7XG4gICAgdmFyIHN0YWNrR3JvdXBzID0gKDAsIF9DaGFydFV0aWxzLmdldFN0YWNrR3JvdXBzQnlBeGlzSWQpKGRhdGEsIGdyYXBoaWNhbEl0ZW1zLCBcIlwiLmNvbmNhdChudW1lcmljQXhpc05hbWUsIFwiSWRcIiksIFwiXCIuY29uY2F0KGNhdGVBeGlzTmFtZSwgXCJJZFwiKSwgc3RhY2tPZmZzZXQsIHJldmVyc2VTdGFja09yZGVyKTtcbiAgICB2YXIgYXhpc09iaiA9IGF4aXNDb21wb25lbnRzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBlbnRyeSkge1xuICAgICAgdmFyIG5hbWUgPSBcIlwiLmNvbmNhdChlbnRyeS5heGlzVHlwZSwgXCJNYXBcIik7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXN1bHQpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBuYW1lLCBnZXRBeGlzTWFwKHByb3BzLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcbiAgICAgICAgZ3JhcGhpY2FsSXRlbXM6IGdyYXBoaWNhbEl0ZW1zLFxuICAgICAgICBzdGFja0dyb3VwczogZW50cnkuYXhpc1R5cGUgPT09IG51bWVyaWNBeGlzTmFtZSAmJiBzdGFja0dyb3VwcyxcbiAgICAgICAgZGF0YVN0YXJ0SW5kZXg6IGRhdGFTdGFydEluZGV4LFxuICAgICAgICBkYXRhRW5kSW5kZXg6IGRhdGFFbmRJbmRleFxuICAgICAgfSkpKSk7XG4gICAgfSwge30pO1xuICAgIHZhciBvZmZzZXQgPSBjYWxjdWxhdGVPZmZzZXQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBheGlzT2JqKSwge30sIHtcbiAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgIGdyYXBoaWNhbEl0ZW1zOiBncmFwaGljYWxJdGVtc1xuICAgIH0pLCBwcmV2U3RhdGUgPT09IG51bGwgfHwgcHJldlN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2U3RhdGUubGVnZW5kQkJveCk7XG4gICAgT2JqZWN0LmtleXMoYXhpc09iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBheGlzT2JqW2tleV0gPSBmb3JtYXRBeGlzTWFwKHByb3BzLCBheGlzT2JqW2tleV0sIG9mZnNldCwga2V5LnJlcGxhY2UoJ01hcCcsICcnKSwgY2hhcnROYW1lKTtcbiAgICB9KTtcbiAgICB2YXIgY2F0ZUF4aXNNYXAgPSBheGlzT2JqW1wiXCIuY29uY2F0KGNhdGVBeGlzTmFtZSwgXCJNYXBcIildO1xuICAgIHZhciB0aWNrc09iaiA9IHRvb2x0aXBUaWNrc0dlbmVyYXRvcihjYXRlQXhpc01hcCk7XG4gICAgdmFyIGZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zID0gZ2V0Rm9ybWF0SXRlbXMocHJvcHMsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYXhpc09iaiksIHt9LCB7XG4gICAgICBkYXRhU3RhcnRJbmRleDogZGF0YVN0YXJ0SW5kZXgsXG4gICAgICBkYXRhRW5kSW5kZXg6IGRhdGFFbmRJbmRleCxcbiAgICAgIHVwZGF0ZUlkOiB1cGRhdGVJZCxcbiAgICAgIGdyYXBoaWNhbEl0ZW1zOiBncmFwaGljYWxJdGVtcyxcbiAgICAgIHN0YWNrR3JvdXBzOiBzdGFja0dyb3VwcyxcbiAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgfSkpO1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXM6IGZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zLFxuICAgICAgZ3JhcGhpY2FsSXRlbXM6IGdyYXBoaWNhbEl0ZW1zLFxuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBzdGFja0dyb3Vwczogc3RhY2tHcm91cHNcbiAgICB9LCB0aWNrc09iaiksIGF4aXNPYmopO1xuICB9O1xuICB2YXIgQ2F0ZWdvcmljYWxDaGFydFdyYXBwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICBmdW5jdGlvbiBDYXRlZ29yaWNhbENoYXJ0V3JhcHBlcihfcHJvcHMpIHtcbiAgICAgIHZhciBfcHJvcHMkaWQsIF9wcm9wcyR0aHJvdHRsZURlbGF5O1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyKTtcbiAgICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBDYXRlZ29yaWNhbENoYXJ0V3JhcHBlciwgW19wcm9wc10pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImV2ZW50RW1pdHRlclN5bWJvbFwiLCBTeW1ib2woJ3JlY2hhcnRzRXZlbnRFbWl0dGVyJykpO1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImFjY2Vzc2liaWxpdHlNYW5hZ2VyXCIsIG5ldyBfQWNjZXNzaWJpbGl0eU1hbmFnZXIuQWNjZXNzaWJpbGl0eU1hbmFnZXIoKSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlTGVnZW5kQkJveFVwZGF0ZVwiLCBmdW5jdGlvbiAoYm94KSB7XG4gICAgICAgIGlmIChib3gpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkc3RhdGUgPSBfdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIGRhdGFTdGFydEluZGV4ID0gX3RoaXMkc3RhdGUuZGF0YVN0YXJ0SW5kZXgsXG4gICAgICAgICAgICBkYXRhRW5kSW5kZXggPSBfdGhpcyRzdGF0ZS5kYXRhRW5kSW5kZXgsXG4gICAgICAgICAgICB1cGRhdGVJZCA9IF90aGlzJHN0YXRlLnVwZGF0ZUlkO1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgbGVnZW5kQkJveDogYm94XG4gICAgICAgICAgfSwgdXBkYXRlU3RhdGVPZkF4aXNNYXBzT2Zmc2V0QW5kU3RhY2tHcm91cHMoe1xuICAgICAgICAgICAgcHJvcHM6IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgZGF0YVN0YXJ0SW5kZXg6IGRhdGFTdGFydEluZGV4LFxuICAgICAgICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXgsXG4gICAgICAgICAgICB1cGRhdGVJZDogdXBkYXRlSWRcbiAgICAgICAgICB9LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF90aGlzLnN0YXRlKSwge30sIHtcbiAgICAgICAgICAgIGxlZ2VuZEJCb3g6IGJveFxuICAgICAgICAgIH0pKSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVSZWNlaXZlU3luY0V2ZW50XCIsIGZ1bmN0aW9uIChjSWQsIGRhdGEsIGVtaXR0ZXIpIHtcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLnN5bmNJZCA9PT0gY0lkKSB7XG4gICAgICAgICAgaWYgKGVtaXR0ZXIgPT09IF90aGlzLmV2ZW50RW1pdHRlclN5bWJvbCAmJiB0eXBlb2YgX3RoaXMucHJvcHMuc3luY01ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5hcHBseVN5bmNFdmVudChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQnJ1c2hDaGFuZ2VcIiwgZnVuY3Rpb24gKF9yZWY5KSB7XG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gX3JlZjkuc3RhcnRJbmRleCxcbiAgICAgICAgICBlbmRJbmRleCA9IF9yZWY5LmVuZEluZGV4O1xuICAgICAgICAvLyBPbmx5IHRyaWdnZXIgY2hhbmdlcyBpZiB0aGUgZXh0ZW50cyBvZiB0aGUgYnJ1c2ggaGF2ZSBhY3R1YWxseSBjaGFuZ2VkXG4gICAgICAgIGlmIChzdGFydEluZGV4ICE9PSBfdGhpcy5zdGF0ZS5kYXRhU3RhcnRJbmRleCB8fCBlbmRJbmRleCAhPT0gX3RoaXMuc3RhdGUuZGF0YUVuZEluZGV4KSB7XG4gICAgICAgICAgdmFyIHVwZGF0ZUlkID0gX3RoaXMuc3RhdGUudXBkYXRlSWQ7XG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgICBkYXRhU3RhcnRJbmRleDogc3RhcnRJbmRleCxcbiAgICAgICAgICAgICAgZGF0YUVuZEluZGV4OiBlbmRJbmRleFxuICAgICAgICAgICAgfSwgdXBkYXRlU3RhdGVPZkF4aXNNYXBzT2Zmc2V0QW5kU3RhY2tHcm91cHMoe1xuICAgICAgICAgICAgICBwcm9wczogX3RoaXMucHJvcHMsXG4gICAgICAgICAgICAgIGRhdGFTdGFydEluZGV4OiBzdGFydEluZGV4LFxuICAgICAgICAgICAgICBkYXRhRW5kSW5kZXg6IGVuZEluZGV4LFxuICAgICAgICAgICAgICB1cGRhdGVJZDogdXBkYXRlSWRcbiAgICAgICAgICAgIH0sIF90aGlzLnN0YXRlKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3RoaXMudHJpZ2dlclN5bmNFdmVudCh7XG4gICAgICAgICAgICBkYXRhU3RhcnRJbmRleDogc3RhcnRJbmRleCxcbiAgICAgICAgICAgIGRhdGFFbmRJbmRleDogZW5kSW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoYW5kbGVyIG9mIG1vdXNlIGVudGVyaW5nIGNoYXJ0XG4gICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGUgICAgICAgICAgICAgIEV2ZW50IG9iamVjdFxuICAgICAgICogQHJldHVybiB7TnVsbH0gICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgKi9cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVNb3VzZUVudGVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBtb3VzZSA9IF90aGlzLmdldE1vdXNlSW5mbyhlKTtcbiAgICAgICAgaWYgKG1vdXNlKSB7XG4gICAgICAgICAgdmFyIF9uZXh0U3RhdGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG1vdXNlKSwge30sIHtcbiAgICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKF9uZXh0U3RhdGUpO1xuICAgICAgICAgIF90aGlzLnRyaWdnZXJTeW5jRXZlbnQoX25leHRTdGF0ZSk7XG4gICAgICAgICAgdmFyIG9uTW91c2VFbnRlciA9IF90aGlzLnByb3BzLm9uTW91c2VFbnRlcjtcbiAgICAgICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob25Nb3VzZUVudGVyKSkge1xuICAgICAgICAgICAgb25Nb3VzZUVudGVyKF9uZXh0U3RhdGUsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwidHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG1vdXNlID0gX3RoaXMuZ2V0TW91c2VJbmZvKGUpO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gbW91c2UgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG1vdXNlKSwge30sIHtcbiAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmU6IHRydWVcbiAgICAgICAgfSkgOiB7XG4gICAgICAgICAgaXNUb29sdGlwQWN0aXZlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUpO1xuICAgICAgICBfdGhpcy50cmlnZ2VyU3luY0V2ZW50KG5leHRTdGF0ZSk7XG4gICAgICAgIHZhciBvbk1vdXNlTW92ZSA9IF90aGlzLnByb3BzLm9uTW91c2VNb3ZlO1xuICAgICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob25Nb3VzZU1vdmUpKSB7XG4gICAgICAgICAgb25Nb3VzZU1vdmUobmV4dFN0YXRlLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoYW5kbGVyIG9mIG1vdXNlIGVudGVyaW5nIGEgc2NhdHRlclxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVsIFRoZSBhY3RpdmUgc2NhdHRlclxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBubyByZXR1cm5cbiAgICAgICAqL1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZUl0ZW1Nb3VzZUVudGVyXCIsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFjdGl2ZUl0ZW06IGVsLFxuICAgICAgICAgICAgYWN0aXZlUGF5bG9hZDogZWwudG9vbHRpcFBheWxvYWQsXG4gICAgICAgICAgICBhY3RpdmVDb29yZGluYXRlOiBlbC50b29sdGlwUG9zaXRpb24gfHwge1xuICAgICAgICAgICAgICB4OiBlbC5jeCxcbiAgICAgICAgICAgICAgeTogZWwuY3lcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaGFuZGxlciBvZiBtb3VzZSBsZWF2aW5nIGEgc2NhdHRlclxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBubyByZXR1cm5cbiAgICAgICAqL1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZUl0ZW1Nb3VzZUxlYXZlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmU6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGhhbmRsZXIgb2YgbW91c2UgbW92aW5nIGluIGNoYXJ0XG4gICAgICAgKiBAcGFyYW0gIHtSZWFjdC5Nb3VzZUV2ZW50fSBlICAgICAgICBFdmVudCBvYmplY3RcbiAgICAgICAqIEByZXR1cm4ge3ZvaWR9IG5vIHJldHVyblxuICAgICAgICovXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlTW91c2VNb3ZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgICBfdGhpcy50aHJvdHRsZVRyaWdnZXJlZEFmdGVyTW91c2VNb3ZlKGUpO1xuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoYW5kbGVyIGlmIG1vdXNlIGxlYXZpbmcgY2hhcnRcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIEV2ZW50IG9iamVjdFxuICAgICAgICogQHJldHVybiB7TnVsbH0gbm8gcmV0dXJuXG4gICAgICAgKi9cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVNb3VzZUxlYXZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIF90aGlzLnRocm90dGxlVHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmUuY2FuY2VsKCk7XG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSB7XG4gICAgICAgICAgaXNUb29sdGlwQWN0aXZlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUpO1xuICAgICAgICBfdGhpcy50cmlnZ2VyU3luY0V2ZW50KG5leHRTdGF0ZSk7XG4gICAgICAgIHZhciBvbk1vdXNlTGVhdmUgPSBfdGhpcy5wcm9wcy5vbk1vdXNlTGVhdmU7XG4gICAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvbk1vdXNlTGVhdmUpKSB7XG4gICAgICAgICAgb25Nb3VzZUxlYXZlKG5leHRTdGF0ZSwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZU91dGVyRXZlbnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9ICgwLCBfUmVhY3RVdGlscy5nZXRSZWFjdEV2ZW50QnlUeXBlKShlKTtcbiAgICAgICAgdmFyIGV2ZW50ID0gKDAsIF9nZXRbXCJkZWZhdWx0XCJdKShfdGhpcy5wcm9wcywgXCJcIi5jb25jYXQoZXZlbnROYW1lKSk7XG4gICAgICAgIGlmIChldmVudE5hbWUgJiYgKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkoZXZlbnQpKSB7XG4gICAgICAgICAgdmFyIF9tb3VzZTtcbiAgICAgICAgICB2YXIgbW91c2U7XG4gICAgICAgICAgaWYgKC8uKnRvdWNoLiovaS50ZXN0KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIG1vdXNlID0gX3RoaXMuZ2V0TW91c2VJbmZvKGUuY2hhbmdlZFRvdWNoZXNbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb3VzZSA9IF90aGlzLmdldE1vdXNlSW5mbyhlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXZlbnQoKF9tb3VzZSA9IG1vdXNlKSAhPT0gbnVsbCAmJiBfbW91c2UgIT09IHZvaWQgMCA/IF9tb3VzZSA6IHt9LCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQ2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG1vdXNlID0gX3RoaXMuZ2V0TW91c2VJbmZvKGUpO1xuICAgICAgICBpZiAobW91c2UpIHtcbiAgICAgICAgICB2YXIgX25leHRTdGF0ZTIgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG1vdXNlKSwge30sIHtcbiAgICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKF9uZXh0U3RhdGUyKTtcbiAgICAgICAgICBfdGhpcy50cmlnZ2VyU3luY0V2ZW50KF9uZXh0U3RhdGUyKTtcbiAgICAgICAgICB2YXIgb25DbGljayA9IF90aGlzLnByb3BzLm9uQ2xpY2s7XG4gICAgICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9uQ2xpY2spKSB7XG4gICAgICAgICAgICBvbkNsaWNrKF9uZXh0U3RhdGUyLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZU1vdXNlRG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgb25Nb3VzZURvd24gPSBfdGhpcy5wcm9wcy5vbk1vdXNlRG93bjtcbiAgICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9uTW91c2VEb3duKSkge1xuICAgICAgICAgIHZhciBfbmV4dFN0YXRlMyA9IF90aGlzLmdldE1vdXNlSW5mbyhlKTtcbiAgICAgICAgICBvbk1vdXNlRG93bihfbmV4dFN0YXRlMywgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZU1vdXNlVXBcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG9uTW91c2VVcCA9IF90aGlzLnByb3BzLm9uTW91c2VVcDtcbiAgICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9uTW91c2VVcCkpIHtcbiAgICAgICAgICB2YXIgX25leHRTdGF0ZTQgPSBfdGhpcy5nZXRNb3VzZUluZm8oZSk7XG4gICAgICAgICAgb25Nb3VzZVVwKF9uZXh0U3RhdGU0LCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlVG91Y2hNb3ZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmNoYW5nZWRUb3VjaGVzICE9IG51bGwgJiYgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgX3RoaXMudGhyb3R0bGVUcmlnZ2VyZWRBZnRlck1vdXNlTW92ZShlLmNoYW5nZWRUb3VjaGVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlVG91Y2hTdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5jaGFuZ2VkVG91Y2hlcyAhPSBudWxsICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIF90aGlzLmhhbmRsZU1vdXNlRG93bihlLmNoYW5nZWRUb3VjaGVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlVG91Y2hFbmRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuY2hhbmdlZFRvdWNoZXMgIT0gbnVsbCAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBfdGhpcy5oYW5kbGVNb3VzZVVwKGUuY2hhbmdlZFRvdWNoZXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVEb3VibGVDbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgb25Eb3VibGVDbGljayA9IF90aGlzLnByb3BzLm9uRG91YmxlQ2xpY2s7XG4gICAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvbkRvdWJsZUNsaWNrKSkge1xuICAgICAgICAgIHZhciBfbmV4dFN0YXRlNSA9IF90aGlzLmdldE1vdXNlSW5mbyhlKTtcbiAgICAgICAgICBvbkRvdWJsZUNsaWNrKF9uZXh0U3RhdGU1LCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQ29udGV4dE1lbnVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG9uQ29udGV4dE1lbnUgPSBfdGhpcy5wcm9wcy5vbkNvbnRleHRNZW51O1xuICAgICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob25Db250ZXh0TWVudSkpIHtcbiAgICAgICAgICB2YXIgX25leHRTdGF0ZTYgPSBfdGhpcy5nZXRNb3VzZUluZm8oZSk7XG4gICAgICAgICAgb25Db250ZXh0TWVudShfbmV4dFN0YXRlNiwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInRyaWdnZXJTeW5jRXZlbnRcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLnN5bmNJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX0V2ZW50cy5ldmVudENlbnRlci5lbWl0KF9FdmVudHMuU1lOQ19FVkVOVCwgX3RoaXMucHJvcHMuc3luY0lkLCBkYXRhLCBfdGhpcy5ldmVudEVtaXR0ZXJTeW1ib2wpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJhcHBseVN5bmNFdmVudFwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBsYXlvdXQgPSBfdGhpcyRwcm9wcy5sYXlvdXQsXG4gICAgICAgICAgc3luY01ldGhvZCA9IF90aGlzJHByb3BzLnN5bmNNZXRob2Q7XG4gICAgICAgIHZhciB1cGRhdGVJZCA9IF90aGlzLnN0YXRlLnVwZGF0ZUlkO1xuICAgICAgICB2YXIgZGF0YVN0YXJ0SW5kZXggPSBkYXRhLmRhdGFTdGFydEluZGV4LFxuICAgICAgICAgIGRhdGFFbmRJbmRleCA9IGRhdGEuZGF0YUVuZEluZGV4O1xuICAgICAgICBpZiAoZGF0YS5kYXRhU3RhcnRJbmRleCAhPT0gdW5kZWZpbmVkIHx8IGRhdGEuZGF0YUVuZEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgIGRhdGFTdGFydEluZGV4OiBkYXRhU3RhcnRJbmRleCxcbiAgICAgICAgICAgIGRhdGFFbmRJbmRleDogZGF0YUVuZEluZGV4XG4gICAgICAgICAgfSwgdXBkYXRlU3RhdGVPZkF4aXNNYXBzT2Zmc2V0QW5kU3RhY2tHcm91cHMoe1xuICAgICAgICAgICAgcHJvcHM6IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgZGF0YVN0YXJ0SW5kZXg6IGRhdGFTdGFydEluZGV4LFxuICAgICAgICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXgsXG4gICAgICAgICAgICB1cGRhdGVJZDogdXBkYXRlSWRcbiAgICAgICAgICB9LCBfdGhpcy5zdGF0ZSkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmFjdGl2ZVRvb2x0aXBJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGNoYXJ0WCA9IGRhdGEuY2hhcnRYLFxuICAgICAgICAgICAgY2hhcnRZID0gZGF0YS5jaGFydFk7XG4gICAgICAgICAgdmFyIGFjdGl2ZVRvb2x0aXBJbmRleCA9IGRhdGEuYWN0aXZlVG9vbHRpcEluZGV4O1xuICAgICAgICAgIHZhciBfdGhpcyRzdGF0ZTIgPSBfdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIG9mZnNldCA9IF90aGlzJHN0YXRlMi5vZmZzZXQsXG4gICAgICAgICAgICB0b29sdGlwVGlja3MgPSBfdGhpcyRzdGF0ZTIudG9vbHRpcFRpY2tzO1xuICAgICAgICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2Ygc3luY01ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gQ2FsbCBhIGNhbGxiYWNrIGZ1bmN0aW9uLiBJZiB0aGVyZSBpcyBhbiBhcHBsaWNhdGlvbiBzcGVjaWZpYyBhbGdvcml0aG1cbiAgICAgICAgICAgIGFjdGl2ZVRvb2x0aXBJbmRleCA9IHN5bmNNZXRob2QodG9vbHRpcFRpY2tzLCBkYXRhKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN5bmNNZXRob2QgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIC8vIFNldCBhY3RpdmVUb29sdGlwSW5kZXggdG8gdGhlIGluZGV4IHdpdGggdGhlIHNhbWUgdmFsdWUgYXMgZGF0YS5hY3RpdmVMYWJlbFxuICAgICAgICAgICAgLy8gRm9yIGxvb3AgaW5zdGVhZCBvZiBmaW5kSW5kZXggYmVjYXVzZSB0aGUgbGF0dGVyIGlzIHZlcnkgc2xvdyBpbiBzb21lIGJyb3dzZXJzXG4gICAgICAgICAgICBhY3RpdmVUb29sdGlwSW5kZXggPSAtMTsgLy8gaW4gY2FzZSB3ZSBjYW5ub3QgZmluZCB0aGUgZWxlbWVudFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b29sdGlwVGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHRvb2x0aXBUaWNrc1tpXS52YWx1ZSA9PT0gZGF0YS5hY3RpdmVMYWJlbCkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVRvb2x0aXBJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZpZXdCb3ggPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9mZnNldCksIHt9LCB7XG4gICAgICAgICAgICB4OiBvZmZzZXQubGVmdCxcbiAgICAgICAgICAgIHk6IG9mZnNldC50b3BcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBXaGVuIGEgY2F0ZWdvcmljYWwgY2hhcnQgaXMgY29tYmluZWQgd2l0aCBhbm90aGVyIGNoYXJ0LCB0aGUgdmFsdWUgb2YgY2hhcnRYXG4gICAgICAgICAgLy8gYW5kIGNoYXJ0WSBtYXkgYmV5b25kIHRoZSBib3VuZGFyaWVzLlxuICAgICAgICAgIHZhciB2YWxpZGF0ZUNoYXJ0WCA9IE1hdGgubWluKGNoYXJ0WCwgdmlld0JveC54ICsgdmlld0JveC53aWR0aCk7XG4gICAgICAgICAgdmFyIHZhbGlkYXRlQ2hhcnRZID0gTWF0aC5taW4oY2hhcnRZLCB2aWV3Qm94LnkgKyB2aWV3Qm94LmhlaWdodCk7XG4gICAgICAgICAgdmFyIGFjdGl2ZUxhYmVsID0gdG9vbHRpcFRpY2tzW2FjdGl2ZVRvb2x0aXBJbmRleF0gJiYgdG9vbHRpcFRpY2tzW2FjdGl2ZVRvb2x0aXBJbmRleF0udmFsdWU7XG4gICAgICAgICAgdmFyIGFjdGl2ZVBheWxvYWQgPSBnZXRUb29sdGlwQ29udGVudChfdGhpcy5zdGF0ZSwgX3RoaXMucHJvcHMuZGF0YSwgYWN0aXZlVG9vbHRpcEluZGV4KTtcbiAgICAgICAgICB2YXIgYWN0aXZlQ29vcmRpbmF0ZSA9IHRvb2x0aXBUaWNrc1thY3RpdmVUb29sdGlwSW5kZXhdID8ge1xuICAgICAgICAgICAgeDogbGF5b3V0ID09PSAnaG9yaXpvbnRhbCcgPyB0b29sdGlwVGlja3NbYWN0aXZlVG9vbHRpcEluZGV4XS5jb29yZGluYXRlIDogdmFsaWRhdGVDaGFydFgsXG4gICAgICAgICAgICB5OiBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IHZhbGlkYXRlQ2hhcnRZIDogdG9vbHRpcFRpY2tzW2FjdGl2ZVRvb2x0aXBJbmRleF0uY29vcmRpbmF0ZVxuICAgICAgICAgIH0gOiBvcmlnaW5Db29yZGluYXRlO1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGF0YSksIHt9LCB7XG4gICAgICAgICAgICBhY3RpdmVMYWJlbDogYWN0aXZlTGFiZWwsXG4gICAgICAgICAgICBhY3RpdmVDb29yZGluYXRlOiBhY3RpdmVDb29yZGluYXRlLFxuICAgICAgICAgICAgYWN0aXZlUGF5bG9hZDogYWN0aXZlUGF5bG9hZCxcbiAgICAgICAgICAgIGFjdGl2ZVRvb2x0aXBJbmRleDogYWN0aXZlVG9vbHRpcEluZGV4XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZW5kZXJDdXJzb3JcIiwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF9lbGVtZW50JHByb3BzJGFjdGl2ZTtcbiAgICAgICAgdmFyIF90aGlzJHN0YXRlMyA9IF90aGlzLnN0YXRlLFxuICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZSA9IF90aGlzJHN0YXRlMy5pc1Rvb2x0aXBBY3RpdmUsXG4gICAgICAgICAgYWN0aXZlQ29vcmRpbmF0ZSA9IF90aGlzJHN0YXRlMy5hY3RpdmVDb29yZGluYXRlLFxuICAgICAgICAgIGFjdGl2ZVBheWxvYWQgPSBfdGhpcyRzdGF0ZTMuYWN0aXZlUGF5bG9hZCxcbiAgICAgICAgICBvZmZzZXQgPSBfdGhpcyRzdGF0ZTMub2Zmc2V0LFxuICAgICAgICAgIGFjdGl2ZVRvb2x0aXBJbmRleCA9IF90aGlzJHN0YXRlMy5hY3RpdmVUb29sdGlwSW5kZXgsXG4gICAgICAgICAgdG9vbHRpcEF4aXNCYW5kU2l6ZSA9IF90aGlzJHN0YXRlMy50b29sdGlwQXhpc0JhbmRTaXplO1xuICAgICAgICB2YXIgdG9vbHRpcEV2ZW50VHlwZSA9IF90aGlzLmdldFRvb2x0aXBFdmVudFR5cGUoKTtcbiAgICAgICAgLy8gVGhlIGN1cnNvciBpcyBhIHBhcnQgb2YgdGhlIFRvb2x0aXAsIGFuZCBpdCBzaG91bGQgYmUgc2hvd24gKGJ5IGRlZmF1bHQpIHdoZW4gdGhlIFRvb2x0aXAgaXMgYWN0aXZlLlxuICAgICAgICB2YXIgaXNBY3RpdmUgPSAoX2VsZW1lbnQkcHJvcHMkYWN0aXZlID0gZWxlbWVudC5wcm9wcy5hY3RpdmUpICE9PSBudWxsICYmIF9lbGVtZW50JHByb3BzJGFjdGl2ZSAhPT0gdm9pZCAwID8gX2VsZW1lbnQkcHJvcHMkYWN0aXZlIDogaXNUb29sdGlwQWN0aXZlO1xuICAgICAgICB2YXIgbGF5b3V0ID0gX3RoaXMucHJvcHMubGF5b3V0O1xuICAgICAgICB2YXIga2V5ID0gZWxlbWVudC5rZXkgfHwgJ19yZWNoYXJ0cy1jdXJzb3InO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfQ3Vyc29yLkN1cnNvciwge1xuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIGFjdGl2ZUNvb3JkaW5hdGU6IGFjdGl2ZUNvb3JkaW5hdGUsXG4gICAgICAgICAgYWN0aXZlUGF5bG9hZDogYWN0aXZlUGF5bG9hZCxcbiAgICAgICAgICBhY3RpdmVUb29sdGlwSW5kZXg6IGFjdGl2ZVRvb2x0aXBJbmRleCxcbiAgICAgICAgICBjaGFydE5hbWU6IGNoYXJ0TmFtZSxcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgIGlzQWN0aXZlOiBpc0FjdGl2ZSxcbiAgICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICB0b29sdGlwQXhpc0JhbmRTaXplOiB0b29sdGlwQXhpc0JhbmRTaXplLFxuICAgICAgICAgIHRvb2x0aXBFdmVudFR5cGU6IHRvb2x0aXBFdmVudFR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZW5kZXJQb2xhckF4aXNcIiwgZnVuY3Rpb24gKGVsZW1lbnQsIGRpc3BsYXlOYW1lLCBpbmRleCkge1xuICAgICAgICB2YXIgYXhpc1R5cGUgPSAoMCwgX2dldFtcImRlZmF1bHRcIl0pKGVsZW1lbnQsICd0eXBlLmF4aXNUeXBlJyk7XG4gICAgICAgIHZhciBheGlzTWFwID0gKDAsIF9nZXRbXCJkZWZhdWx0XCJdKShfdGhpcy5zdGF0ZSwgXCJcIi5jb25jYXQoYXhpc1R5cGUsIFwiTWFwXCIpKTtcbiAgICAgICAgdmFyIGVsZW1lbnREZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgICAgICB2YXIgZWxlbWVudFByb3BzID0gZWxlbWVudERlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbGVtZW50RGVmYXVsdFByb3BzKSwgZWxlbWVudC5wcm9wcykgOiBlbGVtZW50LnByb3BzO1xuICAgICAgICB2YXIgYXhpc09wdGlvbiA9IGF4aXNNYXAgJiYgYXhpc01hcFtlbGVtZW50UHJvcHNbXCJcIi5jb25jYXQoYXhpc1R5cGUsIFwiSWRcIildXTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoZWxlbWVudCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBheGlzT3B0aW9uKSwge30sIHtcbiAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKGF4aXNUeXBlLCBheGlzT3B0aW9uLmNsYXNzTmFtZSksXG4gICAgICAgICAga2V5OiBlbGVtZW50LmtleSB8fCBcIlwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCItXCIpLmNvbmNhdChpbmRleCksXG4gICAgICAgICAgdGlja3M6ICgwLCBfQ2hhcnRVdGlscy5nZXRUaWNrc09mQXhpcykoYXhpc09wdGlvbiwgdHJ1ZSlcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVuZGVyUG9sYXJHcmlkXCIsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBfZWxlbWVudCRwcm9wcyA9IGVsZW1lbnQucHJvcHMsXG4gICAgICAgICAgcmFkaWFsTGluZXMgPSBfZWxlbWVudCRwcm9wcy5yYWRpYWxMaW5lcyxcbiAgICAgICAgICBwb2xhckFuZ2xlcyA9IF9lbGVtZW50JHByb3BzLnBvbGFyQW5nbGVzLFxuICAgICAgICAgIHBvbGFyUmFkaXVzID0gX2VsZW1lbnQkcHJvcHMucG9sYXJSYWRpdXM7XG4gICAgICAgIHZhciBfdGhpcyRzdGF0ZTQgPSBfdGhpcy5zdGF0ZSxcbiAgICAgICAgICByYWRpdXNBeGlzTWFwID0gX3RoaXMkc3RhdGU0LnJhZGl1c0F4aXNNYXAsXG4gICAgICAgICAgYW5nbGVBeGlzTWFwID0gX3RoaXMkc3RhdGU0LmFuZ2xlQXhpc01hcDtcbiAgICAgICAgdmFyIHJhZGl1c0F4aXMgPSAoMCwgX0RhdGFVdGlscy5nZXRBbnlFbGVtZW50T2ZPYmplY3QpKHJhZGl1c0F4aXNNYXApO1xuICAgICAgICB2YXIgYW5nbGVBeGlzID0gKDAsIF9EYXRhVXRpbHMuZ2V0QW55RWxlbWVudE9mT2JqZWN0KShhbmdsZUF4aXNNYXApO1xuICAgICAgICB2YXIgY3ggPSBhbmdsZUF4aXMuY3gsXG4gICAgICAgICAgY3kgPSBhbmdsZUF4aXMuY3ksXG4gICAgICAgICAgaW5uZXJSYWRpdXMgPSBhbmdsZUF4aXMuaW5uZXJSYWRpdXMsXG4gICAgICAgICAgb3V0ZXJSYWRpdXMgPSBhbmdsZUF4aXMub3V0ZXJSYWRpdXM7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGVsZW1lbnQsIHtcbiAgICAgICAgICBwb2xhckFuZ2xlczogQXJyYXkuaXNBcnJheShwb2xhckFuZ2xlcykgPyBwb2xhckFuZ2xlcyA6ICgwLCBfQ2hhcnRVdGlscy5nZXRUaWNrc09mQXhpcykoYW5nbGVBeGlzLCB0cnVlKS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkuY29vcmRpbmF0ZTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBwb2xhclJhZGl1czogQXJyYXkuaXNBcnJheShwb2xhclJhZGl1cykgPyBwb2xhclJhZGl1cyA6ICgwLCBfQ2hhcnRVdGlscy5nZXRUaWNrc09mQXhpcykocmFkaXVzQXhpcywgdHJ1ZSkubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LmNvb3JkaW5hdGU7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgY3g6IGN4LFxuICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG4gICAgICAgICAgb3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuICAgICAgICAgIGtleTogZWxlbWVudC5rZXkgfHwgJ3BvbGFyLWdyaWQnLFxuICAgICAgICAgIHJhZGlhbExpbmVzOiByYWRpYWxMaW5lc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBEcmF3IGxlZ2VuZFxuICAgICAgICogQHJldHVybiB7UmVhY3RFbGVtZW50fSAgICAgICAgICAgIFRoZSBpbnN0YW5jZSBvZiBMZWdlbmRcbiAgICAgICAqL1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInJlbmRlckxlZ2VuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcyA9IF90aGlzLnN0YXRlLmZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zO1xuICAgICAgICB2YXIgX3RoaXMkcHJvcHMyID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczIuY2hpbGRyZW4sXG4gICAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczIud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHMyLmhlaWdodDtcbiAgICAgICAgdmFyIG1hcmdpbiA9IF90aGlzLnByb3BzLm1hcmdpbiB8fCB7fTtcbiAgICAgICAgdmFyIGxlZ2VuZFdpZHRoID0gd2lkdGggLSAobWFyZ2luLmxlZnQgfHwgMCkgLSAobWFyZ2luLnJpZ2h0IHx8IDApO1xuICAgICAgICB2YXIgcHJvcHMgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0TGVnZW5kUHJvcHMpKHtcbiAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXM6IGZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zLFxuICAgICAgICAgIGxlZ2VuZFdpZHRoOiBsZWdlbmRXaWR0aCxcbiAgICAgICAgICBsZWdlbmRDb250ZW50OiBsZWdlbmRDb250ZW50XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl0ZW0gPSBwcm9wcy5pdGVtLFxuICAgICAgICAgIG90aGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGl0ZW0sIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3RoZXJQcm9wcyksIHt9LCB7XG4gICAgICAgICAgY2hhcnRXaWR0aDogd2lkdGgsXG4gICAgICAgICAgY2hhcnRIZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICBtYXJnaW46IG1hcmdpbixcbiAgICAgICAgICBvbkJCb3hVcGRhdGU6IF90aGlzLmhhbmRsZUxlZ2VuZEJCb3hVcGRhdGVcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIERyYXcgVG9vbHRpcFxuICAgICAgICogQHJldHVybiB7UmVhY3RFbGVtZW50fSAgVGhlIGluc3RhbmNlIG9mIFRvb2x0aXBcbiAgICAgICAqL1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInJlbmRlclRvb2x0aXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3Rvb2x0aXBJdGVtJHByb3BzJGFjO1xuICAgICAgICB2YXIgX3RoaXMkcHJvcHMzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczMuY2hpbGRyZW4sXG4gICAgICAgICAgYWNjZXNzaWJpbGl0eUxheWVyID0gX3RoaXMkcHJvcHMzLmFjY2Vzc2liaWxpdHlMYXllcjtcbiAgICAgICAgdmFyIHRvb2x0aXBJdGVtID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRDaGlsZEJ5VHlwZSkoY2hpbGRyZW4sIF9Ub29sdGlwLlRvb2x0aXApO1xuICAgICAgICBpZiAoIXRvb2x0aXBJdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF90aGlzJHN0YXRlNSA9IF90aGlzLnN0YXRlLFxuICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZSA9IF90aGlzJHN0YXRlNS5pc1Rvb2x0aXBBY3RpdmUsXG4gICAgICAgICAgYWN0aXZlQ29vcmRpbmF0ZSA9IF90aGlzJHN0YXRlNS5hY3RpdmVDb29yZGluYXRlLFxuICAgICAgICAgIGFjdGl2ZVBheWxvYWQgPSBfdGhpcyRzdGF0ZTUuYWN0aXZlUGF5bG9hZCxcbiAgICAgICAgICBhY3RpdmVMYWJlbCA9IF90aGlzJHN0YXRlNS5hY3RpdmVMYWJlbCxcbiAgICAgICAgICBvZmZzZXQgPSBfdGhpcyRzdGF0ZTUub2Zmc2V0O1xuXG4gICAgICAgIC8vIFRoZSB1c2VyIGNhbiBzZXQgaXNBY3RpdmUgb24gdGhlIFRvb2x0aXAsXG4gICAgICAgIC8vIGFuZCB3ZSByZXNwZWN0IHRoZSB1c2VyIHRvIGVuYWJsZSBjdXN0b21pc2F0aW9uLlxuICAgICAgICAvLyBUaGUgVG9vbHRpcCBpcyBhY3RpdmUgaWYgdGhlIHVzZXIgaGFzIHNldCBpc0FjdGl2ZSwgb3IgaWYgdGhlIHRvb2x0aXAgaXMgYWN0aXZlIGR1ZSB0byBhIG1vdXNlIGV2ZW50LlxuICAgICAgICB2YXIgaXNBY3RpdmUgPSAoX3Rvb2x0aXBJdGVtJHByb3BzJGFjID0gdG9vbHRpcEl0ZW0ucHJvcHMuYWN0aXZlKSAhPT0gbnVsbCAmJiBfdG9vbHRpcEl0ZW0kcHJvcHMkYWMgIT09IHZvaWQgMCA/IF90b29sdGlwSXRlbSRwcm9wcyRhYyA6IGlzVG9vbHRpcEFjdGl2ZTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNsb25lRWxlbWVudCkodG9vbHRpcEl0ZW0sIHtcbiAgICAgICAgICB2aWV3Qm94OiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9mZnNldCksIHt9LCB7XG4gICAgICAgICAgICB4OiBvZmZzZXQubGVmdCxcbiAgICAgICAgICAgIHk6IG9mZnNldC50b3BcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBhY3RpdmU6IGlzQWN0aXZlLFxuICAgICAgICAgIGxhYmVsOiBhY3RpdmVMYWJlbCxcbiAgICAgICAgICBwYXlsb2FkOiBpc0FjdGl2ZSA/IGFjdGl2ZVBheWxvYWQgOiBbXSxcbiAgICAgICAgICBjb29yZGluYXRlOiBhY3RpdmVDb29yZGluYXRlLFxuICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYXllcjogYWNjZXNzaWJpbGl0eUxheWVyXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVuZGVyQnJ1c2hcIiwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzJHByb3BzNCA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIG1hcmdpbiA9IF90aGlzJHByb3BzNC5tYXJnaW4sXG4gICAgICAgICAgZGF0YSA9IF90aGlzJHByb3BzNC5kYXRhO1xuICAgICAgICB2YXIgX3RoaXMkc3RhdGU2ID0gX3RoaXMuc3RhdGUsXG4gICAgICAgICAgb2Zmc2V0ID0gX3RoaXMkc3RhdGU2Lm9mZnNldCxcbiAgICAgICAgICBkYXRhU3RhcnRJbmRleCA9IF90aGlzJHN0YXRlNi5kYXRhU3RhcnRJbmRleCxcbiAgICAgICAgICBkYXRhRW5kSW5kZXggPSBfdGhpcyRzdGF0ZTYuZGF0YUVuZEluZGV4LFxuICAgICAgICAgIHVwZGF0ZUlkID0gX3RoaXMkc3RhdGU2LnVwZGF0ZUlkO1xuXG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBicnVzaCB3aGVuIGNoaWxkcmVuIHVwZGF0ZVxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShlbGVtZW50LCB7XG4gICAgICAgICAga2V5OiBlbGVtZW50LmtleSB8fCAnX3JlY2hhcnRzLWJydXNoJyxcbiAgICAgICAgICBvbkNoYW5nZTogKDAsIF9DaGFydFV0aWxzLmNvbWJpbmVFdmVudEhhbmRsZXJzKShfdGhpcy5oYW5kbGVCcnVzaENoYW5nZSwgZWxlbWVudC5wcm9wcy5vbkNoYW5nZSksXG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICB4OiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoZWxlbWVudC5wcm9wcy54KSA/IGVsZW1lbnQucHJvcHMueCA6IG9mZnNldC5sZWZ0LFxuICAgICAgICAgIHk6ICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShlbGVtZW50LnByb3BzLnkpID8gZWxlbWVudC5wcm9wcy55IDogb2Zmc2V0LnRvcCArIG9mZnNldC5oZWlnaHQgKyBvZmZzZXQuYnJ1c2hCb3R0b20gLSAobWFyZ2luLmJvdHRvbSB8fCAwKSxcbiAgICAgICAgICB3aWR0aDogKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGVsZW1lbnQucHJvcHMud2lkdGgpID8gZWxlbWVudC5wcm9wcy53aWR0aCA6IG9mZnNldC53aWR0aCxcbiAgICAgICAgICBzdGFydEluZGV4OiBkYXRhU3RhcnRJbmRleCxcbiAgICAgICAgICBlbmRJbmRleDogZGF0YUVuZEluZGV4LFxuICAgICAgICAgIHVwZGF0ZUlkOiBcImJydXNoLVwiLmNvbmNhdCh1cGRhdGVJZClcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZW5kZXJSZWZlcmVuY2VFbGVtZW50XCIsIGZ1bmN0aW9uIChlbGVtZW50LCBkaXNwbGF5TmFtZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF90aGlzMiA9IF90aGlzLFxuICAgICAgICAgIGNsaXBQYXRoSWQgPSBfdGhpczIuY2xpcFBhdGhJZDtcbiAgICAgICAgdmFyIF90aGlzJHN0YXRlNyA9IF90aGlzLnN0YXRlLFxuICAgICAgICAgIHhBeGlzTWFwID0gX3RoaXMkc3RhdGU3LnhBeGlzTWFwLFxuICAgICAgICAgIHlBeGlzTWFwID0gX3RoaXMkc3RhdGU3LnlBeGlzTWFwLFxuICAgICAgICAgIG9mZnNldCA9IF90aGlzJHN0YXRlNy5vZmZzZXQ7XG4gICAgICAgIHZhciBlbGVtZW50RGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcyB8fCB7fTtcbiAgICAgICAgdmFyIF9lbGVtZW50JHByb3BzMiA9IGVsZW1lbnQucHJvcHMsXG4gICAgICAgICAgX2VsZW1lbnQkcHJvcHMyJHhBeGlzID0gX2VsZW1lbnQkcHJvcHMyLnhBeGlzSWQsXG4gICAgICAgICAgeEF4aXNJZCA9IF9lbGVtZW50JHByb3BzMiR4QXhpcyA9PT0gdm9pZCAwID8gZWxlbWVudERlZmF1bHRQcm9wcy54QXhpc0lkIDogX2VsZW1lbnQkcHJvcHMyJHhBeGlzLFxuICAgICAgICAgIF9lbGVtZW50JHByb3BzMiR5QXhpcyA9IF9lbGVtZW50JHByb3BzMi55QXhpc0lkLFxuICAgICAgICAgIHlBeGlzSWQgPSBfZWxlbWVudCRwcm9wczIkeUF4aXMgPT09IHZvaWQgMCA/IGVsZW1lbnREZWZhdWx0UHJvcHMueUF4aXNJZCA6IF9lbGVtZW50JHByb3BzMiR5QXhpcztcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNsb25lRWxlbWVudCkoZWxlbWVudCwge1xuICAgICAgICAgIGtleTogZWxlbWVudC5rZXkgfHwgXCJcIi5jb25jYXQoZGlzcGxheU5hbWUsIFwiLVwiKS5jb25jYXQoaW5kZXgpLFxuICAgICAgICAgIHhBeGlzOiB4QXhpc01hcFt4QXhpc0lkXSxcbiAgICAgICAgICB5QXhpczogeUF4aXNNYXBbeUF4aXNJZF0sXG4gICAgICAgICAgdmlld0JveDoge1xuICAgICAgICAgICAgeDogb2Zmc2V0LmxlZnQsXG4gICAgICAgICAgICB5OiBvZmZzZXQudG9wLFxuICAgICAgICAgICAgd2lkdGg6IG9mZnNldC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogb2Zmc2V0LmhlaWdodFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xpcFBhdGhJZDogY2xpcFBhdGhJZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInJlbmRlckFjdGl2ZVBvaW50c1wiLCBmdW5jdGlvbiAoX3JlZjEwKSB7XG4gICAgICAgIHZhciBpdGVtID0gX3JlZjEwLml0ZW0sXG4gICAgICAgICAgYWN0aXZlUG9pbnQgPSBfcmVmMTAuYWN0aXZlUG9pbnQsXG4gICAgICAgICAgYmFzZVBvaW50ID0gX3JlZjEwLmJhc2VQb2ludCxcbiAgICAgICAgICBjaGlsZEluZGV4ID0gX3JlZjEwLmNoaWxkSW5kZXgsXG4gICAgICAgICAgaXNSYW5nZSA9IF9yZWYxMC5pc1JhbmdlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIC8vIGl0ZW0gaXMgbm90IGEgUmVhY3QgRWxlbWVudCBzbyB3ZSBkb24ndCBuZWVkIHRvIHJlc29sdmUgZGVmYXVsdFByb3BzLlxuICAgICAgICB2YXIga2V5ID0gaXRlbS5wcm9wcy5rZXk7XG4gICAgICAgIHZhciBpdGVtSXRlbVByb3BzID0gaXRlbS5pdGVtLnR5cGUuZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGl0ZW0uaXRlbS50eXBlLmRlZmF1bHRQcm9wcyksIGl0ZW0uaXRlbS5wcm9wcykgOiBpdGVtLml0ZW0ucHJvcHM7XG4gICAgICAgIHZhciBhY3RpdmVEb3QgPSBpdGVtSXRlbVByb3BzLmFjdGl2ZURvdCxcbiAgICAgICAgICBkYXRhS2V5ID0gaXRlbUl0ZW1Qcm9wcy5kYXRhS2V5O1xuICAgICAgICB2YXIgZG90UHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIGluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICAgIGRhdGFLZXk6IGRhdGFLZXksXG4gICAgICAgICAgY3g6IGFjdGl2ZVBvaW50LngsXG4gICAgICAgICAgY3k6IGFjdGl2ZVBvaW50LnksXG4gICAgICAgICAgcjogNCxcbiAgICAgICAgICBmaWxsOiAoMCwgX0NoYXJ0VXRpbHMuZ2V0TWFpbkNvbG9yT2ZHcmFwaGljSXRlbSkoaXRlbS5pdGVtKSxcbiAgICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgICBzdHJva2U6ICcjZmZmJyxcbiAgICAgICAgICBwYXlsb2FkOiBhY3RpdmVQb2ludC5wYXlsb2FkLFxuICAgICAgICAgIHZhbHVlOiBhY3RpdmVQb2ludC52YWx1ZVxuICAgICAgICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKGFjdGl2ZURvdCwgZmFsc2UpKSwgKDAsIF90eXBlcy5hZGFwdEV2ZW50SGFuZGxlcnMpKGFjdGl2ZURvdCkpO1xuICAgICAgICByZXN1bHQucHVzaChDYXRlZ29yaWNhbENoYXJ0V3JhcHBlci5yZW5kZXJBY3RpdmVEb3QoYWN0aXZlRG90LCBkb3RQcm9wcywgXCJcIi5jb25jYXQoa2V5LCBcIi1hY3RpdmVQb2ludC1cIikuY29uY2F0KGNoaWxkSW5kZXgpKSk7XG4gICAgICAgIGlmIChiYXNlUG9pbnQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChDYXRlZ29yaWNhbENoYXJ0V3JhcHBlci5yZW5kZXJBY3RpdmVEb3QoYWN0aXZlRG90LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRvdFByb3BzKSwge30sIHtcbiAgICAgICAgICAgIGN4OiBiYXNlUG9pbnQueCxcbiAgICAgICAgICAgIGN5OiBiYXNlUG9pbnQueVxuICAgICAgICAgIH0pLCBcIlwiLmNvbmNhdChrZXksIFwiLWJhc2VQb2ludC1cIikuY29uY2F0KGNoaWxkSW5kZXgpKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSYW5nZSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZW5kZXJHcmFwaGljQ2hpbGRcIiwgZnVuY3Rpb24gKGVsZW1lbnQsIGRpc3BsYXlOYW1lLCBpbmRleCkge1xuICAgICAgICB2YXIgaXRlbSA9IF90aGlzLmZpbHRlckZvcm1hdEl0ZW0oZWxlbWVudCwgZGlzcGxheU5hbWUsIGluZGV4KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvb2x0aXBFdmVudFR5cGUgPSBfdGhpcy5nZXRUb29sdGlwRXZlbnRUeXBlKCk7XG4gICAgICAgIHZhciBfdGhpcyRzdGF0ZTggPSBfdGhpcy5zdGF0ZSxcbiAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmUgPSBfdGhpcyRzdGF0ZTguaXNUb29sdGlwQWN0aXZlLFxuICAgICAgICAgIHRvb2x0aXBBeGlzID0gX3RoaXMkc3RhdGU4LnRvb2x0aXBBeGlzLFxuICAgICAgICAgIGFjdGl2ZVRvb2x0aXBJbmRleCA9IF90aGlzJHN0YXRlOC5hY3RpdmVUb29sdGlwSW5kZXgsXG4gICAgICAgICAgYWN0aXZlTGFiZWwgPSBfdGhpcyRzdGF0ZTguYWN0aXZlTGFiZWw7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IF90aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgdG9vbHRpcEl0ZW0gPSAoMCwgX1JlYWN0VXRpbHMuZmluZENoaWxkQnlUeXBlKShjaGlsZHJlbiwgX1Rvb2x0aXAuVG9vbHRpcCk7XG4gICAgICAgIC8vIGl0ZW0gaXMgbm90IGEgUmVhY3QgRWxlbWVudCBzbyB3ZSBkb24ndCBuZWVkIHRvIHJlc29sdmUgZGVmYXVsdFByb3BzXG4gICAgICAgIHZhciBfaXRlbSRwcm9wcyA9IGl0ZW0ucHJvcHMsXG4gICAgICAgICAgcG9pbnRzID0gX2l0ZW0kcHJvcHMucG9pbnRzLFxuICAgICAgICAgIGlzUmFuZ2UgPSBfaXRlbSRwcm9wcy5pc1JhbmdlLFxuICAgICAgICAgIGJhc2VMaW5lID0gX2l0ZW0kcHJvcHMuYmFzZUxpbmU7XG4gICAgICAgIHZhciBpdGVtSXRlbVByb3BzID0gaXRlbS5pdGVtLnR5cGUuZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGl0ZW0uaXRlbS50eXBlLmRlZmF1bHRQcm9wcyksIGl0ZW0uaXRlbS5wcm9wcykgOiBpdGVtLml0ZW0ucHJvcHM7XG4gICAgICAgIHZhciBhY3RpdmVEb3QgPSBpdGVtSXRlbVByb3BzLmFjdGl2ZURvdCxcbiAgICAgICAgICBoaWRlID0gaXRlbUl0ZW1Qcm9wcy5oaWRlLFxuICAgICAgICAgIGFjdGl2ZUJhciA9IGl0ZW1JdGVtUHJvcHMuYWN0aXZlQmFyLFxuICAgICAgICAgIGFjdGl2ZVNoYXBlID0gaXRlbUl0ZW1Qcm9wcy5hY3RpdmVTaGFwZTtcbiAgICAgICAgdmFyIGhhc0FjdGl2ZSA9IEJvb2xlYW4oIWhpZGUgJiYgaXNUb29sdGlwQWN0aXZlICYmIHRvb2x0aXBJdGVtICYmIChhY3RpdmVEb3QgfHwgYWN0aXZlQmFyIHx8IGFjdGl2ZVNoYXBlKSk7XG4gICAgICAgIHZhciBpdGVtRXZlbnRzID0ge307XG4gICAgICAgIGlmICh0b29sdGlwRXZlbnRUeXBlICE9PSAnYXhpcycgJiYgdG9vbHRpcEl0ZW0gJiYgdG9vbHRpcEl0ZW0ucHJvcHMudHJpZ2dlciA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgIGl0ZW1FdmVudHMgPSB7XG4gICAgICAgICAgICBvbkNsaWNrOiAoMCwgX0NoYXJ0VXRpbHMuY29tYmluZUV2ZW50SGFuZGxlcnMpKF90aGlzLmhhbmRsZUl0ZW1Nb3VzZUVudGVyLCBlbGVtZW50LnByb3BzLm9uQ2xpY2spXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0b29sdGlwRXZlbnRUeXBlICE9PSAnYXhpcycpIHtcbiAgICAgICAgICBpdGVtRXZlbnRzID0ge1xuICAgICAgICAgICAgb25Nb3VzZUxlYXZlOiAoMCwgX0NoYXJ0VXRpbHMuY29tYmluZUV2ZW50SGFuZGxlcnMpKF90aGlzLmhhbmRsZUl0ZW1Nb3VzZUxlYXZlLCBlbGVtZW50LnByb3BzLm9uTW91c2VMZWF2ZSksXG4gICAgICAgICAgICBvbk1vdXNlRW50ZXI6ICgwLCBfQ2hhcnRVdGlscy5jb21iaW5lRXZlbnRIYW5kbGVycykoX3RoaXMuaGFuZGxlSXRlbU1vdXNlRW50ZXIsIGVsZW1lbnQucHJvcHMub25Nb3VzZUVudGVyKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyYXBoaWNhbEl0ZW0gPSAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGVsZW1lbnQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbS5wcm9wcyksIGl0ZW1FdmVudHMpKTtcbiAgICAgICAgZnVuY3Rpb24gZmluZFdpdGhQYXlsb2FkKGVudHJ5KSB7XG4gICAgICAgICAgLy8gVE9ETyBuZWVkcyB0byB2ZXJpZnkgZGF0YUtleSBpcyBGdW5jdGlvblxuICAgICAgICAgIHJldHVybiB0eXBlb2YgdG9vbHRpcEF4aXMuZGF0YUtleSA9PT0gJ2Z1bmN0aW9uJyA/IHRvb2x0aXBBeGlzLmRhdGFLZXkoZW50cnkucGF5bG9hZCkgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNBY3RpdmUpIHtcbiAgICAgICAgICBpZiAoYWN0aXZlVG9vbHRpcEluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHZhciBhY3RpdmVQb2ludCwgYmFzZVBvaW50O1xuICAgICAgICAgICAgaWYgKHRvb2x0aXBBeGlzLmRhdGFLZXkgJiYgIXRvb2x0aXBBeGlzLmFsbG93RHVwbGljYXRlZENhdGVnb3J5KSB7XG4gICAgICAgICAgICAgIC8vIG51bWJlciB0cmFuc2Zvcm0gdG8gc3RyaW5nXG4gICAgICAgICAgICAgIHZhciBzcGVjaWZpZWRLZXkgPSB0eXBlb2YgdG9vbHRpcEF4aXMuZGF0YUtleSA9PT0gJ2Z1bmN0aW9uJyA/IGZpbmRXaXRoUGF5bG9hZCA6ICdwYXlsb2FkLicuY29uY2F0KHRvb2x0aXBBeGlzLmRhdGFLZXkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgIGFjdGl2ZVBvaW50ID0gKDAsIF9EYXRhVXRpbHMuZmluZEVudHJ5SW5BcnJheSkocG9pbnRzLCBzcGVjaWZpZWRLZXksIGFjdGl2ZUxhYmVsKTtcbiAgICAgICAgICAgICAgYmFzZVBvaW50ID0gaXNSYW5nZSAmJiBiYXNlTGluZSAmJiAoMCwgX0RhdGFVdGlscy5maW5kRW50cnlJbkFycmF5KShiYXNlTGluZSwgc3BlY2lmaWVkS2V5LCBhY3RpdmVMYWJlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhY3RpdmVQb2ludCA9IHBvaW50cyA9PT0gbnVsbCB8fCBwb2ludHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvaW50c1thY3RpdmVUb29sdGlwSW5kZXhdO1xuICAgICAgICAgICAgICBiYXNlUG9pbnQgPSBpc1JhbmdlICYmIGJhc2VMaW5lICYmIGJhc2VMaW5lW2FjdGl2ZVRvb2x0aXBJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aXZlU2hhcGUgfHwgYWN0aXZlQmFyKSB7XG4gICAgICAgICAgICAgIHZhciBhY3RpdmVJbmRleCA9IGVsZW1lbnQucHJvcHMuYWN0aXZlSW5kZXggIT09IHVuZGVmaW5lZCA/IGVsZW1lbnQucHJvcHMuYWN0aXZlSW5kZXggOiBhY3RpdmVUb29sdGlwSW5kZXg7XG4gICAgICAgICAgICAgIHJldHVybiBbLyojX19QVVJFX18qLygwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShlbGVtZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbS5wcm9wcyksIGl0ZW1FdmVudHMpLCB7fSwge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUluZGV4OiBhY3RpdmVJbmRleFxuICAgICAgICAgICAgICB9KSksIG51bGwsIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoYWN0aXZlUG9pbnQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbZ3JhcGhpY2FsSXRlbV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShfdGhpcy5yZW5kZXJBY3RpdmVQb2ludHMoe1xuICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgYWN0aXZlUG9pbnQ6IGFjdGl2ZVBvaW50LFxuICAgICAgICAgICAgICAgIGJhc2VQb2ludDogYmFzZVBvaW50LFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IGFjdGl2ZVRvb2x0aXBJbmRleCxcbiAgICAgICAgICAgICAgICBpc1JhbmdlOiBpc1JhbmdlXG4gICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyRnZXRJdGVtQnlYWTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2UgaGl0IHRoaXMgYmxvY2sgaWYgY29uc3VtZXIgdXNlcyBhIFRvb2x0aXAgd2l0aG91dCBYQXhpcyBhbmQvb3IgWUF4aXMuXG4gICAgICAgICAgICAgKiBJbiB3aGljaCBjYXNlLCB0aGlzLnN0YXRlLmFjdGl2ZVRvb2x0aXBJbmRleCBuZXZlciBnZXRzIHNldFxuICAgICAgICAgICAgICogYmVjYXVzZSB0aGUgbW91c2UgZXZlbnRzIHRoYXQgdHJpZ2dlciB0aGF0IHZhbHVlIGdldHRpbmcgc2V0IG5ldmVyIGdldCB0cmlnZ2VkIHdpdGhvdXQgdGhlIGF4aXMgY29tcG9uZW50cy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBBbiBleGFtcGxlIHVzYWdlIGNhc2UgaXMgYSBGdW5uZWxDaGFydFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgX3JlZjExID0gKF90aGlzJGdldEl0ZW1CeVhZID0gX3RoaXMuZ2V0SXRlbUJ5WFkoX3RoaXMuc3RhdGUuYWN0aXZlQ29vcmRpbmF0ZSkpICE9PSBudWxsICYmIF90aGlzJGdldEl0ZW1CeVhZICE9PSB2b2lkIDAgPyBfdGhpcyRnZXRJdGVtQnlYWSA6IHtcbiAgICAgICAgICAgICAgICBncmFwaGljYWxJdGVtOiBncmFwaGljYWxJdGVtXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF9yZWYxMSRncmFwaGljYWxJdGVtID0gX3JlZjExLmdyYXBoaWNhbEl0ZW0sXG4gICAgICAgICAgICAgIF9yZWYxMSRncmFwaGljYWxJdGVtJCA9IF9yZWYxMSRncmFwaGljYWxJdGVtLml0ZW0sXG4gICAgICAgICAgICAgIHh5SXRlbSA9IF9yZWYxMSRncmFwaGljYWxJdGVtJCA9PT0gdm9pZCAwID8gZWxlbWVudCA6IF9yZWYxMSRncmFwaGljYWxJdGVtJCxcbiAgICAgICAgICAgICAgY2hpbGRJbmRleCA9IF9yZWYxMSRncmFwaGljYWxJdGVtLmNoaWxkSW5kZXg7XG4gICAgICAgICAgICB2YXIgZWxlbWVudFByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGl0ZW0ucHJvcHMpLCBpdGVtRXZlbnRzKSwge30sIHtcbiAgICAgICAgICAgICAgYWN0aXZlSW5kZXg6IGNoaWxkSW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFsvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKHh5SXRlbSwgZWxlbWVudFByb3BzKSwgbnVsbCwgbnVsbF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuIFtncmFwaGljYWxJdGVtLCBudWxsLCBudWxsXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2dyYXBoaWNhbEl0ZW0sIG51bGxdO1xuICAgICAgfSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVuZGVyQ3VzdG9taXplZFwiLCBmdW5jdGlvbiAoZWxlbWVudCwgZGlzcGxheU5hbWUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGVsZW1lbnQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAga2V5OiBcInJlY2hhcnRzLWN1c3RvbWl6ZWQtXCIuY29uY2F0KGluZGV4KVxuICAgICAgICB9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKSk7XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZW5kZXJNYXBcIiwge1xuICAgICAgICBDYXJ0ZXNpYW5HcmlkOiB7XG4gICAgICAgICAgaGFuZGxlcjogcmVuZGVyQXNJcyxcbiAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFJlZmVyZW5jZUFyZWE6IHtcbiAgICAgICAgICBoYW5kbGVyOiBfdGhpcy5yZW5kZXJSZWZlcmVuY2VFbGVtZW50XG4gICAgICAgIH0sXG4gICAgICAgIFJlZmVyZW5jZUxpbmU6IHtcbiAgICAgICAgICBoYW5kbGVyOiByZW5kZXJBc0lzXG4gICAgICAgIH0sXG4gICAgICAgIFJlZmVyZW5jZURvdDoge1xuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlclJlZmVyZW5jZUVsZW1lbnRcbiAgICAgICAgfSxcbiAgICAgICAgWEF4aXM6IHtcbiAgICAgICAgICBoYW5kbGVyOiByZW5kZXJBc0lzXG4gICAgICAgIH0sXG4gICAgICAgIFlBeGlzOiB7XG4gICAgICAgICAgaGFuZGxlcjogcmVuZGVyQXNJc1xuICAgICAgICB9LFxuICAgICAgICBCcnVzaDoge1xuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlckJydXNoLFxuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgQmFyOiB7XG4gICAgICAgICAgaGFuZGxlcjogX3RoaXMucmVuZGVyR3JhcGhpY0NoaWxkXG4gICAgICAgIH0sXG4gICAgICAgIExpbmU6IHtcbiAgICAgICAgICBoYW5kbGVyOiBfdGhpcy5yZW5kZXJHcmFwaGljQ2hpbGRcbiAgICAgICAgfSxcbiAgICAgICAgQXJlYToge1xuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlckdyYXBoaWNDaGlsZFxuICAgICAgICB9LFxuICAgICAgICBSYWRhcjoge1xuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlckdyYXBoaWNDaGlsZFxuICAgICAgICB9LFxuICAgICAgICBSYWRpYWxCYXI6IHtcbiAgICAgICAgICBoYW5kbGVyOiBfdGhpcy5yZW5kZXJHcmFwaGljQ2hpbGRcbiAgICAgICAgfSxcbiAgICAgICAgU2NhdHRlcjoge1xuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlckdyYXBoaWNDaGlsZFxuICAgICAgICB9LFxuICAgICAgICBQaWU6IHtcbiAgICAgICAgICBoYW5kbGVyOiBfdGhpcy5yZW5kZXJHcmFwaGljQ2hpbGRcbiAgICAgICAgfSxcbiAgICAgICAgRnVubmVsOiB7XG4gICAgICAgICAgaGFuZGxlcjogX3RoaXMucmVuZGVyR3JhcGhpY0NoaWxkXG4gICAgICAgIH0sXG4gICAgICAgIFRvb2x0aXA6IHtcbiAgICAgICAgICBoYW5kbGVyOiBfdGhpcy5yZW5kZXJDdXJzb3IsXG4gICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBQb2xhckdyaWQ6IHtcbiAgICAgICAgICBoYW5kbGVyOiBfdGhpcy5yZW5kZXJQb2xhckdyaWQsXG4gICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBQb2xhckFuZ2xlQXhpczoge1xuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlclBvbGFyQXhpc1xuICAgICAgICB9LFxuICAgICAgICBQb2xhclJhZGl1c0F4aXM6IHtcbiAgICAgICAgICBoYW5kbGVyOiBfdGhpcy5yZW5kZXJQb2xhckF4aXNcbiAgICAgICAgfSxcbiAgICAgICAgQ3VzdG9taXplZDoge1xuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlckN1c3RvbWl6ZWRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBfdGhpcy5jbGlwUGF0aElkID0gXCJcIi5jb25jYXQoKF9wcm9wcyRpZCA9IF9wcm9wcy5pZCkgIT09IG51bGwgJiYgX3Byb3BzJGlkICE9PSB2b2lkIDAgPyBfcHJvcHMkaWQgOiAoMCwgX0RhdGFVdGlscy51bmlxdWVJZCkoJ3JlY2hhcnRzJyksIFwiLWNsaXBcIik7XG5cbiAgICAgIC8vIHRyaWdnZXIgNjBmcHNcbiAgICAgIF90aGlzLnRocm90dGxlVHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmUgPSAoMCwgX3Rocm90dGxlW1wiZGVmYXVsdFwiXSkoX3RoaXMudHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmUsIChfcHJvcHMkdGhyb3R0bGVEZWxheSA9IF9wcm9wcy50aHJvdHRsZURlbGF5KSAhPT0gbnVsbCAmJiBfcHJvcHMkdGhyb3R0bGVEZWxheSAhPT0gdm9pZCAwID8gX3Byb3BzJHRocm90dGxlRGVsYXkgOiAxMDAwIC8gNjApO1xuICAgICAgX3RoaXMuc3RhdGUgPSB7fTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2luaGVyaXRzKENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyLCBfQ29tcG9uZW50KTtcbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyLCBbe1xuICAgICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyRtYXJnaW4kbGUsIF90aGlzJHByb3BzJG1hcmdpbiR0bztcbiAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLmFjY2Vzc2liaWxpdHlNYW5hZ2VyLnNldERldGFpbHMoe1xuICAgICAgICAgIGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICBsZWZ0OiAoX3RoaXMkcHJvcHMkbWFyZ2luJGxlID0gdGhpcy5wcm9wcy5tYXJnaW4ubGVmdCkgIT09IG51bGwgJiYgX3RoaXMkcHJvcHMkbWFyZ2luJGxlICE9PSB2b2lkIDAgPyBfdGhpcyRwcm9wcyRtYXJnaW4kbGUgOiAwLFxuICAgICAgICAgICAgdG9wOiAoX3RoaXMkcHJvcHMkbWFyZ2luJHRvID0gdGhpcy5wcm9wcy5tYXJnaW4udG9wKSAhPT0gbnVsbCAmJiBfdGhpcyRwcm9wcyRtYXJnaW4kdG8gIT09IHZvaWQgMCA/IF90aGlzJHByb3BzJG1hcmdpbiR0byA6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvb3JkaW5hdGVMaXN0OiB0aGlzLnN0YXRlLnRvb2x0aXBUaWNrcyxcbiAgICAgICAgICBtb3VzZUhhbmRsZXJDYWxsYmFjazogdGhpcy50cmlnZ2VyZWRBZnRlck1vdXNlTW92ZSxcbiAgICAgICAgICBsYXlvdXQ6IHRoaXMucHJvcHMubGF5b3V0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpc3BsYXlEZWZhdWx0VG9vbHRpcCgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkaXNwbGF5RGVmYXVsdFRvb2x0aXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwbGF5RGVmYXVsdFRvb2x0aXAoKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wczUgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHM1LmNoaWxkcmVuLFxuICAgICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wczUuZGF0YSxcbiAgICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczUuaGVpZ2h0LFxuICAgICAgICAgIGxheW91dCA9IF90aGlzJHByb3BzNS5sYXlvdXQ7XG4gICAgICAgIHZhciB0b29sdGlwRWxlbSA9ICgwLCBfUmVhY3RVdGlscy5maW5kQ2hpbGRCeVR5cGUpKGNoaWxkcmVuLCBfVG9vbHRpcC5Ub29sdGlwKTtcbiAgICAgICAgLy8gSWYgdGhlIGNoYXJ0IGRvZXNuJ3QgaW5jbHVkZSBhIDxUb29sdGlwIC8+IGVsZW1lbnQsIHRoZXJlJ3Mgbm8gdG9vbHRpcCB0byBkaXNwbGF5XG4gICAgICAgIGlmICghdG9vbHRpcEVsZW0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlZmF1bHRJbmRleCA9IHRvb2x0aXBFbGVtLnByb3BzLmRlZmF1bHRJbmRleDtcblxuICAgICAgICAvLyBQcm90ZWN0IGFnYWluc3QgcnVudGltZSBlcnJvcnNcbiAgICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0SW5kZXggIT09ICdudW1iZXInIHx8IGRlZmF1bHRJbmRleCA8IDAgfHwgZGVmYXVsdEluZGV4ID4gdGhpcy5zdGF0ZS50b29sdGlwVGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWN0aXZlTGFiZWwgPSB0aGlzLnN0YXRlLnRvb2x0aXBUaWNrc1tkZWZhdWx0SW5kZXhdICYmIHRoaXMuc3RhdGUudG9vbHRpcFRpY2tzW2RlZmF1bHRJbmRleF0udmFsdWU7XG4gICAgICAgIHZhciBhY3RpdmVQYXlsb2FkID0gZ2V0VG9vbHRpcENvbnRlbnQodGhpcy5zdGF0ZSwgZGF0YSwgZGVmYXVsdEluZGV4LCBhY3RpdmVMYWJlbCk7XG4gICAgICAgIHZhciBpbmRlcGVuZGVudEF4aXNDb29yZCA9IHRoaXMuc3RhdGUudG9vbHRpcFRpY2tzW2RlZmF1bHRJbmRleF0uY29vcmRpbmF0ZTtcbiAgICAgICAgdmFyIGRlcGVuZGVudEF4aXNDb29yZCA9ICh0aGlzLnN0YXRlLm9mZnNldC50b3AgKyBoZWlnaHQpIC8gMjtcbiAgICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGxheW91dCA9PT0gJ2hvcml6b250YWwnO1xuICAgICAgICB2YXIgYWN0aXZlQ29vcmRpbmF0ZSA9IGlzSG9yaXpvbnRhbCA/IHtcbiAgICAgICAgICB4OiBpbmRlcGVuZGVudEF4aXNDb29yZCxcbiAgICAgICAgICB5OiBkZXBlbmRlbnRBeGlzQ29vcmRcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB5OiBpbmRlcGVuZGVudEF4aXNDb29yZCxcbiAgICAgICAgICB4OiBkZXBlbmRlbnRBeGlzQ29vcmRcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVbmxpa2Ugb3RoZXIgY2hhcnQgdHlwZXMsIHNjYXR0ZXIgcGxvdCdzIHRvb2x0aXAgcG9zaXRpb25zIHJlbHkgb24gYm90aCBYIGFuZCBZIGNvb3JkaW5hdGVzLiBPbmx5IHRoZSBzY2F0dGVyIHBsb3RcbiAgICAgICAgLy8gZWxlbWVudCBrbm93cyBpdHMgb3duIFkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYSBzY2F0dGVyIHBsb3QsIHdlJ2xsIHdhbnQgdG8gZ3JhYiB0aGF0IGVsZW1lbnQgZm9yIGFuIGludGVycm9nYXRpb24uXG4gICAgICAgIHZhciBzY2F0dGVyUGxvdEVsZW1lbnQgPSB0aGlzLnN0YXRlLmZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zLmZpbmQoZnVuY3Rpb24gKF9yZWYxMikge1xuICAgICAgICAgIHZhciBpdGVtID0gX3JlZjEyLml0ZW07XG4gICAgICAgICAgcmV0dXJuIGl0ZW0udHlwZS5uYW1lID09PSAnU2NhdHRlcic7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2NhdHRlclBsb3RFbGVtZW50KSB7XG4gICAgICAgICAgYWN0aXZlQ29vcmRpbmF0ZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYWN0aXZlQ29vcmRpbmF0ZSksIHNjYXR0ZXJQbG90RWxlbWVudC5wcm9wcy5wb2ludHNbZGVmYXVsdEluZGV4XS50b29sdGlwUG9zaXRpb24pO1xuICAgICAgICAgIGFjdGl2ZVBheWxvYWQgPSBzY2F0dGVyUGxvdEVsZW1lbnQucHJvcHMucG9pbnRzW2RlZmF1bHRJbmRleF0udG9vbHRpcFBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHtcbiAgICAgICAgICBhY3RpdmVUb29sdGlwSW5kZXg6IGRlZmF1bHRJbmRleCxcbiAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmU6IHRydWUsXG4gICAgICAgICAgYWN0aXZlTGFiZWw6IGFjdGl2ZUxhYmVsLFxuICAgICAgICAgIGFjdGl2ZVBheWxvYWQ6IGFjdGl2ZVBheWxvYWQsXG4gICAgICAgICAgYWN0aXZlQ29vcmRpbmF0ZTogYWN0aXZlQ29vcmRpbmF0ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFN0YXRlKG5leHRTdGF0ZSk7XG4gICAgICAgIHRoaXMucmVuZGVyQ3Vyc29yKHRvb2x0aXBFbGVtKTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBhbnlvbmUgd2hvIGtleWJvYXJkLW9ubHkgdXNlcnMgd2hvIHRhYiB0byB0aGUgY2hhcnQgd2lsbCBzdGFydCB0aGVpclxuICAgICAgICAvLyBjdXJzb3JzIGF0IGRlZmF1bHRJbmRleFxuICAgICAgICB0aGlzLmFjY2Vzc2liaWxpdHlNYW5hZ2VyLnNldEluZGV4KGRlZmF1bHRJbmRleCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFNuYXBzaG90QmVmb3JlVXBkYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLmFjY2Vzc2liaWxpdHlMYXllcikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnRvb2x0aXBUaWNrcyAhPT0gcHJldlN0YXRlLnRvb2x0aXBUaWNrcykge1xuICAgICAgICAgIHRoaXMuYWNjZXNzaWJpbGl0eU1hbmFnZXIuc2V0RGV0YWlscyh7XG4gICAgICAgICAgICBjb29yZGluYXRlTGlzdDogdGhpcy5zdGF0ZS50b29sdGlwVGlja3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wcy5sYXlvdXQgIT09IHByZXZQcm9wcy5sYXlvdXQpIHtcbiAgICAgICAgICB0aGlzLmFjY2Vzc2liaWxpdHlNYW5hZ2VyLnNldERldGFpbHMoe1xuICAgICAgICAgICAgbGF5b3V0OiB0aGlzLnByb3BzLmxheW91dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm1hcmdpbiAhPT0gcHJldlByb3BzLm1hcmdpbikge1xuICAgICAgICAgIHZhciBfdGhpcyRwcm9wcyRtYXJnaW4kbGUyLCBfdGhpcyRwcm9wcyRtYXJnaW4kdG8yO1xuICAgICAgICAgIHRoaXMuYWNjZXNzaWJpbGl0eU1hbmFnZXIuc2V0RGV0YWlscyh7XG4gICAgICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgICAgbGVmdDogKF90aGlzJHByb3BzJG1hcmdpbiRsZTIgPSB0aGlzLnByb3BzLm1hcmdpbi5sZWZ0KSAhPT0gbnVsbCAmJiBfdGhpcyRwcm9wcyRtYXJnaW4kbGUyICE9PSB2b2lkIDAgPyBfdGhpcyRwcm9wcyRtYXJnaW4kbGUyIDogMCxcbiAgICAgICAgICAgICAgdG9wOiAoX3RoaXMkcHJvcHMkbWFyZ2luJHRvMiA9IHRoaXMucHJvcHMubWFyZ2luLnRvcCkgIT09IG51bGwgJiYgX3RoaXMkcHJvcHMkbWFyZ2luJHRvMiAhPT0gdm9pZCAwID8gX3RoaXMkcHJvcHMkbWFyZ2luJHRvMiA6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvbWV0aGluZyBoYXMgdG8gYmUgcmV0dXJuZWQgZm9yIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgVG9vbHRpcCB1cGRhdGVkLiBJZiBzbywgcmUtY2hlY2sgZGVmYXVsdCB0b29sdGlwIHBvc2l0aW9uXG4gICAgICAgIGlmICghKDAsIF9SZWFjdFV0aWxzLmlzQ2hpbGRyZW5FcXVhbCkoWygwLCBfUmVhY3RVdGlscy5maW5kQ2hpbGRCeVR5cGUpKHByZXZQcm9wcy5jaGlsZHJlbiwgX1Rvb2x0aXAuVG9vbHRpcCldLCBbKDAsIF9SZWFjdFV0aWxzLmZpbmRDaGlsZEJ5VHlwZSkodGhpcy5wcm9wcy5jaGlsZHJlbiwgX1Rvb2x0aXAuVG9vbHRpcCldKSkge1xuICAgICAgICAgIHRoaXMuZGlzcGxheURlZmF1bHRUb29sdGlwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLnRocm90dGxlVHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmUuY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFRvb2x0aXBFdmVudFR5cGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb29sdGlwRXZlbnRUeXBlKCkge1xuICAgICAgICB2YXIgdG9vbHRpcEl0ZW0gPSAoMCwgX1JlYWN0VXRpbHMuZmluZENoaWxkQnlUeXBlKSh0aGlzLnByb3BzLmNoaWxkcmVuLCBfVG9vbHRpcC5Ub29sdGlwKTtcbiAgICAgICAgaWYgKHRvb2x0aXBJdGVtICYmIHR5cGVvZiB0b29sdGlwSXRlbS5wcm9wcy5zaGFyZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHZhciBldmVudFR5cGUgPSB0b29sdGlwSXRlbS5wcm9wcy5zaGFyZWQgPyAnYXhpcycgOiAnaXRlbSc7XG4gICAgICAgICAgcmV0dXJuIHZhbGlkYXRlVG9vbHRpcEV2ZW50VHlwZXMuaW5kZXhPZihldmVudFR5cGUpID49IDAgPyBldmVudFR5cGUgOiBkZWZhdWx0VG9vbHRpcEV2ZW50VHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdFRvb2x0aXBFdmVudFR5cGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBpbmZvcm1hdGlvbiBvZiBtb3VzZSBpbiBjaGFydCwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbW91c2UgaXMgbm90IGluIHRoZSBjaGFydFxuICAgICAgICogQHBhcmFtICB7TW91c2VQb2ludGVyfSBldmVudCAgICBUaGUgZXZlbnQgb2JqZWN0XG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgIE1vdXNlIGRhdGFcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRNb3VzZUluZm9cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb3VzZUluZm8oZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgY29udGFpbmVyT2Zmc2V0ID0gKDAsIF9ET01VdGlscy5nZXRPZmZzZXQpKGJvdW5kaW5nUmVjdCk7XG4gICAgICAgIHZhciBlID0ge1xuICAgICAgICAgIGNoYXJ0WDogTWF0aC5yb3VuZChldmVudC5wYWdlWCAtIGNvbnRhaW5lck9mZnNldC5sZWZ0KSxcbiAgICAgICAgICBjaGFydFk6IE1hdGgucm91bmQoZXZlbnQucGFnZVkgLSBjb250YWluZXJPZmZzZXQudG9wKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2NhbGUgPSBib3VuZGluZ1JlY3Qud2lkdGggLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gICAgICAgIHZhciByYW5nZU9iaiA9IHRoaXMuaW5SYW5nZShlLmNoYXJ0WCwgZS5jaGFydFksIHNjYWxlKTtcbiAgICAgICAgaWYgKCFyYW5nZU9iaikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdGhpcyRzdGF0ZTkgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgIHhBeGlzTWFwID0gX3RoaXMkc3RhdGU5LnhBeGlzTWFwLFxuICAgICAgICAgIHlBeGlzTWFwID0gX3RoaXMkc3RhdGU5LnlBeGlzTWFwO1xuICAgICAgICB2YXIgdG9vbHRpcEV2ZW50VHlwZSA9IHRoaXMuZ2V0VG9vbHRpcEV2ZW50VHlwZSgpO1xuICAgICAgICBpZiAodG9vbHRpcEV2ZW50VHlwZSAhPT0gJ2F4aXMnICYmIHhBeGlzTWFwICYmIHlBeGlzTWFwKSB7XG4gICAgICAgICAgdmFyIHhTY2FsZSA9ICgwLCBfRGF0YVV0aWxzLmdldEFueUVsZW1lbnRPZk9iamVjdCkoeEF4aXNNYXApLnNjYWxlO1xuICAgICAgICAgIHZhciB5U2NhbGUgPSAoMCwgX0RhdGFVdGlscy5nZXRBbnlFbGVtZW50T2ZPYmplY3QpKHlBeGlzTWFwKS5zY2FsZTtcbiAgICAgICAgICB2YXIgeFZhbHVlID0geFNjYWxlICYmIHhTY2FsZS5pbnZlcnQgPyB4U2NhbGUuaW52ZXJ0KGUuY2hhcnRYKSA6IG51bGw7XG4gICAgICAgICAgdmFyIHlWYWx1ZSA9IHlTY2FsZSAmJiB5U2NhbGUuaW52ZXJ0ID8geVNjYWxlLmludmVydChlLmNoYXJ0WSkgOiBudWxsO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGUpLCB7fSwge1xuICAgICAgICAgICAgeFZhbHVlOiB4VmFsdWUsXG4gICAgICAgICAgICB5VmFsdWU6IHlWYWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b29sVGlwRGF0YSA9IGdldFRvb2x0aXBEYXRhKHRoaXMuc3RhdGUsIHRoaXMucHJvcHMuZGF0YSwgdGhpcy5wcm9wcy5sYXlvdXQsIHJhbmdlT2JqKTtcbiAgICAgICAgaWYgKHRvb2xUaXBEYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZSksIHRvb2xUaXBEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW5SYW5nZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluUmFuZ2UoeCwgeSkge1xuICAgICAgICB2YXIgc2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLnByb3BzLmxheW91dDtcbiAgICAgICAgdmFyIHNjYWxlZFggPSB4IC8gc2NhbGUsXG4gICAgICAgICAgc2NhbGVkWSA9IHkgLyBzY2FsZTtcbiAgICAgICAgaWYgKGxheW91dCA9PT0gJ2hvcml6b250YWwnIHx8IGxheW91dCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnN0YXRlLm9mZnNldDtcbiAgICAgICAgICB2YXIgaXNJblJhbmdlID0gc2NhbGVkWCA+PSBvZmZzZXQubGVmdCAmJiBzY2FsZWRYIDw9IG9mZnNldC5sZWZ0ICsgb2Zmc2V0LndpZHRoICYmIHNjYWxlZFkgPj0gb2Zmc2V0LnRvcCAmJiBzY2FsZWRZIDw9IG9mZnNldC50b3AgKyBvZmZzZXQuaGVpZ2h0O1xuICAgICAgICAgIHJldHVybiBpc0luUmFuZ2UgPyB7XG4gICAgICAgICAgICB4OiBzY2FsZWRYLFxuICAgICAgICAgICAgeTogc2NhbGVkWVxuICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdGhpcyRzdGF0ZTEwID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICBhbmdsZUF4aXNNYXAgPSBfdGhpcyRzdGF0ZTEwLmFuZ2xlQXhpc01hcCxcbiAgICAgICAgICByYWRpdXNBeGlzTWFwID0gX3RoaXMkc3RhdGUxMC5yYWRpdXNBeGlzTWFwO1xuICAgICAgICBpZiAoYW5nbGVBeGlzTWFwICYmIHJhZGl1c0F4aXNNYXApIHtcbiAgICAgICAgICB2YXIgYW5nbGVBeGlzID0gKDAsIF9EYXRhVXRpbHMuZ2V0QW55RWxlbWVudE9mT2JqZWN0KShhbmdsZUF4aXNNYXApO1xuICAgICAgICAgIHJldHVybiAoMCwgX1BvbGFyVXRpbHMuaW5SYW5nZU9mU2VjdG9yKSh7XG4gICAgICAgICAgICB4OiBzY2FsZWRYLFxuICAgICAgICAgICAgeTogc2NhbGVkWVxuICAgICAgICAgIH0sIGFuZ2xlQXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBhcnNlRXZlbnRzT2ZXcmFwcGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VFdmVudHNPZldyYXBwZXIoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciB0b29sdGlwRXZlbnRUeXBlID0gdGhpcy5nZXRUb29sdGlwRXZlbnRUeXBlKCk7XG4gICAgICAgIHZhciB0b29sdGlwSXRlbSA9ICgwLCBfUmVhY3RVdGlscy5maW5kQ2hpbGRCeVR5cGUpKGNoaWxkcmVuLCBfVG9vbHRpcC5Ub29sdGlwKTtcbiAgICAgICAgdmFyIHRvb2x0aXBFdmVudHMgPSB7fTtcbiAgICAgICAgaWYgKHRvb2x0aXBJdGVtICYmIHRvb2x0aXBFdmVudFR5cGUgPT09ICdheGlzJykge1xuICAgICAgICAgIGlmICh0b29sdGlwSXRlbS5wcm9wcy50cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICB0b29sdGlwRXZlbnRzID0ge1xuICAgICAgICAgICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b29sdGlwRXZlbnRzID0ge1xuICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI6IHRoaXMuaGFuZGxlTW91c2VFbnRlcixcbiAgICAgICAgICAgICAgb25Eb3VibGVDbGljazogdGhpcy5oYW5kbGVEb3VibGVDbGljayxcbiAgICAgICAgICAgICAgb25Nb3VzZU1vdmU6IHRoaXMuaGFuZGxlTW91c2VNb3ZlLFxuICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU6IHRoaXMuaGFuZGxlTW91c2VMZWF2ZSxcbiAgICAgICAgICAgICAgb25Ub3VjaE1vdmU6IHRoaXMuaGFuZGxlVG91Y2hNb3ZlLFxuICAgICAgICAgICAgICBvblRvdWNoU3RhcnQ6IHRoaXMuaGFuZGxlVG91Y2hTdGFydCxcbiAgICAgICAgICAgICAgb25Ub3VjaEVuZDogdGhpcy5oYW5kbGVUb3VjaEVuZCxcbiAgICAgICAgICAgICAgb25Db250ZXh0TWVudTogdGhpcy5oYW5kbGVDb250ZXh0TWVudVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGFkYXB0RXZlbnRIYW5kbGVycyBleHBlY3RzIERPTSBFdmVudCBidXQgZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IHdvcmtzIHdpdGggUmVhY3QgVUlFdmVudHNcbiAgICAgICAgdmFyIG91dGVyRXZlbnRzID0gKDAsIF90eXBlcy5hZGFwdEV2ZW50SGFuZGxlcnMpKHRoaXMucHJvcHMsIHRoaXMuaGFuZGxlT3V0ZXJFdmVudCk7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG91dGVyRXZlbnRzKSwgdG9vbHRpcEV2ZW50cyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZExpc3RlbmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTGlzdGVuZXIoKSB7XG4gICAgICAgIF9FdmVudHMuZXZlbnRDZW50ZXIub24oX0V2ZW50cy5TWU5DX0VWRU5ULCB0aGlzLmhhbmRsZVJlY2VpdmVTeW5jRXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdmVMaXN0ZW5lclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgICBfRXZlbnRzLmV2ZW50Q2VudGVyLnJlbW92ZUxpc3RlbmVyKF9FdmVudHMuU1lOQ19FVkVOVCwgdGhpcy5oYW5kbGVSZWNlaXZlU3luY0V2ZW50KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZmlsdGVyRm9ybWF0SXRlbVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlckZvcm1hdEl0ZW0oaXRlbSwgZGlzcGxheU5hbWUsIGNoaWxkSW5kZXgpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zID0gdGhpcy5zdGF0ZS5mb3JtYXR0ZWRHcmFwaGljYWxJdGVtcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXNbaV07XG4gICAgICAgICAgaWYgKGVudHJ5Lml0ZW0gPT09IGl0ZW0gfHwgZW50cnkucHJvcHMua2V5ID09PSBpdGVtLmtleSB8fCBkaXNwbGF5TmFtZSA9PT0gKDAsIF9SZWFjdFV0aWxzLmdldERpc3BsYXlOYW1lKShlbnRyeS5pdGVtLnR5cGUpICYmIGNoaWxkSW5kZXggPT09IGVudHJ5LmNoaWxkSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlckNsaXBQYXRoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ2xpcFBhdGgoKSB7XG4gICAgICAgIHZhciBjbGlwUGF0aElkID0gdGhpcy5jbGlwUGF0aElkO1xuICAgICAgICB2YXIgX3RoaXMkc3RhdGUkb2Zmc2V0ID0gdGhpcy5zdGF0ZS5vZmZzZXQsXG4gICAgICAgICAgbGVmdCA9IF90aGlzJHN0YXRlJG9mZnNldC5sZWZ0LFxuICAgICAgICAgIHRvcCA9IF90aGlzJHN0YXRlJG9mZnNldC50b3AsXG4gICAgICAgICAgaGVpZ2h0ID0gX3RoaXMkc3RhdGUkb2Zmc2V0LmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF90aGlzJHN0YXRlJG9mZnNldC53aWR0aDtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIsIG51bGwsIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiLCB7XG4gICAgICAgICAgaWQ6IGNsaXBQYXRoSWRcbiAgICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgeTogdG9wLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRYU2NhbGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0WFNjYWxlcygpIHtcbiAgICAgICAgdmFyIHhBeGlzTWFwID0gdGhpcy5zdGF0ZS54QXhpc01hcDtcbiAgICAgICAgcmV0dXJuIHhBeGlzTWFwID8gT2JqZWN0LmVudHJpZXMoeEF4aXNNYXApLnJlZHVjZShmdW5jdGlvbiAocmVzLCBfcmVmMTMpIHtcbiAgICAgICAgICB2YXIgX3JlZjE0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjEzLCAyKSxcbiAgICAgICAgICAgIGF4aXNJZCA9IF9yZWYxNFswXSxcbiAgICAgICAgICAgIGF4aXNQcm9wcyA9IF9yZWYxNFsxXTtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXMpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBheGlzSWQsIGF4aXNQcm9wcy5zY2FsZSkpO1xuICAgICAgICB9LCB7fSkgOiBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRZU2NhbGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0WVNjYWxlcygpIHtcbiAgICAgICAgdmFyIHlBeGlzTWFwID0gdGhpcy5zdGF0ZS55QXhpc01hcDtcbiAgICAgICAgcmV0dXJuIHlBeGlzTWFwID8gT2JqZWN0LmVudHJpZXMoeUF4aXNNYXApLnJlZHVjZShmdW5jdGlvbiAocmVzLCBfcmVmMTUpIHtcbiAgICAgICAgICB2YXIgX3JlZjE2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE1LCAyKSxcbiAgICAgICAgICAgIGF4aXNJZCA9IF9yZWYxNlswXSxcbiAgICAgICAgICAgIGF4aXNQcm9wcyA9IF9yZWYxNlsxXTtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXMpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBheGlzSWQsIGF4aXNQcm9wcy5zY2FsZSkpO1xuICAgICAgICB9LCB7fSkgOiBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRYU2NhbGVCeUF4aXNJZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFhTY2FsZUJ5QXhpc0lkKGF4aXNJZCkge1xuICAgICAgICB2YXIgX3RoaXMkc3RhdGUkeEF4aXNNYXA7XG4gICAgICAgIHJldHVybiAoX3RoaXMkc3RhdGUkeEF4aXNNYXAgPSB0aGlzLnN0YXRlLnhBeGlzTWFwKSA9PT0gbnVsbCB8fCBfdGhpcyRzdGF0ZSR4QXhpc01hcCA9PT0gdm9pZCAwIHx8IChfdGhpcyRzdGF0ZSR4QXhpc01hcCA9IF90aGlzJHN0YXRlJHhBeGlzTWFwW2F4aXNJZF0pID09PSBudWxsIHx8IF90aGlzJHN0YXRlJHhBeGlzTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRzdGF0ZSR4QXhpc01hcC5zY2FsZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0WVNjYWxlQnlBeGlzSWRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRZU2NhbGVCeUF4aXNJZChheGlzSWQpIHtcbiAgICAgICAgdmFyIF90aGlzJHN0YXRlJHlBeGlzTWFwO1xuICAgICAgICByZXR1cm4gKF90aGlzJHN0YXRlJHlBeGlzTWFwID0gdGhpcy5zdGF0ZS55QXhpc01hcCkgPT09IG51bGwgfHwgX3RoaXMkc3RhdGUkeUF4aXNNYXAgPT09IHZvaWQgMCB8fCAoX3RoaXMkc3RhdGUkeUF4aXNNYXAgPSBfdGhpcyRzdGF0ZSR5QXhpc01hcFtheGlzSWRdKSA9PT0gbnVsbCB8fCBfdGhpcyRzdGF0ZSR5QXhpc01hcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkc3RhdGUkeUF4aXNNYXAuc2NhbGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEl0ZW1CeVhZXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SXRlbUJ5WFkoY2hhcnRYWSkge1xuICAgICAgICB2YXIgX3RoaXMkc3RhdGUxMSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXMgPSBfdGhpcyRzdGF0ZTExLmZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zLFxuICAgICAgICAgIGFjdGl2ZUl0ZW0gPSBfdGhpcyRzdGF0ZTExLmFjdGl2ZUl0ZW07XG4gICAgICAgIGlmIChmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcyAmJiBmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBncmFwaGljYWxJdGVtID0gZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXNbaV07XG4gICAgICAgICAgICAvLyBncmFwaGljYWxJdGVtIGlzIG5vdCBhIFJlYWN0IEVsZW1lbnQgc28gd2UgZG9uJ3QgbmVlZCB0byByZXNvbHZlIGRlZmF1bHRQcm9wc1xuICAgICAgICAgICAgdmFyIHByb3BzID0gZ3JhcGhpY2FsSXRlbS5wcm9wcyxcbiAgICAgICAgICAgICAgaXRlbSA9IGdyYXBoaWNhbEl0ZW0uaXRlbTtcbiAgICAgICAgICAgIHZhciBpdGVtUHJvcHMgPSBpdGVtLnR5cGUuZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGl0ZW0udHlwZS5kZWZhdWx0UHJvcHMpLCBpdGVtLnByb3BzKSA6IGl0ZW0ucHJvcHM7XG4gICAgICAgICAgICB2YXIgaXRlbURpc3BsYXlOYW1lID0gKDAsIF9SZWFjdFV0aWxzLmdldERpc3BsYXlOYW1lKShpdGVtLnR5cGUpO1xuICAgICAgICAgICAgaWYgKGl0ZW1EaXNwbGF5TmFtZSA9PT0gJ0JhcicpIHtcbiAgICAgICAgICAgICAgdmFyIGFjdGl2ZUJhckl0ZW0gPSAocHJvcHMuZGF0YSB8fCBbXSkuZmluZChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9SZWN0YW5nbGUuaXNJblJlY3RhbmdsZSkoY2hhcnRYWSwgZW50cnkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGFjdGl2ZUJhckl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgZ3JhcGhpY2FsSXRlbTogZ3JhcGhpY2FsSXRlbSxcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGFjdGl2ZUJhckl0ZW1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW1EaXNwbGF5TmFtZSA9PT0gJ1JhZGlhbEJhcicpIHtcbiAgICAgICAgICAgICAgdmFyIF9hY3RpdmVCYXJJdGVtID0gKHByb3BzLmRhdGEgfHwgW10pLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfUG9sYXJVdGlscy5pblJhbmdlT2ZTZWN0b3IpKGNoYXJ0WFksIGVudHJ5KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChfYWN0aXZlQmFySXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBncmFwaGljYWxJdGVtOiBncmFwaGljYWxJdGVtLFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZDogX2FjdGl2ZUJhckl0ZW1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgwLCBfQWN0aXZlU2hhcGVVdGlscy5pc0Z1bm5lbCkoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkgfHwgKDAsIF9BY3RpdmVTaGFwZVV0aWxzLmlzUGllKShncmFwaGljYWxJdGVtLCBhY3RpdmVJdGVtKSB8fCAoMCwgX0FjdGl2ZVNoYXBlVXRpbHMuaXNTY2F0dGVyKShncmFwaGljYWxJdGVtLCBhY3RpdmVJdGVtKSkge1xuICAgICAgICAgICAgICB2YXIgYWN0aXZlSW5kZXggPSAoMCwgX0FjdGl2ZVNoYXBlVXRpbHMuZ2V0QWN0aXZlU2hhcGVJbmRleEZvclRvb2x0aXApKHtcbiAgICAgICAgICAgICAgICBncmFwaGljYWxJdGVtOiBncmFwaGljYWxJdGVtLFxuICAgICAgICAgICAgICAgIGFjdGl2ZVRvb2x0aXBJdGVtOiBhY3RpdmVJdGVtLFxuICAgICAgICAgICAgICAgIGl0ZW1EYXRhOiBpdGVtUHJvcHMuZGF0YVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkSW5kZXggPSBpdGVtUHJvcHMuYWN0aXZlSW5kZXggPT09IHVuZGVmaW5lZCA/IGFjdGl2ZUluZGV4IDogaXRlbVByb3BzLmFjdGl2ZUluZGV4O1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdyYXBoaWNhbEl0ZW06IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZ3JhcGhpY2FsSXRlbSksIHt9LCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiBjaGlsZEluZGV4XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogKDAsIF9BY3RpdmVTaGFwZVV0aWxzLmlzU2NhdHRlcikoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkgPyBpdGVtUHJvcHMuZGF0YVthY3RpdmVJbmRleF0gOiBncmFwaGljYWxJdGVtLnByb3BzLmRhdGFbYWN0aXZlSW5kZXhdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgICBpZiAoISgwLCBfUmVhY3RVdGlscy52YWxpZGF0ZVdpZHRoSGVpZ2h0KSh0aGlzKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdGhpcyRwcm9wczYgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHM2LmNoaWxkcmVuLFxuICAgICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzNi5jbGFzc05hbWUsXG4gICAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczYud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHM2LmhlaWdodCxcbiAgICAgICAgICBzdHlsZSA9IF90aGlzJHByb3BzNi5zdHlsZSxcbiAgICAgICAgICBjb21wYWN0ID0gX3RoaXMkcHJvcHM2LmNvbXBhY3QsXG4gICAgICAgICAgdGl0bGUgPSBfdGhpcyRwcm9wczYudGl0bGUsXG4gICAgICAgICAgZGVzYyA9IF90aGlzJHByb3BzNi5kZXNjLFxuICAgICAgICAgIG90aGVycyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRwcm9wczYsIF9leGNsdWRlZDIpO1xuICAgICAgICB2YXIgYXR0cnMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKG90aGVycywgZmFsc2UpO1xuXG4gICAgICAgIC8vIFRoZSBcImNvbXBhY3RcIiBtb2RlIGlzIG1haW5seSB1c2VkIGFzIHRoZSBwYW5vcmFtYSB3aXRoaW4gQnJ1c2hcbiAgICAgICAgaWYgKGNvbXBhY3QpIHtcbiAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfY2hhcnRMYXlvdXRDb250ZXh0LkNoYXJ0TGF5b3V0Q29udGV4dFByb3ZpZGVyLCB7XG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLnByb3BzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnByb3BzLmhlaWdodCxcbiAgICAgICAgICAgIGNsaXBQYXRoSWQ6IHRoaXMuY2xpcFBhdGhJZFxuICAgICAgICAgIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1N1cmZhY2UuU3VyZmFjZSwgX2V4dGVuZHMoe30sIGF0dHJzLCB7XG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgIGRlc2M6IGRlc2NcbiAgICAgICAgICB9KSwgdGhpcy5yZW5kZXJDbGlwUGF0aCgpLCAoMCwgX1JlYWN0VXRpbHMucmVuZGVyQnlPcmRlcikoY2hpbGRyZW4sIHRoaXMucmVuZGVyTWFwKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmFjY2Vzc2liaWxpdHlMYXllcikge1xuICAgICAgICAgIHZhciBfdGhpcyRwcm9wcyR0YWJJbmRleCwgX3RoaXMkcHJvcHMkcm9sZTtcbiAgICAgICAgICAvLyBTZXQgdGFiSW5kZXggdG8gMCBieSBkZWZhdWx0IChjYW4gYmUgb3ZlcndyaXR0ZW4pXG4gICAgICAgICAgYXR0cnMudGFiSW5kZXggPSAoX3RoaXMkcHJvcHMkdGFiSW5kZXggPSB0aGlzLnByb3BzLnRhYkluZGV4KSAhPT0gbnVsbCAmJiBfdGhpcyRwcm9wcyR0YWJJbmRleCAhPT0gdm9pZCAwID8gX3RoaXMkcHJvcHMkdGFiSW5kZXggOiAwO1xuICAgICAgICAgIC8vIFNldCByb2xlIHRvIGltZyBieSBkZWZhdWx0IChjYW4gYmUgb3ZlcndyaXR0ZW4pXG4gICAgICAgICAgYXR0cnMucm9sZSA9IChfdGhpcyRwcm9wcyRyb2xlID0gdGhpcy5wcm9wcy5yb2xlKSAhPT0gbnVsbCAmJiBfdGhpcyRwcm9wcyRyb2xlICE9PSB2b2lkIDAgPyBfdGhpcyRwcm9wcyRyb2xlIDogJ2FwcGxpY2F0aW9uJztcbiAgICAgICAgICBhdHRycy5vbktleURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMzLmFjY2Vzc2liaWxpdHlNYW5hZ2VyLmtleWJvYXJkRXZlbnQoZSk7XG4gICAgICAgICAgICAvLyAnb25LZXlEb3duJyBpcyBub3QgY3VycmVudGx5IGEgc3VwcG9ydGVkIHByb3AgdGhhdCBjYW4gYmUgcGFzc2VkIHRocm91Z2hcbiAgICAgICAgICAgIC8vIGlmIGl0J3MgYWRkZWQsIHRoaXMgc2hvdWxkIGJlIGFkZGVkOiB0aGlzLnByb3BzLm9uS2V5RG93bihlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGF0dHJzLm9uRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYWNjZXNzaWJpbGl0eU1hbmFnZXIuZm9jdXMoKTtcbiAgICAgICAgICAgIC8vICdvbkZvY3VzJyBpcyBub3QgY3VycmVudGx5IGEgc3VwcG9ydGVkIHByb3AgdGhhdCBjYW4gYmUgcGFzc2VkIHRocm91Z2hcbiAgICAgICAgICAgIC8vIGlmIGl0J3MgYWRkZWQsIHRoZSBmb2N1cyBldmVudCBzaG91bGQgYmUgZm9yd2FyZGVkIHRvIHRoZSBwcm9wXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5wYXJzZUV2ZW50c09mV3JhcHBlcigpO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfY2hhcnRMYXlvdXRDb250ZXh0LkNoYXJ0TGF5b3V0Q29udGV4dFByb3ZpZGVyLCB7XG4gICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgd2lkdGg6IHRoaXMucHJvcHMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLnByb3BzLmhlaWdodCxcbiAgICAgICAgICBjbGlwUGF0aElkOiB0aGlzLmNsaXBQYXRoSWRcbiAgICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtd3JhcHBlcicsIGNsYXNzTmFtZSksXG4gICAgICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICBjdXJzb3I6ICdkZWZhdWx0JyxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgfSwgc3R5bGUpXG4gICAgICAgIH0sIGV2ZW50cywge1xuICAgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKG5vZGUpIHtcbiAgICAgICAgICAgIF90aGlzMy5jb250YWluZXIgPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1N1cmZhY2UuU3VyZmFjZSwgX2V4dGVuZHMoe30sIGF0dHJzLCB7XG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICBkZXNjOiBkZXNjLFxuICAgICAgICAgIHN0eWxlOiBGVUxMX1dJRFRIX0FORF9IRUlHSFRcbiAgICAgICAgfSksIHRoaXMucmVuZGVyQ2xpcFBhdGgoKSwgKDAsIF9SZWFjdFV0aWxzLnJlbmRlckJ5T3JkZXIpKGNoaWxkcmVuLCB0aGlzLnJlbmRlck1hcCkpLCB0aGlzLnJlbmRlckxlZ2VuZCgpLCB0aGlzLnJlbmRlclRvb2x0aXAoKSkpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfShfcmVhY3QuQ29tcG9uZW50KTtcbiAgX2RlZmluZVByb3BlcnR5KENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyLCBcImRpc3BsYXlOYW1lXCIsIGNoYXJ0TmFtZSk7XG4gIC8vIHRvZG8gam9pbiBzcGVjaWZpYyBjaGFydCBwcm9wVHlwZXNcbiAgX2RlZmluZVByb3BlcnR5KENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyLCBcImRlZmF1bHRQcm9wc1wiLCBfb2JqZWN0U3ByZWFkKHtcbiAgICBsYXlvdXQ6ICdob3Jpem9udGFsJyxcbiAgICBzdGFja09mZnNldDogJ25vbmUnLFxuICAgIGJhckNhdGVnb3J5R2FwOiAnMTAlJyxcbiAgICBiYXJHYXA6IDQsXG4gICAgbWFyZ2luOiB7XG4gICAgICB0b3A6IDUsXG4gICAgICByaWdodDogNSxcbiAgICAgIGJvdHRvbTogNSxcbiAgICAgIGxlZnQ6IDVcbiAgICB9LFxuICAgIHJldmVyc2VTdGFja09yZGVyOiBmYWxzZSxcbiAgICBzeW5jTWV0aG9kOiAnaW5kZXgnXG4gIH0sIGRlZmF1bHRQcm9wcykpO1xuICBfZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcmljYWxDaGFydFdyYXBwZXIsIFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXCIsIGZ1bmN0aW9uIChuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgIHZhciBkYXRhS2V5ID0gbmV4dFByb3BzLmRhdGFLZXksXG4gICAgICBkYXRhID0gbmV4dFByb3BzLmRhdGEsXG4gICAgICBjaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbixcbiAgICAgIHdpZHRoID0gbmV4dFByb3BzLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gbmV4dFByb3BzLmhlaWdodCxcbiAgICAgIGxheW91dCA9IG5leHRQcm9wcy5sYXlvdXQsXG4gICAgICBzdGFja09mZnNldCA9IG5leHRQcm9wcy5zdGFja09mZnNldCxcbiAgICAgIG1hcmdpbiA9IG5leHRQcm9wcy5tYXJnaW47XG4gICAgdmFyIGRhdGFTdGFydEluZGV4ID0gcHJldlN0YXRlLmRhdGFTdGFydEluZGV4LFxuICAgICAgZGF0YUVuZEluZGV4ID0gcHJldlN0YXRlLmRhdGFFbmRJbmRleDtcbiAgICBpZiAocHJldlN0YXRlLnVwZGF0ZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBkZWZhdWx0U3RhdGUgPSBjcmVhdGVEZWZhdWx0U3RhdGUobmV4dFByb3BzKTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFN0YXRlKSwge30sIHtcbiAgICAgICAgdXBkYXRlSWQ6IDBcbiAgICAgIH0sIHVwZGF0ZVN0YXRlT2ZBeGlzTWFwc09mZnNldEFuZFN0YWNrR3JvdXBzKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIHByb3BzOiBuZXh0UHJvcHNcbiAgICAgIH0sIGRlZmF1bHRTdGF0ZSksIHt9LCB7XG4gICAgICAgIHVwZGF0ZUlkOiAwXG4gICAgICB9KSwgcHJldlN0YXRlKSksIHt9LCB7XG4gICAgICAgIHByZXZEYXRhS2V5OiBkYXRhS2V5LFxuICAgICAgICBwcmV2RGF0YTogZGF0YSxcbiAgICAgICAgcHJldldpZHRoOiB3aWR0aCxcbiAgICAgICAgcHJldkhlaWdodDogaGVpZ2h0LFxuICAgICAgICBwcmV2TGF5b3V0OiBsYXlvdXQsXG4gICAgICAgIHByZXZTdGFja09mZnNldDogc3RhY2tPZmZzZXQsXG4gICAgICAgIHByZXZNYXJnaW46IG1hcmdpbixcbiAgICAgICAgcHJldkNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkYXRhS2V5ICE9PSBwcmV2U3RhdGUucHJldkRhdGFLZXkgfHwgZGF0YSAhPT0gcHJldlN0YXRlLnByZXZEYXRhIHx8IHdpZHRoICE9PSBwcmV2U3RhdGUucHJldldpZHRoIHx8IGhlaWdodCAhPT0gcHJldlN0YXRlLnByZXZIZWlnaHQgfHwgbGF5b3V0ICE9PSBwcmV2U3RhdGUucHJldkxheW91dCB8fCBzdGFja09mZnNldCAhPT0gcHJldlN0YXRlLnByZXZTdGFja09mZnNldCB8fCAhKDAsIF9TaGFsbG93RXF1YWwuc2hhbGxvd0VxdWFsKShtYXJnaW4sIHByZXZTdGF0ZS5wcmV2TWFyZ2luKSkge1xuICAgICAgdmFyIF9kZWZhdWx0U3RhdGUgPSBjcmVhdGVEZWZhdWx0U3RhdGUobmV4dFByb3BzKTtcblxuICAgICAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3JlY2hhcnRzL3JlY2hhcnRzL2lzc3Vlcy8yMTQzXG4gICAgICB2YXIga2VlcEZyb21QcmV2U3RhdGUgPSB7XG4gICAgICAgIC8vIChjaGFydFgsIGNoYXJ0WSkgYXJlICgwLDApIGluIGRlZmF1bHQgc3RhdGUsIGJ1dCB3ZSB3YW50IHRvIGtlZXAgdGhlIGxhc3QgbW91c2UgcG9zaXRpb24gdG8gYXZvaWRcbiAgICAgICAgLy8gYW55IGZsaWNrZXJpbmdcbiAgICAgICAgY2hhcnRYOiBwcmV2U3RhdGUuY2hhcnRYLFxuICAgICAgICBjaGFydFk6IHByZXZTdGF0ZS5jaGFydFksXG4gICAgICAgIC8vIFRoZSB0b29sdGlwIHNob3VsZCBzdGF5IGFjdGl2ZSB3aGVuIGl0IHdhcyBhY3RpdmUgaW4gdGhlIHByZXZpb3VzIHJlbmRlci4gSWYgdGhpcyBpcyBub3RcbiAgICAgICAgLy8gdGhlIGNhc2UsIHRoZSB0b29sdGlwIGRpc2FwcGVhcnMgYW5kIGltbWVkaWF0ZWx5IHJlLWFwcGVhcnMsIGNhdXNpbmcgYSBmbGlja2VyaW5nIGVmZmVjdFxuICAgICAgICBpc1Rvb2x0aXBBY3RpdmU6IHByZXZTdGF0ZS5pc1Rvb2x0aXBBY3RpdmVcbiAgICAgIH07XG4gICAgICB2YXIgdXBkYXRlc1RvU3RhdGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGdldFRvb2x0aXBEYXRhKHByZXZTdGF0ZSwgZGF0YSwgbGF5b3V0KSksIHt9LCB7XG4gICAgICAgIHVwZGF0ZUlkOiBwcmV2U3RhdGUudXBkYXRlSWQgKyAxXG4gICAgICB9KTtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfZGVmYXVsdFN0YXRlKSwga2VlcEZyb21QcmV2U3RhdGUpLCB1cGRhdGVzVG9TdGF0ZSk7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG5ld1N0YXRlKSwgdXBkYXRlU3RhdGVPZkF4aXNNYXBzT2Zmc2V0QW5kU3RhY2tHcm91cHMoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIHByb3BzOiBuZXh0UHJvcHNcbiAgICAgIH0sIG5ld1N0YXRlKSwgcHJldlN0YXRlKSksIHt9LCB7XG4gICAgICAgIHByZXZEYXRhS2V5OiBkYXRhS2V5LFxuICAgICAgICBwcmV2RGF0YTogZGF0YSxcbiAgICAgICAgcHJldldpZHRoOiB3aWR0aCxcbiAgICAgICAgcHJldkhlaWdodDogaGVpZ2h0LFxuICAgICAgICBwcmV2TGF5b3V0OiBsYXlvdXQsXG4gICAgICAgIHByZXZTdGFja09mZnNldDogc3RhY2tPZmZzZXQsXG4gICAgICAgIHByZXZNYXJnaW46IG1hcmdpbixcbiAgICAgICAgcHJldkNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghKDAsIF9SZWFjdFV0aWxzLmlzQ2hpbGRyZW5FcXVhbCkoY2hpbGRyZW4sIHByZXZTdGF0ZS5wcmV2Q2hpbGRyZW4pKSB7XG4gICAgICB2YXIgX2JydXNoJHByb3BzJHN0YXJ0SW5kLCBfYnJ1c2gkcHJvcHMsIF9icnVzaCRwcm9wcyRlbmRJbmRleCwgX2JydXNoJHByb3BzMjtcbiAgICAgIC8vIHNwZWNpZmljYWxseSBjaGVjayBmb3IgQnJ1c2ggLSBpZiBpdCBleGlzdHMgYW5kIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4ZXMgYXJlIGRpZmZlcmVudCwgcmUtcmVuZGVyIHdpdGggdGhlIG5ldyBvbmVzXG4gICAgICB2YXIgYnJ1c2ggPSAoMCwgX1JlYWN0VXRpbHMuZmluZENoaWxkQnlUeXBlKShjaGlsZHJlbiwgX0JydXNoLkJydXNoKTtcbiAgICAgIHZhciBzdGFydEluZGV4ID0gYnJ1c2ggPyAoX2JydXNoJHByb3BzJHN0YXJ0SW5kID0gKF9icnVzaCRwcm9wcyA9IGJydXNoLnByb3BzKSA9PT0gbnVsbCB8fCBfYnJ1c2gkcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9icnVzaCRwcm9wcy5zdGFydEluZGV4KSAhPT0gbnVsbCAmJiBfYnJ1c2gkcHJvcHMkc3RhcnRJbmQgIT09IHZvaWQgMCA/IF9icnVzaCRwcm9wcyRzdGFydEluZCA6IGRhdGFTdGFydEluZGV4IDogZGF0YVN0YXJ0SW5kZXg7XG4gICAgICB2YXIgZW5kSW5kZXggPSBicnVzaCA/IChfYnJ1c2gkcHJvcHMkZW5kSW5kZXggPSAoX2JydXNoJHByb3BzMiA9IGJydXNoLnByb3BzKSA9PT0gbnVsbCB8fCBfYnJ1c2gkcHJvcHMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYnJ1c2gkcHJvcHMyLmVuZEluZGV4KSAhPT0gbnVsbCAmJiBfYnJ1c2gkcHJvcHMkZW5kSW5kZXggIT09IHZvaWQgMCA/IF9icnVzaCRwcm9wcyRlbmRJbmRleCA6IGRhdGFFbmRJbmRleCA6IGRhdGFFbmRJbmRleDtcbiAgICAgIHZhciBoYXNEaWZmZXJlbnRTdGFydE9yRW5kSW5kZXggPSBzdGFydEluZGV4ICE9PSBkYXRhU3RhcnRJbmRleCB8fCBlbmRJbmRleCAhPT0gZGF0YUVuZEluZGV4O1xuXG4gICAgICAvLyB1cGRhdGUgY29uZmlndXJhdGlvbiBpbiBjaGlsZHJlblxuICAgICAgdmFyIGhhc0dsb2JhbERhdGEgPSAhKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGRhdGEpO1xuICAgICAgdmFyIG5ld1VwZGF0ZUlkID0gaGFzR2xvYmFsRGF0YSAmJiAhaGFzRGlmZmVyZW50U3RhcnRPckVuZEluZGV4ID8gcHJldlN0YXRlLnVwZGF0ZUlkIDogcHJldlN0YXRlLnVwZGF0ZUlkICsgMTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICB1cGRhdGVJZDogbmV3VXBkYXRlSWRcbiAgICAgIH0sIHVwZGF0ZVN0YXRlT2ZBeGlzTWFwc09mZnNldEFuZFN0YWNrR3JvdXBzKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIHByb3BzOiBuZXh0UHJvcHNcbiAgICAgIH0sIHByZXZTdGF0ZSksIHt9LCB7XG4gICAgICAgIHVwZGF0ZUlkOiBuZXdVcGRhdGVJZCxcbiAgICAgICAgZGF0YVN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG4gICAgICAgIGRhdGFFbmRJbmRleDogZW5kSW5kZXhcbiAgICAgIH0pLCBwcmV2U3RhdGUpKSwge30sIHtcbiAgICAgICAgcHJldkNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgZGF0YVN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG4gICAgICAgIGRhdGFFbmRJbmRleDogZW5kSW5kZXhcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSk7XG4gIF9kZWZpbmVQcm9wZXJ0eShDYXRlZ29yaWNhbENoYXJ0V3JhcHBlciwgXCJyZW5kZXJBY3RpdmVEb3RcIiwgZnVuY3Rpb24gKG9wdGlvbiwgcHJvcHMsIGtleSkge1xuICAgIHZhciBkb3Q7XG4gICAgaWYgKCAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5pc1ZhbGlkRWxlbWVudCkob3B0aW9uKSkge1xuICAgICAgZG90ID0gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShvcHRpb24sIHByb3BzKTtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9wdGlvbikpIHtcbiAgICAgIGRvdCA9IG9wdGlvbihwcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvdCA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0RvdC5Eb3QsIHByb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XG4gICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtYWN0aXZlLWRvdFwiLFxuICAgICAga2V5OiBrZXlcbiAgICB9LCBkb3QpO1xuICB9KTtcbiAgdmFyIENhdGVnb3JpY2FsQ2hhcnQgPSAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5mb3J3YXJkUmVmKShmdW5jdGlvbiBDYXRlZ29yaWNhbENoYXJ0KHByb3BzLCByZWYpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChDYXRlZ29yaWNhbENoYXJ0V3JhcHBlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICByZWY6IHJlZlxuICAgIH0pKTtcbiAgfSk7XG4gIENhdGVnb3JpY2FsQ2hhcnQuZGlzcGxheU5hbWUgPSBDYXRlZ29yaWNhbENoYXJ0V3JhcHBlci5kaXNwbGF5TmFtZTtcbiAgcmV0dXJuIENhdGVnb3JpY2FsQ2hhcnQ7XG59OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEF4aXNNYXBCeUF4ZXMiLCJnZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQiLCJjcmVhdGVEZWZhdWx0U3RhdGUiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfaXNOaWwiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2lzRnVuY3Rpb24iLCJfcmFuZ2UiLCJfZ2V0IiwiX3NvcnRCeSIsIl90aHJvdHRsZSIsIl9jbHN4IiwiX3RpbnlJbnZhcmlhbnQiLCJfU3VyZmFjZSIsIl9MYXllciIsIl9Ub29sdGlwIiwiX0xlZ2VuZCIsIl9Eb3QiLCJfUmVjdGFuZ2xlIiwiX1JlYWN0VXRpbHMiLCJfQnJ1c2giLCJfRE9NVXRpbHMiLCJfRGF0YVV0aWxzIiwiX0NoYXJ0VXRpbHMiLCJfRGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW4iLCJfUG9sYXJVdGlscyIsIl9TaGFsbG93RXF1YWwiLCJfRXZlbnRzIiwiX3R5cGVzIiwiX0FjY2Vzc2liaWxpdHlNYW5hZ2VyIiwiX2lzRG9tYWluU3BlY2lmaWVkQnlVc2VyIiwiX0FjdGl2ZVNoYXBlVXRpbHMiLCJfQ3Vyc29yIiwiX2NoYXJ0TGF5b3V0Q29udGV4dCIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJhcHBseSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIlR5cGVFcnJvciIsImwiLCJmIiwibmV4dCIsImRvbmUiLCJwdXNoIiwiQXJyYXkiLCJpc0FycmF5IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsImZyb20iLCJ0ZXN0IiwiaXRlciIsImxlbiIsImFycjIiLCJvd25LZXlzIiwia2V5cyIsImZpbHRlciIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIk9SSUVOVF9NQVAiLCJ4QXhpcyIsInlBeGlzIiwiRlVMTF9XSURUSF9BTkRfSEVJR0hUIiwid2lkdGgiLCJoZWlnaHQiLCJvcmlnaW5Db29yZGluYXRlIiwieCIsInkiLCJyZW5kZXJBc0lzIiwiZWxlbWVudCIsImNhbGN1bGF0ZVRvb2x0aXBQb3MiLCJyYW5nZU9iaiIsImxheW91dCIsImFuZ2xlIiwicmFkaXVzIiwiZ2V0QWN0aXZlQ29vcmRpbmF0ZSIsInRvb2x0aXBUaWNrcyIsImFjdGl2ZUluZGV4IiwiZW50cnkiLCJmaW5kIiwidGljayIsImluZGV4IiwiY29vcmRpbmF0ZSIsIl9hbmdsZSIsIl9yYWRpdXMiLCJwb2xhclRvQ2FydGVzaWFuIiwiY3giLCJjeSIsImdldERpc3BsYXllZERhdGEiLCJkYXRhIiwiX3JlZiIsImdyYXBoaWNhbEl0ZW1zIiwiZGF0YVN0YXJ0SW5kZXgiLCJkYXRhRW5kSW5kZXgiLCJpdGVtc0RhdGEiLCJyZWR1Y2UiLCJyZXN1bHQiLCJjaGlsZCIsIml0ZW1EYXRhIiwiY29uY2F0IiwiaXNOdW1iZXIiLCJnZXREZWZhdWx0RG9tYWluQnlBeGlzVHlwZSIsImF4aXNUeXBlIiwidW5kZWZpbmVkIiwiZ2V0VG9vbHRpcENvbnRlbnQiLCJzdGF0ZSIsImNoYXJ0RGF0YSIsImFjdGl2ZUxhYmVsIiwidG9vbHRpcEF4aXMiLCJkaXNwbGF5ZWREYXRhIiwiX2NoaWxkJHByb3BzJGRhdGEiLCJwYXlsb2FkIiwiZGF0YUtleSIsImFsbG93RHVwbGljYXRlZENhdGVnb3J5IiwiZW50cmllcyIsImZpbmRFbnRyeUluQXJyYXkiLCJnZXRUb29sdGlwSXRlbSIsImdldFRvb2x0aXBEYXRhIiwicmFuZ2VEYXRhIiwiY2hhcnRYIiwiY2hhcnRZIiwicG9zIiwidGlja3MiLCJvcmRlcmVkVG9vbHRpcFRpY2tzIiwiYXhpcyIsImNhbGN1bGF0ZUFjdGl2ZVRpY2tJbmRleCIsImFjdGl2ZVBheWxvYWQiLCJhY3RpdmVDb29yZGluYXRlIiwiYWN0aXZlVG9vbHRpcEluZGV4IiwiX3JlZjIiLCJheGVzIiwiYXhpc0lkS2V5Iiwic3RhY2tHcm91cHMiLCJjaGlsZHJlbiIsInN0YWNrT2Zmc2V0IiwiaXNDYXRlZ29yaWNhbCIsImlzQ2F0ZWdvcmljYWxBeGlzIiwiX2NoaWxkUHJvcHMkZG9tYWluMiIsImNoaWxkUHJvcHMiLCJ0eXBlIiwiZGVmYXVsdFByb3BzIiwiYWxsb3dEYXRhT3ZlcmZsb3ciLCJzY2FsZSIsImluY2x1ZGVIaWRkZW4iLCJheGlzSWQiLCJpdGVtIiwiX2RlZmF1bHRQcm9wcyIsIml0ZW1BeGlzSWQiLCJkb21haW4iLCJkdXBsaWNhdGVEb21haW4iLCJjYXRlZ29yaWNhbERvbWFpbiIsImlzRG9tYWluU3BlY2lmaWVkQnlVc2VyIiwicGFyc2VTcGVjaWZpZWREb21haW4iLCJnZXREb21haW5PZkRhdGFCeUtleSIsImRlZmF1bHREb21haW4iLCJfY2hpbGRQcm9wcyRkb21haW4iLCJjaGlsZERvbWFpbiIsImR1cGxpY2F0ZSIsImhhc0R1cGxpY2F0ZSIsInBhcnNlRG9tYWluT2ZDYXRlZ29yeUF4aXMiLCJmaW5hbERvbWFpbiIsImVycm9yQmFyc0RvbWFpbiIsInBhcnNlRXJyb3JCYXJzT2ZBeGlzIiwiX2RlZmF1bHRQcm9wczIiLCJfZGVmYXVsdFByb3BzMyIsIml0ZW1IaWRlIiwiaGlkZSIsImhhc1N0YWNrIiwiZ2V0RG9tYWluT2ZTdGFja0dyb3VwcyIsImdldERvbWFpbk9mSXRlbXNXaXRoU2FtZUF4aXMiLCJkZXRlY3RSZWZlcmVuY2VFbGVtZW50c0RvbWFpbiIsImF4aXNEb21haW4iLCJpc0RvbWFpblZhbGlkIiwiZXZlcnkiLCJvcmlnaW5hbERvbWFpbiIsImdldEF4aXNNYXBCeUl0ZW1zIiwiX3JlZjMiLCJBeGlzIiwiX2RlZmF1bHRQcm9wczQiLCJfZGVmYXVsdFByb3BzNSIsIm9yaWVudGF0aW9uIiwiZ2V0QXhpc01hcCIsIl9yZWY0IiwiX3JlZjQkYXhpc1R5cGUiLCJBeGlzQ29tcCIsImZpbmRBbGxCeVR5cGUiLCJheGlzTWFwIiwidG9vbHRpcFRpY2tzR2VuZXJhdG9yIiwiZ2V0QW55RWxlbWVudE9mT2JqZWN0IiwiZ2V0VGlja3NPZkF4aXMiLCJ0b29sdGlwQXhpc0JhbmRTaXplIiwiZ2V0QmFuZFNpemVPZkF4aXMiLCJkZWZhdWx0U2hvd1Rvb2x0aXAiLCJicnVzaEl0ZW0iLCJmaW5kQ2hpbGRCeVR5cGUiLCJCcnVzaCIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsImlzVG9vbHRpcEFjdGl2ZSIsImhhc0dyYXBoaWNhbEJhckl0ZW0iLCJzb21lIiwiZ2V0RGlzcGxheU5hbWUiLCJnZXRBeGlzTmFtZUJ5TGF5b3V0IiwibnVtZXJpY0F4aXNOYW1lIiwiY2F0ZUF4aXNOYW1lIiwiY2FsY3VsYXRlT2Zmc2V0IiwiX3JlZjUiLCJwcmV2TGVnZW5kQkJveCIsIl9yZWY1JHhBeGlzTWFwIiwieEF4aXNNYXAiLCJfcmVmNSR5QXhpc01hcCIsInlBeGlzTWFwIiwibWFyZ2luIiwibGVnZW5kSXRlbSIsIkxlZ2VuZCIsIm9mZnNldEgiLCJpZCIsIm1pcnJvciIsImxlZnQiLCJyaWdodCIsIm9mZnNldFYiLCJ0b3AiLCJib3R0b20iLCJvZmZzZXQiLCJicnVzaEJvdHRvbSIsImFwcGVuZE9mZnNldE9mTGVnZW5kIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJNYXRoIiwibWF4IiwiZ2V0Q2FydGVzaWFuQXhpc1NpemUiLCJheGlzT2JqIiwiYXhpc05hbWUiLCJfcmVmNiIsImNoYXJ0TmFtZSIsIkdyYXBoaWNhbENoaWxkIiwiX3JlZjYkZGVmYXVsdFRvb2x0aXBFIiwiZGVmYXVsdFRvb2x0aXBFdmVudFR5cGUiLCJfcmVmNiR2YWxpZGF0ZVRvb2x0aXAiLCJ2YWxpZGF0ZVRvb2x0aXBFdmVudFR5cGVzIiwiYXhpc0NvbXBvbmVudHMiLCJsZWdlbmRDb250ZW50IiwiZm9ybWF0QXhpc01hcCIsImdldEZvcm1hdEl0ZW1zIiwiY3VycmVudFN0YXRlIiwidXBkYXRlSWQiLCJiYXJTaXplIiwiYmFyR2FwIiwiYmFyQ2F0ZWdvcnlHYXAiLCJnbG9iYWxNYXhCYXJTaXplIiwibWF4QmFyU2l6ZSIsIl9nZXRBeGlzTmFtZUJ5TGF5b3V0IiwiaGFzQmFyIiwiZm9ybWF0dGVkSXRlbXMiLCJpdGVtUHJvcHMiLCJjaGlsZE1heEJhclNpemUiLCJudW1lcmljQXhpc0lkIiwiY2F0ZUF4aXNJZCIsImF4aXNPYmpJbml0aWFsVmFsdWUiLCJfaXRlbSR0eXBlJGRpc3BsYXlOYW0iLCJfaXRlbSR0eXBlIiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIiwiY2F0ZUF4aXMiLCJjYXRlVGlja3MiLCJzdGFja2VkRGF0YSIsImdldFN0YWNrZWREYXRhT2ZJdGVtIiwiaXRlbUlzQmFyIiwiYmFuZFNpemUiLCJiYXJQb3NpdGlvbiIsInNpemVMaXN0IiwiZ2V0QmFyU2l6ZUxpc3QiLCJ0b3RhbFNpemUiLCJfcmVmNyIsIl9nZXRCYW5kU2l6ZU9mQXhpcyIsImJhckJhbmRTaXplIiwiZ2V0QmFyUG9zaXRpb24iLCJtYXAiLCJwb3NpdGlvbiIsImNvbXBvc2VkRm4iLCJnZXRDb21wb3NlZERhdGEiLCJjaGlsZEluZGV4IiwicGFyc2VDaGlsZEluZGV4IiwidXBkYXRlU3RhdGVPZkF4aXNNYXBzT2Zmc2V0QW5kU3RhY2tHcm91cHMiLCJfcmVmOCIsInByZXZTdGF0ZSIsInZhbGlkYXRlV2lkdGhIZWlnaHQiLCJyZXZlcnNlU3RhY2tPcmRlciIsIl9nZXRBeGlzTmFtZUJ5TGF5b3V0MiIsImdldFN0YWNrR3JvdXBzQnlBeGlzSWQiLCJsZWdlbmRCQm94IiwicmVwbGFjZSIsImNhdGVBeGlzTWFwIiwidGlja3NPYmoiLCJmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcyIsIkNhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyIiwiX0NvbXBvbmVudCIsIl9wcm9wcyIsIl9wcm9wcyRpZCIsIl9wcm9wcyR0aHJvdHRsZURlbGF5IiwiX3RoaXMiLCJBY2Nlc3NpYmlsaXR5TWFuYWdlciIsImJveCIsIl90aGlzJHN0YXRlIiwic2V0U3RhdGUiLCJjSWQiLCJlbWl0dGVyIiwic3luY0lkIiwiZXZlbnRFbWl0dGVyU3ltYm9sIiwic3luY01ldGhvZCIsImFwcGx5U3luY0V2ZW50IiwiX3JlZjkiLCJ0cmlnZ2VyU3luY0V2ZW50IiwibW91c2UiLCJnZXRNb3VzZUluZm8iLCJfbmV4dFN0YXRlIiwib25Nb3VzZUVudGVyIiwibmV4dFN0YXRlIiwib25Nb3VzZU1vdmUiLCJlbCIsImFjdGl2ZUl0ZW0iLCJ0b29sdGlwUGF5bG9hZCIsInRvb2x0aXBQb3NpdGlvbiIsInBlcnNpc3QiLCJ0aHJvdHRsZVRyaWdnZXJlZEFmdGVyTW91c2VNb3ZlIiwiY2FuY2VsIiwib25Nb3VzZUxlYXZlIiwiZXZlbnROYW1lIiwiZ2V0UmVhY3RFdmVudEJ5VHlwZSIsImV2ZW50IiwiX21vdXNlIiwiY2hhbmdlZFRvdWNoZXMiLCJfbmV4dFN0YXRlMiIsIm9uQ2xpY2siLCJvbk1vdXNlRG93biIsIl9uZXh0U3RhdGUzIiwib25Nb3VzZVVwIiwiX25leHRTdGF0ZTQiLCJoYW5kbGVNb3VzZURvd24iLCJoYW5kbGVNb3VzZVVwIiwib25Eb3VibGVDbGljayIsIl9uZXh0U3RhdGU1Iiwib25Db250ZXh0TWVudSIsIl9uZXh0U3RhdGU2IiwiZXZlbnRDZW50ZXIiLCJlbWl0IiwiU1lOQ19FVkVOVCIsIl90aGlzJHByb3BzIiwiX3RoaXMkc3RhdGUyIiwidmlld0JveCIsInZhbGlkYXRlQ2hhcnRYIiwibWluIiwidmFsaWRhdGVDaGFydFkiLCJfZWxlbWVudCRwcm9wcyRhY3RpdmUiLCJfdGhpcyRzdGF0ZTMiLCJ0b29sdGlwRXZlbnRUeXBlIiwiZ2V0VG9vbHRpcEV2ZW50VHlwZSIsImlzQWN0aXZlIiwiYWN0aXZlIiwiY3JlYXRlRWxlbWVudCIsIkN1cnNvciIsImVsZW1lbnREZWZhdWx0UHJvcHMiLCJlbGVtZW50UHJvcHMiLCJheGlzT3B0aW9uIiwiY2xvbmVFbGVtZW50IiwiY2xhc3NOYW1lIiwiX2VsZW1lbnQkcHJvcHMiLCJyYWRpYWxMaW5lcyIsInBvbGFyQW5nbGVzIiwicG9sYXJSYWRpdXMiLCJfdGhpcyRzdGF0ZTQiLCJyYWRpdXNBeGlzTWFwIiwiYW5nbGVBeGlzTWFwIiwicmFkaXVzQXhpcyIsImFuZ2xlQXhpcyIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJfdGhpcyRwcm9wczIiLCJsZWdlbmRXaWR0aCIsImdldExlZ2VuZFByb3BzIiwib3RoZXJQcm9wcyIsImNoYXJ0V2lkdGgiLCJjaGFydEhlaWdodCIsIm9uQkJveFVwZGF0ZSIsImhhbmRsZUxlZ2VuZEJCb3hVcGRhdGUiLCJfdG9vbHRpcEl0ZW0kcHJvcHMkYWMiLCJfdGhpcyRwcm9wczMiLCJhY2Nlc3NpYmlsaXR5TGF5ZXIiLCJ0b29sdGlwSXRlbSIsIlRvb2x0aXAiLCJfdGhpcyRzdGF0ZTUiLCJsYWJlbCIsIl90aGlzJHByb3BzNCIsIl90aGlzJHN0YXRlNiIsIm9uQ2hhbmdlIiwiY29tYmluZUV2ZW50SGFuZGxlcnMiLCJoYW5kbGVCcnVzaENoYW5nZSIsIl90aGlzMiIsImNsaXBQYXRoSWQiLCJfdGhpcyRzdGF0ZTciLCJfZWxlbWVudCRwcm9wczIiLCJfZWxlbWVudCRwcm9wczIkeEF4aXMiLCJ4QXhpc0lkIiwiX2VsZW1lbnQkcHJvcHMyJHlBeGlzIiwieUF4aXNJZCIsIl9yZWYxMCIsImFjdGl2ZVBvaW50IiwiYmFzZVBvaW50IiwiaXNSYW5nZSIsIml0ZW1JdGVtUHJvcHMiLCJhY3RpdmVEb3QiLCJkb3RQcm9wcyIsImZpbGwiLCJnZXRNYWluQ29sb3JPZkdyYXBoaWNJdGVtIiwic3Ryb2tlV2lkdGgiLCJzdHJva2UiLCJmaWx0ZXJQcm9wcyIsImFkYXB0RXZlbnRIYW5kbGVycyIsInJlbmRlckFjdGl2ZURvdCIsImZpbHRlckZvcm1hdEl0ZW0iLCJfdGhpcyRzdGF0ZTgiLCJfaXRlbSRwcm9wcyIsInBvaW50cyIsImJhc2VMaW5lIiwiYWN0aXZlQmFyIiwiYWN0aXZlU2hhcGUiLCJoYXNBY3RpdmUiLCJpdGVtRXZlbnRzIiwidHJpZ2dlciIsImhhbmRsZUl0ZW1Nb3VzZUVudGVyIiwiaGFuZGxlSXRlbU1vdXNlTGVhdmUiLCJncmFwaGljYWxJdGVtIiwiZmluZFdpdGhQYXlsb2FkIiwic3BlY2lmaWVkS2V5IiwicmVuZGVyQWN0aXZlUG9pbnRzIiwiX3RoaXMkZ2V0SXRlbUJ5WFkiLCJfcmVmMTEiLCJnZXRJdGVtQnlYWSIsIl9yZWYxMSRncmFwaGljYWxJdGVtIiwiX3JlZjExJGdyYXBoaWNhbEl0ZW0kIiwieHlJdGVtIiwiQ2FydGVzaWFuR3JpZCIsImhhbmRsZXIiLCJvbmNlIiwiUmVmZXJlbmNlQXJlYSIsInJlbmRlclJlZmVyZW5jZUVsZW1lbnQiLCJSZWZlcmVuY2VMaW5lIiwiUmVmZXJlbmNlRG90IiwiWEF4aXMiLCJZQXhpcyIsInJlbmRlckJydXNoIiwiQmFyIiwicmVuZGVyR3JhcGhpY0NoaWxkIiwiTGluZSIsIkFyZWEiLCJSYWRhciIsIlJhZGlhbEJhciIsIlNjYXR0ZXIiLCJQaWUiLCJGdW5uZWwiLCJyZW5kZXJDdXJzb3IiLCJQb2xhckdyaWQiLCJyZW5kZXJQb2xhckdyaWQiLCJQb2xhckFuZ2xlQXhpcyIsInJlbmRlclBvbGFyQXhpcyIsIlBvbGFyUmFkaXVzQXhpcyIsIkN1c3RvbWl6ZWQiLCJyZW5kZXJDdXN0b21pemVkIiwidW5pcXVlSWQiLCJ0cmlnZ2VyZWRBZnRlck1vdXNlTW92ZSIsInRocm90dGxlRGVsYXkiLCJjb21wb25lbnREaWRNb3VudCIsIl90aGlzJHByb3BzJG1hcmdpbiRsZSIsIl90aGlzJHByb3BzJG1hcmdpbiR0byIsImFkZExpc3RlbmVyIiwiYWNjZXNzaWJpbGl0eU1hbmFnZXIiLCJzZXREZXRhaWxzIiwiY29udGFpbmVyIiwiY29vcmRpbmF0ZUxpc3QiLCJtb3VzZUhhbmRsZXJDYWxsYmFjayIsImRpc3BsYXlEZWZhdWx0VG9vbHRpcCIsIl90aGlzJHByb3BzNSIsInRvb2x0aXBFbGVtIiwiZGVmYXVsdEluZGV4IiwiaW5kZXBlbmRlbnRBeGlzQ29vcmQiLCJkZXBlbmRlbnRBeGlzQ29vcmQiLCJpc0hvcml6b250YWwiLCJzY2F0dGVyUGxvdEVsZW1lbnQiLCJfcmVmMTIiLCJzZXRJbmRleCIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwicHJldlByb3BzIiwiX3RoaXMkcHJvcHMkbWFyZ2luJGxlMiIsIl90aGlzJHByb3BzJG1hcmdpbiR0bzIiLCJjb21wb25lbnREaWRVcGRhdGUiLCJpc0NoaWxkcmVuRXF1YWwiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbW92ZUxpc3RlbmVyIiwic2hhcmVkIiwiZXZlbnRUeXBlIiwiYm91bmRpbmdSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY29udGFpbmVyT2Zmc2V0IiwiZ2V0T2Zmc2V0Iiwicm91bmQiLCJwYWdlWCIsInBhZ2VZIiwiaW5SYW5nZSIsIl90aGlzJHN0YXRlOSIsInhTY2FsZSIsInlTY2FsZSIsInhWYWx1ZSIsImludmVydCIsInlWYWx1ZSIsInRvb2xUaXBEYXRhIiwic2NhbGVkWCIsInNjYWxlZFkiLCJpc0luUmFuZ2UiLCJfdGhpcyRzdGF0ZTEwIiwiaW5SYW5nZU9mU2VjdG9yIiwicGFyc2VFdmVudHNPZldyYXBwZXIiLCJ0b29sdGlwRXZlbnRzIiwiaGFuZGxlQ2xpY2siLCJoYW5kbGVNb3VzZUVudGVyIiwiaGFuZGxlRG91YmxlQ2xpY2siLCJoYW5kbGVNb3VzZU1vdmUiLCJoYW5kbGVNb3VzZUxlYXZlIiwib25Ub3VjaE1vdmUiLCJoYW5kbGVUb3VjaE1vdmUiLCJvblRvdWNoU3RhcnQiLCJoYW5kbGVUb3VjaFN0YXJ0Iiwib25Ub3VjaEVuZCIsImhhbmRsZVRvdWNoRW5kIiwiaGFuZGxlQ29udGV4dE1lbnUiLCJvdXRlckV2ZW50cyIsImhhbmRsZU91dGVyRXZlbnQiLCJvbiIsImhhbmRsZVJlY2VpdmVTeW5jRXZlbnQiLCJyZW5kZXJDbGlwUGF0aCIsIl90aGlzJHN0YXRlJG9mZnNldCIsImdldFhTY2FsZXMiLCJyZXMiLCJfcmVmMTMiLCJfcmVmMTQiLCJheGlzUHJvcHMiLCJnZXRZU2NhbGVzIiwiX3JlZjE1IiwiX3JlZjE2IiwiZ2V0WFNjYWxlQnlBeGlzSWQiLCJfdGhpcyRzdGF0ZSR4QXhpc01hcCIsImdldFlTY2FsZUJ5QXhpc0lkIiwiX3RoaXMkc3RhdGUkeUF4aXNNYXAiLCJjaGFydFhZIiwiX3RoaXMkc3RhdGUxMSIsIml0ZW1EaXNwbGF5TmFtZSIsImFjdGl2ZUJhckl0ZW0iLCJpc0luUmVjdGFuZ2xlIiwiX2FjdGl2ZUJhckl0ZW0iLCJpc0Z1bm5lbCIsImlzUGllIiwiaXNTY2F0dGVyIiwiZ2V0QWN0aXZlU2hhcGVJbmRleEZvclRvb2x0aXAiLCJhY3RpdmVUb29sdGlwSXRlbSIsInJlbmRlciIsIl90aGlzMyIsIl90aGlzJHByb3BzNiIsInN0eWxlIiwiY29tcGFjdCIsInRpdGxlIiwiZGVzYyIsIm90aGVycyIsImF0dHJzIiwiQ2hhcnRMYXlvdXRDb250ZXh0UHJvdmlkZXIiLCJTdXJmYWNlIiwicmVuZGVyQnlPcmRlciIsInJlbmRlck1hcCIsIl90aGlzJHByb3BzJHRhYkluZGV4IiwiX3RoaXMkcHJvcHMkcm9sZSIsInRhYkluZGV4Iiwicm9sZSIsIm9uS2V5RG93biIsImtleWJvYXJkRXZlbnQiLCJvbkZvY3VzIiwiZm9jdXMiLCJldmVudHMiLCJjdXJzb3IiLCJyZWYiLCJub2RlIiwicmVuZGVyTGVnZW5kIiwicmVuZGVyVG9vbHRpcCIsIkNvbXBvbmVudCIsIm5leHRQcm9wcyIsImRlZmF1bHRTdGF0ZSIsInByZXZEYXRhS2V5IiwicHJldkRhdGEiLCJwcmV2V2lkdGgiLCJwcmV2SGVpZ2h0IiwicHJldkxheW91dCIsInByZXZTdGFja09mZnNldCIsInByZXZNYXJnaW4iLCJwcmV2Q2hpbGRyZW4iLCJzaGFsbG93RXF1YWwiLCJfZGVmYXVsdFN0YXRlIiwia2VlcEZyb21QcmV2U3RhdGUiLCJ1cGRhdGVzVG9TdGF0ZSIsIm5ld1N0YXRlIiwiX2JydXNoJHByb3BzJHN0YXJ0SW5kIiwiX2JydXNoJHByb3BzIiwiX2JydXNoJHByb3BzJGVuZEluZGV4IiwiX2JydXNoJHByb3BzMiIsImJydXNoIiwiaGFzRGlmZmVyZW50U3RhcnRPckVuZEluZGV4IiwiaGFzR2xvYmFsRGF0YSIsIm5ld1VwZGF0ZUlkIiwib3B0aW9uIiwiZG90IiwiaXNWYWxpZEVsZW1lbnQiLCJEb3QiLCJMYXllciIsIkNhdGVnb3JpY2FsQ2hhcnQiLCJmb3J3YXJkUmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/chart/generateCategoricalChart.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/component/Cell.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/component/Cell.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Cell = void 0;\n/**\n * @fileOverview Cross\n */ var Cell = exports.Cell = function Cell(_props) {\n    return null;\n};\nCell.displayName = \"Cell\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9DZWxsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxZQUFZLEdBQUcsS0FBSztBQUNwQjs7Q0FFQyxHQUVELElBQUlFLE9BQU9GLFlBQVksR0FBRyxTQUFTRSxLQUFLQyxNQUFNO0lBQzVDLE9BQU87QUFDVDtBQUNBRCxLQUFLRSxXQUFXLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9DZWxsLmpzP2VlN2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNlbGwgPSB2b2lkIDA7XG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgQ3Jvc3NcbiAqL1xuXG52YXIgQ2VsbCA9IGV4cG9ydHMuQ2VsbCA9IGZ1bmN0aW9uIENlbGwoX3Byb3BzKSB7XG4gIHJldHVybiBudWxsO1xufTtcbkNlbGwuZGlzcGxheU5hbWUgPSAnQ2VsbCc7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2VsbCIsIl9wcm9wcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/component/Cell.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/component/Cursor.js":
/*!*******************************************************!*\
  !*** ./node_modules/recharts/lib/component/Cursor.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Cursor = Cursor;\nvar _react = __webpack_require__(/*! react */ \"react\");\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _Curve = __webpack_require__(/*! ../shape/Curve */ \"./node_modules/recharts/lib/shape/Curve.js\");\nvar _Cross = __webpack_require__(/*! ../shape/Cross */ \"./node_modules/recharts/lib/shape/Cross.js\");\nvar _getCursorRectangle = __webpack_require__(/*! ../util/cursor/getCursorRectangle */ \"./node_modules/recharts/lib/util/cursor/getCursorRectangle.js\");\nvar _Rectangle = __webpack_require__(/*! ../shape/Rectangle */ \"./node_modules/recharts/lib/shape/Rectangle.js\");\nvar _getRadialCursorPoints = __webpack_require__(/*! ../util/cursor/getRadialCursorPoints */ \"./node_modules/recharts/lib/util/cursor/getRadialCursorPoints.js\");\nvar _Sector = __webpack_require__(/*! ../shape/Sector */ \"./node_modules/recharts/lib/shape/Sector.js\");\nvar _getCursorPoints = __webpack_require__(/*! ../util/cursor/getCursorPoints */ \"./node_modules/recharts/lib/util/cursor/getCursorPoints.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n/*\n * Cursor is the background, or a highlight,\n * that shows when user mouses over or activates\n * an area.\n *\n * It usually shows together with a tooltip\n * to emphasise which part of the chart does the tooltip refer to.\n */ function Cursor(props) {\n    var _element$props$cursor, _defaultProps;\n    var element = props.element, tooltipEventType = props.tooltipEventType, isActive = props.isActive, activeCoordinate = props.activeCoordinate, activePayload = props.activePayload, offset = props.offset, activeTooltipIndex = props.activeTooltipIndex, tooltipAxisBandSize = props.tooltipAxisBandSize, layout = props.layout, chartName = props.chartName;\n    var elementPropsCursor = (_element$props$cursor = element.props.cursor) !== null && _element$props$cursor !== void 0 ? _element$props$cursor : (_defaultProps = element.type.defaultProps) === null || _defaultProps === void 0 ? void 0 : _defaultProps.cursor;\n    if (!element || !elementPropsCursor || !isActive || !activeCoordinate || chartName !== \"ScatterChart\" && tooltipEventType !== \"axis\") {\n        return null;\n    }\n    var restProps;\n    var cursorComp = _Curve.Curve;\n    if (chartName === \"ScatterChart\") {\n        restProps = activeCoordinate;\n        cursorComp = _Cross.Cross;\n    } else if (chartName === \"BarChart\") {\n        restProps = (0, _getCursorRectangle.getCursorRectangle)(layout, activeCoordinate, offset, tooltipAxisBandSize);\n        cursorComp = _Rectangle.Rectangle;\n    } else if (layout === \"radial\") {\n        var _getRadialCursorPoint = (0, _getRadialCursorPoints.getRadialCursorPoints)(activeCoordinate), cx = _getRadialCursorPoint.cx, cy = _getRadialCursorPoint.cy, radius = _getRadialCursorPoint.radius, startAngle = _getRadialCursorPoint.startAngle, endAngle = _getRadialCursorPoint.endAngle;\n        restProps = {\n            cx: cx,\n            cy: cy,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            innerRadius: radius,\n            outerRadius: radius\n        };\n        cursorComp = _Sector.Sector;\n    } else {\n        restProps = {\n            points: (0, _getCursorPoints.getCursorPoints)(layout, activeCoordinate, offset)\n        };\n        cursorComp = _Curve.Curve;\n    }\n    var cursorProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread({\n        stroke: \"#ccc\",\n        pointerEvents: \"none\"\n    }, offset), restProps), (0, _ReactUtils.filterProps)(elementPropsCursor, false)), {}, {\n        payload: activePayload,\n        payloadIndex: activeTooltipIndex,\n        className: (0, _clsx[\"default\"])(\"recharts-tooltip-cursor\", elementPropsCursor.className)\n    });\n    return /*#__PURE__*/ (0, _react.isValidElement)(elementPropsCursor) ? /*#__PURE__*/ (0, _react.cloneElement)(elementPropsCursor, cursorProps) : /*#__PURE__*/ (0, _react.createElement)(cursorComp, cursorProps);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9DdXJzb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGNBQWMsR0FBR0U7QUFDakIsSUFBSUMsU0FBU0MsbUJBQU9BLENBQUMsb0JBQU87QUFDNUIsSUFBSUMsUUFBUUMsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQkFBTTtBQUNqRCxJQUFJRyxTQUFTSCxtQkFBT0EsQ0FBQyxrRUFBZ0I7QUFDckMsSUFBSUksU0FBU0osbUJBQU9BLENBQUMsa0VBQWdCO0FBQ3JDLElBQUlLLHNCQUFzQkwsbUJBQU9BLENBQUMsd0dBQW1DO0FBQ3JFLElBQUlNLGFBQWFOLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM3QyxJQUFJTyx5QkFBeUJQLG1CQUFPQSxDQUFDLDhHQUFzQztBQUMzRSxJQUFJUSxVQUFVUixtQkFBT0EsQ0FBQyxvRUFBaUI7QUFDdkMsSUFBSVMsbUJBQW1CVCxtQkFBT0EsQ0FBQyxrR0FBZ0M7QUFDL0QsSUFBSVUsY0FBY1YsbUJBQU9BLENBQUMsMEVBQW9CO0FBQzlDLFNBQVNFLHVCQUF1QlMsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0ssUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFB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Y0FBY0EsY0FBYztRQUN4RXNELFFBQVE7UUFDUkMsZUFBZTtJQUNqQixHQUFHN0IsU0FBU1MsWUFBWSxDQUFDLEdBQUd2RCxZQUFZNEUsV0FBVyxFQUFFekIsb0JBQW9CLFNBQVMsQ0FBQyxHQUFHO1FBQ3BGMEIsU0FBU2hDO1FBQ1RpQyxjQUFjL0I7UUFDZGdDLFdBQVcsQ0FBQyxHQUFHeEYsS0FBSyxDQUFDLFVBQVUsRUFBRSwyQkFBMkI0RCxtQkFBbUI0QixTQUFTO0lBQzFGO0lBQ0EsT0FBb0IsV0FBRixHQUFHLElBQUcxRixPQUFPMkYsY0FBYyxFQUFFN0Isc0JBQW1DLFdBQUYsR0FBRyxJQUFHOUQsT0FBTzRGLFlBQVksRUFBRTlCLG9CQUFvQnNCLGVBQTRCLFdBQUYsR0FBRyxJQUFHcEYsT0FBTzZGLGFBQWEsRUFBRTFCLFlBQVlpQjtBQUNuTSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29tcG9uZW50L0N1cnNvci5qcz85ZTNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5DdXJzb3IgPSBDdXJzb3I7XG52YXIgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX0N1cnZlID0gcmVxdWlyZShcIi4uL3NoYXBlL0N1cnZlXCIpO1xudmFyIF9Dcm9zcyA9IHJlcXVpcmUoXCIuLi9zaGFwZS9Dcm9zc1wiKTtcbnZhciBfZ2V0Q3Vyc29yUmVjdGFuZ2xlID0gcmVxdWlyZShcIi4uL3V0aWwvY3Vyc29yL2dldEN1cnNvclJlY3RhbmdsZVwiKTtcbnZhciBfUmVjdGFuZ2xlID0gcmVxdWlyZShcIi4uL3NoYXBlL1JlY3RhbmdsZVwiKTtcbnZhciBfZ2V0UmFkaWFsQ3Vyc29yUG9pbnRzID0gcmVxdWlyZShcIi4uL3V0aWwvY3Vyc29yL2dldFJhZGlhbEN1cnNvclBvaW50c1wiKTtcbnZhciBfU2VjdG9yID0gcmVxdWlyZShcIi4uL3NoYXBlL1NlY3RvclwiKTtcbnZhciBfZ2V0Q3Vyc29yUG9pbnRzID0gcmVxdWlyZShcIi4uL3V0aWwvY3Vyc29yL2dldEN1cnNvclBvaW50c1wiKTtcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG4vKlxuICogQ3Vyc29yIGlzIHRoZSBiYWNrZ3JvdW5kLCBvciBhIGhpZ2hsaWdodCxcbiAqIHRoYXQgc2hvd3Mgd2hlbiB1c2VyIG1vdXNlcyBvdmVyIG9yIGFjdGl2YXRlc1xuICogYW4gYXJlYS5cbiAqXG4gKiBJdCB1c3VhbGx5IHNob3dzIHRvZ2V0aGVyIHdpdGggYSB0b29sdGlwXG4gKiB0byBlbXBoYXNpc2Ugd2hpY2ggcGFydCBvZiB0aGUgY2hhcnQgZG9lcyB0aGUgdG9vbHRpcCByZWZlciB0by5cbiAqL1xuZnVuY3Rpb24gQ3Vyc29yKHByb3BzKSB7XG4gIHZhciBfZWxlbWVudCRwcm9wcyRjdXJzb3IsIF9kZWZhdWx0UHJvcHM7XG4gIHZhciBlbGVtZW50ID0gcHJvcHMuZWxlbWVudCxcbiAgICB0b29sdGlwRXZlbnRUeXBlID0gcHJvcHMudG9vbHRpcEV2ZW50VHlwZSxcbiAgICBpc0FjdGl2ZSA9IHByb3BzLmlzQWN0aXZlLFxuICAgIGFjdGl2ZUNvb3JkaW5hdGUgPSBwcm9wcy5hY3RpdmVDb29yZGluYXRlLFxuICAgIGFjdGl2ZVBheWxvYWQgPSBwcm9wcy5hY3RpdmVQYXlsb2FkLFxuICAgIG9mZnNldCA9IHByb3BzLm9mZnNldCxcbiAgICBhY3RpdmVUb29sdGlwSW5kZXggPSBwcm9wcy5hY3RpdmVUb29sdGlwSW5kZXgsXG4gICAgdG9vbHRpcEF4aXNCYW5kU2l6ZSA9IHByb3BzLnRvb2x0aXBBeGlzQmFuZFNpemUsXG4gICAgbGF5b3V0ID0gcHJvcHMubGF5b3V0LFxuICAgIGNoYXJ0TmFtZSA9IHByb3BzLmNoYXJ0TmFtZTtcbiAgdmFyIGVsZW1lbnRQcm9wc0N1cnNvciA9IChfZWxlbWVudCRwcm9wcyRjdXJzb3IgPSBlbGVtZW50LnByb3BzLmN1cnNvcikgIT09IG51bGwgJiYgX2VsZW1lbnQkcHJvcHMkY3Vyc29yICE9PSB2b2lkIDAgPyBfZWxlbWVudCRwcm9wcyRjdXJzb3IgOiAoX2RlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpID09PSBudWxsIHx8IF9kZWZhdWx0UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kZWZhdWx0UHJvcHMuY3Vyc29yO1xuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnRQcm9wc0N1cnNvciB8fCAhaXNBY3RpdmUgfHwgIWFjdGl2ZUNvb3JkaW5hdGUgfHwgY2hhcnROYW1lICE9PSAnU2NhdHRlckNoYXJ0JyAmJiB0b29sdGlwRXZlbnRUeXBlICE9PSAnYXhpcycpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcmVzdFByb3BzO1xuICB2YXIgY3Vyc29yQ29tcCA9IF9DdXJ2ZS5DdXJ2ZTtcbiAgaWYgKGNoYXJ0TmFtZSA9PT0gJ1NjYXR0ZXJDaGFydCcpIHtcbiAgICByZXN0UHJvcHMgPSBhY3RpdmVDb29yZGluYXRlO1xuICAgIGN1cnNvckNvbXAgPSBfQ3Jvc3MuQ3Jvc3M7XG4gIH0gZWxzZSBpZiAoY2hhcnROYW1lID09PSAnQmFyQ2hhcnQnKSB7XG4gICAgcmVzdFByb3BzID0gKDAsIF9nZXRDdXJzb3JSZWN0YW5nbGUuZ2V0Q3Vyc29yUmVjdGFuZ2xlKShsYXlvdXQsIGFjdGl2ZUNvb3JkaW5hdGUsIG9mZnNldCwgdG9vbHRpcEF4aXNCYW5kU2l6ZSk7XG4gICAgY3Vyc29yQ29tcCA9IF9SZWN0YW5nbGUuUmVjdGFuZ2xlO1xuICB9IGVsc2UgaWYgKGxheW91dCA9PT0gJ3JhZGlhbCcpIHtcbiAgICB2YXIgX2dldFJhZGlhbEN1cnNvclBvaW50ID0gKDAsIF9nZXRSYWRpYWxDdXJzb3JQb2ludHMuZ2V0UmFkaWFsQ3Vyc29yUG9pbnRzKShhY3RpdmVDb29yZGluYXRlKSxcbiAgICAgIGN4ID0gX2dldFJhZGlhbEN1cnNvclBvaW50LmN4LFxuICAgICAgY3kgPSBfZ2V0UmFkaWFsQ3Vyc29yUG9pbnQuY3ksXG4gICAgICByYWRpdXMgPSBfZ2V0UmFkaWFsQ3Vyc29yUG9pbnQucmFkaXVzLFxuICAgICAgc3RhcnRBbmdsZSA9IF9nZXRSYWRpYWxDdXJzb3JQb2ludC5zdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUgPSBfZ2V0UmFkaWFsQ3Vyc29yUG9pbnQuZW5kQW5nbGU7XG4gICAgcmVzdFByb3BzID0ge1xuICAgICAgY3g6IGN4LFxuICAgICAgY3k6IGN5LFxuICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcbiAgICAgIGlubmVyUmFkaXVzOiByYWRpdXMsXG4gICAgICBvdXRlclJhZGl1czogcmFkaXVzXG4gICAgfTtcbiAgICBjdXJzb3JDb21wID0gX1NlY3Rvci5TZWN0b3I7XG4gIH0gZWxzZSB7XG4gICAgcmVzdFByb3BzID0ge1xuICAgICAgcG9pbnRzOiAoMCwgX2dldEN1cnNvclBvaW50cy5nZXRDdXJzb3JQb2ludHMpKGxheW91dCwgYWN0aXZlQ29vcmRpbmF0ZSwgb2Zmc2V0KVxuICAgIH07XG4gICAgY3Vyc29yQ29tcCA9IF9DdXJ2ZS5DdXJ2ZTtcbiAgfVxuICB2YXIgY3Vyc29yUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICBzdHJva2U6ICcjY2NjJyxcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgfSwgb2Zmc2V0KSwgcmVzdFByb3BzKSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShlbGVtZW50UHJvcHNDdXJzb3IsIGZhbHNlKSksIHt9LCB7XG4gICAgcGF5bG9hZDogYWN0aXZlUGF5bG9hZCxcbiAgICBwYXlsb2FkSW5kZXg6IGFjdGl2ZVRvb2x0aXBJbmRleCxcbiAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy10b29sdGlwLWN1cnNvcicsIGVsZW1lbnRQcm9wc0N1cnNvci5jbGFzc05hbWUpXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qLygwLCBfcmVhY3QuaXNWYWxpZEVsZW1lbnQpKGVsZW1lbnRQcm9wc0N1cnNvcikgPyAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGVsZW1lbnRQcm9wc0N1cnNvciwgY3Vyc29yUHJvcHMpIDogLyojX19QVVJFX18qLygwLCBfcmVhY3QuY3JlYXRlRWxlbWVudCkoY3Vyc29yQ29tcCwgY3Vyc29yUHJvcHMpO1xufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkN1cnNvciIsIl9yZWFjdCIsInJlcXVpcmUiLCJfY2xzeCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfQ3VydmUiLCJfQ3Jvc3MiLCJfZ2V0Q3Vyc29yUmVjdGFuZ2xlIiwiX1JlY3RhbmdsZSIsIl9nZXRSYWRpYWxDdXJzb3JQb2ludHMiLCJfU2VjdG9yIiwiX2dldEN1cnNvclBvaW50cyIsIl9SZWFjdFV0aWxzIiwib2JqIiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIm93bktleXMiLCJlIiwiciIsInQiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJrZXkiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiaSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsInByb3BzIiwiX2VsZW1lbnQkcHJvcHMkY3Vyc29yIiwiX2RlZmF1bHRQcm9wcyIsImVsZW1lbnQiLCJ0b29sdGlwRXZlbnRUeXBlIiwiaXNBY3RpdmUiLCJhY3RpdmVDb29yZGluYXRlIiwiYWN0aXZlUGF5bG9hZCIsIm9mZnNldCIsImFjdGl2ZVRvb2x0aXBJbmRleCIsInRvb2x0aXBBeGlzQmFuZFNpemUiLCJsYXlvdXQiLCJjaGFydE5hbWUiLCJlbGVtZW50UHJvcHNDdXJzb3IiLCJjdXJzb3IiLCJ0eXBlIiwiZGVmYXVsdFByb3BzIiwicmVzdFByb3BzIiwiY3Vyc29yQ29tcCIsIkN1cnZlIiwiQ3Jvc3MiLCJnZXRDdXJzb3JSZWN0YW5nbGUiLCJSZWN0YW5nbGUiLCJfZ2V0UmFkaWFsQ3Vyc29yUG9pbnQiLCJnZXRSYWRpYWxDdXJzb3JQb2ludHMiLCJjeCIsImN5IiwicmFkaXVzIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsIlNlY3RvciIsInBvaW50cyIsImdldEN1cnNvclBvaW50cyIsImN1cnNvclByb3BzIiwic3Ryb2tlIiwicG9pbnRlckV2ZW50cyIsImZpbHRlclByb3BzIiwicGF5bG9hZCIsInBheWxvYWRJbmRleCIsImNsYXNzTmFtZSIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlRWxlbWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/component/Cursor.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/component/Customized.js":
/*!***********************************************************!*\
  !*** ./node_modules/recharts/lib/component/Customized.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Customized = Customized;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"./node_modules/recharts/lib/util/LogUtils.js\");\nvar _excluded = [\n    \"component\"\n];\n/**\n * @fileOverview Customized\n */ function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n/**\n * custom svg elements by rechart instance props and state.\n * @returns {Object}   svg elements\n */ function Customized(_ref) {\n    var component = _ref.component, props = _objectWithoutProperties(_ref, _excluded);\n    var child;\n    if (/*#__PURE__*/ (0, _react.isValidElement)(component)) {\n        child = /*#__PURE__*/ (0, _react.cloneElement)(component, props);\n    } else if ((0, _isFunction[\"default\"])(component)) {\n        child = /*#__PURE__*/ (0, _react.createElement)(component, props);\n    } else {\n        (0, _LogUtils.warn)(false, \"Customized's props `component` must be React.element or Function, but got %s.\", _typeof(component));\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n        className: \"recharts-customized-wrapper\"\n    }, child);\n}\nCustomized.displayName = \"Customized\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9DdXN0b21pemVkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxrQkFBa0IsR0FBR0U7QUFDckIsSUFBSUMsU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyxjQUFjQyx1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJRyxTQUFTSCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDekMsSUFBSUksWUFBWUosbUJBQU9BLENBQUMsc0VBQWtCO0FBQzFDLElBQUlLLFlBQVk7SUFBQztDQUFZO0FBQzdCOztDQUVDLEdBQ0QsU0FBU0gsdUJBQXVCSSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLHlCQUF5QkMsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLE9BQU87SUFBTSxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx5QkFBeUJDLENBQUM7UUFBSSxPQUFPQSxJQUFJRyxJQUFJRDtJQUFHLEdBQUdGO0FBQUk7QUFDbk8sU0FBU1Ysd0JBQXdCVSxDQUFDLEVBQUVFLENBQUM7SUFBSSxJQUFJLENBQUNBLEtBQUtGLEtBQUtBLEVBQUVGLFVBQVUsRUFBRSxPQUFPRTtJQUFHLElBQUksU0FBU0EsS0FBSyxZQUFZSSxRQUFRSixNQUFNLGNBQWMsT0FBT0EsR0FBRyxPQUFPO1FBQUUsV0FBV0E7SUFBRTtJQUFHLElBQUlHLElBQUlKLHlCQUF5Qkc7SUFBSSxJQUFJQyxLQUFLQSxFQUFFRSxHQUFHLENBQUNMLElBQUksT0FBT0csRUFBRUcsR0FBRyxDQUFDTjtJQUFJLElBQUlPLElBQUk7UUFBRUMsV0FBVztJQUFLLEdBQUdDLElBQUl6QixPQUFPQyxjQUFjLElBQUlELE9BQU8wQix3QkFBd0I7SUFBRSxJQUFLLElBQUlDLEtBQUtYLEVBQUcsSUFBSSxjQUFjVyxLQUFLLEVBQUMsR0FBRUMsY0FBYyxDQUFDQyxJQUFJLENBQUNiLEdBQUdXLElBQUk7UUFBRSxJQUFJRyxJQUFJTCxJQUFJekIsT0FBTzBCLHdCQUF3QixDQUFDVixHQUFHVyxLQUFLO1FBQU1HLEtBQU1BLENBQUFBLEVBQUVSLEdBQUcsSUFBSVEsRUFBRUMsR0FBRyxJQUFJL0IsT0FBT0MsY0FBYyxDQUFDc0IsR0FBR0ksR0FBR0csS0FBS1AsQ0FBQyxDQUFDSSxFQUFFLEdBQUdYLENBQUMsQ0FBQ1csRUFBRTtJQUFFO0lBQUUsT0FBT0osQ0FBQyxDQUFDLFVBQVUsR0FBR1AsR0FBR0csS0FBS0EsRUFBRVksR0FBRyxDQUFDZixHQUFHTyxJQUFJQTtBQUFHO0FBQ3prQixTQUFTSCxRQUFRWSxDQUFDO0lBQUk7SUFBMkIsT0FBT1osVUFBVSxjQUFjLE9BQU9hLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdaLFFBQVFZO0FBQUk7QUFDN1QsU0FBU0sseUJBQXlCQyxNQUFNLEVBQUVDLFFBQVE7SUFBSSxJQUFJRCxVQUFVLE1BQU0sT0FBTyxDQUFDO0lBQUcsSUFBSUUsU0FBU0MsOEJBQThCSCxRQUFRQztJQUFXLElBQUlHLEtBQUtaO0lBQUcsSUFBSTlCLE9BQU8yQyxxQkFBcUIsRUFBRTtRQUFFLElBQUlDLG1CQUFtQjVDLE9BQU8yQyxxQkFBcUIsQ0FBQ0w7UUFBUyxJQUFLUixJQUFJLEdBQUdBLElBQUljLGlCQUFpQkMsTUFBTSxFQUFFZixJQUFLO1lBQUVZLE1BQU1FLGdCQUFnQixDQUFDZCxFQUFFO1lBQUUsSUFBSVMsU0FBU08sT0FBTyxDQUFDSixRQUFRLEdBQUc7WUFBVSxJQUFJLENBQUMxQyxPQUFPb0MsU0FBUyxDQUFDVyxvQkFBb0IsQ0FBQ2xCLElBQUksQ0FBQ1MsUUFBUUksTUFBTTtZQUFVRixNQUFNLENBQUNFLElBQUksR0FBR0osTUFBTSxDQUFDSSxJQUFJO1FBQUU7SUFBRTtJQUFFLE9BQU9GO0FBQVE7QUFDM2UsU0FBU0MsOEJBQThCSCxNQUFNLEVBQUVDLFFBQVE7SUFBSSxJQUFJRCxVQUFVLE1BQU0sT0FBTyxDQUFDO0lBQUcsSUFBSUUsU0FBUyxDQUFDO0lBQUcsSUFBSyxJQUFJRSxPQUFPSixPQUFRO1FBQUUsSUFBSXRDLE9BQU9vQyxTQUFTLENBQUNSLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUyxRQUFRSSxNQUFNO1lBQUUsSUFBSUgsU0FBU08sT0FBTyxDQUFDSixRQUFRLEdBQUc7WUFBVUYsTUFBTSxDQUFDRSxJQUFJLEdBQUdKLE1BQU0sQ0FBQ0ksSUFBSTtRQUFFO0lBQUU7SUFBRSxPQUFPRjtBQUFRO0FBQ3RSOzs7Q0FHQyxHQUNELFNBQVNwQyxXQUFXNEMsSUFBSTtJQUN0QixJQUFJQyxZQUFZRCxLQUFLQyxTQUFTLEVBQzVCQyxRQUFRYix5QkFBeUJXLE1BQU1wQztJQUN6QyxJQUFJdUM7SUFDSixJQUFrQixXQUFGLEdBQUcsSUFBRzlDLE9BQU8rQyxjQUFjLEVBQUVILFlBQVk7UUFDdkRFLFFBQXFCLFdBQUYsR0FBRyxJQUFHOUMsT0FBT2dELFlBQVksRUFBRUosV0FBV0M7SUFDM0QsT0FBTyxJQUFJLENBQUMsR0FBRzFDLFdBQVcsQ0FBQyxVQUFVLEVBQUV5QyxZQUFZO1FBQ2pERSxRQUFxQixXQUFGLEdBQUcsSUFBRzlDLE9BQU9pRCxhQUFhLEVBQUVMLFdBQVdDO0lBQzVELE9BQU87UUFDSixJQUFHdkMsVUFBVTRDLElBQUksRUFBRSxPQUFPLGlGQUFpRm5DLFFBQVE2QjtJQUN0SDtJQUNBLE9BQU8sV0FBVyxHQUFFNUMsTUFBTSxDQUFDLFVBQVUsQ0FBQ2lELGFBQWEsQ0FBQzVDLE9BQU84QyxLQUFLLEVBQUU7UUFDaEVDLFdBQVc7SUFDYixHQUFHTjtBQUNMO0FBQ0EvQyxXQUFXc0QsV0FBVyxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9jb21wb25lbnQvQ3VzdG9taXplZC5qcz9jZTY1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5DdXN0b21pemVkID0gQ3VzdG9taXplZDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XG52YXIgX0xvZ1V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvTG9nVXRpbHNcIik7XG52YXIgX2V4Y2x1ZGVkID0gW1wiY29tcG9uZW50XCJdO1xuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IEN1c3RvbWl6ZWRcbiAqL1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcbiAqIGN1c3RvbSBzdmcgZWxlbWVudHMgYnkgcmVjaGFydCBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAgIHN2ZyBlbGVtZW50c1xuICovXG5mdW5jdGlvbiBDdXN0b21pemVkKF9yZWYpIHtcbiAgdmFyIGNvbXBvbmVudCA9IF9yZWYuY29tcG9uZW50LFxuICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG4gIHZhciBjaGlsZDtcbiAgaWYgKCAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5pc1ZhbGlkRWxlbWVudCkoY29tcG9uZW50KSkge1xuICAgIGNoaWxkID0gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShjb21wb25lbnQsIHByb3BzKTtcbiAgfSBlbHNlIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShjb21wb25lbnQpKSB7XG4gICAgY2hpbGQgPSAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jcmVhdGVFbGVtZW50KShjb21wb25lbnQsIHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICAoMCwgX0xvZ1V0aWxzLndhcm4pKGZhbHNlLCBcIkN1c3RvbWl6ZWQncyBwcm9wcyBgY29tcG9uZW50YCBtdXN0IGJlIFJlYWN0LmVsZW1lbnQgb3IgRnVuY3Rpb24sIGJ1dCBnb3QgJXMuXCIsIF90eXBlb2YoY29tcG9uZW50KSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XG4gICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWN1c3RvbWl6ZWQtd3JhcHBlclwiXG4gIH0sIGNoaWxkKTtcbn1cbkN1c3RvbWl6ZWQuZGlzcGxheU5hbWUgPSAnQ3VzdG9taXplZCc7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ3VzdG9taXplZCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9pc0Z1bmN0aW9uIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9MYXllciIsIl9Mb2dVdGlscyIsIl9leGNsdWRlZCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZSIsImV4Y2x1ZGVkIiwidGFyZ2V0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJrZXkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwibGVuZ3RoIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX3JlZiIsImNvbXBvbmVudCIsInByb3BzIiwiY2hpbGQiLCJpc1ZhbGlkRWxlbWVudCIsImNsb25lRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ3YXJuIiwiTGF5ZXIiLCJjbGFzc05hbWUiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/component/Customized.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/component/DefaultLegendContent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/recharts/lib/component/DefaultLegendContent.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DefaultLegendContent = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx2 = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"./node_modules/recharts/lib/util/LogUtils.js\");\nvar _Surface = __webpack_require__(/*! ../container/Surface */ \"./node_modules/recharts/lib/container/Surface.js\");\nvar _Symbols = __webpack_require__(/*! ../shape/Symbols */ \"./node_modules/recharts/lib/shape/Symbols.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"./node_modules/recharts/lib/util/types.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Default Legend Content\n */ \nvar SIZE = 32;\nvar DefaultLegendContent = exports.DefaultLegendContent = /*#__PURE__*/ function(_PureComponent) {\n    function DefaultLegendContent() {\n        _classCallCheck(this, DefaultLegendContent);\n        return _callSuper(this, DefaultLegendContent, arguments);\n    }\n    _inherits(DefaultLegendContent, _PureComponent);\n    return _createClass(DefaultLegendContent, [\n        {\n            key: \"renderIcon\",\n            value: /**\n     * Render the path of icon\n     * @param {Object} data Data of each legend item\n     * @return {String} Path element\n     */ function renderIcon(data) {\n                var inactiveColor = this.props.inactiveColor;\n                var halfSize = SIZE / 2;\n                var sixthSize = SIZE / 6;\n                var thirdSize = SIZE / 3;\n                var color = data.inactive ? inactiveColor : data.color;\n                if (data.type === \"plainline\") {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"line\", {\n                        strokeWidth: 4,\n                        fill: \"none\",\n                        stroke: color,\n                        strokeDasharray: data.payload.strokeDasharray,\n                        x1: 0,\n                        y1: halfSize,\n                        x2: SIZE,\n                        y2: halfSize,\n                        className: \"recharts-legend-icon\"\n                    });\n                }\n                if (data.type === \"line\") {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", {\n                        strokeWidth: 4,\n                        fill: \"none\",\n                        stroke: color,\n                        d: \"M0,\".concat(halfSize, \"h\").concat(thirdSize, \"\\n            A\").concat(sixthSize, \",\").concat(sixthSize, \",0,1,1,\").concat(2 * thirdSize, \",\").concat(halfSize, \"\\n            H\").concat(SIZE, \"M\").concat(2 * thirdSize, \",\").concat(halfSize, \"\\n            A\").concat(sixthSize, \",\").concat(sixthSize, \",0,1,1,\").concat(thirdSize, \",\").concat(halfSize),\n                        className: \"recharts-legend-icon\"\n                    });\n                }\n                if (data.type === \"rect\") {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", {\n                        stroke: \"none\",\n                        fill: color,\n                        d: \"M0,\".concat(SIZE / 8, \"h\").concat(SIZE, \"v\").concat(SIZE * 3 / 4, \"h\").concat(-SIZE, \"z\"),\n                        className: \"recharts-legend-icon\"\n                    });\n                }\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(data.legendIcon)) {\n                    var iconProps = _objectSpread({}, data);\n                    delete iconProps.legendIcon;\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(data.legendIcon, iconProps);\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Symbols.Symbols, {\n                    fill: color,\n                    cx: halfSize,\n                    cy: halfSize,\n                    size: SIZE,\n                    sizeType: \"diameter\",\n                    type: data.type\n                });\n            }\n        },\n        {\n            key: \"renderItems\",\n            value: function renderItems() {\n                var _this = this;\n                var _this$props = this.props, payload = _this$props.payload, iconSize = _this$props.iconSize, layout = _this$props.layout, formatter = _this$props.formatter, inactiveColor = _this$props.inactiveColor;\n                var viewBox = {\n                    x: 0,\n                    y: 0,\n                    width: SIZE,\n                    height: SIZE\n                };\n                var itemStyle = {\n                    display: layout === \"horizontal\" ? \"inline-block\" : \"block\",\n                    marginRight: 10\n                };\n                var svgStyle = {\n                    display: \"inline-block\",\n                    verticalAlign: \"middle\",\n                    marginRight: 4\n                };\n                return payload.map(function(entry, i) {\n                    var finalFormatter = entry.formatter || formatter;\n                    var className = (0, _clsx2[\"default\"])(_defineProperty(_defineProperty({\n                        \"recharts-legend-item\": true\n                    }, \"legend-item-\".concat(i), true), \"inactive\", entry.inactive));\n                    if (entry.type === \"none\") {\n                        return null;\n                    }\n                    // Do not render entry.value as functions. Always require static string properties.\n                    var entryValue = !(0, _isFunction[\"default\"])(entry.value) ? entry.value : null;\n                    (0, _LogUtils.warn)(!(0, _isFunction[\"default\"])(entry.value), 'The name property is also required when using a function for the dataKey of a chart\\'s cartesian components. Ex: <Bar name=\"Name of my Data\"/>' // eslint-disable-line max-len\n                    );\n                    var color = entry.inactive ? inactiveColor : entry.color;\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"li\", _extends({\n                        className: className,\n                        style: itemStyle,\n                        key: \"legend-item-\".concat(i)\n                    }, (0, _types.adaptEventsOfChild)(_this.props, entry, i)), /*#__PURE__*/ _react[\"default\"].createElement(_Surface.Surface, {\n                        width: iconSize,\n                        height: iconSize,\n                        viewBox: viewBox,\n                        style: svgStyle\n                    }, _this.renderIcon(entry)), /*#__PURE__*/ _react[\"default\"].createElement(\"span\", {\n                        className: \"recharts-legend-item-text\",\n                        style: {\n                            color: color\n                        }\n                    }, finalFormatter ? finalFormatter(entryValue, entry, i) : entryValue));\n                });\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props2 = this.props, payload = _this$props2.payload, layout = _this$props2.layout, align = _this$props2.align;\n                if (!payload || !payload.length) {\n                    return null;\n                }\n                var finalStyle = {\n                    padding: 0,\n                    margin: 0,\n                    textAlign: layout === \"horizontal\" ? align : \"left\"\n                };\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"ul\", {\n                    className: \"recharts-default-legend\",\n                    style: finalStyle\n                }, this.renderItems());\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(DefaultLegendContent, \"displayName\", \"Legend\");\n_defineProperty(DefaultLegendContent, \"defaultProps\", {\n    iconSize: 14,\n    layout: \"horizontal\",\n    align: \"center\",\n    verticalAlign: \"middle\",\n    inactiveColor: \"#ccc\"\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9EZWZhdWx0TGVnZW5kQ29udGVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsNEJBQTRCLEdBQUcsS0FBSztBQUNwQyxJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLGNBQWNDLHVCQUF1QkYsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlHLFNBQVNELHVCQUF1QkYsbUJBQU9BLENBQUMsa0JBQU07QUFDbEQsSUFBSUksWUFBWUosbUJBQU9BLENBQUMsc0VBQWtCO0FBQzFDLElBQUlLLFdBQVdMLG1CQUFPQSxDQUFDLDhFQUFzQjtBQUM3QyxJQUFJTSxXQUFXTixtQkFBT0EsQ0FBQyxzRUFBa0I7QUFDekMsSUFBSU8sU0FBU1AsbUJBQU9BLENBQUMsZ0VBQWU7QUFDcEMsU0FBU0UsdUJBQXVCTSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLHlCQUF5QkMsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLE9BQU87SUFBTSxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx5QkFBeUJDLENBQUM7UUFBSSxPQUFPQSxJQUFJRyxJQUFJRDtJQUFHLEdBQUdGO0FBQUk7QUFDbk8sU0FBU1osd0JBQXdCWSxDQUFDLEVBQUVFLENBQUM7SUFBSSxJQUFJLENBQUNBLEtBQUtGLEtBQUtBLEVBQUVGLFVBQVUsRUFBRSxPQUFPRTtJQUFHLElBQUksU0FBU0EsS0FBSyxZQUFZSSxRQUFRSixNQUFNLGNBQWMsT0FBT0EsR0FBRyxPQUFPO1FBQUUsV0FBV0E7SUFBRTtJQUFHLElBQUlHLElBQUlKLHlCQUF5Qkc7SUFBSSxJQUFJ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UUFBUUQsYUFBYUMsS0FBSztnQkFDNUIsSUFBSSxDQUFDM0MsV0FBVyxDQUFDQSxRQUFRbkUsTUFBTSxFQUFFO29CQUMvQixPQUFPO2dCQUNUO2dCQUNBLElBQUkrRyxhQUFhO29CQUNmQyxTQUFTO29CQUNUQyxRQUFRO29CQUNSQyxXQUFXMUIsV0FBVyxlQUFlc0IsUUFBUTtnQkFDL0M7Z0JBQ0EsT0FBTyxXQUFXLEdBQUVySixNQUFNLENBQUMsVUFBVSxDQUFDcUcsYUFBYSxDQUFDLE1BQU07b0JBQ3hEVSxXQUFXO29CQUNYaUMsT0FBT007Z0JBQ1QsR0FBRyxJQUFJLENBQUMzQixXQUFXO1lBQ3JCO1FBQ0Y7S0FBRTtBQUNKLEVBQUUzSCxPQUFPMEosYUFBYTtBQUN0QnZHLGdCQUFnQnBELHNCQUFzQixlQUFlO0FBQ3JEb0QsZ0JBQWdCcEQsc0JBQXNCLGdCQUFnQjtJQUNwRCtILFVBQVU7SUFDVkMsUUFBUTtJQUNSc0IsT0FBTztJQUNQWCxlQUFlO0lBQ2Y1QyxlQUFlO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9jb21wb25lbnQvRGVmYXVsdExlZ2VuZENvbnRlbnQuanM/Y2M5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRGVmYXVsdExlZ2VuZENvbnRlbnQgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfaXNGdW5jdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpKTtcbnZhciBfY2xzeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfTG9nVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Mb2dVdGlsc1wiKTtcbnZhciBfU3VyZmFjZSA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvU3VyZmFjZVwiKTtcbnZhciBfU3ltYm9scyA9IHJlcXVpcmUoXCIuLi9zaGFwZS9TeW1ib2xzXCIpO1xudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi91dGlsL3R5cGVzXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxuICogQGZpbGVPdmVydmlldyBEZWZhdWx0IExlZ2VuZCBDb250ZW50XG4gKi9cbnZhciBTSVpFID0gMzI7XG52YXIgRGVmYXVsdExlZ2VuZENvbnRlbnQgPSBleHBvcnRzLkRlZmF1bHRMZWdlbmRDb250ZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBmdW5jdGlvbiBEZWZhdWx0TGVnZW5kQ29udGVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVmYXVsdExlZ2VuZENvbnRlbnQpO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIERlZmF1bHRMZWdlbmRDb250ZW50LCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhEZWZhdWx0TGVnZW5kQ29udGVudCwgX1B1cmVDb21wb25lbnQpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKERlZmF1bHRMZWdlbmRDb250ZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJJY29uXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSBwYXRoIG9mIGljb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBEYXRhIG9mIGVhY2ggbGVnZW5kIGl0ZW1cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFBhdGggZWxlbWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbmRlckljb24oZGF0YSkge1xuICAgICAgdmFyIGluYWN0aXZlQ29sb3IgPSB0aGlzLnByb3BzLmluYWN0aXZlQ29sb3I7XG4gICAgICB2YXIgaGFsZlNpemUgPSBTSVpFIC8gMjtcbiAgICAgIHZhciBzaXh0aFNpemUgPSBTSVpFIC8gNjtcbiAgICAgIHZhciB0aGlyZFNpemUgPSBTSVpFIC8gMztcbiAgICAgIHZhciBjb2xvciA9IGRhdGEuaW5hY3RpdmUgPyBpbmFjdGl2ZUNvbG9yIDogZGF0YS5jb2xvcjtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdwbGFpbmxpbmUnKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7XG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDQsXG4gICAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICAgICAgc3Ryb2tlOiBjb2xvcixcbiAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IGRhdGEucGF5bG9hZC5zdHJva2VEYXNoYXJyYXksXG4gICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgeTE6IGhhbGZTaXplLFxuICAgICAgICAgIHgyOiBTSVpFLFxuICAgICAgICAgIHkyOiBoYWxmU2l6ZSxcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtbGVnZW5kLWljb25cIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgICAgICAgIHN0cm9rZVdpZHRoOiA0LFxuICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICAgIHN0cm9rZTogY29sb3IsXG4gICAgICAgICAgZDogXCJNMCxcIi5jb25jYXQoaGFsZlNpemUsIFwiaFwiKS5jb25jYXQodGhpcmRTaXplLCBcIlxcbiAgICAgICAgICAgIEFcIikuY29uY2F0KHNpeHRoU2l6ZSwgXCIsXCIpLmNvbmNhdChzaXh0aFNpemUsIFwiLDAsMSwxLFwiKS5jb25jYXQoMiAqIHRoaXJkU2l6ZSwgXCIsXCIpLmNvbmNhdChoYWxmU2l6ZSwgXCJcXG4gICAgICAgICAgICBIXCIpLmNvbmNhdChTSVpFLCBcIk1cIikuY29uY2F0KDIgKiB0aGlyZFNpemUsIFwiLFwiKS5jb25jYXQoaGFsZlNpemUsIFwiXFxuICAgICAgICAgICAgQVwiKS5jb25jYXQoc2l4dGhTaXplLCBcIixcIikuY29uY2F0KHNpeHRoU2l6ZSwgXCIsMCwxLDEsXCIpLmNvbmNhdCh0aGlyZFNpemUsIFwiLFwiKS5jb25jYXQoaGFsZlNpemUpLFxuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1sZWdlbmQtaWNvblwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3JlY3QnKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgc3Ryb2tlOiBcIm5vbmVcIixcbiAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICBkOiBcIk0wLFwiLmNvbmNhdChTSVpFIC8gOCwgXCJoXCIpLmNvbmNhdChTSVpFLCBcInZcIikuY29uY2F0KFNJWkUgKiAzIC8gNCwgXCJoXCIpLmNvbmNhdCgtU0laRSwgXCJ6XCIpLFxuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1sZWdlbmQtaWNvblwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChkYXRhLmxlZ2VuZEljb24pKSB7XG4gICAgICAgIHZhciBpY29uUHJvcHMgPSBfb2JqZWN0U3ByZWFkKHt9LCBkYXRhKTtcbiAgICAgICAgZGVsZXRlIGljb25Qcm9wcy5sZWdlbmRJY29uO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGRhdGEubGVnZW5kSWNvbiwgaWNvblByb3BzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9TeW1ib2xzLlN5bWJvbHMsIHtcbiAgICAgICAgZmlsbDogY29sb3IsXG4gICAgICAgIGN4OiBoYWxmU2l6ZSxcbiAgICAgICAgY3k6IGhhbGZTaXplLFxuICAgICAgICBzaXplOiBTSVpFLFxuICAgICAgICBzaXplVHlwZTogXCJkaWFtZXRlclwiLFxuICAgICAgICB0eXBlOiBkYXRhLnR5cGVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgaXRlbXMgb2YgbGVnZW5kXG4gICAgICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBJdGVtc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckl0ZW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckl0ZW1zKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHBheWxvYWQgPSBfdGhpcyRwcm9wcy5wYXlsb2FkLFxuICAgICAgICBpY29uU2l6ZSA9IF90aGlzJHByb3BzLmljb25TaXplLFxuICAgICAgICBsYXlvdXQgPSBfdGhpcyRwcm9wcy5sYXlvdXQsXG4gICAgICAgIGZvcm1hdHRlciA9IF90aGlzJHByb3BzLmZvcm1hdHRlcixcbiAgICAgICAgaW5hY3RpdmVDb2xvciA9IF90aGlzJHByb3BzLmluYWN0aXZlQ29sb3I7XG4gICAgICB2YXIgdmlld0JveCA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IFNJWkUsXG4gICAgICAgIGhlaWdodDogU0laRVxuICAgICAgfTtcbiAgICAgIHZhciBpdGVtU3R5bGUgPSB7XG4gICAgICAgIGRpc3BsYXk6IGxheW91dCA9PT0gJ2hvcml6b250YWwnID8gJ2lubGluZS1ibG9jaycgOiAnYmxvY2snLFxuICAgICAgICBtYXJnaW5SaWdodDogMTBcbiAgICAgIH07XG4gICAgICB2YXIgc3ZnU3R5bGUgPSB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgbWFyZ2luUmlnaHQ6IDRcbiAgICAgIH07XG4gICAgICByZXR1cm4gcGF5bG9hZC5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gICAgICAgIHZhciBmaW5hbEZvcm1hdHRlciA9IGVudHJ5LmZvcm1hdHRlciB8fCBmb3JtYXR0ZXI7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAoMCwgX2Nsc3gyW1wiZGVmYXVsdFwiXSkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICAgICAgJ3JlY2hhcnRzLWxlZ2VuZC1pdGVtJzogdHJ1ZVxuICAgICAgICB9LCBcImxlZ2VuZC1pdGVtLVwiLmNvbmNhdChpKSwgdHJ1ZSksIFwiaW5hY3RpdmVcIiwgZW50cnkuaW5hY3RpdmUpKTtcbiAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdub25lJykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gbm90IHJlbmRlciBlbnRyeS52YWx1ZSBhcyBmdW5jdGlvbnMuIEFsd2F5cyByZXF1aXJlIHN0YXRpYyBzdHJpbmcgcHJvcGVydGllcy5cbiAgICAgICAgdmFyIGVudHJ5VmFsdWUgPSAhKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkoZW50cnkudmFsdWUpID8gZW50cnkudmFsdWUgOiBudWxsO1xuICAgICAgICAoMCwgX0xvZ1V0aWxzLndhcm4pKCEoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShlbnRyeS52YWx1ZSksIFwiVGhlIG5hbWUgcHJvcGVydHkgaXMgYWxzbyByZXF1aXJlZCB3aGVuIHVzaW5nIGEgZnVuY3Rpb24gZm9yIHRoZSBkYXRhS2V5IG9mIGEgY2hhcnQncyBjYXJ0ZXNpYW4gY29tcG9uZW50cy4gRXg6IDxCYXIgbmFtZT1cXFwiTmFtZSBvZiBteSBEYXRhXFxcIi8+XCIgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG4gICAgICAgICk7XG4gICAgICAgIHZhciBjb2xvciA9IGVudHJ5LmluYWN0aXZlID8gaW5hY3RpdmVDb2xvciA6IGVudHJ5LmNvbG9yO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImxpXCIsIF9leHRlbmRzKHtcbiAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgICBzdHlsZTogaXRlbVN0eWxlXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgICxcbiAgICAgICAgICBrZXk6IFwibGVnZW5kLWl0ZW0tXCIuY29uY2F0KGkpXG4gICAgICAgIH0sICgwLCBfdHlwZXMuYWRhcHRFdmVudHNPZkNoaWxkKShfdGhpcy5wcm9wcywgZW50cnksIGkpKSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfU3VyZmFjZS5TdXJmYWNlLCB7XG4gICAgICAgICAgd2lkdGg6IGljb25TaXplLFxuICAgICAgICAgIGhlaWdodDogaWNvblNpemUsXG4gICAgICAgICAgdmlld0JveDogdmlld0JveCxcbiAgICAgICAgICBzdHlsZTogc3ZnU3R5bGVcbiAgICAgICAgfSwgX3RoaXMucmVuZGVySWNvbihlbnRyeSkpLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLWxlZ2VuZC1pdGVtLXRleHRcIixcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgY29sb3I6IGNvbG9yXG4gICAgICAgICAgfVxuICAgICAgICB9LCBmaW5hbEZvcm1hdHRlciA/IGZpbmFsRm9ybWF0dGVyKGVudHJ5VmFsdWUsIGVudHJ5LCBpKSA6IGVudHJ5VmFsdWUpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIHBheWxvYWQgPSBfdGhpcyRwcm9wczIucGF5bG9hZCxcbiAgICAgICAgbGF5b3V0ID0gX3RoaXMkcHJvcHMyLmxheW91dCxcbiAgICAgICAgYWxpZ24gPSBfdGhpcyRwcm9wczIuYWxpZ247XG4gICAgICBpZiAoIXBheWxvYWQgfHwgIXBheWxvYWQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGZpbmFsU3R5bGUgPSB7XG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgdGV4dEFsaWduOiBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IGFsaWduIDogJ2xlZnQnXG4gICAgICB9O1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1kZWZhdWx0LWxlZ2VuZFwiLFxuICAgICAgICBzdHlsZTogZmluYWxTdHlsZVxuICAgICAgfSwgdGhpcy5yZW5kZXJJdGVtcygpKTtcbiAgICB9XG4gIH1dKTtcbn0oX3JlYWN0LlB1cmVDb21wb25lbnQpO1xuX2RlZmluZVByb3BlcnR5KERlZmF1bHRMZWdlbmRDb250ZW50LCBcImRpc3BsYXlOYW1lXCIsICdMZWdlbmQnKTtcbl9kZWZpbmVQcm9wZXJ0eShEZWZhdWx0TGVnZW5kQ29udGVudCwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBpY29uU2l6ZTogMTQsXG4gIGxheW91dDogJ2hvcml6b250YWwnLFxuICBhbGlnbjogJ2NlbnRlcicsXG4gIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICBpbmFjdGl2ZUNvbG9yOiAnI2NjYydcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkRlZmF1bHRMZWdlbmRDb250ZW50IiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX2lzRnVuY3Rpb24iLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2Nsc3gyIiwiX0xvZ1V0aWxzIiwiX1N1cmZhY2UiLCJfU3ltYm9scyIsIl90eXBlcyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImFwcGx5Iiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiU0laRSIsIl9QdXJlQ29tcG9uZW50IiwicmVuZGVySWNvbiIsImRhdGEiLCJpbmFjdGl2ZUNvbG9yIiwiaGFsZlNpemUiLCJzaXh0aFNpemUiLCJ0aGlyZFNpemUiLCJjb2xvciIsImluYWN0aXZlIiwidHlwZSIsImNyZWF0ZUVsZW1lbnQiLCJzdHJva2VXaWR0aCIsImZpbGwiLCJzdHJva2UiLCJzdHJva2VEYXNoYXJyYXkiLCJwYXlsb2FkIiwieDEiLCJ5MSIsIngyIiwieTIiLCJjbGFzc05hbWUiLCJkIiwiY29uY2F0IiwiaXNWYWxpZEVsZW1lbnQiLCJsZWdlbmRJY29uIiwiaWNvblByb3BzIiwiY2xvbmVFbGVtZW50IiwiU3ltYm9scyIsImN4IiwiY3kiLCJzaXplIiwic2l6ZVR5cGUiLCJyZW5kZXJJdGVtcyIsIl90aGlzIiwiX3RoaXMkcHJvcHMiLCJpY29uU2l6ZSIsImxheW91dCIsImZvcm1hdHRlciIsInZpZXdCb3giLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0IiwiaXRlbVN0eWxlIiwiZGlzcGxheSIsIm1hcmdpblJpZ2h0Iiwic3ZnU3R5bGUiLCJ2ZXJ0aWNhbEFsaWduIiwibWFwIiwiZW50cnkiLCJmaW5hbEZvcm1hdHRlciIsImVudHJ5VmFsdWUiLCJ3YXJuIiwic3R5bGUiLCJhZGFwdEV2ZW50c09mQ2hpbGQiLCJTdXJmYWNlIiwicmVuZGVyIiwiX3RoaXMkcHJvcHMyIiwiYWxpZ24iLCJmaW5hbFN0eWxlIiwicGFkZGluZyIsIm1hcmdpbiIsInRleHRBbGlnbiIsIlB1cmVDb21wb25lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/component/DefaultLegendContent.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/component/DefaultTooltipContent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/recharts/lib/component/DefaultTooltipContent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DefaultTooltipContent = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _sortBy = _interopRequireDefault(__webpack_require__(/*! lodash/sortBy */ \"lodash/sortBy\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Default Tooltip Content\n */ \nfunction defaultFormatter(value) {\n    return Array.isArray(value) && (0, _DataUtils.isNumOrStr)(value[0]) && (0, _DataUtils.isNumOrStr)(value[1]) ? value.join(\" ~ \") : value;\n}\nvar DefaultTooltipContent = exports.DefaultTooltipContent = function DefaultTooltipContent(props) {\n    var _props$separator = props.separator, separator = _props$separator === void 0 ? \" : \" : _props$separator, _props$contentStyle = props.contentStyle, contentStyle = _props$contentStyle === void 0 ? {} : _props$contentStyle, _props$itemStyle = props.itemStyle, itemStyle = _props$itemStyle === void 0 ? {} : _props$itemStyle, _props$labelStyle = props.labelStyle, labelStyle = _props$labelStyle === void 0 ? {} : _props$labelStyle, payload = props.payload, formatter = props.formatter, itemSorter = props.itemSorter, wrapperClassName = props.wrapperClassName, labelClassName = props.labelClassName, label = props.label, labelFormatter = props.labelFormatter, _props$accessibilityL = props.accessibilityLayer, accessibilityLayer = _props$accessibilityL === void 0 ? false : _props$accessibilityL;\n    var renderContent = function renderContent() {\n        if (payload && payload.length) {\n            var listStyle = {\n                padding: 0,\n                margin: 0\n            };\n            var items = (itemSorter ? (0, _sortBy[\"default\"])(payload, itemSorter) : payload).map(function(entry, i) {\n                if (entry.type === \"none\") {\n                    return null;\n                }\n                var finalItemStyle = _objectSpread({\n                    display: \"block\",\n                    paddingTop: 4,\n                    paddingBottom: 4,\n                    color: entry.color || \"#000\"\n                }, itemStyle);\n                var finalFormatter = entry.formatter || formatter || defaultFormatter;\n                var value = entry.value, name = entry.name;\n                var finalValue = value;\n                var finalName = name;\n                if (finalFormatter && finalValue != null && finalName != null) {\n                    var formatted = finalFormatter(value, name, entry, i, payload);\n                    if (Array.isArray(formatted)) {\n                        var _formatted = _slicedToArray(formatted, 2);\n                        finalValue = _formatted[0];\n                        finalName = _formatted[1];\n                    } else {\n                        finalValue = formatted;\n                    }\n                }\n                return(/*#__PURE__*/ // eslint-disable-next-line react/no-array-index-key\n                _react[\"default\"].createElement(\"li\", {\n                    className: \"recharts-tooltip-item\",\n                    key: \"tooltip-item-\".concat(i),\n                    style: finalItemStyle\n                }, (0, _DataUtils.isNumOrStr)(finalName) ? /*#__PURE__*/ _react[\"default\"].createElement(\"span\", {\n                    className: \"recharts-tooltip-item-name\"\n                }, finalName) : null, (0, _DataUtils.isNumOrStr)(finalName) ? /*#__PURE__*/ _react[\"default\"].createElement(\"span\", {\n                    className: \"recharts-tooltip-item-separator\"\n                }, separator) : null, /*#__PURE__*/ _react[\"default\"].createElement(\"span\", {\n                    className: \"recharts-tooltip-item-value\"\n                }, finalValue), /*#__PURE__*/ _react[\"default\"].createElement(\"span\", {\n                    className: \"recharts-tooltip-item-unit\"\n                }, entry.unit || \"\")));\n            });\n            return /*#__PURE__*/ _react[\"default\"].createElement(\"ul\", {\n                className: \"recharts-tooltip-item-list\",\n                style: listStyle\n            }, items);\n        }\n        return null;\n    };\n    var finalStyle = _objectSpread({\n        margin: 0,\n        padding: 10,\n        backgroundColor: \"#fff\",\n        border: \"1px solid #ccc\",\n        whiteSpace: \"nowrap\"\n    }, contentStyle);\n    var finalLabelStyle = _objectSpread({\n        margin: 0\n    }, labelStyle);\n    var hasLabel = !(0, _isNil[\"default\"])(label);\n    var finalLabel = hasLabel ? label : \"\";\n    var wrapperCN = (0, _clsx[\"default\"])(\"recharts-default-tooltip\", wrapperClassName);\n    var labelCN = (0, _clsx[\"default\"])(\"recharts-tooltip-label\", labelClassName);\n    if (hasLabel && labelFormatter && payload !== undefined && payload !== null) {\n        finalLabel = labelFormatter(label, payload);\n    }\n    var accessibilityAttributes = accessibilityLayer ? {\n        role: \"status\",\n        \"aria-live\": \"assertive\"\n    } : {};\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", _extends({\n        className: wrapperCN,\n        style: finalStyle\n    }, accessibilityAttributes), /*#__PURE__*/ _react[\"default\"].createElement(\"p\", {\n        className: labelCN,\n        style: finalLabelStyle\n    }, /*#__PURE__*/ _react[\"default\"].isValidElement(finalLabel) ? finalLabel : \"\".concat(finalLabel)), renderContent());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9EZWZhdWx0VG9vbHRpcENvbnRlbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELDZCQUE2QixHQUFHLEtBQUs7QUFDckMsSUFBSUcsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxVQUFVRix1QkFBdUJDLG1CQUFPQSxDQUFDLG9DQUFlO0FBQzVELElBQUlFLFNBQVNILHVCQUF1QkMsbUJBQU9BLENBQUMsa0NBQWM7QUFDMUQsSUFBSUcsUUFBUUosdUJBQXVCQyxtQkFBT0EsQ0FBQyxrQkFBTTtBQUNqRCxJQUFJSSxhQUFhSixtQkFBT0EsQ0FBQyx3RUFBbUI7QUFDNUMsU0FBU0QsdUJBQXVCTSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSztJQUFhQSxXQUFXcEIsT0FBT3FCLE1BQU0sR0FBR3JCLE9BQU9xQixNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUFFLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUFFLElBQUssSUFBSUksT0FB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UyxjQUFjN0I7QUFDdEciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9EZWZhdWx0VG9vbHRpcENvbnRlbnQuanM/MzM0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRGVmYXVsdFRvb2x0aXBDb250ZW50ID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfc29ydEJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3NvcnRCeVwiKSk7XG52YXIgX2lzTmlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzTmlsXCIpKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKipcbiAqIEBmaWxlT3ZlcnZpZXcgRGVmYXVsdCBUb29sdGlwIENvbnRlbnRcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdEZvcm1hdHRlcih2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1PclN0cikodmFsdWVbMF0pICYmICgwLCBfRGF0YVV0aWxzLmlzTnVtT3JTdHIpKHZhbHVlWzFdKSA/IHZhbHVlLmpvaW4oJyB+ICcpIDogdmFsdWU7XG59XG52YXIgRGVmYXVsdFRvb2x0aXBDb250ZW50ID0gZXhwb3J0cy5EZWZhdWx0VG9vbHRpcENvbnRlbnQgPSBmdW5jdGlvbiBEZWZhdWx0VG9vbHRpcENvbnRlbnQocHJvcHMpIHtcbiAgdmFyIF9wcm9wcyRzZXBhcmF0b3IgPSBwcm9wcy5zZXBhcmF0b3IsXG4gICAgc2VwYXJhdG9yID0gX3Byb3BzJHNlcGFyYXRvciA9PT0gdm9pZCAwID8gJyA6ICcgOiBfcHJvcHMkc2VwYXJhdG9yLFxuICAgIF9wcm9wcyRjb250ZW50U3R5bGUgPSBwcm9wcy5jb250ZW50U3R5bGUsXG4gICAgY29udGVudFN0eWxlID0gX3Byb3BzJGNvbnRlbnRTdHlsZSA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkY29udGVudFN0eWxlLFxuICAgIF9wcm9wcyRpdGVtU3R5bGUgPSBwcm9wcy5pdGVtU3R5bGUsXG4gICAgaXRlbVN0eWxlID0gX3Byb3BzJGl0ZW1TdHlsZSA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkaXRlbVN0eWxlLFxuICAgIF9wcm9wcyRsYWJlbFN0eWxlID0gcHJvcHMubGFiZWxTdHlsZSxcbiAgICBsYWJlbFN0eWxlID0gX3Byb3BzJGxhYmVsU3R5bGUgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJGxhYmVsU3R5bGUsXG4gICAgcGF5bG9hZCA9IHByb3BzLnBheWxvYWQsXG4gICAgZm9ybWF0dGVyID0gcHJvcHMuZm9ybWF0dGVyLFxuICAgIGl0ZW1Tb3J0ZXIgPSBwcm9wcy5pdGVtU29ydGVyLFxuICAgIHdyYXBwZXJDbGFzc05hbWUgPSBwcm9wcy53cmFwcGVyQ2xhc3NOYW1lLFxuICAgIGxhYmVsQ2xhc3NOYW1lID0gcHJvcHMubGFiZWxDbGFzc05hbWUsXG4gICAgbGFiZWwgPSBwcm9wcy5sYWJlbCxcbiAgICBsYWJlbEZvcm1hdHRlciA9IHByb3BzLmxhYmVsRm9ybWF0dGVyLFxuICAgIF9wcm9wcyRhY2Nlc3NpYmlsaXR5TCA9IHByb3BzLmFjY2Vzc2liaWxpdHlMYXllcixcbiAgICBhY2Nlc3NpYmlsaXR5TGF5ZXIgPSBfcHJvcHMkYWNjZXNzaWJpbGl0eUwgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGFjY2Vzc2liaWxpdHlMO1xuICB2YXIgcmVuZGVyQ29udGVudCA9IGZ1bmN0aW9uIHJlbmRlckNvbnRlbnQoKSB7XG4gICAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC5sZW5ndGgpIHtcbiAgICAgIHZhciBsaXN0U3R5bGUgPSB7XG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG1hcmdpbjogMFxuICAgICAgfTtcbiAgICAgIHZhciBpdGVtcyA9IChpdGVtU29ydGVyID8gKDAsIF9zb3J0QnlbXCJkZWZhdWx0XCJdKShwYXlsb2FkLCBpdGVtU29ydGVyKSA6IHBheWxvYWQpLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdub25lJykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaW5hbEl0ZW1TdHlsZSA9IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgcGFkZGluZ1RvcDogNCxcbiAgICAgICAgICBwYWRkaW5nQm90dG9tOiA0LFxuICAgICAgICAgIGNvbG9yOiBlbnRyeS5jb2xvciB8fCAnIzAwMCdcbiAgICAgICAgfSwgaXRlbVN0eWxlKTtcbiAgICAgICAgdmFyIGZpbmFsRm9ybWF0dGVyID0gZW50cnkuZm9ybWF0dGVyIHx8IGZvcm1hdHRlciB8fCBkZWZhdWx0Rm9ybWF0dGVyO1xuICAgICAgICB2YXIgdmFsdWUgPSBlbnRyeS52YWx1ZSxcbiAgICAgICAgICBuYW1lID0gZW50cnkubmFtZTtcbiAgICAgICAgdmFyIGZpbmFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdmFyIGZpbmFsTmFtZSA9IG5hbWU7XG4gICAgICAgIGlmIChmaW5hbEZvcm1hdHRlciAmJiBmaW5hbFZhbHVlICE9IG51bGwgJiYgZmluYWxOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgZm9ybWF0dGVkID0gZmluYWxGb3JtYXR0ZXIodmFsdWUsIG5hbWUsIGVudHJ5LCBpLCBwYXlsb2FkKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmb3JtYXR0ZWQpKSB7XG4gICAgICAgICAgICB2YXIgX2Zvcm1hdHRlZCA9IF9zbGljZWRUb0FycmF5KGZvcm1hdHRlZCwgMik7XG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gX2Zvcm1hdHRlZFswXTtcbiAgICAgICAgICAgIGZpbmFsTmFtZSA9IF9mb3JtYXR0ZWRbMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBmb3JtYXR0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcbiAgICAgICAgICBfcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtdG9vbHRpcC1pdGVtXCIsXG4gICAgICAgICAgICBrZXk6IFwidG9vbHRpcC1pdGVtLVwiLmNvbmNhdChpKSxcbiAgICAgICAgICAgIHN0eWxlOiBmaW5hbEl0ZW1TdHlsZVxuICAgICAgICAgIH0sICgwLCBfRGF0YVV0aWxzLmlzTnVtT3JTdHIpKGZpbmFsTmFtZSkgPyAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtdG9vbHRpcC1pdGVtLW5hbWVcIlxuICAgICAgICAgIH0sIGZpbmFsTmFtZSkgOiBudWxsLCAoMCwgX0RhdGFVdGlscy5pc051bU9yU3RyKShmaW5hbE5hbWUpID8gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXRvb2x0aXAtaXRlbS1zZXBhcmF0b3JcIlxuICAgICAgICAgIH0sIHNlcGFyYXRvcikgOiBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtdG9vbHRpcC1pdGVtLXZhbHVlXCJcbiAgICAgICAgICB9LCBmaW5hbFZhbHVlKSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXRvb2x0aXAtaXRlbS11bml0XCJcbiAgICAgICAgICB9LCBlbnRyeS51bml0IHx8ICcnKSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy10b29sdGlwLWl0ZW0tbGlzdFwiLFxuICAgICAgICBzdHlsZTogbGlzdFN0eWxlXG4gICAgICB9LCBpdGVtcyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICB2YXIgZmluYWxTdHlsZSA9IF9vYmplY3RTcHJlYWQoe1xuICAgIG1hcmdpbjogMCxcbiAgICBwYWRkaW5nOiAxMCxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZmJyxcbiAgICBib3JkZXI6ICcxcHggc29saWQgI2NjYycsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCdcbiAgfSwgY29udGVudFN0eWxlKTtcbiAgdmFyIGZpbmFsTGFiZWxTdHlsZSA9IF9vYmplY3RTcHJlYWQoe1xuICAgIG1hcmdpbjogMFxuICB9LCBsYWJlbFN0eWxlKTtcbiAgdmFyIGhhc0xhYmVsID0gISgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShsYWJlbCk7XG4gIHZhciBmaW5hbExhYmVsID0gaGFzTGFiZWwgPyBsYWJlbCA6ICcnO1xuICB2YXIgd3JhcHBlckNOID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLWRlZmF1bHQtdG9vbHRpcCcsIHdyYXBwZXJDbGFzc05hbWUpO1xuICB2YXIgbGFiZWxDTiA9ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy10b29sdGlwLWxhYmVsJywgbGFiZWxDbGFzc05hbWUpO1xuICBpZiAoaGFzTGFiZWwgJiYgbGFiZWxGb3JtYXR0ZXIgJiYgcGF5bG9hZCAhPT0gdW5kZWZpbmVkICYmIHBheWxvYWQgIT09IG51bGwpIHtcbiAgICBmaW5hbExhYmVsID0gbGFiZWxGb3JtYXR0ZXIobGFiZWwsIHBheWxvYWQpO1xuICB9XG4gIHZhciBhY2Nlc3NpYmlsaXR5QXR0cmlidXRlcyA9IGFjY2Vzc2liaWxpdHlMYXllciA/IHtcbiAgICByb2xlOiAnc3RhdHVzJyxcbiAgICAnYXJpYS1saXZlJzogJ2Fzc2VydGl2ZSdcbiAgfSA6IHt9O1xuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiB3cmFwcGVyQ04sXG4gICAgc3R5bGU6IGZpbmFsU3R5bGVcbiAgfSwgYWNjZXNzaWJpbGl0eUF0dHJpYnV0ZXMpLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicFwiLCB7XG4gICAgY2xhc3NOYW1lOiBsYWJlbENOLFxuICAgIHN0eWxlOiBmaW5hbExhYmVsU3R5bGVcbiAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQoZmluYWxMYWJlbCkgPyBmaW5hbExhYmVsIDogXCJcIi5jb25jYXQoZmluYWxMYWJlbCkpLCByZW5kZXJDb250ZW50KCkpO1xufTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJEZWZhdWx0VG9vbHRpcENvbnRlbnQiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9zb3J0QnkiLCJfaXNOaWwiLCJfY2xzeCIsIl9EYXRhVXRpbHMiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibGVuIiwiYXJyMiIsInIiLCJsIiwidCIsImUiLCJ1IiwiYSIsImYiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJpc0FycmF5Iiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsImRlZmF1bHRGb3JtYXR0ZXIiLCJpc051bU9yU3RyIiwiam9pbiIsInByb3BzIiwiX3Byb3BzJHNlcGFyYXRvciIsInNlcGFyYXRvciIsIl9wcm9wcyRjb250ZW50U3R5bGUiLCJjb250ZW50U3R5bGUiLCJfcHJvcHMkaXRlbVN0eWxlIiwiaXRlbVN0eWxlIiwiX3Byb3BzJGxhYmVsU3R5bGUiLCJsYWJlbFN0eWxlIiwicGF5bG9hZCIsImZvcm1hdHRlciIsIml0ZW1Tb3J0ZXIiLCJ3cmFwcGVyQ2xhc3NOYW1lIiwibGFiZWxDbGFzc05hbWUiLCJsYWJlbCIsImxhYmVsRm9ybWF0dGVyIiwiX3Byb3BzJGFjY2Vzc2liaWxpdHlMIiwiYWNjZXNzaWJpbGl0eUxheWVyIiwicmVuZGVyQ29udGVudCIsImxpc3RTdHlsZSIsInBhZGRpbmciLCJtYXJnaW4iLCJpdGVtcyIsIm1hcCIsImVudHJ5IiwidHlwZSIsImZpbmFsSXRlbVN0eWxlIiwiZGlzcGxheSIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiY29sb3IiLCJmaW5hbEZvcm1hdHRlciIsImZpbmFsVmFsdWUiLCJmaW5hbE5hbWUiLCJmb3JtYXR0ZWQiLCJfZm9ybWF0dGVkIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImNvbmNhdCIsInN0eWxlIiwidW5pdCIsImZpbmFsU3R5bGUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXIiLCJ3aGl0ZVNwYWNlIiwiZmluYWxMYWJlbFN0eWxlIiwiaGFzTGFiZWwiLCJmaW5hbExhYmVsIiwid3JhcHBlckNOIiwibGFiZWxDTiIsInVuZGVmaW5lZCIsImFjY2Vzc2liaWxpdHlBdHRyaWJ1dGVzIiwicm9sZSIsImlzVmFsaWRFbGVtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/component/DefaultTooltipContent.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/component/Label.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/component/Label.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Label = Label;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _isObject = _interopRequireDefault(__webpack_require__(/*! lodash/isObject */ \"lodash/isObject\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _Text = __webpack_require__(/*! ./Text */ \"./node_modules/recharts/lib/component/Text.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _excluded = [\n    \"offset\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nvar getLabel = function getLabel(props) {\n    var value = props.value, formatter = props.formatter;\n    var label = (0, _isNil[\"default\"])(props.children) ? value : props.children;\n    if ((0, _isFunction[\"default\"])(formatter)) {\n        return formatter(label);\n    }\n    return label;\n};\nvar getDeltaAngle = function getDeltaAngle(startAngle, endAngle) {\n    var sign = (0, _DataUtils.mathSign)(endAngle - startAngle);\n    var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);\n    return sign * deltaAngle;\n};\nvar renderRadialLabel = function renderRadialLabel(labelProps, label, attrs) {\n    var position = labelProps.position, viewBox = labelProps.viewBox, offset = labelProps.offset, className = labelProps.className;\n    var _ref = viewBox, cx = _ref.cx, cy = _ref.cy, innerRadius = _ref.innerRadius, outerRadius = _ref.outerRadius, startAngle = _ref.startAngle, endAngle = _ref.endAngle, clockWise = _ref.clockWise;\n    var radius = (innerRadius + outerRadius) / 2;\n    var deltaAngle = getDeltaAngle(startAngle, endAngle);\n    var sign = deltaAngle >= 0 ? 1 : -1;\n    var labelAngle, direction;\n    if (position === \"insideStart\") {\n        labelAngle = startAngle + sign * offset;\n        direction = clockWise;\n    } else if (position === \"insideEnd\") {\n        labelAngle = endAngle - sign * offset;\n        direction = !clockWise;\n    } else if (position === \"end\") {\n        labelAngle = endAngle + sign * offset;\n        direction = clockWise;\n    }\n    direction = deltaAngle <= 0 ? direction : !direction;\n    var startPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, labelAngle);\n    var endPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, labelAngle + (direction ? 1 : -1) * 359);\n    var path = \"M\".concat(startPoint.x, \",\").concat(startPoint.y, \"\\n    A\").concat(radius, \",\").concat(radius, \",0,1,\").concat(direction ? 0 : 1, \",\\n    \").concat(endPoint.x, \",\").concat(endPoint.y);\n    var id = (0, _isNil[\"default\"])(labelProps.id) ? (0, _DataUtils.uniqueId)(\"recharts-radial-line-\") : labelProps.id;\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"text\", _extends({}, attrs, {\n        dominantBaseline: \"central\",\n        className: (0, _clsx[\"default\"])(\"recharts-radial-bar-label\", className)\n    }), /*#__PURE__*/ _react[\"default\"].createElement(\"defs\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"path\", {\n        id: id,\n        d: path\n    })), /*#__PURE__*/ _react[\"default\"].createElement(\"textPath\", {\n        xlinkHref: \"#\".concat(id)\n    }, label));\n};\nvar getAttrsOfPolarLabel = function getAttrsOfPolarLabel(props) {\n    var viewBox = props.viewBox, offset = props.offset, position = props.position;\n    var _ref2 = viewBox, cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius, startAngle = _ref2.startAngle, endAngle = _ref2.endAngle;\n    var midAngle = (startAngle + endAngle) / 2;\n    if (position === \"outside\") {\n        var _polarToCartesian = (0, _PolarUtils.polarToCartesian)(cx, cy, outerRadius + offset, midAngle), _x = _polarToCartesian.x, _y = _polarToCartesian.y;\n        return {\n            x: _x,\n            y: _y,\n            textAnchor: _x >= cx ? \"start\" : \"end\",\n            verticalAnchor: \"middle\"\n        };\n    }\n    if (position === \"center\") {\n        return {\n            x: cx,\n            y: cy,\n            textAnchor: \"middle\",\n            verticalAnchor: \"middle\"\n        };\n    }\n    if (position === \"centerTop\") {\n        return {\n            x: cx,\n            y: cy,\n            textAnchor: \"middle\",\n            verticalAnchor: \"start\"\n        };\n    }\n    if (position === \"centerBottom\") {\n        return {\n            x: cx,\n            y: cy,\n            textAnchor: \"middle\",\n            verticalAnchor: \"end\"\n        };\n    }\n    var r = (innerRadius + outerRadius) / 2;\n    var _polarToCartesian2 = (0, _PolarUtils.polarToCartesian)(cx, cy, r, midAngle), x = _polarToCartesian2.x, y = _polarToCartesian2.y;\n    return {\n        x: x,\n        y: y,\n        textAnchor: \"middle\",\n        verticalAnchor: \"middle\"\n    };\n};\nvar getAttrsOfCartesianLabel = function getAttrsOfCartesianLabel(props) {\n    var viewBox = props.viewBox, parentViewBox = props.parentViewBox, offset = props.offset, position = props.position;\n    var _ref3 = viewBox, x = _ref3.x, y = _ref3.y, width = _ref3.width, height = _ref3.height;\n    // Define vertical offsets and position inverts based on the value being positive or negative\n    var verticalSign = height >= 0 ? 1 : -1;\n    var verticalOffset = verticalSign * offset;\n    var verticalEnd = verticalSign > 0 ? \"end\" : \"start\";\n    var verticalStart = verticalSign > 0 ? \"start\" : \"end\";\n    // Define horizontal offsets and position inverts based on the value being positive or negative\n    var horizontalSign = width >= 0 ? 1 : -1;\n    var horizontalOffset = horizontalSign * offset;\n    var horizontalEnd = horizontalSign > 0 ? \"end\" : \"start\";\n    var horizontalStart = horizontalSign > 0 ? \"start\" : \"end\";\n    if (position === \"top\") {\n        var attrs = {\n            x: x + width / 2,\n            y: y - verticalSign * offset,\n            textAnchor: \"middle\",\n            verticalAnchor: verticalEnd\n        };\n        return _objectSpread(_objectSpread({}, attrs), parentViewBox ? {\n            height: Math.max(y - parentViewBox.y, 0),\n            width: width\n        } : {});\n    }\n    if (position === \"bottom\") {\n        var _attrs = {\n            x: x + width / 2,\n            y: y + height + verticalOffset,\n            textAnchor: \"middle\",\n            verticalAnchor: verticalStart\n        };\n        return _objectSpread(_objectSpread({}, _attrs), parentViewBox ? {\n            height: Math.max(parentViewBox.y + parentViewBox.height - (y + height), 0),\n            width: width\n        } : {});\n    }\n    if (position === \"left\") {\n        var _attrs2 = {\n            x: x - horizontalOffset,\n            y: y + height / 2,\n            textAnchor: horizontalEnd,\n            verticalAnchor: \"middle\"\n        };\n        return _objectSpread(_objectSpread({}, _attrs2), parentViewBox ? {\n            width: Math.max(_attrs2.x - parentViewBox.x, 0),\n            height: height\n        } : {});\n    }\n    if (position === \"right\") {\n        var _attrs3 = {\n            x: x + width + horizontalOffset,\n            y: y + height / 2,\n            textAnchor: horizontalStart,\n            verticalAnchor: \"middle\"\n        };\n        return _objectSpread(_objectSpread({}, _attrs3), parentViewBox ? {\n            width: Math.max(parentViewBox.x + parentViewBox.width - _attrs3.x, 0),\n            height: height\n        } : {});\n    }\n    var sizeAttrs = parentViewBox ? {\n        width: width,\n        height: height\n    } : {};\n    if (position === \"insideLeft\") {\n        return _objectSpread({\n            x: x + horizontalOffset,\n            y: y + height / 2,\n            textAnchor: horizontalStart,\n            verticalAnchor: \"middle\"\n        }, sizeAttrs);\n    }\n    if (position === \"insideRight\") {\n        return _objectSpread({\n            x: x + width - horizontalOffset,\n            y: y + height / 2,\n            textAnchor: horizontalEnd,\n            verticalAnchor: \"middle\"\n        }, sizeAttrs);\n    }\n    if (position === \"insideTop\") {\n        return _objectSpread({\n            x: x + width / 2,\n            y: y + verticalOffset,\n            textAnchor: \"middle\",\n            verticalAnchor: verticalStart\n        }, sizeAttrs);\n    }\n    if (position === \"insideBottom\") {\n        return _objectSpread({\n            x: x + width / 2,\n            y: y + height - verticalOffset,\n            textAnchor: \"middle\",\n            verticalAnchor: verticalEnd\n        }, sizeAttrs);\n    }\n    if (position === \"insideTopLeft\") {\n        return _objectSpread({\n            x: x + horizontalOffset,\n            y: y + verticalOffset,\n            textAnchor: horizontalStart,\n            verticalAnchor: verticalStart\n        }, sizeAttrs);\n    }\n    if (position === \"insideTopRight\") {\n        return _objectSpread({\n            x: x + width - horizontalOffset,\n            y: y + verticalOffset,\n            textAnchor: horizontalEnd,\n            verticalAnchor: verticalStart\n        }, sizeAttrs);\n    }\n    if (position === \"insideBottomLeft\") {\n        return _objectSpread({\n            x: x + horizontalOffset,\n            y: y + height - verticalOffset,\n            textAnchor: horizontalStart,\n            verticalAnchor: verticalEnd\n        }, sizeAttrs);\n    }\n    if (position === \"insideBottomRight\") {\n        return _objectSpread({\n            x: x + width - horizontalOffset,\n            y: y + height - verticalOffset,\n            textAnchor: horizontalEnd,\n            verticalAnchor: verticalEnd\n        }, sizeAttrs);\n    }\n    if ((0, _isObject[\"default\"])(position) && ((0, _DataUtils.isNumber)(position.x) || (0, _DataUtils.isPercent)(position.x)) && ((0, _DataUtils.isNumber)(position.y) || (0, _DataUtils.isPercent)(position.y))) {\n        return _objectSpread({\n            x: x + (0, _DataUtils.getPercentValue)(position.x, width),\n            y: y + (0, _DataUtils.getPercentValue)(position.y, height),\n            textAnchor: \"end\",\n            verticalAnchor: \"end\"\n        }, sizeAttrs);\n    }\n    return _objectSpread({\n        x: x + width / 2,\n        y: y + height / 2,\n        textAnchor: \"middle\",\n        verticalAnchor: \"middle\"\n    }, sizeAttrs);\n};\nvar isPolar = function isPolar(viewBox) {\n    return \"cx\" in viewBox && (0, _DataUtils.isNumber)(viewBox.cx);\n};\nfunction Label(_ref4) {\n    var _ref4$offset = _ref4.offset, offset = _ref4$offset === void 0 ? 5 : _ref4$offset, restProps = _objectWithoutProperties(_ref4, _excluded);\n    var props = _objectSpread({\n        offset: offset\n    }, restProps);\n    var viewBox = props.viewBox, position = props.position, value = props.value, children = props.children, content = props.content, _props$className = props.className, className = _props$className === void 0 ? \"\" : _props$className, textBreakAll = props.textBreakAll;\n    if (!viewBox || (0, _isNil[\"default\"])(value) && (0, _isNil[\"default\"])(children) && !/*#__PURE__*/ (0, _react.isValidElement)(content) && !(0, _isFunction[\"default\"])(content)) {\n        return null;\n    }\n    if (/*#__PURE__*/ (0, _react.isValidElement)(content)) {\n        return /*#__PURE__*/ (0, _react.cloneElement)(content, props);\n    }\n    var label;\n    if ((0, _isFunction[\"default\"])(content)) {\n        label = /*#__PURE__*/ (0, _react.createElement)(content, props);\n        if (/*#__PURE__*/ (0, _react.isValidElement)(label)) {\n            return label;\n        }\n    } else {\n        label = getLabel(props);\n    }\n    var isPolarLabel = isPolar(viewBox);\n    var attrs = (0, _ReactUtils.filterProps)(props, true);\n    if (isPolarLabel && (position === \"insideStart\" || position === \"insideEnd\" || position === \"end\")) {\n        return renderRadialLabel(props, label, attrs);\n    }\n    var positionAttrs = isPolarLabel ? getAttrsOfPolarLabel(props) : getAttrsOfCartesianLabel(props);\n    return /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({\n        className: (0, _clsx[\"default\"])(\"recharts-label\", className)\n    }, attrs, positionAttrs, {\n        breakAll: textBreakAll\n    }), label);\n}\nLabel.displayName = \"Label\";\nvar parseViewBox = function parseViewBox(props) {\n    var cx = props.cx, cy = props.cy, angle = props.angle, startAngle = props.startAngle, endAngle = props.endAngle, r = props.r, radius = props.radius, innerRadius = props.innerRadius, outerRadius = props.outerRadius, x = props.x, y = props.y, top = props.top, left = props.left, width = props.width, height = props.height, clockWise = props.clockWise, labelViewBox = props.labelViewBox;\n    if (labelViewBox) {\n        return labelViewBox;\n    }\n    if ((0, _DataUtils.isNumber)(width) && (0, _DataUtils.isNumber)(height)) {\n        if ((0, _DataUtils.isNumber)(x) && (0, _DataUtils.isNumber)(y)) {\n            return {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            };\n        }\n        if ((0, _DataUtils.isNumber)(top) && (0, _DataUtils.isNumber)(left)) {\n            return {\n                x: top,\n                y: left,\n                width: width,\n                height: height\n            };\n        }\n    }\n    if ((0, _DataUtils.isNumber)(x) && (0, _DataUtils.isNumber)(y)) {\n        return {\n            x: x,\n            y: y,\n            width: 0,\n            height: 0\n        };\n    }\n    if ((0, _DataUtils.isNumber)(cx) && (0, _DataUtils.isNumber)(cy)) {\n        return {\n            cx: cx,\n            cy: cy,\n            startAngle: startAngle || angle || 0,\n            endAngle: endAngle || angle || 0,\n            innerRadius: innerRadius || 0,\n            outerRadius: outerRadius || radius || r || 0,\n            clockWise: clockWise\n        };\n    }\n    if (props.viewBox) {\n        return props.viewBox;\n    }\n    return {};\n};\nvar parseLabel = function parseLabel(label, viewBox) {\n    if (!label) {\n        return null;\n    }\n    if (label === true) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(Label, {\n            key: \"label-implicit\",\n            viewBox: viewBox\n        });\n    }\n    if ((0, _DataUtils.isNumOrStr)(label)) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(Label, {\n            key: \"label-implicit\",\n            viewBox: viewBox,\n            value: label\n        });\n    }\n    if (/*#__PURE__*/ (0, _react.isValidElement)(label)) {\n        if (label.type === Label) {\n            return /*#__PURE__*/ (0, _react.cloneElement)(label, {\n                key: \"label-implicit\",\n                viewBox: viewBox\n            });\n        }\n        return /*#__PURE__*/ _react[\"default\"].createElement(Label, {\n            key: \"label-implicit\",\n            content: label,\n            viewBox: viewBox\n        });\n    }\n    if ((0, _isFunction[\"default\"])(label)) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(Label, {\n            key: \"label-implicit\",\n            content: label,\n            viewBox: viewBox\n        });\n    }\n    if ((0, _isObject[\"default\"])(label)) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(Label, _extends({\n            viewBox: viewBox\n        }, label, {\n            key: \"label-implicit\"\n        }));\n    }\n    return null;\n};\nvar renderCallByParent = function renderCallByParent(parentProps, viewBox) {\n    var checkPropsLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) {\n        return null;\n    }\n    var children = parentProps.children;\n    var parentViewBox = parseViewBox(parentProps);\n    var explicitChildren = (0, _ReactUtils.findAllByType)(children, Label).map(function(child, index) {\n        return /*#__PURE__*/ (0, _react.cloneElement)(child, {\n            viewBox: viewBox || parentViewBox,\n            // eslint-disable-next-line react/no-array-index-key\n            key: \"label-\".concat(index)\n        });\n    });\n    if (!checkPropsLabel) {\n        return explicitChildren;\n    }\n    var implicitLabel = parseLabel(parentProps.label, viewBox || parentViewBox);\n    return [\n        implicitLabel\n    ].concat(_toConsumableArray(explicitChildren));\n};\nLabel.parseViewBox = parseViewBox;\nLabel.renderCallByParent = renderCallByParent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9MYWJlbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VEssOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGFBQWEsR0FBR0U7QUFDaEIsSUFBSUMsU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyxTQUFTQyx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlHLGNBQWNELHVCQUF1QkYsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlJLFlBQVlGLHVCQUF1QkYsbUJBQU9BLENBQUMsd0NBQWlCO0FBQ2hFLElBQUlLLFFBQVFILHVCQUF1QkYsbUJBQU9BLENBQUMsa0JBQU07QUFDakQsSUFBSU0sUUFBUU4sbUJBQU9BLENBQUMsNkRBQVE7QUFDNUIsSUFBSU8sY0FBY1AsbUJBQU9BLENBQUMsMEVBQW9CO0FBQzlDLElBQUlRLGFBQWFSLG1CQUFPQSxDQUFDLHdFQUFtQjtBQUM1QyxJQUFJUyxjQUFjVCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSVUsWUFBWTtJQUFDO0NBQVM7QUFDMUIsU0FBU1IsdUJBQXVCUyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLHlCQUF5QkMsQ0FBQztJQUFJ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QW9EO1lBQ3BEaEYsS0FBSyxTQUFTNkQsTUFBTSxDQUFDc0U7UUFDdkI7SUFDRjtJQUNBLElBQUksQ0FBQ04saUJBQWlCO1FBQ3BCLE9BQU9FO0lBQ1Q7SUFDQSxJQUFJSyxnQkFBZ0JaLFdBQVdJLFlBQVk5RixLQUFLLEVBQUVlLFdBQVdtQztJQUM3RCxPQUFPO1FBQUNvRDtLQUFjLENBQUN2RSxNQUFNLENBQUN0RixtQkFBbUJ3SjtBQUNuRDtBQUNBeEwsTUFBTTRLLFlBQVksR0FBR0E7QUFDckI1SyxNQUFNb0wsa0JBQWtCLEdBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9jb21wb25lbnQvTGFiZWwuanM/YWM1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTGFiZWwgPSBMYWJlbDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9pc05pbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc05pbFwiKSk7XG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XG52YXIgX2lzT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzT2JqZWN0XCIpKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xudmFyIF9UZXh0ID0gcmVxdWlyZShcIi4vVGV4dFwiKTtcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcbnZhciBfUG9sYXJVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1BvbGFyVXRpbHNcIik7XG52YXIgX2V4Y2x1ZGVkID0gW1wib2Zmc2V0XCJdO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxudmFyIGdldExhYmVsID0gZnVuY3Rpb24gZ2V0TGFiZWwocHJvcHMpIHtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWUsXG4gICAgZm9ybWF0dGVyID0gcHJvcHMuZm9ybWF0dGVyO1xuICB2YXIgbGFiZWwgPSAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkocHJvcHMuY2hpbGRyZW4pID8gdmFsdWUgOiBwcm9wcy5jaGlsZHJlbjtcbiAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKGZvcm1hdHRlcikpIHtcbiAgICByZXR1cm4gZm9ybWF0dGVyKGxhYmVsKTtcbiAgfVxuICByZXR1cm4gbGFiZWw7XG59O1xudmFyIGdldERlbHRhQW5nbGUgPSBmdW5jdGlvbiBnZXREZWx0YUFuZ2xlKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XG4gIHZhciBzaWduID0gKDAsIF9EYXRhVXRpbHMubWF0aFNpZ24pKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gIHZhciBkZWx0YUFuZ2xlID0gTWF0aC5taW4oTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSwgMzYwKTtcbiAgcmV0dXJuIHNpZ24gKiBkZWx0YUFuZ2xlO1xufTtcbnZhciByZW5kZXJSYWRpYWxMYWJlbCA9IGZ1bmN0aW9uIHJlbmRlclJhZGlhbExhYmVsKGxhYmVsUHJvcHMsIGxhYmVsLCBhdHRycykge1xuICB2YXIgcG9zaXRpb24gPSBsYWJlbFByb3BzLnBvc2l0aW9uLFxuICAgIHZpZXdCb3ggPSBsYWJlbFByb3BzLnZpZXdCb3gsXG4gICAgb2Zmc2V0ID0gbGFiZWxQcm9wcy5vZmZzZXQsXG4gICAgY2xhc3NOYW1lID0gbGFiZWxQcm9wcy5jbGFzc05hbWU7XG4gIHZhciBfcmVmID0gdmlld0JveCxcbiAgICBjeCA9IF9yZWYuY3gsXG4gICAgY3kgPSBfcmVmLmN5LFxuICAgIGlubmVyUmFkaXVzID0gX3JlZi5pbm5lclJhZGl1cyxcbiAgICBvdXRlclJhZGl1cyA9IF9yZWYub3V0ZXJSYWRpdXMsXG4gICAgc3RhcnRBbmdsZSA9IF9yZWYuc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZSA9IF9yZWYuZW5kQW5nbGUsXG4gICAgY2xvY2tXaXNlID0gX3JlZi5jbG9ja1dpc2U7XG4gIHZhciByYWRpdXMgPSAoaW5uZXJSYWRpdXMgKyBvdXRlclJhZGl1cykgLyAyO1xuICB2YXIgZGVsdGFBbmdsZSA9IGdldERlbHRhQW5nbGUoc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICB2YXIgc2lnbiA9IGRlbHRhQW5nbGUgPj0gMCA/IDEgOiAtMTtcbiAgdmFyIGxhYmVsQW5nbGUsIGRpcmVjdGlvbjtcbiAgaWYgKHBvc2l0aW9uID09PSAnaW5zaWRlU3RhcnQnKSB7XG4gICAgbGFiZWxBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzaWduICogb2Zmc2V0O1xuICAgIGRpcmVjdGlvbiA9IGNsb2NrV2lzZTtcbiAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2luc2lkZUVuZCcpIHtcbiAgICBsYWJlbEFuZ2xlID0gZW5kQW5nbGUgLSBzaWduICogb2Zmc2V0O1xuICAgIGRpcmVjdGlvbiA9ICFjbG9ja1dpc2U7XG4gIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdlbmQnKSB7XG4gICAgbGFiZWxBbmdsZSA9IGVuZEFuZ2xlICsgc2lnbiAqIG9mZnNldDtcbiAgICBkaXJlY3Rpb24gPSBjbG9ja1dpc2U7XG4gIH1cbiAgZGlyZWN0aW9uID0gZGVsdGFBbmdsZSA8PSAwID8gZGlyZWN0aW9uIDogIWRpcmVjdGlvbjtcbiAgdmFyIHN0YXJ0UG9pbnQgPSAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCByYWRpdXMsIGxhYmVsQW5nbGUpO1xuICB2YXIgZW5kUG9pbnQgPSAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCByYWRpdXMsIGxhYmVsQW5nbGUgKyAoZGlyZWN0aW9uID8gMSA6IC0xKSAqIDM1OSk7XG4gIHZhciBwYXRoID0gXCJNXCIuY29uY2F0KHN0YXJ0UG9pbnQueCwgXCIsXCIpLmNvbmNhdChzdGFydFBvaW50LnksIFwiXFxuICAgIEFcIikuY29uY2F0KHJhZGl1cywgXCIsXCIpLmNvbmNhdChyYWRpdXMsIFwiLDAsMSxcIikuY29uY2F0KGRpcmVjdGlvbiA/IDAgOiAxLCBcIixcXG4gICAgXCIpLmNvbmNhdChlbmRQb2ludC54LCBcIixcIikuY29uY2F0KGVuZFBvaW50LnkpO1xuICB2YXIgaWQgPSAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkobGFiZWxQcm9wcy5pZCkgPyAoMCwgX0RhdGFVdGlscy51bmlxdWVJZCkoJ3JlY2hhcnRzLXJhZGlhbC1saW5lLScpIDogbGFiZWxQcm9wcy5pZDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0XCIsIF9leHRlbmRzKHt9LCBhdHRycywge1xuICAgIGRvbWluYW50QmFzZWxpbmU6IFwiY2VudHJhbFwiLFxuICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXJhZGlhbC1iYXItbGFiZWwnLCBjbGFzc05hbWUpXG4gIH0pLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgaWQ6IGlkLFxuICAgIGQ6IHBhdGhcbiAgfSkpLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwidGV4dFBhdGhcIiwge1xuICAgIHhsaW5rSHJlZjogXCIjXCIuY29uY2F0KGlkKVxuICB9LCBsYWJlbCkpO1xufTtcbnZhciBnZXRBdHRyc09mUG9sYXJMYWJlbCA9IGZ1bmN0aW9uIGdldEF0dHJzT2ZQb2xhckxhYmVsKHByb3BzKSB7XG4gIHZhciB2aWV3Qm94ID0gcHJvcHMudmlld0JveCxcbiAgICBvZmZzZXQgPSBwcm9wcy5vZmZzZXQsXG4gICAgcG9zaXRpb24gPSBwcm9wcy5wb3NpdGlvbjtcbiAgdmFyIF9yZWYyID0gdmlld0JveCxcbiAgICBjeCA9IF9yZWYyLmN4LFxuICAgIGN5ID0gX3JlZjIuY3ksXG4gICAgaW5uZXJSYWRpdXMgPSBfcmVmMi5pbm5lclJhZGl1cyxcbiAgICBvdXRlclJhZGl1cyA9IF9yZWYyLm91dGVyUmFkaXVzLFxuICAgIHN0YXJ0QW5nbGUgPSBfcmVmMi5zdGFydEFuZ2xlLFxuICAgIGVuZEFuZ2xlID0gX3JlZjIuZW5kQW5nbGU7XG4gIHZhciBtaWRBbmdsZSA9IChzdGFydEFuZ2xlICsgZW5kQW5nbGUpIC8gMjtcbiAgaWYgKHBvc2l0aW9uID09PSAnb3V0c2lkZScpIHtcbiAgICB2YXIgX3BvbGFyVG9DYXJ0ZXNpYW4gPSAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCBvdXRlclJhZGl1cyArIG9mZnNldCwgbWlkQW5nbGUpLFxuICAgICAgX3ggPSBfcG9sYXJUb0NhcnRlc2lhbi54LFxuICAgICAgX3kgPSBfcG9sYXJUb0NhcnRlc2lhbi55O1xuICAgIHJldHVybiB7XG4gICAgICB4OiBfeCxcbiAgICAgIHk6IF95LFxuICAgICAgdGV4dEFuY2hvcjogX3ggPj0gY3ggPyAnc3RhcnQnIDogJ2VuZCcsXG4gICAgICB2ZXJ0aWNhbEFuY2hvcjogJ21pZGRsZSdcbiAgICB9O1xuICB9XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogY3gsXG4gICAgICB5OiBjeSxcbiAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgdmVydGljYWxBbmNob3I6ICdtaWRkbGUnXG4gICAgfTtcbiAgfVxuICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXJUb3AnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGN4LFxuICAgICAgeTogY3ksXG4gICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiAnc3RhcnQnXG4gICAgfTtcbiAgfVxuICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXJCb3R0b20nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGN4LFxuICAgICAgeTogY3ksXG4gICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiAnZW5kJ1xuICAgIH07XG4gIH1cbiAgdmFyIHIgPSAoaW5uZXJSYWRpdXMgKyBvdXRlclJhZGl1cykgLyAyO1xuICB2YXIgX3BvbGFyVG9DYXJ0ZXNpYW4yID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgciwgbWlkQW5nbGUpLFxuICAgIHggPSBfcG9sYXJUb0NhcnRlc2lhbjIueCxcbiAgICB5ID0gX3BvbGFyVG9DYXJ0ZXNpYW4yLnk7XG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgIHZlcnRpY2FsQW5jaG9yOiAnbWlkZGxlJ1xuICB9O1xufTtcbnZhciBnZXRBdHRyc09mQ2FydGVzaWFuTGFiZWwgPSBmdW5jdGlvbiBnZXRBdHRyc09mQ2FydGVzaWFuTGFiZWwocHJvcHMpIHtcbiAgdmFyIHZpZXdCb3ggPSBwcm9wcy52aWV3Qm94LFxuICAgIHBhcmVudFZpZXdCb3ggPSBwcm9wcy5wYXJlbnRWaWV3Qm94LFxuICAgIG9mZnNldCA9IHByb3BzLm9mZnNldCxcbiAgICBwb3NpdGlvbiA9IHByb3BzLnBvc2l0aW9uO1xuICB2YXIgX3JlZjMgPSB2aWV3Qm94LFxuICAgIHggPSBfcmVmMy54LFxuICAgIHkgPSBfcmVmMy55LFxuICAgIHdpZHRoID0gX3JlZjMud2lkdGgsXG4gICAgaGVpZ2h0ID0gX3JlZjMuaGVpZ2h0O1xuXG4gIC8vIERlZmluZSB2ZXJ0aWNhbCBvZmZzZXRzIGFuZCBwb3NpdGlvbiBpbnZlcnRzIGJhc2VkIG9uIHRoZSB2YWx1ZSBiZWluZyBwb3NpdGl2ZSBvciBuZWdhdGl2ZVxuICB2YXIgdmVydGljYWxTaWduID0gaGVpZ2h0ID49IDAgPyAxIDogLTE7XG4gIHZhciB2ZXJ0aWNhbE9mZnNldCA9IHZlcnRpY2FsU2lnbiAqIG9mZnNldDtcbiAgdmFyIHZlcnRpY2FsRW5kID0gdmVydGljYWxTaWduID4gMCA/ICdlbmQnIDogJ3N0YXJ0JztcbiAgdmFyIHZlcnRpY2FsU3RhcnQgPSB2ZXJ0aWNhbFNpZ24gPiAwID8gJ3N0YXJ0JyA6ICdlbmQnO1xuXG4gIC8vIERlZmluZSBob3Jpem9udGFsIG9mZnNldHMgYW5kIHBvc2l0aW9uIGludmVydHMgYmFzZWQgb24gdGhlIHZhbHVlIGJlaW5nIHBvc2l0aXZlIG9yIG5lZ2F0aXZlXG4gIHZhciBob3Jpem9udGFsU2lnbiA9IHdpZHRoID49IDAgPyAxIDogLTE7XG4gIHZhciBob3Jpem9udGFsT2Zmc2V0ID0gaG9yaXpvbnRhbFNpZ24gKiBvZmZzZXQ7XG4gIHZhciBob3Jpem9udGFsRW5kID0gaG9yaXpvbnRhbFNpZ24gPiAwID8gJ2VuZCcgOiAnc3RhcnQnO1xuICB2YXIgaG9yaXpvbnRhbFN0YXJ0ID0gaG9yaXpvbnRhbFNpZ24gPiAwID8gJ3N0YXJ0JyA6ICdlbmQnO1xuICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgdmFyIGF0dHJzID0ge1xuICAgICAgeDogeCArIHdpZHRoIC8gMixcbiAgICAgIHk6IHkgLSB2ZXJ0aWNhbFNpZ24gKiBvZmZzZXQsXG4gICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiB2ZXJ0aWNhbEVuZFxuICAgIH07XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYXR0cnMpLCBwYXJlbnRWaWV3Qm94ID8ge1xuICAgICAgaGVpZ2h0OiBNYXRoLm1heCh5IC0gcGFyZW50Vmlld0JveC55LCAwKSxcbiAgICAgIHdpZHRoOiB3aWR0aFxuICAgIH0gOiB7fSk7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgIHZhciBfYXR0cnMgPSB7XG4gICAgICB4OiB4ICsgd2lkdGggLyAyLFxuICAgICAgeTogeSArIGhlaWdodCArIHZlcnRpY2FsT2Zmc2V0LFxuICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICB2ZXJ0aWNhbEFuY2hvcjogdmVydGljYWxTdGFydFxuICAgIH07XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX2F0dHJzKSwgcGFyZW50Vmlld0JveCA/IHtcbiAgICAgIGhlaWdodDogTWF0aC5tYXgocGFyZW50Vmlld0JveC55ICsgcGFyZW50Vmlld0JveC5oZWlnaHQgLSAoeSArIGhlaWdodCksIDApLFxuICAgICAgd2lkdGg6IHdpZHRoXG4gICAgfSA6IHt9KTtcbiAgfVxuICBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgIHZhciBfYXR0cnMyID0ge1xuICAgICAgeDogeCAtIGhvcml6b250YWxPZmZzZXQsXG4gICAgICB5OiB5ICsgaGVpZ2h0IC8gMixcbiAgICAgIHRleHRBbmNob3I6IGhvcml6b250YWxFbmQsXG4gICAgICB2ZXJ0aWNhbEFuY2hvcjogJ21pZGRsZSdcbiAgICB9O1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF9hdHRyczIpLCBwYXJlbnRWaWV3Qm94ID8ge1xuICAgICAgd2lkdGg6IE1hdGgubWF4KF9hdHRyczIueCAtIHBhcmVudFZpZXdCb3gueCwgMCksXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH0gOiB7fSk7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgdmFyIF9hdHRyczMgPSB7XG4gICAgICB4OiB4ICsgd2lkdGggKyBob3Jpem9udGFsT2Zmc2V0LFxuICAgICAgeTogeSArIGhlaWdodCAvIDIsXG4gICAgICB0ZXh0QW5jaG9yOiBob3Jpem9udGFsU3RhcnQsXG4gICAgICB2ZXJ0aWNhbEFuY2hvcjogJ21pZGRsZSdcbiAgICB9O1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF9hdHRyczMpLCBwYXJlbnRWaWV3Qm94ID8ge1xuICAgICAgd2lkdGg6IE1hdGgubWF4KHBhcmVudFZpZXdCb3gueCArIHBhcmVudFZpZXdCb3gud2lkdGggLSBfYXR0cnMzLngsIDApLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9IDoge30pO1xuICB9XG4gIHZhciBzaXplQXR0cnMgPSBwYXJlbnRWaWV3Qm94ID8ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9IDoge307XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2luc2lkZUxlZnQnKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgeDogeCArIGhvcml6b250YWxPZmZzZXQsXG4gICAgICB5OiB5ICsgaGVpZ2h0IC8gMixcbiAgICAgIHRleHRBbmNob3I6IGhvcml6b250YWxTdGFydCxcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiAnbWlkZGxlJ1xuICAgIH0sIHNpemVBdHRycyk7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSAnaW5zaWRlUmlnaHQnKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgeDogeCArIHdpZHRoIC0gaG9yaXpvbnRhbE9mZnNldCxcbiAgICAgIHk6IHkgKyBoZWlnaHQgLyAyLFxuICAgICAgdGV4dEFuY2hvcjogaG9yaXpvbnRhbEVuZCxcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiAnbWlkZGxlJ1xuICAgIH0sIHNpemVBdHRycyk7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSAnaW5zaWRlVG9wJykge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHg6IHggKyB3aWR0aCAvIDIsXG4gICAgICB5OiB5ICsgdmVydGljYWxPZmZzZXQsXG4gICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgIHZlcnRpY2FsQW5jaG9yOiB2ZXJ0aWNhbFN0YXJ0XG4gICAgfSwgc2l6ZUF0dHJzKTtcbiAgfVxuICBpZiAocG9zaXRpb24gPT09ICdpbnNpZGVCb3R0b20nKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgeDogeCArIHdpZHRoIC8gMixcbiAgICAgIHk6IHkgKyBoZWlnaHQgLSB2ZXJ0aWNhbE9mZnNldCxcbiAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgdmVydGljYWxBbmNob3I6IHZlcnRpY2FsRW5kXG4gICAgfSwgc2l6ZUF0dHJzKTtcbiAgfVxuICBpZiAocG9zaXRpb24gPT09ICdpbnNpZGVUb3BMZWZ0Jykge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHg6IHggKyBob3Jpem9udGFsT2Zmc2V0LFxuICAgICAgeTogeSArIHZlcnRpY2FsT2Zmc2V0LFxuICAgICAgdGV4dEFuY2hvcjogaG9yaXpvbnRhbFN0YXJ0LFxuICAgICAgdmVydGljYWxBbmNob3I6IHZlcnRpY2FsU3RhcnRcbiAgICB9LCBzaXplQXR0cnMpO1xuICB9XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2luc2lkZVRvcFJpZ2h0Jykge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHg6IHggKyB3aWR0aCAtIGhvcml6b250YWxPZmZzZXQsXG4gICAgICB5OiB5ICsgdmVydGljYWxPZmZzZXQsXG4gICAgICB0ZXh0QW5jaG9yOiBob3Jpem9udGFsRW5kLFxuICAgICAgdmVydGljYWxBbmNob3I6IHZlcnRpY2FsU3RhcnRcbiAgICB9LCBzaXplQXR0cnMpO1xuICB9XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2luc2lkZUJvdHRvbUxlZnQnKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgeDogeCArIGhvcml6b250YWxPZmZzZXQsXG4gICAgICB5OiB5ICsgaGVpZ2h0IC0gdmVydGljYWxPZmZzZXQsXG4gICAgICB0ZXh0QW5jaG9yOiBob3Jpem9udGFsU3RhcnQsXG4gICAgICB2ZXJ0aWNhbEFuY2hvcjogdmVydGljYWxFbmRcbiAgICB9LCBzaXplQXR0cnMpO1xuICB9XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2luc2lkZUJvdHRvbVJpZ2h0Jykge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHg6IHggKyB3aWR0aCAtIGhvcml6b250YWxPZmZzZXQsXG4gICAgICB5OiB5ICsgaGVpZ2h0IC0gdmVydGljYWxPZmZzZXQsXG4gICAgICB0ZXh0QW5jaG9yOiBob3Jpem9udGFsRW5kLFxuICAgICAgdmVydGljYWxBbmNob3I6IHZlcnRpY2FsRW5kXG4gICAgfSwgc2l6ZUF0dHJzKTtcbiAgfVxuICBpZiAoKDAsIF9pc09iamVjdFtcImRlZmF1bHRcIl0pKHBvc2l0aW9uKSAmJiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHBvc2l0aW9uLngpIHx8ICgwLCBfRGF0YVV0aWxzLmlzUGVyY2VudCkocG9zaXRpb24ueCkpICYmICgoMCwgX0RhdGFVdGlscy5pc051bWJlcikocG9zaXRpb24ueSkgfHwgKDAsIF9EYXRhVXRpbHMuaXNQZXJjZW50KShwb3NpdGlvbi55KSkpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgICB4OiB4ICsgKDAsIF9EYXRhVXRpbHMuZ2V0UGVyY2VudFZhbHVlKShwb3NpdGlvbi54LCB3aWR0aCksXG4gICAgICB5OiB5ICsgKDAsIF9EYXRhVXRpbHMuZ2V0UGVyY2VudFZhbHVlKShwb3NpdGlvbi55LCBoZWlnaHQpLFxuICAgICAgdGV4dEFuY2hvcjogJ2VuZCcsXG4gICAgICB2ZXJ0aWNhbEFuY2hvcjogJ2VuZCdcbiAgICB9LCBzaXplQXR0cnMpO1xuICB9XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICB4OiB4ICsgd2lkdGggLyAyLFxuICAgIHk6IHkgKyBoZWlnaHQgLyAyLFxuICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgIHZlcnRpY2FsQW5jaG9yOiAnbWlkZGxlJ1xuICB9LCBzaXplQXR0cnMpO1xufTtcbnZhciBpc1BvbGFyID0gZnVuY3Rpb24gaXNQb2xhcih2aWV3Qm94KSB7XG4gIHJldHVybiAnY3gnIGluIHZpZXdCb3ggJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHZpZXdCb3guY3gpO1xufTtcbmZ1bmN0aW9uIExhYmVsKF9yZWY0KSB7XG4gIHZhciBfcmVmNCRvZmZzZXQgPSBfcmVmNC5vZmZzZXQsXG4gICAgb2Zmc2V0ID0gX3JlZjQkb2Zmc2V0ID09PSB2b2lkIDAgPyA1IDogX3JlZjQkb2Zmc2V0LFxuICAgIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNCwgX2V4Y2x1ZGVkKTtcbiAgdmFyIHByb3BzID0gX29iamVjdFNwcmVhZCh7XG4gICAgb2Zmc2V0OiBvZmZzZXRcbiAgfSwgcmVzdFByb3BzKTtcbiAgdmFyIHZpZXdCb3ggPSBwcm9wcy52aWV3Qm94LFxuICAgIHBvc2l0aW9uID0gcHJvcHMucG9zaXRpb24sXG4gICAgdmFsdWUgPSBwcm9wcy52YWx1ZSxcbiAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgIGNvbnRlbnQgPSBwcm9wcy5jb250ZW50LFxuICAgIF9wcm9wcyRjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgY2xhc3NOYW1lID0gX3Byb3BzJGNsYXNzTmFtZSA9PT0gdm9pZCAwID8gJycgOiBfcHJvcHMkY2xhc3NOYW1lLFxuICAgIHRleHRCcmVha0FsbCA9IHByb3BzLnRleHRCcmVha0FsbDtcbiAgaWYgKCF2aWV3Qm94IHx8ICgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKSh2YWx1ZSkgJiYgKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGNoaWxkcmVuKSAmJiAhIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmlzVmFsaWRFbGVtZW50KShjb250ZW50KSAmJiAhKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkoY29udGVudCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmlzVmFsaWRFbGVtZW50KShjb250ZW50KSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGNvbnRlbnQsIHByb3BzKTtcbiAgfVxuICB2YXIgbGFiZWw7XG4gIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShjb250ZW50KSkge1xuICAgIGxhYmVsID0gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY3JlYXRlRWxlbWVudCkoY29udGVudCwgcHJvcHMpO1xuICAgIGlmICggLyojX19QVVJFX18qLygwLCBfcmVhY3QuaXNWYWxpZEVsZW1lbnQpKGxhYmVsKSkge1xuICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsYWJlbCA9IGdldExhYmVsKHByb3BzKTtcbiAgfVxuICB2YXIgaXNQb2xhckxhYmVsID0gaXNQb2xhcih2aWV3Qm94KTtcbiAgdmFyIGF0dHJzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShwcm9wcywgdHJ1ZSk7XG4gIGlmIChpc1BvbGFyTGFiZWwgJiYgKHBvc2l0aW9uID09PSAnaW5zaWRlU3RhcnQnIHx8IHBvc2l0aW9uID09PSAnaW5zaWRlRW5kJyB8fCBwb3NpdGlvbiA9PT0gJ2VuZCcpKSB7XG4gICAgcmV0dXJuIHJlbmRlclJhZGlhbExhYmVsKHByb3BzLCBsYWJlbCwgYXR0cnMpO1xuICB9XG4gIHZhciBwb3NpdGlvbkF0dHJzID0gaXNQb2xhckxhYmVsID8gZ2V0QXR0cnNPZlBvbGFyTGFiZWwocHJvcHMpIDogZ2V0QXR0cnNPZkNhcnRlc2lhbkxhYmVsKHByb3BzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1RleHQuVGV4dCwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLWxhYmVsJywgY2xhc3NOYW1lKVxuICB9LCBhdHRycywgcG9zaXRpb25BdHRycywge1xuICAgIGJyZWFrQWxsOiB0ZXh0QnJlYWtBbGxcbiAgfSksIGxhYmVsKTtcbn1cbkxhYmVsLmRpc3BsYXlOYW1lID0gJ0xhYmVsJztcbnZhciBwYXJzZVZpZXdCb3ggPSBmdW5jdGlvbiBwYXJzZVZpZXdCb3gocHJvcHMpIHtcbiAgdmFyIGN4ID0gcHJvcHMuY3gsXG4gICAgY3kgPSBwcm9wcy5jeSxcbiAgICBhbmdsZSA9IHByb3BzLmFuZ2xlLFxuICAgIHN0YXJ0QW5nbGUgPSBwcm9wcy5zdGFydEFuZ2xlLFxuICAgIGVuZEFuZ2xlID0gcHJvcHMuZW5kQW5nbGUsXG4gICAgciA9IHByb3BzLnIsXG4gICAgcmFkaXVzID0gcHJvcHMucmFkaXVzLFxuICAgIGlubmVyUmFkaXVzID0gcHJvcHMuaW5uZXJSYWRpdXMsXG4gICAgb3V0ZXJSYWRpdXMgPSBwcm9wcy5vdXRlclJhZGl1cyxcbiAgICB4ID0gcHJvcHMueCxcbiAgICB5ID0gcHJvcHMueSxcbiAgICB0b3AgPSBwcm9wcy50b3AsXG4gICAgbGVmdCA9IHByb3BzLmxlZnQsXG4gICAgd2lkdGggPSBwcm9wcy53aWR0aCxcbiAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQsXG4gICAgY2xvY2tXaXNlID0gcHJvcHMuY2xvY2tXaXNlLFxuICAgIGxhYmVsVmlld0JveCA9IHByb3BzLmxhYmVsVmlld0JveDtcbiAgaWYgKGxhYmVsVmlld0JveCkge1xuICAgIHJldHVybiBsYWJlbFZpZXdCb3g7XG4gIH1cbiAgaWYgKCgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh3aWR0aCkgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGhlaWdodCkpIHtcbiAgICBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHgpICYmICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh5KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh0b3ApICYmICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShsZWZ0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdG9wLFxuICAgICAgICB5OiBsZWZ0LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHgpICYmICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh5KSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgfVxuICBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGN4KSAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoY3kpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN4OiBjeCxcbiAgICAgIGN5OiBjeSxcbiAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUgfHwgYW5nbGUgfHwgMCxcbiAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSB8fCBhbmdsZSB8fCAwLFxuICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzIHx8IDAsXG4gICAgICBvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMgfHwgcmFkaXVzIHx8IHIgfHwgMCxcbiAgICAgIGNsb2NrV2lzZTogY2xvY2tXaXNlXG4gICAgfTtcbiAgfVxuICBpZiAocHJvcHMudmlld0JveCkge1xuICAgIHJldHVybiBwcm9wcy52aWV3Qm94O1xuICB9XG4gIHJldHVybiB7fTtcbn07XG52YXIgcGFyc2VMYWJlbCA9IGZ1bmN0aW9uIHBhcnNlTGFiZWwobGFiZWwsIHZpZXdCb3gpIHtcbiAgaWYgKCFsYWJlbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChsYWJlbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KExhYmVsLCB7XG4gICAgICBrZXk6IFwibGFiZWwtaW1wbGljaXRcIixcbiAgICAgIHZpZXdCb3g6IHZpZXdCb3hcbiAgICB9KTtcbiAgfVxuICBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1PclN0cikobGFiZWwpKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoTGFiZWwsIHtcbiAgICAgIGtleTogXCJsYWJlbC1pbXBsaWNpdFwiLFxuICAgICAgdmlld0JveDogdmlld0JveCxcbiAgICAgIHZhbHVlOiBsYWJlbFxuICAgIH0pO1xuICB9XG4gIGlmICggLyojX19QVVJFX18qLygwLCBfcmVhY3QuaXNWYWxpZEVsZW1lbnQpKGxhYmVsKSkge1xuICAgIGlmIChsYWJlbC50eXBlID09PSBMYWJlbCkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNsb25lRWxlbWVudCkobGFiZWwsIHtcbiAgICAgICAga2V5OiAnbGFiZWwtaW1wbGljaXQnLFxuICAgICAgICB2aWV3Qm94OiB2aWV3Qm94XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoTGFiZWwsIHtcbiAgICAgIGtleTogXCJsYWJlbC1pbXBsaWNpdFwiLFxuICAgICAgY29udGVudDogbGFiZWwsXG4gICAgICB2aWV3Qm94OiB2aWV3Qm94XG4gICAgfSk7XG4gIH1cbiAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKGxhYmVsKSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KExhYmVsLCB7XG4gICAgICBrZXk6IFwibGFiZWwtaW1wbGljaXRcIixcbiAgICAgIGNvbnRlbnQ6IGxhYmVsLFxuICAgICAgdmlld0JveDogdmlld0JveFxuICAgIH0pO1xuICB9XG4gIGlmICgoMCwgX2lzT2JqZWN0W1wiZGVmYXVsdFwiXSkobGFiZWwpKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoTGFiZWwsIF9leHRlbmRzKHtcbiAgICAgIHZpZXdCb3g6IHZpZXdCb3hcbiAgICB9LCBsYWJlbCwge1xuICAgICAga2V5OiBcImxhYmVsLWltcGxpY2l0XCJcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIHJlbmRlckNhbGxCeVBhcmVudCA9IGZ1bmN0aW9uIHJlbmRlckNhbGxCeVBhcmVudChwYXJlbnRQcm9wcywgdmlld0JveCkge1xuICB2YXIgY2hlY2tQcm9wc0xhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICBpZiAoIXBhcmVudFByb3BzIHx8ICFwYXJlbnRQcm9wcy5jaGlsZHJlbiAmJiBjaGVja1Byb3BzTGFiZWwgJiYgIXBhcmVudFByb3BzLmxhYmVsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGNoaWxkcmVuID0gcGFyZW50UHJvcHMuY2hpbGRyZW47XG4gIHZhciBwYXJlbnRWaWV3Qm94ID0gcGFyc2VWaWV3Qm94KHBhcmVudFByb3BzKTtcbiAgdmFyIGV4cGxpY2l0Q2hpbGRyZW4gPSAoMCwgX1JlYWN0VXRpbHMuZmluZEFsbEJ5VHlwZSkoY2hpbGRyZW4sIExhYmVsKS5tYXAoZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGNoaWxkLCB7XG4gICAgICB2aWV3Qm94OiB2aWV3Qm94IHx8IHBhcmVudFZpZXdCb3gsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICBrZXk6IFwibGFiZWwtXCIuY29uY2F0KGluZGV4KVxuICAgIH0pO1xuICB9KTtcbiAgaWYgKCFjaGVja1Byb3BzTGFiZWwpIHtcbiAgICByZXR1cm4gZXhwbGljaXRDaGlsZHJlbjtcbiAgfVxuICB2YXIgaW1wbGljaXRMYWJlbCA9IHBhcnNlTGFiZWwocGFyZW50UHJvcHMubGFiZWwsIHZpZXdCb3ggfHwgcGFyZW50Vmlld0JveCk7XG4gIHJldHVybiBbaW1wbGljaXRMYWJlbF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShleHBsaWNpdENoaWxkcmVuKSk7XG59O1xuTGFiZWwucGFyc2VWaWV3Qm94ID0gcGFyc2VWaWV3Qm94O1xuTGFiZWwucmVuZGVyQ2FsbEJ5UGFyZW50ID0gcmVuZGVyQ2FsbEJ5UGFyZW50OyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkxhYmVsIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX2lzTmlsIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9pc0Z1bmN0aW9uIiwiX2lzT2JqZWN0IiwiX2Nsc3giLCJfVGV4dCIsIl9SZWFjdFV0aWxzIiwiX0RhdGFVdGlscyIsIl9Qb2xhclV0aWxzIiwiX2V4Y2x1ZGVkIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIlR5cGVFcnJvciIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwiaXRlciIsImlzQXJyYXkiLCJsZW4iLCJsZW5ndGgiLCJhcnIyIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwic291cmNlIiwiZXhjbHVkZWQiLCJ0YXJnZXQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImtleSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJvd25LZXlzIiwia2V5cyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwiZ2V0TGFiZWwiLCJwcm9wcyIsImZvcm1hdHRlciIsImxhYmVsIiwiY2hpbGRyZW4iLCJnZXREZWx0YUFuZ2xlIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwic2lnbiIsIm1hdGhTaWduIiwiZGVsdGFBbmdsZSIsIk1hdGgiLCJtaW4iLCJhYnMiLCJyZW5kZXJSYWRpYWxMYWJlbCIsImxhYmVsUHJvcHMiLCJhdHRycyIsInBvc2l0aW9uIiwidmlld0JveCIsIm9mZnNldCIsImNsYXNzTmFtZSIsIl9yZWYiLCJjeCIsImN5IiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsImNsb2NrV2lzZSIsInJhZGl1cyIsImxhYmVsQW5nbGUiLCJkaXJlY3Rpb24iLCJzdGFydFBvaW50IiwicG9sYXJUb0NhcnRlc2lhbiIsImVuZFBvaW50IiwicGF0aCIsImNvbmNhdCIsIngiLCJ5IiwiaWQiLCJ1bmlxdWVJZCIsImNyZWF0ZUVsZW1lbnQiLCJkb21pbmFudEJhc2VsaW5lIiwiZCIsInhsaW5rSHJlZiIsImdldEF0dHJzT2ZQb2xhckxhYmVsIiwiX3JlZjIiLCJtaWRBbmdsZSIsIl9wb2xhclRvQ2FydGVzaWFuIiwiX3giLCJfeSIsInRleHRBbmNob3IiLCJ2ZXJ0aWNhbEFuY2hvciIsIl9wb2xhclRvQ2FydGVzaWFuMiIsImdldEF0dHJzT2ZDYXJ0ZXNpYW5MYWJlbCIsInBhcmVudFZpZXdCb3giLCJfcmVmMyIsIndpZHRoIiwiaGVpZ2h0IiwidmVydGljYWxTaWduIiwidmVydGljYWxPZmZzZXQiLCJ2ZXJ0aWNhbEVuZCIsInZlcnRpY2FsU3RhcnQiLCJob3Jpem9udGFsU2lnbiIsImhvcml6b250YWxPZmZzZXQiLCJob3Jpem9udGFsRW5kIiwiaG9yaXpvbnRhbFN0YXJ0IiwibWF4IiwiX2F0dHJzIiwiX2F0dHJzMiIsIl9hdHRyczMiLCJzaXplQXR0cnMiLCJpc051bWJlciIsImlzUGVyY2VudCIsImdldFBlcmNlbnRWYWx1ZSIsImlzUG9sYXIiLCJfcmVmNCIsIl9yZWY0JG9mZnNldCIsInJlc3RQcm9wcyIsImNvbnRlbnQiLCJfcHJvcHMkY2xhc3NOYW1lIiwidGV4dEJyZWFrQWxsIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJpc1BvbGFyTGFiZWwiLCJmaWx0ZXJQcm9wcyIsInBvc2l0aW9uQXR0cnMiLCJUZXh0IiwiYnJlYWtBbGwiLCJkaXNwbGF5TmFtZSIsInBhcnNlVmlld0JveCIsImFuZ2xlIiwidG9wIiwibGVmdCIsImxhYmVsVmlld0JveCIsInBhcnNlTGFiZWwiLCJpc051bU9yU3RyIiwidHlwZSIsInJlbmRlckNhbGxCeVBhcmVudCIsInBhcmVudFByb3BzIiwiY2hlY2tQcm9wc0xhYmVsIiwidW5kZWZpbmVkIiwiZXhwbGljaXRDaGlsZHJlbiIsImZpbmRBbGxCeVR5cGUiLCJtYXAiLCJjaGlsZCIsImluZGV4IiwiaW1wbGljaXRMYWJlbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/component/Label.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/component/LabelList.js":
/*!**********************************************************!*\
  !*** ./node_modules/recharts/lib/component/LabelList.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LabelList = LabelList;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isObject = _interopRequireDefault(__webpack_require__(/*! lodash/isObject */ \"lodash/isObject\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _last = _interopRequireDefault(__webpack_require__(/*! lodash/last */ \"lodash/last\"));\nvar _Label = __webpack_require__(/*! ./Label */ \"./node_modules/recharts/lib/component/Label.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _excluded = [\n    \"valueAccessor\"\n], _excluded2 = [\n    \"data\",\n    \"dataKey\",\n    \"clockWise\",\n    \"id\",\n    \"textBreakAll\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nvar defaultAccessor = function defaultAccessor(entry) {\n    return Array.isArray(entry.value) ? (0, _last[\"default\"])(entry.value) : entry.value;\n};\nfunction LabelList(_ref) {\n    var _ref$valueAccessor = _ref.valueAccessor, valueAccessor = _ref$valueAccessor === void 0 ? defaultAccessor : _ref$valueAccessor, restProps = _objectWithoutProperties(_ref, _excluded);\n    var data = restProps.data, dataKey = restProps.dataKey, clockWise = restProps.clockWise, id = restProps.id, textBreakAll = restProps.textBreakAll, others = _objectWithoutProperties(restProps, _excluded2);\n    if (!data || !data.length) {\n        return null;\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n        className: \"recharts-label-list\"\n    }, data.map(function(entry, index) {\n        var value = (0, _isNil[\"default\"])(dataKey) ? valueAccessor(entry, index) : (0, _ChartUtils.getValueByDataKey)(entry && entry.payload, dataKey);\n        var idProps = (0, _isNil[\"default\"])(id) ? {} : {\n            id: \"\".concat(id, \"-\").concat(index)\n        };\n        return /*#__PURE__*/ _react[\"default\"].createElement(_Label.Label, _extends({}, (0, _ReactUtils.filterProps)(entry, true), others, idProps, {\n            parentViewBox: entry.parentViewBox,\n            value: value,\n            textBreakAll: textBreakAll,\n            viewBox: _Label.Label.parseViewBox((0, _isNil[\"default\"])(clockWise) ? entry : _objectSpread(_objectSpread({}, entry), {}, {\n                clockWise: clockWise\n            })),\n            key: \"label-\".concat(index) // eslint-disable-line react/no-array-index-key\n            ,\n            index: index\n        }));\n    }));\n}\nLabelList.displayName = \"LabelList\";\nfunction parseLabelList(label, data) {\n    if (!label) {\n        return null;\n    }\n    if (label === true) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(LabelList, {\n            key: \"labelList-implicit\",\n            data: data\n        });\n    }\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(label) || (0, _isFunction[\"default\"])(label)) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(LabelList, {\n            key: \"labelList-implicit\",\n            data: data,\n            content: label\n        });\n    }\n    if ((0, _isObject[\"default\"])(label)) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(LabelList, _extends({\n            data: data\n        }, label, {\n            key: \"labelList-implicit\"\n        }));\n    }\n    return null;\n}\nfunction renderCallByParent(parentProps, data) {\n    var checkPropsLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) {\n        return null;\n    }\n    var children = parentProps.children;\n    var explicitChildren = (0, _ReactUtils.findAllByType)(children, LabelList).map(function(child, index) {\n        return /*#__PURE__*/ (0, _react.cloneElement)(child, {\n            data: data,\n            // eslint-disable-next-line react/no-array-index-key\n            key: \"labelList-\".concat(index)\n        });\n    });\n    if (!checkPropsLabel) {\n        return explicitChildren;\n    }\n    var implicitLabelList = parseLabelList(parentProps.label, data);\n    return [\n        implicitLabelList\n    ].concat(_toConsumableArray(explicitChildren));\n}\nLabelList.renderCallByParent = renderCallByParent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9MYWJlbExpc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1RLLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxpQkFBaUIsR0FBR0U7QUFDcEIsSUFBSUMsU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyxTQUFTQyx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlHLFlBQVlELHVCQUF1QkYsbUJBQU9BLENBQUMsd0NBQWlCO0FBQ2hFLElBQUlJLGNBQWNGLHVCQUF1QkYsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlLLFFBQVFILHVCQUF1QkYsbUJBQU9BLENBQUMsZ0NBQWE7QUFDeEQsSUFBSU0sU0FBU04sbUJBQU9BLENBQUMsK0RBQVM7QUFDOUIsSUFBSU8sU0FBU1AsbUJBQU9BLENBQUMsMEVBQW9CO0FBQ3pDLElBQUlRLGNBQWNSLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJUyxjQUFjVCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSVUsWUFBWTtJQUFDO0NBQWdCLEVBQy9CQyxhQUFhO0lBQUM7SUFBUTtJQUFXO0lBQWE7SUFBTTtDQUFlO0FBQ3JFLFNBQVNULHVCQUF1QlUsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtR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RyxhQUFhLENBQUNqRyxXQUFXcUQsU0FBUztZQUN0RXNDLE1BQU1BO1FBQ1IsR0FBR3NCLE9BQU87WUFDUnRELEtBQUs7UUFDUDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBU3lELG1CQUFtQkMsV0FBVyxFQUFFMUIsSUFBSTtJQUMzQyxJQUFJMkIsa0JBQWtCN0QsVUFBVU4sTUFBTSxHQUFHLEtBQUtNLFNBQVMsQ0FBQyxFQUFFLEtBQUs4RCxZQUFZOUQsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUMxRixJQUFJLENBQUM0RCxlQUFlLENBQUNBLFlBQVlHLFFBQVEsSUFBSUYsbUJBQW1CLENBQUNELFlBQVlKLEtBQUssRUFBRTtRQUNsRixPQUFPO0lBQ1Q7SUFDQSxJQUFJTyxXQUFXSCxZQUFZRyxRQUFRO0lBQ25DLElBQUlDLG1CQUFtQixDQUFDLEdBQUc5RyxZQUFZK0csYUFBYSxFQUFFRixVQUFVeEgsV0FBV29HLEdBQUcsQ0FBQyxTQUFVdUIsS0FBSyxFQUFFdEIsS0FBSztRQUNuRyxPQUFvQixXQUFGLEdBQUcsSUFBR3BHLE9BQU8ySCxZQUFZLEVBQUVELE9BQU87WUFDbERoQyxNQUFNQTtZQUNOLG9EQUFvRDtZQUNwRGhDLEtBQUssYUFBYThDLE1BQU0sQ0FBQ0o7UUFDM0I7SUFDRjtJQUNBLElBQUksQ0FBQ2lCLGlCQUFpQjtRQUNwQixPQUFPRztJQUNUO0lBQ0EsSUFBSUksb0JBQW9CYixlQUFlSyxZQUFZSixLQUFLLEVBQUV0QjtJQUMxRCxPQUFPO1FBQUNrQztLQUFrQixDQUFDcEIsTUFBTSxDQUFDeEUsbUJBQW1Cd0Y7QUFDdkQ7QUFDQXpILFVBQVVvSCxrQkFBa0IsR0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9MYWJlbExpc3QuanM/NzQ5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTGFiZWxMaXN0ID0gTGFiZWxMaXN0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2lzTmlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzTmlsXCIpKTtcbnZhciBfaXNPYmplY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNPYmplY3RcIikpO1xudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xudmFyIF9sYXN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2xhc3RcIikpO1xudmFyIF9MYWJlbCA9IHJlcXVpcmUoXCIuL0xhYmVsXCIpO1xudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xudmFyIF9DaGFydFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQ2hhcnRVdGlsc1wiKTtcbnZhciBfZXhjbHVkZWQgPSBbXCJ2YWx1ZUFjY2Vzc29yXCJdLFxuICBfZXhjbHVkZWQyID0gW1wiZGF0YVwiLCBcImRhdGFLZXlcIiwgXCJjbG9ja1dpc2VcIiwgXCJpZFwiLCBcInRleHRCcmVha0FsbFwiXTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBkZWZhdWx0QWNjZXNzb3IgPSBmdW5jdGlvbiBkZWZhdWx0QWNjZXNzb3IoZW50cnkpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZW50cnkudmFsdWUpID8gKDAsIF9sYXN0W1wiZGVmYXVsdFwiXSkoZW50cnkudmFsdWUpIDogZW50cnkudmFsdWU7XG59O1xuZnVuY3Rpb24gTGFiZWxMaXN0KF9yZWYpIHtcbiAgdmFyIF9yZWYkdmFsdWVBY2Nlc3NvciA9IF9yZWYudmFsdWVBY2Nlc3NvcixcbiAgICB2YWx1ZUFjY2Vzc29yID0gX3JlZiR2YWx1ZUFjY2Vzc29yID09PSB2b2lkIDAgPyBkZWZhdWx0QWNjZXNzb3IgOiBfcmVmJHZhbHVlQWNjZXNzb3IsXG4gICAgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG4gIHZhciBkYXRhID0gcmVzdFByb3BzLmRhdGEsXG4gICAgZGF0YUtleSA9IHJlc3RQcm9wcy5kYXRhS2V5LFxuICAgIGNsb2NrV2lzZSA9IHJlc3RQcm9wcy5jbG9ja1dpc2UsXG4gICAgaWQgPSByZXN0UHJvcHMuaWQsXG4gICAgdGV4dEJyZWFrQWxsID0gcmVzdFByb3BzLnRleHRCcmVha0FsbCxcbiAgICBvdGhlcnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmVzdFByb3BzLCBfZXhjbHVkZWQyKTtcbiAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xuICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1sYWJlbC1saXN0XCJcbiAgfSwgZGF0YS5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xuICAgIHZhciB2YWx1ZSA9ICgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShkYXRhS2V5KSA/IHZhbHVlQWNjZXNzb3IoZW50cnksIGluZGV4KSA6ICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkoZW50cnkgJiYgZW50cnkucGF5bG9hZCwgZGF0YUtleSk7XG4gICAgdmFyIGlkUHJvcHMgPSAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoaWQpID8ge30gOiB7XG4gICAgICBpZDogXCJcIi5jb25jYXQoaWQsIFwiLVwiKS5jb25jYXQoaW5kZXgpXG4gICAgfTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGFiZWwuTGFiZWwsIF9leHRlbmRzKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKGVudHJ5LCB0cnVlKSwgb3RoZXJzLCBpZFByb3BzLCB7XG4gICAgICBwYXJlbnRWaWV3Qm94OiBlbnRyeS5wYXJlbnRWaWV3Qm94LFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgdGV4dEJyZWFrQWxsOiB0ZXh0QnJlYWtBbGwsXG4gICAgICB2aWV3Qm94OiBfTGFiZWwuTGFiZWwucGFyc2VWaWV3Qm94KCgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShjbG9ja1dpc2UpID8gZW50cnkgOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcbiAgICAgICAgY2xvY2tXaXNlOiBjbG9ja1dpc2VcbiAgICAgIH0pKSxcbiAgICAgIGtleTogXCJsYWJlbC1cIi5jb25jYXQoaW5kZXgpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICAsXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9KSk7XG4gIH0pKTtcbn1cbkxhYmVsTGlzdC5kaXNwbGF5TmFtZSA9ICdMYWJlbExpc3QnO1xuZnVuY3Rpb24gcGFyc2VMYWJlbExpc3QobGFiZWwsIGRhdGEpIHtcbiAgaWYgKCFsYWJlbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChsYWJlbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KExhYmVsTGlzdCwge1xuICAgICAga2V5OiBcImxhYmVsTGlzdC1pbXBsaWNpdFwiLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9XG4gIGlmICggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQobGFiZWwpIHx8ICgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKGxhYmVsKSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KExhYmVsTGlzdCwge1xuICAgICAga2V5OiBcImxhYmVsTGlzdC1pbXBsaWNpdFwiLFxuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIGNvbnRlbnQ6IGxhYmVsXG4gICAgfSk7XG4gIH1cbiAgaWYgKCgwLCBfaXNPYmplY3RbXCJkZWZhdWx0XCJdKShsYWJlbCkpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChMYWJlbExpc3QsIF9leHRlbmRzKHtcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9LCBsYWJlbCwge1xuICAgICAga2V5OiBcImxhYmVsTGlzdC1pbXBsaWNpdFwiXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcmVuZGVyQ2FsbEJ5UGFyZW50KHBhcmVudFByb3BzLCBkYXRhKSB7XG4gIHZhciBjaGVja1Byb3BzTGFiZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gIGlmICghcGFyZW50UHJvcHMgfHwgIXBhcmVudFByb3BzLmNoaWxkcmVuICYmIGNoZWNrUHJvcHNMYWJlbCAmJiAhcGFyZW50UHJvcHMubGFiZWwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgY2hpbGRyZW4gPSBwYXJlbnRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGV4cGxpY2l0Q2hpbGRyZW4gPSAoMCwgX1JlYWN0VXRpbHMuZmluZEFsbEJ5VHlwZSkoY2hpbGRyZW4sIExhYmVsTGlzdCkubWFwKGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShjaGlsZCwge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcbiAgICAgIGtleTogXCJsYWJlbExpc3QtXCIuY29uY2F0KGluZGV4KVxuICAgIH0pO1xuICB9KTtcbiAgaWYgKCFjaGVja1Byb3BzTGFiZWwpIHtcbiAgICByZXR1cm4gZXhwbGljaXRDaGlsZHJlbjtcbiAgfVxuICB2YXIgaW1wbGljaXRMYWJlbExpc3QgPSBwYXJzZUxhYmVsTGlzdChwYXJlbnRQcm9wcy5sYWJlbCwgZGF0YSk7XG4gIHJldHVybiBbaW1wbGljaXRMYWJlbExpc3RdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZXhwbGljaXRDaGlsZHJlbikpO1xufVxuTGFiZWxMaXN0LnJlbmRlckNhbGxCeVBhcmVudCA9IHJlbmRlckNhbGxCeVBhcmVudDsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJMYWJlbExpc3QiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfaXNOaWwiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2lzT2JqZWN0IiwiX2lzRnVuY3Rpb24iLCJfbGFzdCIsIl9MYWJlbCIsIl9MYXllciIsIl9SZWFjdFV0aWxzIiwiX0NoYXJ0VXRpbHMiLCJfZXhjbHVkZWQiLCJfZXhjbHVkZWQyIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIlR5cGVFcnJvciIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwiaXRlciIsImlzQXJyYXkiLCJsZW4iLCJsZW5ndGgiLCJhcnIyIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwic291cmNlIiwia2V5IiwiYXBwbHkiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJzb3VyY2VTeW1ib2xLZXlzIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZGVmYXVsdEFjY2Vzc29yIiwiZW50cnkiLCJfcmVmIiwiX3JlZiR2YWx1ZUFjY2Vzc29yIiwidmFsdWVBY2Nlc3NvciIsInJlc3RQcm9wcyIsImRhdGEiLCJkYXRhS2V5IiwiY2xvY2tXaXNlIiwiaWQiLCJ0ZXh0QnJlYWtBbGwiLCJvdGhlcnMiLCJjcmVhdGVFbGVtZW50IiwiTGF5ZXIiLCJjbGFzc05hbWUiLCJtYXAiLCJpbmRleCIsImdldFZhbHVlQnlEYXRhS2V5IiwicGF5bG9hZCIsImlkUHJvcHMiLCJjb25jYXQiLCJMYWJlbCIsImZpbHRlclByb3BzIiwicGFyZW50Vmlld0JveCIsInZpZXdCb3giLCJwYXJzZVZpZXdCb3giLCJkaXNwbGF5TmFtZSIsInBhcnNlTGFiZWxMaXN0IiwibGFiZWwiLCJpc1ZhbGlkRWxlbWVudCIsImNvbnRlbnQiLCJyZW5kZXJDYWxsQnlQYXJlbnQiLCJwYXJlbnRQcm9wcyIsImNoZWNrUHJvcHNMYWJlbCIsInVuZGVmaW5lZCIsImNoaWxkcmVuIiwiZXhwbGljaXRDaGlsZHJlbiIsImZpbmRBbGxCeVR5cGUiLCJjaGlsZCIsImNsb25lRWxlbWVudCIsImltcGxpY2l0TGFiZWxMaXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/component/LabelList.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/component/Legend.js":
/*!*******************************************************!*\
  !*** ./node_modules/recharts/lib/component/Legend.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Legend = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _DefaultLegendContent = __webpack_require__(/*! ./DefaultLegendContent */ \"./node_modules/recharts/lib/component/DefaultLegendContent.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _getUniqPayload = __webpack_require__(/*! ../util/payload/getUniqPayload */ \"./node_modules/recharts/lib/util/payload/getUniqPayload.js\");\nvar _excluded = [\n    \"ref\"\n];\n/**\n * @fileOverview Legend\n */ function _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction defaultUniqBy(entry) {\n    return entry.value;\n}\nfunction renderContent(content, props) {\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(content)) {\n        return /*#__PURE__*/ _react[\"default\"].cloneElement(content, props);\n    }\n    if (typeof content === \"function\") {\n        return /*#__PURE__*/ _react[\"default\"].createElement(content, props);\n    }\n    var ref = props.ref, otherProps = _objectWithoutProperties(props, _excluded);\n    return /*#__PURE__*/ _react[\"default\"].createElement(_DefaultLegendContent.DefaultLegendContent, otherProps);\n}\nvar EPS = 1;\nvar Legend = exports.Legend = /*#__PURE__*/ function(_PureComponent) {\n    function Legend() {\n        var _this;\n        _classCallCheck(this, Legend);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Legend, [].concat(args));\n        _defineProperty(_this, \"lastBoundingBox\", {\n            width: -1,\n            height: -1\n        });\n        return _this;\n    }\n    _inherits(Legend, _PureComponent);\n    return _createClass(Legend, [\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                this.updateBBox();\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate() {\n                this.updateBBox();\n            }\n        },\n        {\n            key: \"getBBox\",\n            value: function getBBox() {\n                if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {\n                    var box = this.wrapperNode.getBoundingClientRect();\n                    box.height = this.wrapperNode.offsetHeight;\n                    box.width = this.wrapperNode.offsetWidth;\n                    return box;\n                }\n                return null;\n            }\n        },\n        {\n            key: \"updateBBox\",\n            value: function updateBBox() {\n                var onBBoxUpdate = this.props.onBBoxUpdate;\n                var box = this.getBBox();\n                if (box) {\n                    if (Math.abs(box.width - this.lastBoundingBox.width) > EPS || Math.abs(box.height - this.lastBoundingBox.height) > EPS) {\n                        this.lastBoundingBox.width = box.width;\n                        this.lastBoundingBox.height = box.height;\n                        if (onBBoxUpdate) {\n                            onBBoxUpdate(box);\n                        }\n                    }\n                } else if (this.lastBoundingBox.width !== -1 || this.lastBoundingBox.height !== -1) {\n                    this.lastBoundingBox.width = -1;\n                    this.lastBoundingBox.height = -1;\n                    if (onBBoxUpdate) {\n                        onBBoxUpdate(null);\n                    }\n                }\n            }\n        },\n        {\n            key: \"getBBoxSnapshot\",\n            value: function getBBoxSnapshot() {\n                if (this.lastBoundingBox.width >= 0 && this.lastBoundingBox.height >= 0) {\n                    return _objectSpread({}, this.lastBoundingBox);\n                }\n                return {\n                    width: 0,\n                    height: 0\n                };\n            }\n        },\n        {\n            key: \"getDefaultPosition\",\n            value: function getDefaultPosition(style) {\n                var _this$props = this.props, layout = _this$props.layout, align = _this$props.align, verticalAlign = _this$props.verticalAlign, margin = _this$props.margin, chartWidth = _this$props.chartWidth, chartHeight = _this$props.chartHeight;\n                var hPos, vPos;\n                if (!style || (style.left === undefined || style.left === null) && (style.right === undefined || style.right === null)) {\n                    if (align === \"center\" && layout === \"vertical\") {\n                        var box = this.getBBoxSnapshot();\n                        hPos = {\n                            left: ((chartWidth || 0) - box.width) / 2\n                        };\n                    } else {\n                        hPos = align === \"right\" ? {\n                            right: margin && margin.right || 0\n                        } : {\n                            left: margin && margin.left || 0\n                        };\n                    }\n                }\n                if (!style || (style.top === undefined || style.top === null) && (style.bottom === undefined || style.bottom === null)) {\n                    if (verticalAlign === \"middle\") {\n                        var _box = this.getBBoxSnapshot();\n                        vPos = {\n                            top: ((chartHeight || 0) - _box.height) / 2\n                        };\n                    } else {\n                        vPos = verticalAlign === \"bottom\" ? {\n                            bottom: margin && margin.bottom || 0\n                        } : {\n                            top: margin && margin.top || 0\n                        };\n                    }\n                }\n                return _objectSpread(_objectSpread({}, hPos), vPos);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this2 = this;\n                var _this$props2 = this.props, content = _this$props2.content, width = _this$props2.width, height = _this$props2.height, wrapperStyle = _this$props2.wrapperStyle, payloadUniqBy = _this$props2.payloadUniqBy, payload = _this$props2.payload;\n                var outerStyle = _objectSpread(_objectSpread({\n                    position: \"absolute\",\n                    width: width || \"auto\",\n                    height: height || \"auto\"\n                }, this.getDefaultPosition(wrapperStyle)), wrapperStyle);\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                    className: \"recharts-legend-wrapper\",\n                    style: outerStyle,\n                    ref: function ref(node) {\n                        _this2.wrapperNode = node;\n                    }\n                }, renderContent(content, _objectSpread(_objectSpread({}, this.props), {}, {\n                    payload: (0, _getUniqPayload.getUniqPayload)(payload, payloadUniqBy, defaultUniqBy)\n                })));\n            }\n        }\n    ], [\n        {\n            key: \"getWithHeight\",\n            value: function getWithHeight(item, chartWidth) {\n                var _this$defaultProps$it = _objectSpread(_objectSpread({}, this.defaultProps), item.props), layout = _this$defaultProps$it.layout;\n                if (layout === \"vertical\" && (0, _DataUtils.isNumber)(item.props.height)) {\n                    return {\n                        height: item.props.height\n                    };\n                }\n                if (layout === \"horizontal\") {\n                    return {\n                        width: item.props.width || chartWidth\n                    };\n                }\n                return null;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(Legend, \"displayName\", \"Legend\");\n_defineProperty(Legend, \"defaultProps\", {\n    iconSize: 14,\n    layout: \"horizontal\",\n    align: \"center\",\n    verticalAlign: \"bottom\"\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9MZWdlbmQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1RLLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxjQUFjLEdBQUcsS0FBSztBQUN0QixJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLHdCQUF3QkQsbUJBQU9BLENBQUMsNkZBQXdCO0FBQzVELElBQUlFLGFBQWFGLG1CQUFPQSxDQUFDLHdFQUFtQjtBQUM1QyxJQUFJRyxrQkFBa0JILG1CQUFPQSxDQUFDLGtHQUFnQztBQUM5RCxJQUFJSSxZQUFZO0lBQUM7Q0FBTTtBQUN2Qjs7Q0FFQyxHQUNELFNBQVNDLHlCQUF5QkMsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLE9BQU87SUFBTSxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx5QkFBeUJDLENBQUM7UUFBSSxPQUFPQSxJQUFJRyxJQUFJRDtJQUFHLEdBQUdGO0FBQUk7QUFDbk8sU0FBU1Asd0JBQXdCTyxDQUFDLEVBQUVFLENBQUM7SUFBSSxJQUFJLENBQUNBLEtBQUtGLEtBQUtBLEVBQUVJLFVBQVUsRUFBRSxPQUFPSjtJQUFHLElBQUksU0FBU0EsS0FBSyxZQUFZbkIsUUFBUW1CLE1BQU0sY0FBYyxP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M0IsTUFBTTtnQkFDdkMsSUFBSUEsV0FBVyxjQUFjLENBQUMsR0FBR3RILFdBQVdtSixRQUFRLEVBQUVILEtBQUt4RyxLQUFLLENBQUM0RCxNQUFNLEdBQUc7b0JBQ3hFLE9BQU87d0JBQ0xBLFFBQVE0QyxLQUFLeEcsS0FBSyxDQUFDNEQsTUFBTTtvQkFDM0I7Z0JBQ0Y7Z0JBQ0EsSUFBSWtCLFdBQVcsY0FBYztvQkFDM0IsT0FBTzt3QkFDTG5CLE9BQU82QyxLQUFLeEcsS0FBSyxDQUFDMkQsS0FBSyxJQUFJdUI7b0JBQzdCO2dCQUNGO2dCQUNBLE9BQU87WUFDVDtRQUNGO0tBQUU7QUFDSixFQUFFOUgsT0FBT3dKLGFBQWE7QUFDdEJySCxnQkFBZ0JwQyxRQUFRLGVBQWU7QUFDdkNvQyxnQkFBZ0JwQyxRQUFRLGdCQUFnQjtJQUN0QzBKLFVBQVU7SUFDVi9CLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxlQUFlO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9jb21wb25lbnQvTGVnZW5kLmpzPzM1ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkxlZ2VuZCA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9EZWZhdWx0TGVnZW5kQ29udGVudCA9IHJlcXVpcmUoXCIuL0RlZmF1bHRMZWdlbmRDb250ZW50XCIpO1xudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XG52YXIgX2dldFVuaXFQYXlsb2FkID0gcmVxdWlyZShcIi4uL3V0aWwvcGF5bG9hZC9nZXRVbmlxUGF5bG9hZFwiKTtcbnZhciBfZXhjbHVkZWQgPSBbXCJyZWZcIl07XG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgTGVnZW5kXG4gKi9cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gZGVmYXVsdFVuaXFCeShlbnRyeSkge1xuICByZXR1cm4gZW50cnkudmFsdWU7XG59XG5mdW5jdGlvbiByZW5kZXJDb250ZW50KGNvbnRlbnQsIHByb3BzKSB7XG4gIGlmICggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQoY29udGVudCkpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNvbnRlbnQsIHByb3BzKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChjb250ZW50LCBwcm9wcyk7XG4gIH1cbiAgdmFyIHJlZiA9IHByb3BzLnJlZixcbiAgICBvdGhlclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfRGVmYXVsdExlZ2VuZENvbnRlbnQuRGVmYXVsdExlZ2VuZENvbnRlbnQsIG90aGVyUHJvcHMpO1xufVxudmFyIEVQUyA9IDE7XG52YXIgTGVnZW5kID0gZXhwb3J0cy5MZWdlbmQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIExlZ2VuZCgpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExlZ2VuZCk7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgTGVnZW5kLCBbXS5jb25jYXQoYXJncykpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJsYXN0Qm91bmRpbmdCb3hcIiwge1xuICAgICAgd2lkdGg6IC0xLFxuICAgICAgaGVpZ2h0OiAtMVxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoTGVnZW5kLCBfUHVyZUNvbXBvbmVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoTGVnZW5kLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHRoaXMudXBkYXRlQkJveCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgdGhpcy51cGRhdGVCQm94KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QkJveCgpIHtcbiAgICAgIGlmICh0aGlzLndyYXBwZXJOb2RlICYmIHRoaXMud3JhcHBlck5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgICAgIHZhciBib3ggPSB0aGlzLndyYXBwZXJOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBib3guaGVpZ2h0ID0gdGhpcy53cmFwcGVyTm9kZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGJveC53aWR0aCA9IHRoaXMud3JhcHBlck5vZGUub2Zmc2V0V2lkdGg7XG4gICAgICAgIHJldHVybiBib3g7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQkJveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCQm94KCkge1xuICAgICAgdmFyIG9uQkJveFVwZGF0ZSA9IHRoaXMucHJvcHMub25CQm94VXBkYXRlO1xuICAgICAgdmFyIGJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgICAgaWYgKGJveCkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoYm94LndpZHRoIC0gdGhpcy5sYXN0Qm91bmRpbmdCb3gud2lkdGgpID4gRVBTIHx8IE1hdGguYWJzKGJveC5oZWlnaHQgLSB0aGlzLmxhc3RCb3VuZGluZ0JveC5oZWlnaHQpID4gRVBTKSB7XG4gICAgICAgICAgdGhpcy5sYXN0Qm91bmRpbmdCb3gud2lkdGggPSBib3gud2lkdGg7XG4gICAgICAgICAgdGhpcy5sYXN0Qm91bmRpbmdCb3guaGVpZ2h0ID0gYm94LmhlaWdodDtcbiAgICAgICAgICBpZiAob25CQm94VXBkYXRlKSB7XG4gICAgICAgICAgICBvbkJCb3hVcGRhdGUoYm94KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5sYXN0Qm91bmRpbmdCb3gud2lkdGggIT09IC0xIHx8IHRoaXMubGFzdEJvdW5kaW5nQm94LmhlaWdodCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5sYXN0Qm91bmRpbmdCb3gud2lkdGggPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0Qm91bmRpbmdCb3guaGVpZ2h0ID0gLTE7XG4gICAgICAgIGlmIChvbkJCb3hVcGRhdGUpIHtcbiAgICAgICAgICBvbkJCb3hVcGRhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QkJveFNuYXBzaG90XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJCb3hTbmFwc2hvdCgpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RCb3VuZGluZ0JveC53aWR0aCA+PSAwICYmIHRoaXMubGFzdEJvdW5kaW5nQm94LmhlaWdodCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmxhc3RCb3VuZGluZ0JveCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREZWZhdWx0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmYXVsdFBvc2l0aW9uKHN0eWxlKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBsYXlvdXQgPSBfdGhpcyRwcm9wcy5sYXlvdXQsXG4gICAgICAgIGFsaWduID0gX3RoaXMkcHJvcHMuYWxpZ24sXG4gICAgICAgIHZlcnRpY2FsQWxpZ24gPSBfdGhpcyRwcm9wcy52ZXJ0aWNhbEFsaWduLFxuICAgICAgICBtYXJnaW4gPSBfdGhpcyRwcm9wcy5tYXJnaW4sXG4gICAgICAgIGNoYXJ0V2lkdGggPSBfdGhpcyRwcm9wcy5jaGFydFdpZHRoLFxuICAgICAgICBjaGFydEhlaWdodCA9IF90aGlzJHByb3BzLmNoYXJ0SGVpZ2h0O1xuICAgICAgdmFyIGhQb3MsIHZQb3M7XG4gICAgICBpZiAoIXN0eWxlIHx8IChzdHlsZS5sZWZ0ID09PSB1bmRlZmluZWQgfHwgc3R5bGUubGVmdCA9PT0gbnVsbCkgJiYgKHN0eWxlLnJpZ2h0ID09PSB1bmRlZmluZWQgfHwgc3R5bGUucmlnaHQgPT09IG51bGwpKSB7XG4gICAgICAgIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicgJiYgbGF5b3V0ID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgdmFyIGJveCA9IHRoaXMuZ2V0QkJveFNuYXBzaG90KCk7XG4gICAgICAgICAgaFBvcyA9IHtcbiAgICAgICAgICAgIGxlZnQ6ICgoY2hhcnRXaWR0aCB8fCAwKSAtIGJveC53aWR0aCkgLyAyXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoUG9zID0gYWxpZ24gPT09ICdyaWdodCcgPyB7XG4gICAgICAgICAgICByaWdodDogbWFyZ2luICYmIG1hcmdpbi5yaWdodCB8fCAwXG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGxlZnQ6IG1hcmdpbiAmJiBtYXJnaW4ubGVmdCB8fCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFzdHlsZSB8fCAoc3R5bGUudG9wID09PSB1bmRlZmluZWQgfHwgc3R5bGUudG9wID09PSBudWxsKSAmJiAoc3R5bGUuYm90dG9tID09PSB1bmRlZmluZWQgfHwgc3R5bGUuYm90dG9tID09PSBudWxsKSkge1xuICAgICAgICBpZiAodmVydGljYWxBbGlnbiA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgICB2YXIgX2JveCA9IHRoaXMuZ2V0QkJveFNuYXBzaG90KCk7XG4gICAgICAgICAgdlBvcyA9IHtcbiAgICAgICAgICAgIHRvcDogKChjaGFydEhlaWdodCB8fCAwKSAtIF9ib3guaGVpZ2h0KSAvIDJcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZQb3MgPSB2ZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJyA/IHtcbiAgICAgICAgICAgIGJvdHRvbTogbWFyZ2luICYmIG1hcmdpbi5ib3R0b20gfHwgMFxuICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICB0b3A6IG1hcmdpbiAmJiBtYXJnaW4udG9wIHx8IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBoUG9zKSwgdlBvcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBjb250ZW50ID0gX3RoaXMkcHJvcHMyLmNvbnRlbnQsXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHMyLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczIuaGVpZ2h0LFxuICAgICAgICB3cmFwcGVyU3R5bGUgPSBfdGhpcyRwcm9wczIud3JhcHBlclN0eWxlLFxuICAgICAgICBwYXlsb2FkVW5pcUJ5ID0gX3RoaXMkcHJvcHMyLnBheWxvYWRVbmlxQnksXG4gICAgICAgIHBheWxvYWQgPSBfdGhpcyRwcm9wczIucGF5bG9hZDtcbiAgICAgIHZhciBvdXRlclN0eWxlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHdpZHRoOiB3aWR0aCB8fCAnYXV0bycsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0IHx8ICdhdXRvJ1xuICAgICAgfSwgdGhpcy5nZXREZWZhdWx0UG9zaXRpb24od3JhcHBlclN0eWxlKSksIHdyYXBwZXJTdHlsZSk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1sZWdlbmQtd3JhcHBlclwiLFxuICAgICAgICBzdHlsZTogb3V0ZXJTdHlsZSxcbiAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYobm9kZSkge1xuICAgICAgICAgIF90aGlzMi53cmFwcGVyTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0sIHJlbmRlckNvbnRlbnQoY29udGVudCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLnByb3BzKSwge30sIHtcbiAgICAgICAgcGF5bG9hZDogKDAsIF9nZXRVbmlxUGF5bG9hZC5nZXRVbmlxUGF5bG9hZCkocGF5bG9hZCwgcGF5bG9hZFVuaXFCeSwgZGVmYXVsdFVuaXFCeSlcbiAgICAgIH0pKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0V2l0aEhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXaXRoSGVpZ2h0KGl0ZW0sIGNoYXJ0V2lkdGgpIHtcbiAgICAgIHZhciBfdGhpcyRkZWZhdWx0UHJvcHMkaXQgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuZGVmYXVsdFByb3BzKSwgaXRlbS5wcm9wcyksXG4gICAgICAgIGxheW91dCA9IF90aGlzJGRlZmF1bHRQcm9wcyRpdC5sYXlvdXQ7XG4gICAgICBpZiAobGF5b3V0ID09PSAndmVydGljYWwnICYmICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShpdGVtLnByb3BzLmhlaWdodCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoZWlnaHQ6IGl0ZW0ucHJvcHMuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogaXRlbS5wcm9wcy53aWR0aCB8fCBjaGFydFdpZHRoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcbn0oX3JlYWN0LlB1cmVDb21wb25lbnQpO1xuX2RlZmluZVByb3BlcnR5KExlZ2VuZCwgXCJkaXNwbGF5TmFtZVwiLCAnTGVnZW5kJyk7XG5fZGVmaW5lUHJvcGVydHkoTGVnZW5kLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIGljb25TaXplOiAxNCxcbiAgbGF5b3V0OiAnaG9yaXpvbnRhbCcsXG4gIGFsaWduOiAnY2VudGVyJyxcbiAgdmVydGljYWxBbGlnbjogJ2JvdHRvbSdcbn0pOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkxlZ2VuZCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9EZWZhdWx0TGVnZW5kQ29udGVudCIsIl9EYXRhVXRpbHMiLCJfZ2V0VW5pcVBheWxvYWQiLCJfZXhjbHVkZWQiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX19lc01vZHVsZSIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsImJpbmQiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwib2JqIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2UiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImRlZmF1bHRVbmlxQnkiLCJlbnRyeSIsInJlbmRlckNvbnRlbnQiLCJjb250ZW50IiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwicmVmIiwib3RoZXJQcm9wcyIsIkRlZmF1bHRMZWdlbmRDb250ZW50IiwiRVBTIiwiX1B1cmVDb21wb25lbnQiLCJfdGhpcyIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiY29uY2F0Iiwid2lkdGgiLCJoZWlnaHQiLCJjb21wb25lbnREaWRNb3VudCIsInVwZGF0ZUJCb3giLCJjb21wb25lbnREaWRVcGRhdGUiLCJnZXRCQm94Iiwid3JhcHBlck5vZGUiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJib3giLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsIm9uQkJveFVwZGF0ZSIsIk1hdGgiLCJhYnMiLCJsYXN0Qm91bmRpbmdCb3giLCJnZXRCQm94U25hcHNob3QiLCJnZXREZWZhdWx0UG9zaXRpb24iLCJzdHlsZSIsIl90aGlzJHByb3BzIiwibGF5b3V0IiwiYWxpZ24iLCJ2ZXJ0aWNhbEFsaWduIiwibWFyZ2luIiwiY2hhcnRXaWR0aCIsImNoYXJ0SGVpZ2h0IiwiaFBvcyIsInZQb3MiLCJsZWZ0IiwidW5kZWZpbmVkIiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJfYm94IiwicmVuZGVyIiwiX3RoaXMyIiwiX3RoaXMkcHJvcHMyIiwid3JhcHBlclN0eWxlIiwicGF5bG9hZFVuaXFCeSIsInBheWxvYWQiLCJvdXRlclN0eWxlIiwicG9zaXRpb24iLCJjbGFzc05hbWUiLCJub2RlIiwiZ2V0VW5pcVBheWxvYWQiLCJnZXRXaXRoSGVpZ2h0IiwiaXRlbSIsIl90aGlzJGRlZmF1bHRQcm9wcyRpdCIsImRlZmF1bHRQcm9wcyIsImlzTnVtYmVyIiwiUHVyZUNvbXBvbmVudCIsImljb25TaXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/component/Legend.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/component/ResponsiveContainer.js":
/*!********************************************************************!*\
  !*** ./node_modules/recharts/lib/component/ResponsiveContainer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ResponsiveContainer = void 0;\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _throttle = _interopRequireDefault(__webpack_require__(/*! lodash/throttle */ \"lodash/throttle\"));\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"./node_modules/recharts/lib/util/LogUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n} /**\n * @fileOverview Wrapper component to make charts adapt to the size of parent * DOM\n */ \nvar ResponsiveContainer = exports.ResponsiveContainer = /*#__PURE__*/ (0, _react.forwardRef)(function(_ref, ref) {\n    var aspect = _ref.aspect, _ref$initialDimension = _ref.initialDimension, initialDimension = _ref$initialDimension === void 0 ? {\n        width: -1,\n        height: -1\n    } : _ref$initialDimension, _ref$width = _ref.width, width = _ref$width === void 0 ? \"100%\" : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? \"100%\" : _ref$height, _ref$minWidth = _ref.minWidth, minWidth = _ref$minWidth === void 0 ? 0 : _ref$minWidth, minHeight = _ref.minHeight, maxHeight = _ref.maxHeight, children = _ref.children, _ref$debounce = _ref.debounce, debounce = _ref$debounce === void 0 ? 0 : _ref$debounce, id = _ref.id, className = _ref.className, onResize = _ref.onResize, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style;\n    var containerRef = (0, _react.useRef)(null);\n    var onResizeRef = (0, _react.useRef)();\n    onResizeRef.current = onResize;\n    (0, _react.useImperativeHandle)(ref, function() {\n        return Object.defineProperty(containerRef.current, \"current\", {\n            get: function get() {\n                // eslint-disable-next-line no-console\n                console.warn(\"The usage of ref.current.current is deprecated and will no longer be supported.\");\n                return containerRef.current;\n            },\n            configurable: true\n        });\n    });\n    var _useState = (0, _react.useState)({\n        containerWidth: initialDimension.width,\n        containerHeight: initialDimension.height\n    }), _useState2 = _slicedToArray(_useState, 2), sizes = _useState2[0], setSizes = _useState2[1];\n    var setContainerSize = (0, _react.useCallback)(function(newWidth, newHeight) {\n        setSizes(function(prevState) {\n            var roundedWidth = Math.round(newWidth);\n            var roundedHeight = Math.round(newHeight);\n            if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) {\n                return prevState;\n            }\n            return {\n                containerWidth: roundedWidth,\n                containerHeight: roundedHeight\n            };\n        });\n    }, []);\n    (0, _react.useEffect)(function() {\n        var callback = function callback(entries) {\n            var _onResizeRef$current;\n            var _entries$0$contentRec = entries[0].contentRect, containerWidth = _entries$0$contentRec.width, containerHeight = _entries$0$contentRec.height;\n            setContainerSize(containerWidth, containerHeight);\n            (_onResizeRef$current = onResizeRef.current) === null || _onResizeRef$current === void 0 || _onResizeRef$current.call(onResizeRef, containerWidth, containerHeight);\n        };\n        if (debounce > 0) {\n            callback = (0, _throttle[\"default\"])(callback, debounce, {\n                trailing: true,\n                leading: false\n            });\n        }\n        var observer = new ResizeObserver(callback);\n        var _containerRef$current = containerRef.current.getBoundingClientRect(), containerWidth = _containerRef$current.width, containerHeight = _containerRef$current.height;\n        setContainerSize(containerWidth, containerHeight);\n        observer.observe(containerRef.current);\n        return function() {\n            observer.disconnect();\n        };\n    }, [\n        setContainerSize,\n        debounce\n    ]);\n    var chartContent = (0, _react.useMemo)(function() {\n        var containerWidth = sizes.containerWidth, containerHeight = sizes.containerHeight;\n        if (containerWidth < 0 || containerHeight < 0) {\n            return null;\n        }\n        (0, _LogUtils.warn)((0, _DataUtils.isPercent)(width) || (0, _DataUtils.isPercent)(height), \"The width(%s) and height(%s) are both fixed numbers,\\n       maybe you don't need to use a ResponsiveContainer.\", width, height);\n        (0, _LogUtils.warn)(!aspect || aspect > 0, \"The aspect(%s) must be greater than zero.\", aspect);\n        var calculatedWidth = (0, _DataUtils.isPercent)(width) ? containerWidth : width;\n        var calculatedHeight = (0, _DataUtils.isPercent)(height) ? containerHeight : height;\n        if (aspect && aspect > 0) {\n            // Preserve the desired aspect ratio\n            if (calculatedWidth) {\n                // Will default to using width for aspect ratio\n                calculatedHeight = calculatedWidth / aspect;\n            } else if (calculatedHeight) {\n                // But we should also take height into consideration\n                calculatedWidth = calculatedHeight * aspect;\n            }\n            // if maxHeight is set, overwrite if calculatedHeight is greater than maxHeight\n            if (maxHeight && calculatedHeight > maxHeight) {\n                calculatedHeight = maxHeight;\n            }\n        }\n        (0, _LogUtils.warn)(calculatedWidth > 0 || calculatedHeight > 0, \"The width(%s) and height(%s) of chart should be greater than 0,\\n       please check the style of container, or the props width(%s) and height(%s),\\n       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the\\n       height and width.\", calculatedWidth, calculatedHeight, width, height, minWidth, minHeight, aspect);\n        var isCharts = !Array.isArray(children) && (0, _ReactUtils.getDisplayName)(children.type).endsWith(\"Chart\");\n        return _react[\"default\"].Children.map(children, function(child) {\n            if (/*#__PURE__*/ _react[\"default\"].isValidElement(child)) {\n                return /*#__PURE__*/ (0, _react.cloneElement)(child, _objectSpread({\n                    width: calculatedWidth,\n                    height: calculatedHeight\n                }, isCharts ? {\n                    style: _objectSpread({\n                        height: \"100%\",\n                        width: \"100%\",\n                        maxHeight: calculatedHeight,\n                        maxWidth: calculatedWidth\n                    }, child.props.style)\n                } : {}));\n            }\n            return child;\n        });\n    }, [\n        aspect,\n        children,\n        height,\n        maxHeight,\n        minHeight,\n        minWidth,\n        sizes,\n        width\n    ]);\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n        id: id ? \"\".concat(id) : undefined,\n        className: (0, _clsx[\"default\"])(\"recharts-responsive-container\", className),\n        style: _objectSpread(_objectSpread({}, style), {}, {\n            width: width,\n            height: height,\n            minWidth: minWidth,\n            minHeight: minHeight,\n            maxHeight: maxHeight\n        }),\n        ref: containerRef\n    }, chartContent);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9SZXNwb25zaXZlQ29udGFpbmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdUSyw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsMkJBQTJCLEdBQUcsS0FBSztBQUNuQyxJQUFJRyxRQUFRQyx1QkFBdUJDLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlDLFNBQVNDLHdCQUF3QkYsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUcsWUFBWUosdUJBQXVCQyxtQkFBT0EsQ0FBQyx3Q0FBaUI7QUFDaEUsSUFBSUksYUFBYUosbUJBQU9BLENBQUMsd0VBQW1CO0FBQzVDLElBQUlLLFlBQVlMLG1CQUFPQSxDQUFDLHNFQUFrQjtBQUMxQyxJQUFJTSxjQUFjTixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsU0FBU08seUJBQXlCQyxDQUFDO0lBQUksSUFBSSxjQUFjLE9BQU9DLFNBQVMsT0FBTztJQUFNLElBQUlDLElBQUksSUFBSUQsV0FBV0UsSUFBSSxJQUFJRjtJQUFXLE9BQU8sQ0FBQ0YsMkJBQTJCLFNBQVNBLHlCQUF5QkMsQ0FBQztRQUFJLE9BQU9BLElBQUlHLElBQUlEO0lBQUcsR0FBR0Y7QUFBSTtBQUNuTyxTQUFTTix3QkFBd0JNLENBQUMsRUFBRUUsQ0FBQztJQUFJLElBQUksQ0FBQ0EsS0FBS0YsS0FBS0EsRUFBRUks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LFFBQVE7d0JBQ1JELE9BQU87d0JBQ1BPLFdBQVdrRDt3QkFDWFUsVUFBVVg7b0JBQ1osR0FBR1EsTUFBTUksS0FBSyxDQUFDckQsS0FBSztnQkFDdEIsSUFBSSxDQUFDO1lBQ1A7WUFDQSxPQUFPaUQ7UUFDVDtJQUNGLEdBQUc7UUFBQ25FO1FBQVFXO1FBQVVQO1FBQVFNO1FBQVdEO1FBQVdEO1FBQVV1QjtRQUFPNUI7S0FBTTtJQUMzRSxPQUFPLFdBQVcsR0FBRTFFLE1BQU0sQ0FBQyxVQUFVLENBQUMrSSxhQUFhLENBQUMsT0FBTztRQUN6RDFELElBQUlBLEtBQUssR0FBRzJELE1BQU0sQ0FBQzNELE1BQU00RDtRQUN6QjNELFdBQVcsQ0FBQyxHQUFHekYsS0FBSyxDQUFDLFVBQVUsRUFBRSxpQ0FBaUN5RjtRQUNsRUcsT0FBTzFELGNBQWNBLGNBQWMsQ0FBQyxHQUFHMEQsUUFBUSxDQUFDLEdBQUc7WUFDakRmLE9BQU9BO1lBQ1BDLFFBQVFBO1lBQ1JJLFVBQVVBO1lBQ1ZDLFdBQVdBO1lBQ1hDLFdBQVdBO1FBQ2I7UUFDQVgsS0FBS29CO0lBQ1AsR0FBR3FDO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9SZXNwb25zaXZlQ29udGFpbmVyLmpzP2E4YjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlJlc3BvbnNpdmVDb250YWluZXIgPSB2b2lkIDA7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF90aHJvdHRsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC90aHJvdHRsZVwiKSk7XG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcbnZhciBfTG9nVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Mb2dVdGlsc1wiKTtcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfSAvKipcbiAqIEBmaWxlT3ZlcnZpZXcgV3JhcHBlciBjb21wb25lbnQgdG8gbWFrZSBjaGFydHMgYWRhcHQgdG8gdGhlIHNpemUgb2YgcGFyZW50ICogRE9NXG4gKi9cbnZhciBSZXNwb25zaXZlQ29udGFpbmVyID0gZXhwb3J0cy5SZXNwb25zaXZlQ29udGFpbmVyID0gLyojX19QVVJFX18qLygwLCBfcmVhY3QuZm9yd2FyZFJlZikoZnVuY3Rpb24gKF9yZWYsIHJlZikge1xuICB2YXIgYXNwZWN0ID0gX3JlZi5hc3BlY3QsXG4gICAgX3JlZiRpbml0aWFsRGltZW5zaW9uID0gX3JlZi5pbml0aWFsRGltZW5zaW9uLFxuICAgIGluaXRpYWxEaW1lbnNpb24gPSBfcmVmJGluaXRpYWxEaW1lbnNpb24gPT09IHZvaWQgMCA/IHtcbiAgICAgIHdpZHRoOiAtMSxcbiAgICAgIGhlaWdodDogLTFcbiAgICB9IDogX3JlZiRpbml0aWFsRGltZW5zaW9uLFxuICAgIF9yZWYkd2lkdGggPSBfcmVmLndpZHRoLFxuICAgIHdpZHRoID0gX3JlZiR3aWR0aCA9PT0gdm9pZCAwID8gJzEwMCUnIDogX3JlZiR3aWR0aCxcbiAgICBfcmVmJGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgIGhlaWdodCA9IF9yZWYkaGVpZ2h0ID09PSB2b2lkIDAgPyAnMTAwJScgOiBfcmVmJGhlaWdodCxcbiAgICBfcmVmJG1pbldpZHRoID0gX3JlZi5taW5XaWR0aCxcbiAgICBtaW5XaWR0aCA9IF9yZWYkbWluV2lkdGggPT09IHZvaWQgMCA/IDAgOiBfcmVmJG1pbldpZHRoLFxuICAgIG1pbkhlaWdodCA9IF9yZWYubWluSGVpZ2h0LFxuICAgIG1heEhlaWdodCA9IF9yZWYubWF4SGVpZ2h0LFxuICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICBfcmVmJGRlYm91bmNlID0gX3JlZi5kZWJvdW5jZSxcbiAgICBkZWJvdW5jZSA9IF9yZWYkZGVib3VuY2UgPT09IHZvaWQgMCA/IDAgOiBfcmVmJGRlYm91bmNlLFxuICAgIGlkID0gX3JlZi5pZCxcbiAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICBvblJlc2l6ZSA9IF9yZWYub25SZXNpemUsXG4gICAgX3JlZiRzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgc3R5bGUgPSBfcmVmJHN0eWxlID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkc3R5bGU7XG4gIHZhciBjb250YWluZXJSZWYgPSAoMCwgX3JlYWN0LnVzZVJlZikobnVsbCk7XG4gIHZhciBvblJlc2l6ZVJlZiA9ICgwLCBfcmVhY3QudXNlUmVmKSgpO1xuICBvblJlc2l6ZVJlZi5jdXJyZW50ID0gb25SZXNpemU7XG4gICgwLCBfcmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZSkocmVmLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250YWluZXJSZWYuY3VycmVudCwgJ2N1cnJlbnQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKCdUaGUgdXNhZ2Ugb2YgcmVmLmN1cnJlbnQuY3VycmVudCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIG5vIGxvbmdlciBiZSBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIHJldHVybiBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSk7XG4gIHZhciBfdXNlU3RhdGUgPSAoMCwgX3JlYWN0LnVzZVN0YXRlKSh7XG4gICAgICBjb250YWluZXJXaWR0aDogaW5pdGlhbERpbWVuc2lvbi53aWR0aCxcbiAgICAgIGNvbnRhaW5lckhlaWdodDogaW5pdGlhbERpbWVuc2lvbi5oZWlnaHRcbiAgICB9KSxcbiAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICBzaXplcyA9IF91c2VTdGF0ZTJbMF0sXG4gICAgc2V0U2l6ZXMgPSBfdXNlU3RhdGUyWzFdO1xuICB2YXIgc2V0Q29udGFpbmVyU2l6ZSA9ICgwLCBfcmVhY3QudXNlQ2FsbGJhY2spKGZ1bmN0aW9uIChuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7XG4gICAgc2V0U2l6ZXMoZnVuY3Rpb24gKHByZXZTdGF0ZSkge1xuICAgICAgdmFyIHJvdW5kZWRXaWR0aCA9IE1hdGgucm91bmQobmV3V2lkdGgpO1xuICAgICAgdmFyIHJvdW5kZWRIZWlnaHQgPSBNYXRoLnJvdW5kKG5ld0hlaWdodCk7XG4gICAgICBpZiAocHJldlN0YXRlLmNvbnRhaW5lcldpZHRoID09PSByb3VuZGVkV2lkdGggJiYgcHJldlN0YXRlLmNvbnRhaW5lckhlaWdodCA9PT0gcm91bmRlZEhlaWdodCkge1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGFpbmVyV2lkdGg6IHJvdW5kZWRXaWR0aCxcbiAgICAgICAgY29udGFpbmVySGVpZ2h0OiByb3VuZGVkSGVpZ2h0XG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBbXSk7XG4gICgwLCBfcmVhY3QudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soZW50cmllcykge1xuICAgICAgdmFyIF9vblJlc2l6ZVJlZiRjdXJyZW50O1xuICAgICAgdmFyIF9lbnRyaWVzJDAkY29udGVudFJlYyA9IGVudHJpZXNbMF0uY29udGVudFJlY3QsXG4gICAgICAgIGNvbnRhaW5lcldpZHRoID0gX2VudHJpZXMkMCRjb250ZW50UmVjLndpZHRoLFxuICAgICAgICBjb250YWluZXJIZWlnaHQgPSBfZW50cmllcyQwJGNvbnRlbnRSZWMuaGVpZ2h0O1xuICAgICAgc2V0Q29udGFpbmVyU2l6ZShjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KTtcbiAgICAgIChfb25SZXNpemVSZWYkY3VycmVudCA9IG9uUmVzaXplUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9vblJlc2l6ZVJlZiRjdXJyZW50ID09PSB2b2lkIDAgfHwgX29uUmVzaXplUmVmJGN1cnJlbnQuY2FsbChvblJlc2l6ZVJlZiwgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCk7XG4gICAgfTtcbiAgICBpZiAoZGVib3VuY2UgPiAwKSB7XG4gICAgICBjYWxsYmFjayA9ICgwLCBfdGhyb3R0bGVbXCJkZWZhdWx0XCJdKShjYWxsYmFjaywgZGVib3VuY2UsIHtcbiAgICAgICAgdHJhaWxpbmc6IHRydWUsXG4gICAgICAgIGxlYWRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICB2YXIgX2NvbnRhaW5lclJlZiRjdXJyZW50ID0gY29udGFpbmVyUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBjb250YWluZXJXaWR0aCA9IF9jb250YWluZXJSZWYkY3VycmVudC53aWR0aCxcbiAgICAgIGNvbnRhaW5lckhlaWdodCA9IF9jb250YWluZXJSZWYkY3VycmVudC5oZWlnaHQ7XG4gICAgc2V0Q29udGFpbmVyU2l6ZShjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lclJlZi5jdXJyZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH0sIFtzZXRDb250YWluZXJTaXplLCBkZWJvdW5jZV0pO1xuICB2YXIgY2hhcnRDb250ZW50ID0gKDAsIF9yZWFjdC51c2VNZW1vKShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRhaW5lcldpZHRoID0gc2l6ZXMuY29udGFpbmVyV2lkdGgsXG4gICAgICBjb250YWluZXJIZWlnaHQgPSBzaXplcy5jb250YWluZXJIZWlnaHQ7XG4gICAgaWYgKGNvbnRhaW5lcldpZHRoIDwgMCB8fCBjb250YWluZXJIZWlnaHQgPCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgKDAsIF9Mb2dVdGlscy53YXJuKSgoMCwgX0RhdGFVdGlscy5pc1BlcmNlbnQpKHdpZHRoKSB8fCAoMCwgX0RhdGFVdGlscy5pc1BlcmNlbnQpKGhlaWdodCksIFwiVGhlIHdpZHRoKCVzKSBhbmQgaGVpZ2h0KCVzKSBhcmUgYm90aCBmaXhlZCBudW1iZXJzLFxcbiAgICAgICBtYXliZSB5b3UgZG9uJ3QgbmVlZCB0byB1c2UgYSBSZXNwb25zaXZlQ29udGFpbmVyLlwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAoMCwgX0xvZ1V0aWxzLndhcm4pKCFhc3BlY3QgfHwgYXNwZWN0ID4gMCwgJ1RoZSBhc3BlY3QoJXMpIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uJywgYXNwZWN0KTtcbiAgICB2YXIgY2FsY3VsYXRlZFdpZHRoID0gKDAsIF9EYXRhVXRpbHMuaXNQZXJjZW50KSh3aWR0aCkgPyBjb250YWluZXJXaWR0aCA6IHdpZHRoO1xuICAgIHZhciBjYWxjdWxhdGVkSGVpZ2h0ID0gKDAsIF9EYXRhVXRpbHMuaXNQZXJjZW50KShoZWlnaHQpID8gY29udGFpbmVySGVpZ2h0IDogaGVpZ2h0O1xuICAgIGlmIChhc3BlY3QgJiYgYXNwZWN0ID4gMCkge1xuICAgICAgLy8gUHJlc2VydmUgdGhlIGRlc2lyZWQgYXNwZWN0IHJhdGlvXG4gICAgICBpZiAoY2FsY3VsYXRlZFdpZHRoKSB7XG4gICAgICAgIC8vIFdpbGwgZGVmYXVsdCB0byB1c2luZyB3aWR0aCBmb3IgYXNwZWN0IHJhdGlvXG4gICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBjYWxjdWxhdGVkV2lkdGggLyBhc3BlY3Q7XG4gICAgICB9IGVsc2UgaWYgKGNhbGN1bGF0ZWRIZWlnaHQpIHtcbiAgICAgICAgLy8gQnV0IHdlIHNob3VsZCBhbHNvIHRha2UgaGVpZ2h0IGludG8gY29uc2lkZXJhdGlvblxuICAgICAgICBjYWxjdWxhdGVkV2lkdGggPSBjYWxjdWxhdGVkSGVpZ2h0ICogYXNwZWN0O1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBtYXhIZWlnaHQgaXMgc2V0LCBvdmVyd3JpdGUgaWYgY2FsY3VsYXRlZEhlaWdodCBpcyBncmVhdGVyIHRoYW4gbWF4SGVpZ2h0XG4gICAgICBpZiAobWF4SGVpZ2h0ICYmIGNhbGN1bGF0ZWRIZWlnaHQgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgY2FsY3VsYXRlZEhlaWdodCA9IG1heEhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgKDAsIF9Mb2dVdGlscy53YXJuKShjYWxjdWxhdGVkV2lkdGggPiAwIHx8IGNhbGN1bGF0ZWRIZWlnaHQgPiAwLCBcIlRoZSB3aWR0aCglcykgYW5kIGhlaWdodCglcykgb2YgY2hhcnQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiAwLFxcbiAgICAgICBwbGVhc2UgY2hlY2sgdGhlIHN0eWxlIG9mIGNvbnRhaW5lciwgb3IgdGhlIHByb3BzIHdpZHRoKCVzKSBhbmQgaGVpZ2h0KCVzKSxcXG4gICAgICAgb3IgYWRkIGEgbWluV2lkdGgoJXMpIG9yIG1pbkhlaWdodCglcykgb3IgdXNlIGFzcGVjdCglcykgdG8gY29udHJvbCB0aGVcXG4gICAgICAgaGVpZ2h0IGFuZCB3aWR0aC5cIiwgY2FsY3VsYXRlZFdpZHRoLCBjYWxjdWxhdGVkSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBtaW5XaWR0aCwgbWluSGVpZ2h0LCBhc3BlY3QpO1xuICAgIHZhciBpc0NoYXJ0cyA9ICFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiAoMCwgX1JlYWN0VXRpbHMuZ2V0RGlzcGxheU5hbWUpKGNoaWxkcmVuLnR5cGUpLmVuZHNXaXRoKCdDaGFydCcpO1xuICAgIHJldHVybiBfcmVhY3RbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShjaGlsZCwgX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgd2lkdGg6IGNhbGN1bGF0ZWRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNhbGN1bGF0ZWRIZWlnaHRcbiAgICAgICAgfSwgaXNDaGFydHMgPyB7XG4gICAgICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBjYWxjdWxhdGVkSGVpZ2h0LFxuICAgICAgICAgICAgbWF4V2lkdGg6IGNhbGN1bGF0ZWRXaWR0aFxuICAgICAgICAgIH0sIGNoaWxkLnByb3BzLnN0eWxlKVxuICAgICAgICB9IDoge30pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9KTtcbiAgfSwgW2FzcGVjdCwgY2hpbGRyZW4sIGhlaWdodCwgbWF4SGVpZ2h0LCBtaW5IZWlnaHQsIG1pbldpZHRoLCBzaXplcywgd2lkdGhdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGlkOiBpZCA/IFwiXCIuY29uY2F0KGlkKSA6IHVuZGVmaW5lZCxcbiAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1yZXNwb25zaXZlLWNvbnRhaW5lcicsIGNsYXNzTmFtZSksXG4gICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3R5bGUpLCB7fSwge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBtaW5XaWR0aDogbWluV2lkdGgsXG4gICAgICBtaW5IZWlnaHQ6IG1pbkhlaWdodCxcbiAgICAgIG1heEhlaWdodDogbWF4SGVpZ2h0XG4gICAgfSksXG4gICAgcmVmOiBjb250YWluZXJSZWZcbiAgfSwgY2hhcnRDb250ZW50KTtcbn0pOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJlc3BvbnNpdmVDb250YWluZXIiLCJfY2xzeCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfdGhyb3R0bGUiLCJfRGF0YVV0aWxzIiwiX0xvZ1V0aWxzIiwiX1JlYWN0VXRpbHMiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX19lc01vZHVsZSIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvYmoiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwia2V5IiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJsZW4iLCJhcnIyIiwibCIsImYiLCJuZXh0IiwiZG9uZSIsImlzQXJyYXkiLCJmb3J3YXJkUmVmIiwiX3JlZiIsInJlZiIsImFzcGVjdCIsIl9yZWYkaW5pdGlhbERpbWVuc2lvbiIsImluaXRpYWxEaW1lbnNpb24iLCJ3aWR0aCIsImhlaWdodCIsIl9yZWYkd2lkdGgiLCJfcmVmJGhlaWdodCIsIl9yZWYkbWluV2lkdGgiLCJtaW5XaWR0aCIsIm1pbkhlaWdodCIsIm1heEhlaWdodCIsImNoaWxkcmVuIiwiX3JlZiRkZWJvdW5jZSIsImRlYm91bmNlIiwiaWQiLCJjbGFzc05hbWUiLCJvblJlc2l6ZSIsIl9yZWYkc3R5bGUiLCJzdHlsZSIsImNvbnRhaW5lclJlZiIsInVzZVJlZiIsIm9uUmVzaXplUmVmIiwiY3VycmVudCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJjb25zb2xlIiwid2FybiIsIl91c2VTdGF0ZSIsInVzZVN0YXRlIiwiY29udGFpbmVyV2lkdGgiLCJjb250YWluZXJIZWlnaHQiLCJfdXNlU3RhdGUyIiwic2l6ZXMiLCJzZXRTaXplcyIsInNldENvbnRhaW5lclNpemUiLCJ1c2VDYWxsYmFjayIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwicHJldlN0YXRlIiwicm91bmRlZFdpZHRoIiwiTWF0aCIsInJvdW5kIiwicm91bmRlZEhlaWdodCIsInVzZUVmZmVjdCIsImNhbGxiYWNrIiwiZW50cmllcyIsIl9vblJlc2l6ZVJlZiRjdXJyZW50IiwiX2VudHJpZXMkMCRjb250ZW50UmVjIiwiY29udGVudFJlY3QiLCJ0cmFpbGluZyIsImxlYWRpbmciLCJvYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwiX2NvbnRhaW5lclJlZiRjdXJyZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJjaGFydENvbnRlbnQiLCJ1c2VNZW1vIiwiaXNQZXJjZW50IiwiY2FsY3VsYXRlZFdpZHRoIiwiY2FsY3VsYXRlZEhlaWdodCIsImlzQ2hhcnRzIiwiZ2V0RGlzcGxheU5hbWUiLCJ0eXBlIiwiZW5kc1dpdGgiLCJDaGlsZHJlbiIsIm1hcCIsImNoaWxkIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJtYXhXaWR0aCIsInByb3BzIiwiY3JlYXRlRWxlbWVudCIsImNvbmNhdCIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/component/ResponsiveContainer.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/component/Text.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/component/Text.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Text = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"./node_modules/recharts/lib/util/Global.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _DOMUtils = __webpack_require__(/*! ../util/DOMUtils */ \"./node_modules/recharts/lib/util/DOMUtils.js\");\nvar _ReduceCSSCalc = __webpack_require__(/*! ../util/ReduceCSSCalc */ \"./node_modules/recharts/lib/util/ReduceCSSCalc.js\");\nvar _excluded = [\n    \"x\",\n    \"y\",\n    \"lineHeight\",\n    \"capHeight\",\n    \"scaleToFit\",\n    \"textAnchor\",\n    \"verticalAnchor\",\n    \"fill\"\n], _excluded2 = [\n    \"dx\",\n    \"dy\",\n    \"angle\",\n    \"className\",\n    \"breakAll\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nvar BREAKING_SPACES = /[ \\f\\n\\r\\t\\v\\u2028\\u2029]+/;\nvar calculateWordWidths = function calculateWordWidths(_ref) {\n    var children = _ref.children, breakAll = _ref.breakAll, style = _ref.style;\n    try {\n        var words = [];\n        if (!(0, _isNil[\"default\"])(children)) {\n            if (breakAll) {\n                words = children.toString().split(\"\");\n            } else {\n                words = children.toString().split(BREAKING_SPACES);\n            }\n        }\n        var wordsWithComputedWidth = words.map(function(word) {\n            return {\n                word: word,\n                width: (0, _DOMUtils.getStringSize)(word, style).width\n            };\n        });\n        var spaceWidth = breakAll ? 0 : (0, _DOMUtils.getStringSize)(\"\\xa0\", style).width;\n        return {\n            wordsWithComputedWidth: wordsWithComputedWidth,\n            spaceWidth: spaceWidth\n        };\n    } catch (e) {\n        return null;\n    }\n};\nvar calculateWordsByLines = function calculateWordsByLines(_ref2, initialWordsWithComputedWith, spaceWidth, lineWidth, scaleToFit) {\n    var maxLines = _ref2.maxLines, children = _ref2.children, style = _ref2.style, breakAll = _ref2.breakAll;\n    var shouldLimitLines = (0, _DataUtils.isNumber)(maxLines);\n    var text = children;\n    var calculate = function calculate() {\n        var words = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        return words.reduce(function(result, _ref3) {\n            var word = _ref3.word, width = _ref3.width;\n            var currentLine = result[result.length - 1];\n            if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < Number(lineWidth))) {\n                // Word can be added to an existing line\n                currentLine.words.push(word);\n                currentLine.width += width + spaceWidth;\n            } else {\n                // Add first word to line or word is too long to scaleToFit on existing line\n                var newLine = {\n                    words: [\n                        word\n                    ],\n                    width: width\n                };\n                result.push(newLine);\n            }\n            return result;\n        }, []);\n    };\n    var originalResult = calculate(initialWordsWithComputedWith);\n    var findLongestLine = function findLongestLine(words) {\n        return words.reduce(function(a, b) {\n            return a.width > b.width ? a : b;\n        });\n    };\n    if (!shouldLimitLines) {\n        return originalResult;\n    }\n    var suffix = \"…\";\n    var checkOverflow = function checkOverflow(index) {\n        var tempText = text.slice(0, index);\n        var words = calculateWordWidths({\n            breakAll: breakAll,\n            style: style,\n            children: tempText + suffix\n        }).wordsWithComputedWidth;\n        var result = calculate(words);\n        var doesOverflow = result.length > maxLines || findLongestLine(result).width > Number(lineWidth);\n        return [\n            doesOverflow,\n            result\n        ];\n    };\n    var start = 0;\n    var end = text.length - 1;\n    var iterations = 0;\n    var trimmedResult;\n    while(start <= end && iterations <= text.length - 1){\n        var middle = Math.floor((start + end) / 2);\n        var prev = middle - 1;\n        var _checkOverflow = checkOverflow(prev), _checkOverflow2 = _slicedToArray(_checkOverflow, 2), doesPrevOverflow = _checkOverflow2[0], result = _checkOverflow2[1];\n        var _checkOverflow3 = checkOverflow(middle), _checkOverflow4 = _slicedToArray(_checkOverflow3, 1), doesMiddleOverflow = _checkOverflow4[0];\n        if (!doesPrevOverflow && !doesMiddleOverflow) {\n            start = middle + 1;\n        }\n        if (doesPrevOverflow && doesMiddleOverflow) {\n            end = middle - 1;\n        }\n        if (!doesPrevOverflow && doesMiddleOverflow) {\n            trimmedResult = result;\n            break;\n        }\n        iterations++;\n    }\n    // Fallback to originalResult (result without trimming) if we cannot find the\n    // where to trim.  This should not happen :tm:\n    return trimmedResult || originalResult;\n};\nvar getWordsWithoutCalculate = function getWordsWithoutCalculate(children) {\n    var words = !(0, _isNil[\"default\"])(children) ? children.toString().split(BREAKING_SPACES) : [];\n    return [\n        {\n            words: words\n        }\n    ];\n};\nvar getWordsByLines = function getWordsByLines(_ref4) {\n    var width = _ref4.width, scaleToFit = _ref4.scaleToFit, children = _ref4.children, style = _ref4.style, breakAll = _ref4.breakAll, maxLines = _ref4.maxLines;\n    // Only perform calculations if using features that require them (multiline, scaleToFit)\n    if ((width || scaleToFit) && !_Global.Global.isSsr) {\n        var wordsWithComputedWidth, spaceWidth;\n        var wordWidths = calculateWordWidths({\n            breakAll: breakAll,\n            children: children,\n            style: style\n        });\n        if (wordWidths) {\n            var wcw = wordWidths.wordsWithComputedWidth, sw = wordWidths.spaceWidth;\n            wordsWithComputedWidth = wcw;\n            spaceWidth = sw;\n        } else {\n            return getWordsWithoutCalculate(children);\n        }\n        return calculateWordsByLines({\n            breakAll: breakAll,\n            children: children,\n            maxLines: maxLines,\n            style: style\n        }, wordsWithComputedWidth, spaceWidth, width, scaleToFit);\n    }\n    return getWordsWithoutCalculate(children);\n};\nvar DEFAULT_FILL = \"#808080\";\nvar Text = exports.Text = function Text(_ref5) {\n    var _ref5$x = _ref5.x, propsX = _ref5$x === void 0 ? 0 : _ref5$x, _ref5$y = _ref5.y, propsY = _ref5$y === void 0 ? 0 : _ref5$y, _ref5$lineHeight = _ref5.lineHeight, lineHeight = _ref5$lineHeight === void 0 ? \"1em\" : _ref5$lineHeight, _ref5$capHeight = _ref5.capHeight, capHeight = _ref5$capHeight === void 0 ? \"0.71em\" : _ref5$capHeight, _ref5$scaleToFit = _ref5.scaleToFit, scaleToFit = _ref5$scaleToFit === void 0 ? false : _ref5$scaleToFit, _ref5$textAnchor = _ref5.textAnchor, textAnchor = _ref5$textAnchor === void 0 ? \"start\" : _ref5$textAnchor, _ref5$verticalAnchor = _ref5.verticalAnchor, verticalAnchor = _ref5$verticalAnchor === void 0 ? \"end\" : _ref5$verticalAnchor, _ref5$fill = _ref5.fill, fill = _ref5$fill === void 0 ? DEFAULT_FILL : _ref5$fill, props = _objectWithoutProperties(_ref5, _excluded);\n    var wordsByLines = (0, _react.useMemo)(function() {\n        return getWordsByLines({\n            breakAll: props.breakAll,\n            children: props.children,\n            maxLines: props.maxLines,\n            scaleToFit: scaleToFit,\n            style: props.style,\n            width: props.width\n        });\n    }, [\n        props.breakAll,\n        props.children,\n        props.maxLines,\n        scaleToFit,\n        props.style,\n        props.width\n    ]);\n    var dx = props.dx, dy = props.dy, angle = props.angle, className = props.className, breakAll = props.breakAll, textProps = _objectWithoutProperties(props, _excluded2);\n    if (!(0, _DataUtils.isNumOrStr)(propsX) || !(0, _DataUtils.isNumOrStr)(propsY)) {\n        return null;\n    }\n    var x = propsX + ((0, _DataUtils.isNumber)(dx) ? dx : 0);\n    var y = propsY + ((0, _DataUtils.isNumber)(dy) ? dy : 0);\n    var startDy;\n    switch(verticalAnchor){\n        case \"start\":\n            startDy = (0, _ReduceCSSCalc.reduceCSSCalc)(\"calc(\".concat(capHeight, \")\"));\n            break;\n        case \"middle\":\n            startDy = (0, _ReduceCSSCalc.reduceCSSCalc)(\"calc(\".concat((wordsByLines.length - 1) / 2, \" * -\").concat(lineHeight, \" + (\").concat(capHeight, \" / 2))\"));\n            break;\n        default:\n            startDy = (0, _ReduceCSSCalc.reduceCSSCalc)(\"calc(\".concat(wordsByLines.length - 1, \" * -\").concat(lineHeight, \")\"));\n            break;\n    }\n    var transforms = [];\n    if (scaleToFit) {\n        var lineWidth = wordsByLines[0].width;\n        var width = props.width;\n        transforms.push(\"scale(\".concat(((0, _DataUtils.isNumber)(width) ? width / lineWidth : 1) / lineWidth, \")\"));\n    }\n    if (angle) {\n        transforms.push(\"rotate(\".concat(angle, \", \").concat(x, \", \").concat(y, \")\"));\n    }\n    if (transforms.length) {\n        textProps.transform = transforms.join(\" \");\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"text\", _extends({}, (0, _ReactUtils.filterProps)(textProps, true), {\n        x: x,\n        y: y,\n        className: (0, _clsx[\"default\"])(\"recharts-text\", className),\n        textAnchor: textAnchor,\n        fill: fill.includes(\"url\") ? DEFAULT_FILL : fill\n    }), wordsByLines.map(function(line, index) {\n        var words = line.words.join(breakAll ? \"\" : \" \");\n        return(/*#__PURE__*/ // duplicate words will cause duplicate keys\n        // eslint-disable-next-line react/no-array-index-key\n        _react[\"default\"].createElement(\"tspan\", {\n            x: x,\n            dy: index === 0 ? startDy : lineHeight,\n            key: \"\".concat(words, \"-\").concat(index)\n        }, words));\n    }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9UZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdUSyw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsWUFBWSxHQUFHLEtBQUs7QUFDcEIsSUFBSUcsU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyxTQUFTQyx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlHLFFBQVFELHVCQUF1QkYsbUJBQU9BLENBQUMsa0JBQU07QUFDakQsSUFBSUksYUFBYUosbUJBQU9BLENBQUMsd0VBQW1CO0FBQzVDLElBQUlLLFVBQVVMLG1CQUFPQSxDQUFDLGtFQUFnQjtBQUN0QyxJQUFJTSxjQUFjTixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSU8sWUFBWVAsbUJBQU9BLENBQUMsc0VBQWtCO0FBQzFDLElBQUlRLGlCQUFpQlIsbUJBQU9BLENBQUMsZ0ZBQXVCO0FBQ3BELElBQUlTLFlBQVk7SUFBQztJQUFLO0lBQUs7SUFBYztJQUFhO0lBQWM7SUFBYztJQUFrQjtDQUFPLEVBQ3pHQyxhQUFhO0lBQUM7SUFBTTtJQUFNO0lBQVM7SUFBYTtDQUFXO0FBQzdELFNBQVNSLHVCQUF1QlMsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFB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L2xpYi9jb21wb25lbnQvVGV4dC5qcz84YmJmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5UZXh0ID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2lzTmlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzTmlsXCIpKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XG52YXIgX0dsb2JhbCA9IHJlcXVpcmUoXCIuLi91dGlsL0dsb2JhbFwiKTtcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRE9NVXRpbHNcIik7XG52YXIgX1JlZHVjZUNTU0NhbGMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWR1Y2VDU1NDYWxjXCIpO1xudmFyIF9leGNsdWRlZCA9IFtcInhcIiwgXCJ5XCIsIFwibGluZUhlaWdodFwiLCBcImNhcEhlaWdodFwiLCBcInNjYWxlVG9GaXRcIiwgXCJ0ZXh0QW5jaG9yXCIsIFwidmVydGljYWxBbmNob3JcIiwgXCJmaWxsXCJdLFxuICBfZXhjbHVkZWQyID0gW1wiZHhcIiwgXCJkeVwiLCBcImFuZ2xlXCIsIFwiY2xhc3NOYW1lXCIsIFwiYnJlYWtBbGxcIl07XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG52YXIgQlJFQUtJTkdfU1BBQ0VTID0gL1sgXFxmXFxuXFxyXFx0XFx2XFx1MjAyOFxcdTIwMjldKy87XG52YXIgY2FsY3VsYXRlV29yZFdpZHRocyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVdvcmRXaWR0aHMoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgIGJyZWFrQWxsID0gX3JlZi5icmVha0FsbCxcbiAgICBzdHlsZSA9IF9yZWYuc3R5bGU7XG4gIHRyeSB7XG4gICAgdmFyIHdvcmRzID0gW107XG4gICAgaWYgKCEoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAoYnJlYWtBbGwpIHtcbiAgICAgICAgd29yZHMgPSBjaGlsZHJlbi50b1N0cmluZygpLnNwbGl0KCcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmRzID0gY2hpbGRyZW4udG9TdHJpbmcoKS5zcGxpdChCUkVBS0lOR19TUEFDRVMpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgd29yZHNXaXRoQ29tcHV0ZWRXaWR0aCA9IHdvcmRzLm1hcChmdW5jdGlvbiAod29yZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd29yZDogd29yZCxcbiAgICAgICAgd2lkdGg6ICgwLCBfRE9NVXRpbHMuZ2V0U3RyaW5nU2l6ZSkod29yZCwgc3R5bGUpLndpZHRoXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHZhciBzcGFjZVdpZHRoID0gYnJlYWtBbGwgPyAwIDogKDAsIF9ET01VdGlscy5nZXRTdHJpbmdTaXplKShcIlxceEEwXCIsIHN0eWxlKS53aWR0aDtcbiAgICByZXR1cm4ge1xuICAgICAgd29yZHNXaXRoQ29tcHV0ZWRXaWR0aDogd29yZHNXaXRoQ29tcHV0ZWRXaWR0aCxcbiAgICAgIHNwYWNlV2lkdGg6IHNwYWNlV2lkdGhcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG52YXIgY2FsY3VsYXRlV29yZHNCeUxpbmVzID0gZnVuY3Rpb24gY2FsY3VsYXRlV29yZHNCeUxpbmVzKF9yZWYyLCBpbml0aWFsV29yZHNXaXRoQ29tcHV0ZWRXaXRoLCBzcGFjZVdpZHRoLCBsaW5lV2lkdGgsIHNjYWxlVG9GaXQpIHtcbiAgdmFyIG1heExpbmVzID0gX3JlZjIubWF4TGluZXMsXG4gICAgY2hpbGRyZW4gPSBfcmVmMi5jaGlsZHJlbixcbiAgICBzdHlsZSA9IF9yZWYyLnN0eWxlLFxuICAgIGJyZWFrQWxsID0gX3JlZjIuYnJlYWtBbGw7XG4gIHZhciBzaG91bGRMaW1pdExpbmVzID0gKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKG1heExpbmVzKTtcbiAgdmFyIHRleHQgPSBjaGlsZHJlbjtcbiAgdmFyIGNhbGN1bGF0ZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZSgpIHtcbiAgICB2YXIgd29yZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIHJldHVybiB3b3Jkcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgX3JlZjMpIHtcbiAgICAgIHZhciB3b3JkID0gX3JlZjMud29yZCxcbiAgICAgICAgd2lkdGggPSBfcmVmMy53aWR0aDtcbiAgICAgIHZhciBjdXJyZW50TGluZSA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoY3VycmVudExpbmUgJiYgKGxpbmVXaWR0aCA9PSBudWxsIHx8IHNjYWxlVG9GaXQgfHwgY3VycmVudExpbmUud2lkdGggKyB3aWR0aCArIHNwYWNlV2lkdGggPCBOdW1iZXIobGluZVdpZHRoKSkpIHtcbiAgICAgICAgLy8gV29yZCBjYW4gYmUgYWRkZWQgdG8gYW4gZXhpc3RpbmcgbGluZVxuICAgICAgICBjdXJyZW50TGluZS53b3Jkcy5wdXNoKHdvcmQpO1xuICAgICAgICBjdXJyZW50TGluZS53aWR0aCArPSB3aWR0aCArIHNwYWNlV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQgZmlyc3Qgd29yZCB0byBsaW5lIG9yIHdvcmQgaXMgdG9vIGxvbmcgdG8gc2NhbGVUb0ZpdCBvbiBleGlzdGluZyBsaW5lXG4gICAgICAgIHZhciBuZXdMaW5lID0ge1xuICAgICAgICAgIHdvcmRzOiBbd29yZF0sXG4gICAgICAgICAgd2lkdGg6IHdpZHRoXG4gICAgICAgIH07XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ld0xpbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG4gIH07XG4gIHZhciBvcmlnaW5hbFJlc3VsdCA9IGNhbGN1bGF0ZShpbml0aWFsV29yZHNXaXRoQ29tcHV0ZWRXaXRoKTtcbiAgdmFyIGZpbmRMb25nZXN0TGluZSA9IGZ1bmN0aW9uIGZpbmRMb25nZXN0TGluZSh3b3Jkcykge1xuICAgIHJldHVybiB3b3Jkcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLndpZHRoID4gYi53aWR0aCA/IGEgOiBiO1xuICAgIH0pO1xuICB9O1xuICBpZiAoIXNob3VsZExpbWl0TGluZXMpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxSZXN1bHQ7XG4gIH1cbiAgdmFyIHN1ZmZpeCA9ICfigKYnO1xuICB2YXIgY2hlY2tPdmVyZmxvdyA9IGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3coaW5kZXgpIHtcbiAgICB2YXIgdGVtcFRleHQgPSB0ZXh0LnNsaWNlKDAsIGluZGV4KTtcbiAgICB2YXIgd29yZHMgPSBjYWxjdWxhdGVXb3JkV2lkdGhzKHtcbiAgICAgIGJyZWFrQWxsOiBicmVha0FsbCxcbiAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgIGNoaWxkcmVuOiB0ZW1wVGV4dCArIHN1ZmZpeFxuICAgIH0pLndvcmRzV2l0aENvbXB1dGVkV2lkdGg7XG4gICAgdmFyIHJlc3VsdCA9IGNhbGN1bGF0ZSh3b3Jkcyk7XG4gICAgdmFyIGRvZXNPdmVyZmxvdyA9IHJlc3VsdC5sZW5ndGggPiBtYXhMaW5lcyB8fCBmaW5kTG9uZ2VzdExpbmUocmVzdWx0KS53aWR0aCA+IE51bWJlcihsaW5lV2lkdGgpO1xuICAgIHJldHVybiBbZG9lc092ZXJmbG93LCByZXN1bHRdO1xuICB9O1xuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgZW5kID0gdGV4dC5sZW5ndGggLSAxO1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHZhciB0cmltbWVkUmVzdWx0O1xuICB3aGlsZSAoc3RhcnQgPD0gZW5kICYmIGl0ZXJhdGlvbnMgPD0gdGV4dC5sZW5ndGggLSAxKSB7XG4gICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgIHZhciBwcmV2ID0gbWlkZGxlIC0gMTtcbiAgICB2YXIgX2NoZWNrT3ZlcmZsb3cgPSBjaGVja092ZXJmbG93KHByZXYpLFxuICAgICAgX2NoZWNrT3ZlcmZsb3cyID0gX3NsaWNlZFRvQXJyYXkoX2NoZWNrT3ZlcmZsb3csIDIpLFxuICAgICAgZG9lc1ByZXZPdmVyZmxvdyA9IF9jaGVja092ZXJmbG93MlswXSxcbiAgICAgIHJlc3VsdCA9IF9jaGVja092ZXJmbG93MlsxXTtcbiAgICB2YXIgX2NoZWNrT3ZlcmZsb3czID0gY2hlY2tPdmVyZmxvdyhtaWRkbGUpLFxuICAgICAgX2NoZWNrT3ZlcmZsb3c0ID0gX3NsaWNlZFRvQXJyYXkoX2NoZWNrT3ZlcmZsb3czLCAxKSxcbiAgICAgIGRvZXNNaWRkbGVPdmVyZmxvdyA9IF9jaGVja092ZXJmbG93NFswXTtcbiAgICBpZiAoIWRvZXNQcmV2T3ZlcmZsb3cgJiYgIWRvZXNNaWRkbGVPdmVyZmxvdykge1xuICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgIH1cbiAgICBpZiAoZG9lc1ByZXZPdmVyZmxvdyAmJiBkb2VzTWlkZGxlT3ZlcmZsb3cpIHtcbiAgICAgIGVuZCA9IG1pZGRsZSAtIDE7XG4gICAgfVxuICAgIGlmICghZG9lc1ByZXZPdmVyZmxvdyAmJiBkb2VzTWlkZGxlT3ZlcmZsb3cpIHtcbiAgICAgIHRyaW1tZWRSZXN1bHQgPSByZXN1bHQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaXRlcmF0aW9ucysrO1xuICB9XG5cbiAgLy8gRmFsbGJhY2sgdG8gb3JpZ2luYWxSZXN1bHQgKHJlc3VsdCB3aXRob3V0IHRyaW1taW5nKSBpZiB3ZSBjYW5ub3QgZmluZCB0aGVcbiAgLy8gd2hlcmUgdG8gdHJpbS4gIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4gOnRtOlxuICByZXR1cm4gdHJpbW1lZFJlc3VsdCB8fCBvcmlnaW5hbFJlc3VsdDtcbn07XG52YXIgZ2V0V29yZHNXaXRob3V0Q2FsY3VsYXRlID0gZnVuY3Rpb24gZ2V0V29yZHNXaXRob3V0Q2FsY3VsYXRlKGNoaWxkcmVuKSB7XG4gIHZhciB3b3JkcyA9ICEoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoY2hpbGRyZW4pID8gY2hpbGRyZW4udG9TdHJpbmcoKS5zcGxpdChCUkVBS0lOR19TUEFDRVMpIDogW107XG4gIHJldHVybiBbe1xuICAgIHdvcmRzOiB3b3Jkc1xuICB9XTtcbn07XG52YXIgZ2V0V29yZHNCeUxpbmVzID0gZnVuY3Rpb24gZ2V0V29yZHNCeUxpbmVzKF9yZWY0KSB7XG4gIHZhciB3aWR0aCA9IF9yZWY0LndpZHRoLFxuICAgIHNjYWxlVG9GaXQgPSBfcmVmNC5zY2FsZVRvRml0LFxuICAgIGNoaWxkcmVuID0gX3JlZjQuY2hpbGRyZW4sXG4gICAgc3R5bGUgPSBfcmVmNC5zdHlsZSxcbiAgICBicmVha0FsbCA9IF9yZWY0LmJyZWFrQWxsLFxuICAgIG1heExpbmVzID0gX3JlZjQubWF4TGluZXM7XG4gIC8vIE9ubHkgcGVyZm9ybSBjYWxjdWxhdGlvbnMgaWYgdXNpbmcgZmVhdHVyZXMgdGhhdCByZXF1aXJlIHRoZW0gKG11bHRpbGluZSwgc2NhbGVUb0ZpdClcbiAgaWYgKCh3aWR0aCB8fCBzY2FsZVRvRml0KSAmJiAhX0dsb2JhbC5HbG9iYWwuaXNTc3IpIHtcbiAgICB2YXIgd29yZHNXaXRoQ29tcHV0ZWRXaWR0aCwgc3BhY2VXaWR0aDtcbiAgICB2YXIgd29yZFdpZHRocyA9IGNhbGN1bGF0ZVdvcmRXaWR0aHMoe1xuICAgICAgYnJlYWtBbGw6IGJyZWFrQWxsLFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgc3R5bGU6IHN0eWxlXG4gICAgfSk7XG4gICAgaWYgKHdvcmRXaWR0aHMpIHtcbiAgICAgIHZhciB3Y3cgPSB3b3JkV2lkdGhzLndvcmRzV2l0aENvbXB1dGVkV2lkdGgsXG4gICAgICAgIHN3ID0gd29yZFdpZHRocy5zcGFjZVdpZHRoO1xuICAgICAgd29yZHNXaXRoQ29tcHV0ZWRXaWR0aCA9IHdjdztcbiAgICAgIHNwYWNlV2lkdGggPSBzdztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldFdvcmRzV2l0aG91dENhbGN1bGF0ZShjaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiBjYWxjdWxhdGVXb3Jkc0J5TGluZXMoe1xuICAgICAgYnJlYWtBbGw6IGJyZWFrQWxsLFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgbWF4TGluZXM6IG1heExpbmVzLFxuICAgICAgc3R5bGU6IHN0eWxlXG4gICAgfSwgd29yZHNXaXRoQ29tcHV0ZWRXaWR0aCwgc3BhY2VXaWR0aCwgd2lkdGgsIHNjYWxlVG9GaXQpO1xuICB9XG4gIHJldHVybiBnZXRXb3Jkc1dpdGhvdXRDYWxjdWxhdGUoY2hpbGRyZW4pO1xufTtcbnZhciBERUZBVUxUX0ZJTEwgPSAnIzgwODA4MCc7XG52YXIgVGV4dCA9IGV4cG9ydHMuVGV4dCA9IGZ1bmN0aW9uIFRleHQoX3JlZjUpIHtcbiAgdmFyIF9yZWY1JHggPSBfcmVmNS54LFxuICAgIHByb3BzWCA9IF9yZWY1JHggPT09IHZvaWQgMCA/IDAgOiBfcmVmNSR4LFxuICAgIF9yZWY1JHkgPSBfcmVmNS55LFxuICAgIHByb3BzWSA9IF9yZWY1JHkgPT09IHZvaWQgMCA/IDAgOiBfcmVmNSR5LFxuICAgIF9yZWY1JGxpbmVIZWlnaHQgPSBfcmVmNS5saW5lSGVpZ2h0LFxuICAgIGxpbmVIZWlnaHQgPSBfcmVmNSRsaW5lSGVpZ2h0ID09PSB2b2lkIDAgPyAnMWVtJyA6IF9yZWY1JGxpbmVIZWlnaHQsXG4gICAgX3JlZjUkY2FwSGVpZ2h0ID0gX3JlZjUuY2FwSGVpZ2h0LFxuICAgIGNhcEhlaWdodCA9IF9yZWY1JGNhcEhlaWdodCA9PT0gdm9pZCAwID8gJzAuNzFlbScgOiBfcmVmNSRjYXBIZWlnaHQsXG4gICAgX3JlZjUkc2NhbGVUb0ZpdCA9IF9yZWY1LnNjYWxlVG9GaXQsXG4gICAgc2NhbGVUb0ZpdCA9IF9yZWY1JHNjYWxlVG9GaXQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjUkc2NhbGVUb0ZpdCxcbiAgICBfcmVmNSR0ZXh0QW5jaG9yID0gX3JlZjUudGV4dEFuY2hvcixcbiAgICB0ZXh0QW5jaG9yID0gX3JlZjUkdGV4dEFuY2hvciA9PT0gdm9pZCAwID8gJ3N0YXJ0JyA6IF9yZWY1JHRleHRBbmNob3IsXG4gICAgX3JlZjUkdmVydGljYWxBbmNob3IgPSBfcmVmNS52ZXJ0aWNhbEFuY2hvcixcbiAgICB2ZXJ0aWNhbEFuY2hvciA9IF9yZWY1JHZlcnRpY2FsQW5jaG9yID09PSB2b2lkIDAgPyAnZW5kJyA6IF9yZWY1JHZlcnRpY2FsQW5jaG9yLFxuICAgIF9yZWY1JGZpbGwgPSBfcmVmNS5maWxsLFxuICAgIGZpbGwgPSBfcmVmNSRmaWxsID09PSB2b2lkIDAgPyBERUZBVUxUX0ZJTEwgOiBfcmVmNSRmaWxsLFxuICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY1LCBfZXhjbHVkZWQpO1xuICB2YXIgd29yZHNCeUxpbmVzID0gKDAsIF9yZWFjdC51c2VNZW1vKShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldFdvcmRzQnlMaW5lcyh7XG4gICAgICBicmVha0FsbDogcHJvcHMuYnJlYWtBbGwsXG4gICAgICBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW4sXG4gICAgICBtYXhMaW5lczogcHJvcHMubWF4TGluZXMsXG4gICAgICBzY2FsZVRvRml0OiBzY2FsZVRvRml0LFxuICAgICAgc3R5bGU6IHByb3BzLnN0eWxlLFxuICAgICAgd2lkdGg6IHByb3BzLndpZHRoXG4gICAgfSk7XG4gIH0sIFtwcm9wcy5icmVha0FsbCwgcHJvcHMuY2hpbGRyZW4sIHByb3BzLm1heExpbmVzLCBzY2FsZVRvRml0LCBwcm9wcy5zdHlsZSwgcHJvcHMud2lkdGhdKTtcbiAgdmFyIGR4ID0gcHJvcHMuZHgsXG4gICAgZHkgPSBwcm9wcy5keSxcbiAgICBhbmdsZSA9IHByb3BzLmFuZ2xlLFxuICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICBicmVha0FsbCA9IHByb3BzLmJyZWFrQWxsLFxuICAgIHRleHRQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkMik7XG4gIGlmICghKDAsIF9EYXRhVXRpbHMuaXNOdW1PclN0cikocHJvcHNYKSB8fCAhKDAsIF9EYXRhVXRpbHMuaXNOdW1PclN0cikocHJvcHNZKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciB4ID0gcHJvcHNYICsgKCgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShkeCkgPyBkeCA6IDApO1xuICB2YXIgeSA9IHByb3BzWSArICgoMCwgX0RhdGFVdGlscy5pc051bWJlcikoZHkpID8gZHkgOiAwKTtcbiAgdmFyIHN0YXJ0RHk7XG4gIHN3aXRjaCAodmVydGljYWxBbmNob3IpIHtcbiAgICBjYXNlICdzdGFydCc6XG4gICAgICBzdGFydER5ID0gKDAsIF9SZWR1Y2VDU1NDYWxjLnJlZHVjZUNTU0NhbGMpKFwiY2FsYyhcIi5jb25jYXQoY2FwSGVpZ2h0LCBcIilcIikpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgIHN0YXJ0RHkgPSAoMCwgX1JlZHVjZUNTU0NhbGMucmVkdWNlQ1NTQ2FsYykoXCJjYWxjKFwiLmNvbmNhdCgod29yZHNCeUxpbmVzLmxlbmd0aCAtIDEpIC8gMiwgXCIgKiAtXCIpLmNvbmNhdChsaW5lSGVpZ2h0LCBcIiArIChcIikuY29uY2F0KGNhcEhlaWdodCwgXCIgLyAyKSlcIikpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXJ0RHkgPSAoMCwgX1JlZHVjZUNTU0NhbGMucmVkdWNlQ1NTQ2FsYykoXCJjYWxjKFwiLmNvbmNhdCh3b3Jkc0J5TGluZXMubGVuZ3RoIC0gMSwgXCIgKiAtXCIpLmNvbmNhdChsaW5lSGVpZ2h0LCBcIilcIikpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgdmFyIHRyYW5zZm9ybXMgPSBbXTtcbiAgaWYgKHNjYWxlVG9GaXQpIHtcbiAgICB2YXIgbGluZVdpZHRoID0gd29yZHNCeUxpbmVzWzBdLndpZHRoO1xuICAgIHZhciB3aWR0aCA9IHByb3BzLndpZHRoO1xuICAgIHRyYW5zZm9ybXMucHVzaChcInNjYWxlKFwiLmNvbmNhdCgoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHdpZHRoKSA/IHdpZHRoIC8gbGluZVdpZHRoIDogMSkgLyBsaW5lV2lkdGgsIFwiKVwiKSk7XG4gIH1cbiAgaWYgKGFuZ2xlKSB7XG4gICAgdHJhbnNmb3Jtcy5wdXNoKFwicm90YXRlKFwiLmNvbmNhdChhbmdsZSwgXCIsIFwiKS5jb25jYXQoeCwgXCIsIFwiKS5jb25jYXQoeSwgXCIpXCIpKTtcbiAgfVxuICBpZiAodHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICB0ZXh0UHJvcHMudHJhbnNmb3JtID0gdHJhbnNmb3Jtcy5qb2luKCcgJyk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0XCIsIF9leHRlbmRzKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRleHRQcm9wcywgdHJ1ZSksIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtdGV4dCcsIGNsYXNzTmFtZSksXG4gICAgdGV4dEFuY2hvcjogdGV4dEFuY2hvcixcbiAgICBmaWxsOiBmaWxsLmluY2x1ZGVzKCd1cmwnKSA/IERFRkFVTFRfRklMTCA6IGZpbGxcbiAgfSksIHdvcmRzQnlMaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUsIGluZGV4KSB7XG4gICAgdmFyIHdvcmRzID0gbGluZS53b3Jkcy5qb2luKGJyZWFrQWxsID8gJycgOiAnICcpO1xuICAgIHJldHVybiAoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAvLyBkdXBsaWNhdGUgd29yZHMgd2lsbCBjYXVzZSBkdXBsaWNhdGUga2V5c1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwidHNwYW5cIiwge1xuICAgICAgICB4OiB4LFxuICAgICAgICBkeTogaW5kZXggPT09IDAgPyBzdGFydER5IDogbGluZUhlaWdodCxcbiAgICAgICAga2V5OiBcIlwiLmNvbmNhdCh3b3JkcywgXCItXCIpLmNvbmNhdChpbmRleClcbiAgICAgIH0sIHdvcmRzKVxuICAgICk7XG4gIH0pKTtcbn07Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVGV4dCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9pc05pbCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfY2xzeCIsIl9EYXRhVXRpbHMiLCJfR2xvYmFsIiwiX1JlYWN0VXRpbHMiLCJfRE9NVXRpbHMiLCJfUmVkdWNlQ1NTQ2FsYyIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJhcHBseSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJsZW4iLCJhcnIyIiwibCIsImYiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJpc0FycmF5IiwiQlJFQUtJTkdfU1BBQ0VTIiwiY2FsY3VsYXRlV29yZFdpZHRocyIsIl9yZWYiLCJjaGlsZHJlbiIsImJyZWFrQWxsIiwic3R5bGUiLCJ3b3JkcyIsInNwbGl0Iiwid29yZHNXaXRoQ29tcHV0ZWRXaWR0aCIsIm1hcCIsIndvcmQiLCJ3aWR0aCIsImdldFN0cmluZ1NpemUiLCJzcGFjZVdpZHRoIiwiY2FsY3VsYXRlV29yZHNCeUxpbmVzIiwiX3JlZjIiLCJpbml0aWFsV29yZHNXaXRoQ29tcHV0ZWRXaXRoIiwibGluZVdpZHRoIiwic2NhbGVUb0ZpdCIsIm1heExpbmVzIiwic2hvdWxkTGltaXRMaW5lcyIsImlzTnVtYmVyIiwidGV4dCIsImNhbGN1bGF0ZSIsInVuZGVmaW5lZCIsInJlZHVjZSIsInJlc3VsdCIsIl9yZWYzIiwiY3VycmVudExpbmUiLCJOdW1iZXIiLCJuZXdMaW5lIiwib3JpZ2luYWxSZXN1bHQiLCJmaW5kTG9uZ2VzdExpbmUiLCJiIiwic3VmZml4IiwiY2hlY2tPdmVyZmxvdyIsImluZGV4IiwidGVtcFRleHQiLCJkb2VzT3ZlcmZsb3ciLCJzdGFydCIsImVuZCIsIml0ZXJhdGlvbnMiLCJ0cmltbWVkUmVzdWx0IiwibWlkZGxlIiwiTWF0aCIsImZsb29yIiwicHJldiIsIl9jaGVja092ZXJmbG93IiwiX2NoZWNrT3ZlcmZsb3cyIiwiZG9lc1ByZXZPdmVyZmxvdyIsIl9jaGVja092ZXJmbG93MyIsIl9jaGVja092ZXJmbG93NCIsImRvZXNNaWRkbGVPdmVyZmxvdyIsImdldFdvcmRzV2l0aG91dENhbGN1bGF0ZSIsImdldFdvcmRzQnlMaW5lcyIsIl9yZWY0IiwiR2xvYmFsIiwiaXNTc3IiLCJ3b3JkV2lkdGhzIiwid2N3Iiwic3ciLCJERUZBVUxUX0ZJTEwiLCJfcmVmNSIsIl9yZWY1JHgiLCJ4IiwicHJvcHNYIiwiX3JlZjUkeSIsInkiLCJwcm9wc1kiLCJfcmVmNSRsaW5lSGVpZ2h0IiwibGluZUhlaWdodCIsIl9yZWY1JGNhcEhlaWdodCIsImNhcEhlaWdodCIsIl9yZWY1JHNjYWxlVG9GaXQiLCJfcmVmNSR0ZXh0QW5jaG9yIiwidGV4dEFuY2hvciIsIl9yZWY1JHZlcnRpY2FsQW5jaG9yIiwidmVydGljYWxBbmNob3IiLCJfcmVmNSRmaWxsIiwiZmlsbCIsInByb3BzIiwid29yZHNCeUxpbmVzIiwidXNlTWVtbyIsImR4IiwiZHkiLCJhbmdsZSIsImNsYXNzTmFtZSIsInRleHRQcm9wcyIsImlzTnVtT3JTdHIiLCJzdGFydER5IiwicmVkdWNlQ1NTQ2FsYyIsImNvbmNhdCIsInRyYW5zZm9ybXMiLCJ0cmFuc2Zvcm0iLCJqb2luIiwiY3JlYXRlRWxlbWVudCIsImZpbHRlclByb3BzIiwiaW5jbHVkZXMiLCJsaW5lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/component/Text.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/component/Tooltip.js":
/*!********************************************************!*\
  !*** ./node_modules/recharts/lib/component/Tooltip.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Tooltip = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _DefaultTooltipContent = __webpack_require__(/*! ./DefaultTooltipContent */ \"./node_modules/recharts/lib/component/DefaultTooltipContent.js\");\nvar _TooltipBoundingBox = __webpack_require__(/*! ./TooltipBoundingBox */ \"./node_modules/recharts/lib/component/TooltipBoundingBox.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"./node_modules/recharts/lib/util/Global.js\");\nvar _getUniqPayload = __webpack_require__(/*! ../util/payload/getUniqPayload */ \"./node_modules/recharts/lib/util/payload/getUniqPayload.js\");\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Tooltip\n */ \nfunction defaultUniqBy(entry) {\n    return entry.dataKey;\n}\nfunction renderContent(content, props) {\n    if (/*#__PURE__*/ _react[\"default\"].isValidElement(content)) {\n        return /*#__PURE__*/ _react[\"default\"].cloneElement(content, props);\n    }\n    if (typeof content === \"function\") {\n        return /*#__PURE__*/ _react[\"default\"].createElement(content, props);\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(_DefaultTooltipContent.DefaultTooltipContent, props);\n}\nvar Tooltip = exports.Tooltip = /*#__PURE__*/ function(_PureComponent) {\n    function Tooltip() {\n        _classCallCheck(this, Tooltip);\n        return _callSuper(this, Tooltip, arguments);\n    }\n    _inherits(Tooltip, _PureComponent);\n    return _createClass(Tooltip, [\n        {\n            key: \"render\",\n            value: function render() {\n                var _this = this;\n                var _this$props = this.props, active = _this$props.active, allowEscapeViewBox = _this$props.allowEscapeViewBox, animationDuration = _this$props.animationDuration, animationEasing = _this$props.animationEasing, content = _this$props.content, coordinate = _this$props.coordinate, filterNull = _this$props.filterNull, isAnimationActive = _this$props.isAnimationActive, offset = _this$props.offset, payload = _this$props.payload, payloadUniqBy = _this$props.payloadUniqBy, position = _this$props.position, reverseDirection = _this$props.reverseDirection, useTranslate3d = _this$props.useTranslate3d, viewBox = _this$props.viewBox, wrapperStyle = _this$props.wrapperStyle;\n                var finalPayload = payload !== null && payload !== void 0 ? payload : [];\n                if (filterNull && finalPayload.length) {\n                    finalPayload = (0, _getUniqPayload.getUniqPayload)(payload.filter(function(entry) {\n                        return entry.value != null && (entry.hide !== true || _this.props.includeHidden);\n                    }), payloadUniqBy, defaultUniqBy);\n                }\n                var hasPayload = finalPayload.length > 0;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_TooltipBoundingBox.TooltipBoundingBox, {\n                    allowEscapeViewBox: allowEscapeViewBox,\n                    animationDuration: animationDuration,\n                    animationEasing: animationEasing,\n                    isAnimationActive: isAnimationActive,\n                    active: active,\n                    coordinate: coordinate,\n                    hasPayload: hasPayload,\n                    offset: offset,\n                    position: position,\n                    reverseDirection: reverseDirection,\n                    useTranslate3d: useTranslate3d,\n                    viewBox: viewBox,\n                    wrapperStyle: wrapperStyle\n                }, renderContent(content, _objectSpread(_objectSpread({}, this.props), {}, {\n                    payload: finalPayload\n                })));\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(Tooltip, \"displayName\", \"Tooltip\");\n_defineProperty(Tooltip, \"defaultProps\", {\n    accessibilityLayer: false,\n    allowEscapeViewBox: {\n        x: false,\n        y: false\n    },\n    animationDuration: 400,\n    animationEasing: \"ease\",\n    contentStyle: {},\n    coordinate: {\n        x: 0,\n        y: 0\n    },\n    cursor: true,\n    cursorStyle: {},\n    filterNull: true,\n    isAnimationActive: !_Global.Global.isSsr,\n    itemStyle: {},\n    labelStyle: {},\n    offset: 10,\n    reverseDirection: {\n        x: false,\n        y: false\n    },\n    separator: \" : \",\n    trigger: \"hover\",\n    useTranslate3d: false,\n    viewBox: {\n        x: 0,\n        y: 0,\n        height: 0,\n        width: 0\n    },\n    wrapperStyle: {}\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9Ub29sdGlwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxlQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLHlCQUF5QkQsbUJBQU9BLENBQUMsK0ZBQXlCO0FBQzlELElBQUlFLHNCQUFzQkYsbUJBQU9BLENBQUMseUZBQXNCO0FBQ3hELElBQUlHLFVBQVVILG1CQUFPQSxDQUFDLGtFQUFnQjtBQUN0QyxJQUFJSSxrQkFBa0JKLG1CQUFPQSxDQUFDLGtHQUFnQztBQUM5RCxTQUFTSyx5QkFBeUJDLENBQUM7SUFBSSxJQUFJLGNBQWMsT0FBT0MsU0FBUyxPQUFPO0lBQU0sSUFBSUMsSUFBSSxJQUFJRCxXQUFXRSxJQUFJLElBQUlGO0lBQVcsT0FBTyxDQUFDRiwyQkFBMkIsU0FBU0EseUJBQXlCQyxDQUFDO1FBQUksT0FBT0EsSUFBSUcsSUFBSUQ7SUFBRyxHQUFHRjtBQUFJO0FBQ25PLFNBQVNQLHdCQUF3Qk8sQ0FBQyxFQUFFRSxDQUFDO0lBQUksSUFBSSxDQUFDQSxLQUFLRixLQUFLQSxFQUFFSSxVQUFVLEVBQUUsT0FBT0o7SUFBRyxJQUFJLFNBQVNBLEtBQUssWUFBWUssUUFBUUwsTUFBTSxjQUFjLE9BQU9BLEdBQUcsT0FBTztRQUFFLFdBQVdBO0lBQUU7SUFBRyxJQUFJRyxJQUFJSix5QkFBeUJHO0lBQUksSUFBSUMsS0FBS0EsRUFBRUcsR0FBRyxDQUFDTixJQUFJLE9BQU9HLEVBQUVJLEdBQUcsQ0FBQ1A7SUFBSSxJQUFJUSxJQUFJO1FBQUVDLFdBQVc7SUFBSyxHQUFHQyxJQUFJdkIsT0FBT0MsY0FBYyxJQUFJRCxPQUFPd0Isd0JBQXdCO0lBQUUsSUFBSyxJQUFJQyxLQUFLWixFQUFHLElBQUksY0FBY1ksS0FBSyxFQUFDLEdBQUVD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SUFDQXJCLGNBQWMsQ0FBQztBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29tcG9uZW50L1Rvb2x0aXAuanM/N2JmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVG9vbHRpcCA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9EZWZhdWx0VG9vbHRpcENvbnRlbnQgPSByZXF1aXJlKFwiLi9EZWZhdWx0VG9vbHRpcENvbnRlbnRcIik7XG52YXIgX1Rvb2x0aXBCb3VuZGluZ0JveCA9IHJlcXVpcmUoXCIuL1Rvb2x0aXBCb3VuZGluZ0JveFwiKTtcbnZhciBfR2xvYmFsID0gcmVxdWlyZShcIi4uL3V0aWwvR2xvYmFsXCIpO1xudmFyIF9nZXRVbmlxUGF5bG9hZCA9IHJlcXVpcmUoXCIuLi91dGlsL3BheWxvYWQvZ2V0VW5pcVBheWxvYWRcIik7XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKipcbiAqIEBmaWxlT3ZlcnZpZXcgVG9vbHRpcFxuICovXG5mdW5jdGlvbiBkZWZhdWx0VW5pcUJ5KGVudHJ5KSB7XG4gIHJldHVybiBlbnRyeS5kYXRhS2V5O1xufVxuZnVuY3Rpb24gcmVuZGVyQ29udGVudChjb250ZW50LCBwcm9wcykge1xuICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KGNvbnRlbnQpKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChjb250ZW50LCBwcm9wcyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoY29udGVudCwgcHJvcHMpO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9EZWZhdWx0VG9vbHRpcENvbnRlbnQuRGVmYXVsdFRvb2x0aXBDb250ZW50LCBwcm9wcyk7XG59XG52YXIgVG9vbHRpcCA9IGV4cG9ydHMuVG9vbHRpcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcbiAgZnVuY3Rpb24gVG9vbHRpcCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbHRpcCk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgVG9vbHRpcCwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoVG9vbHRpcCwgX1B1cmVDb21wb25lbnQpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFRvb2x0aXAsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYWN0aXZlID0gX3RoaXMkcHJvcHMuYWN0aXZlLFxuICAgICAgICBhbGxvd0VzY2FwZVZpZXdCb3ggPSBfdGhpcyRwcm9wcy5hbGxvd0VzY2FwZVZpZXdCb3gsXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uID0gX3RoaXMkcHJvcHMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZyA9IF90aGlzJHByb3BzLmFuaW1hdGlvbkVhc2luZyxcbiAgICAgICAgY29udGVudCA9IF90aGlzJHByb3BzLmNvbnRlbnQsXG4gICAgICAgIGNvb3JkaW5hdGUgPSBfdGhpcyRwcm9wcy5jb29yZGluYXRlLFxuICAgICAgICBmaWx0ZXJOdWxsID0gX3RoaXMkcHJvcHMuZmlsdGVyTnVsbCxcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wcy5pc0FuaW1hdGlvbkFjdGl2ZSxcbiAgICAgICAgb2Zmc2V0ID0gX3RoaXMkcHJvcHMub2Zmc2V0LFxuICAgICAgICBwYXlsb2FkID0gX3RoaXMkcHJvcHMucGF5bG9hZCxcbiAgICAgICAgcGF5bG9hZFVuaXFCeSA9IF90aGlzJHByb3BzLnBheWxvYWRVbmlxQnksXG4gICAgICAgIHBvc2l0aW9uID0gX3RoaXMkcHJvcHMucG9zaXRpb24sXG4gICAgICAgIHJldmVyc2VEaXJlY3Rpb24gPSBfdGhpcyRwcm9wcy5yZXZlcnNlRGlyZWN0aW9uLFxuICAgICAgICB1c2VUcmFuc2xhdGUzZCA9IF90aGlzJHByb3BzLnVzZVRyYW5zbGF0ZTNkLFxuICAgICAgICB2aWV3Qm94ID0gX3RoaXMkcHJvcHMudmlld0JveCxcbiAgICAgICAgd3JhcHBlclN0eWxlID0gX3RoaXMkcHJvcHMud3JhcHBlclN0eWxlO1xuICAgICAgdmFyIGZpbmFsUGF5bG9hZCA9IHBheWxvYWQgIT09IG51bGwgJiYgcGF5bG9hZCAhPT0gdm9pZCAwID8gcGF5bG9hZCA6IFtdO1xuICAgICAgaWYgKGZpbHRlck51bGwgJiYgZmluYWxQYXlsb2FkLmxlbmd0aCkge1xuICAgICAgICBmaW5hbFBheWxvYWQgPSAoMCwgX2dldFVuaXFQYXlsb2FkLmdldFVuaXFQYXlsb2FkKShwYXlsb2FkLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICByZXR1cm4gZW50cnkudmFsdWUgIT0gbnVsbCAmJiAoZW50cnkuaGlkZSAhPT0gdHJ1ZSB8fCBfdGhpcy5wcm9wcy5pbmNsdWRlSGlkZGVuKTtcbiAgICAgICAgfSksIHBheWxvYWRVbmlxQnksIGRlZmF1bHRVbmlxQnkpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc1BheWxvYWQgPSBmaW5hbFBheWxvYWQubGVuZ3RoID4gMDtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9Ub29sdGlwQm91bmRpbmdCb3guVG9vbHRpcEJvdW5kaW5nQm94LCB7XG4gICAgICAgIGFsbG93RXNjYXBlVmlld0JveDogYWxsb3dFc2NhcGVWaWV3Qm94LFxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZzogYW5pbWF0aW9uRWFzaW5nLFxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZTogaXNBbmltYXRpb25BY3RpdmUsXG4gICAgICAgIGFjdGl2ZTogYWN0aXZlLFxuICAgICAgICBjb29yZGluYXRlOiBjb29yZGluYXRlLFxuICAgICAgICBoYXNQYXlsb2FkOiBoYXNQYXlsb2FkLFxuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICByZXZlcnNlRGlyZWN0aW9uOiByZXZlcnNlRGlyZWN0aW9uLFxuICAgICAgICB1c2VUcmFuc2xhdGUzZDogdXNlVHJhbnNsYXRlM2QsXG4gICAgICAgIHZpZXdCb3g6IHZpZXdCb3gsXG4gICAgICAgIHdyYXBwZXJTdHlsZTogd3JhcHBlclN0eWxlXG4gICAgICB9LCByZW5kZXJDb250ZW50KGNvbnRlbnQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5wcm9wcyksIHt9LCB7XG4gICAgICAgIHBheWxvYWQ6IGZpbmFsUGF5bG9hZFxuICAgICAgfSkpKTtcbiAgICB9XG4gIH1dKTtcbn0oX3JlYWN0LlB1cmVDb21wb25lbnQpO1xuX2RlZmluZVByb3BlcnR5KFRvb2x0aXAsIFwiZGlzcGxheU5hbWVcIiwgJ1Rvb2x0aXAnKTtcbl9kZWZpbmVQcm9wZXJ0eShUb29sdGlwLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIGFjY2Vzc2liaWxpdHlMYXllcjogZmFsc2UsXG4gIGFsbG93RXNjYXBlVmlld0JveDoge1xuICAgIHg6IGZhbHNlLFxuICAgIHk6IGZhbHNlXG4gIH0sXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA0MDAsXG4gIGFuaW1hdGlvbkVhc2luZzogJ2Vhc2UnLFxuICBjb250ZW50U3R5bGU6IHt9LFxuICBjb29yZGluYXRlOiB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH0sXG4gIGN1cnNvcjogdHJ1ZSxcbiAgY3Vyc29yU3R5bGU6IHt9LFxuICBmaWx0ZXJOdWxsOiB0cnVlLFxuICBpc0FuaW1hdGlvbkFjdGl2ZTogIV9HbG9iYWwuR2xvYmFsLmlzU3NyLFxuICBpdGVtU3R5bGU6IHt9LFxuICBsYWJlbFN0eWxlOiB7fSxcbiAgb2Zmc2V0OiAxMCxcbiAgcmV2ZXJzZURpcmVjdGlvbjoge1xuICAgIHg6IGZhbHNlLFxuICAgIHk6IGZhbHNlXG4gIH0sXG4gIHNlcGFyYXRvcjogJyA6ICcsXG4gIHRyaWdnZXI6ICdob3ZlcicsXG4gIHVzZVRyYW5zbGF0ZTNkOiBmYWxzZSxcbiAgdmlld0JveDoge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgd2lkdGg6IDBcbiAgfSxcbiAgd3JhcHBlclN0eWxlOiB7fVxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVG9vbHRpcCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9EZWZhdWx0VG9vbHRpcENvbnRlbnQiLCJfVG9vbHRpcEJvdW5kaW5nQm94IiwiX0dsb2JhbCIsIl9nZXRVbmlxUGF5bG9hZCIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiYmluZCIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJvYmoiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsImRlZmF1bHRVbmlxQnkiLCJlbnRyeSIsImRhdGFLZXkiLCJyZW5kZXJDb250ZW50IiwiY29udGVudCIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsIkRlZmF1bHRUb29sdGlwQ29udGVudCIsIl9QdXJlQ29tcG9uZW50IiwicmVuZGVyIiwiX3RoaXMiLCJfdGhpcyRwcm9wcyIsImFjdGl2ZSIsImFsbG93RXNjYXBlVmlld0JveCIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRWFzaW5nIiwiY29vcmRpbmF0ZSIsImZpbHRlck51bGwiLCJpc0FuaW1hdGlvbkFjdGl2ZSIsIm9mZnNldCIsInBheWxvYWQiLCJwYXlsb2FkVW5pcUJ5IiwicG9zaXRpb24iLCJyZXZlcnNlRGlyZWN0aW9uIiwidXNlVHJhbnNsYXRlM2QiLCJ2aWV3Qm94Iiwid3JhcHBlclN0eWxlIiwiZmluYWxQYXlsb2FkIiwiZ2V0VW5pcVBheWxvYWQiLCJoaWRlIiwiaW5jbHVkZUhpZGRlbiIsImhhc1BheWxvYWQiLCJUb29sdGlwQm91bmRpbmdCb3giLCJQdXJlQ29tcG9uZW50IiwiYWNjZXNzaWJpbGl0eUxheWVyIiwieCIsInkiLCJjb250ZW50U3R5bGUiLCJjdXJzb3IiLCJjdXJzb3JTdHlsZSIsIkdsb2JhbCIsImlzU3NyIiwiaXRlbVN0eWxlIiwibGFiZWxTdHlsZSIsInNlcGFyYXRvciIsInRyaWdnZXIiLCJoZWlnaHQiLCJ3aWR0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/component/Tooltip.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/component/TooltipBoundingBox.js":
/*!*******************************************************************!*\
  !*** ./node_modules/recharts/lib/component/TooltipBoundingBox.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.TooltipBoundingBox = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _translate = __webpack_require__(/*! ../util/tooltip/translate */ \"./node_modules/recharts/lib/util/tooltip/translate.js\");\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar EPSILON = 1;\nvar TooltipBoundingBox = exports.TooltipBoundingBox = /*#__PURE__*/ function(_PureComponent) {\n    function TooltipBoundingBox() {\n        var _this;\n        _classCallCheck(this, TooltipBoundingBox);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, TooltipBoundingBox, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            dismissed: false,\n            dismissedAtCoordinate: {\n                x: 0,\n                y: 0\n            },\n            lastBoundingBox: {\n                width: -1,\n                height: -1\n            }\n        });\n        _defineProperty(_this, \"handleKeyDown\", function(event) {\n            if (event.key === \"Escape\") {\n                var _this$props$coordinat, _this$props$coordinat2, _this$props$coordinat3, _this$props$coordinat4;\n                _this.setState({\n                    dismissed: true,\n                    dismissedAtCoordinate: {\n                        x: (_this$props$coordinat = (_this$props$coordinat2 = _this.props.coordinate) === null || _this$props$coordinat2 === void 0 ? void 0 : _this$props$coordinat2.x) !== null && _this$props$coordinat !== void 0 ? _this$props$coordinat : 0,\n                        y: (_this$props$coordinat3 = (_this$props$coordinat4 = _this.props.coordinate) === null || _this$props$coordinat4 === void 0 ? void 0 : _this$props$coordinat4.y) !== null && _this$props$coordinat3 !== void 0 ? _this$props$coordinat3 : 0\n                    }\n                });\n            }\n        });\n        return _this;\n    }\n    _inherits(TooltipBoundingBox, _PureComponent);\n    return _createClass(TooltipBoundingBox, [\n        {\n            key: \"updateBBox\",\n            value: function updateBBox() {\n                if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {\n                    var box = this.wrapperNode.getBoundingClientRect();\n                    if (Math.abs(box.width - this.state.lastBoundingBox.width) > EPSILON || Math.abs(box.height - this.state.lastBoundingBox.height) > EPSILON) {\n                        this.setState({\n                            lastBoundingBox: {\n                                width: box.width,\n                                height: box.height\n                            }\n                        });\n                    }\n                } else if (this.state.lastBoundingBox.width !== -1 || this.state.lastBoundingBox.height !== -1) {\n                    this.setState({\n                        lastBoundingBox: {\n                            width: -1,\n                            height: -1\n                        }\n                    });\n                }\n            }\n        },\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                document.addEventListener(\"keydown\", this.handleKeyDown);\n                this.updateBBox();\n            }\n        },\n        {\n            key: \"componentWillUnmount\",\n            value: function componentWillUnmount() {\n                document.removeEventListener(\"keydown\", this.handleKeyDown);\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate() {\n                var _this$props$coordinat5, _this$props$coordinat6;\n                if (this.props.active) {\n                    this.updateBBox();\n                }\n                if (!this.state.dismissed) {\n                    return;\n                }\n                if (((_this$props$coordinat5 = this.props.coordinate) === null || _this$props$coordinat5 === void 0 ? void 0 : _this$props$coordinat5.x) !== this.state.dismissedAtCoordinate.x || ((_this$props$coordinat6 = this.props.coordinate) === null || _this$props$coordinat6 === void 0 ? void 0 : _this$props$coordinat6.y) !== this.state.dismissedAtCoordinate.y) {\n                    this.state.dismissed = false;\n                }\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this2 = this;\n                var _this$props = this.props, active = _this$props.active, allowEscapeViewBox = _this$props.allowEscapeViewBox, animationDuration = _this$props.animationDuration, animationEasing = _this$props.animationEasing, children = _this$props.children, coordinate = _this$props.coordinate, hasPayload = _this$props.hasPayload, isAnimationActive = _this$props.isAnimationActive, offset = _this$props.offset, position = _this$props.position, reverseDirection = _this$props.reverseDirection, useTranslate3d = _this$props.useTranslate3d, viewBox = _this$props.viewBox, wrapperStyle = _this$props.wrapperStyle;\n                var _getTooltipTranslate = (0, _translate.getTooltipTranslate)({\n                    allowEscapeViewBox: allowEscapeViewBox,\n                    coordinate: coordinate,\n                    offsetTopLeft: offset,\n                    position: position,\n                    reverseDirection: reverseDirection,\n                    tooltipBox: this.state.lastBoundingBox,\n                    useTranslate3d: useTranslate3d,\n                    viewBox: viewBox\n                }), cssClasses = _getTooltipTranslate.cssClasses, cssProperties = _getTooltipTranslate.cssProperties;\n                var outerStyle = _objectSpread(_objectSpread({\n                    transition: isAnimationActive && active ? \"transform \".concat(animationDuration, \"ms \").concat(animationEasing) : undefined\n                }, cssProperties), {}, {\n                    pointerEvents: \"none\",\n                    visibility: !this.state.dismissed && active && hasPayload ? \"visible\" : \"hidden\",\n                    position: \"absolute\",\n                    top: 0,\n                    left: 0\n                }, wrapperStyle);\n                return(/*#__PURE__*/ // This element allow listening to the `Escape` key.\n                // See https://github.com/recharts/recharts/pull/2925\n                _react[\"default\"].createElement(\"div\", {\n                    tabIndex: -1,\n                    className: cssClasses,\n                    style: outerStyle,\n                    ref: function ref(node) {\n                        _this2.wrapperNode = node;\n                    }\n                }, children));\n            }\n        }\n    ]);\n}(_react.PureComponent);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9Ub29sdGlwQm91bmRpbmdCb3guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELDBCQUEwQixHQUFHLEtBQUs7QUFDbEMsSUFBSUcsU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyxhQUFhRCxtQkFBT0EsQ0FBQyx3RkFBMkI7QUFDcEQsU0FBU0UseUJBQXlCQyxDQUFDO0lBQUksSUFBSSxjQUFjLE9BQU9DLFNBQVMsT0FBTztJQUFNLElBQUlDLElBQUksSUFBSUQsV0FBV0UsSUFBSSxJQUFJRjtJQUFXLE9BQU8sQ0FBQ0YsMkJBQTJCLFNBQVNBLHlCQUF5QkMsQ0FBQztRQUFJLE9BQU9BLElBQUlHLElBQUlEO0lBQUcsR0FBR0Y7QUFBSTtBQUNuTyxTQUFTSix3QkFBd0JJLENBQUMsRUFBRUUsQ0FBQztJQUFJLElBQUksQ0FBQ0EsS0FBS0YsS0FBS0EsRUFBRUksVUFBVSxFQUFFLE9BQU9KO0lBQUcsSUFBSSxTQUFTQSxLQUFLLFlBQVlLLFFBQVFMLE1BQU0sY0FBYyxPQUFPQSxHQUFHLE9BQU87UUFBRSxXQUFXQTtJQUFFO0lBQUcsSUFBSUcsSUFBSUoseUJBQXlCRztJQUFJLElBQUlDLEtBQUtBLEVBQUVHLEdBQUcsQ0FBQ04sSUFBSSxPQUFPRyxFQUFFSSxHQUFHLENBQUNQO0lBQUksSUFBSVEsSUFBSTtRQUFFQyxXQUFXO0lBQUssR0FBR0MsSUFBSXBCLE9BQU9DLGNBQWMsSUFBSUQsT0FBT3FCLHdCQUF3QjtJQUFFLElBQUssSUFBSUMsS0FBS1osRUFBRyxJQUFJLGNBQWNZLEtBQUssRUFBQyxHQUFFQyxjQUFjLENBQUNDLElBQUksQ0FBQ2QsR0FBR1ksSUFBSTtRQUFFLElBQUlHLElBQUlMLElBQUlwQixPQUFPcUIsd0JBQXdCLENBQUNYLEdBQUdZLEtBQUs7UUFBTUcsS0FBTUEsQ0FB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LG1CQUFtQmtCO2dCQUNwSCxHQUFHSCxnQkFBZ0IsQ0FBQyxHQUFHO29CQUNyQkksZUFBZTtvQkFDZkMsWUFBWSxDQUFDLElBQUksQ0FBQ3BDLEtBQUssQ0FBQ3BCLFNBQVMsSUFBSThCLFVBQVVRLGFBQWEsWUFBWTtvQkFDeEVHLFVBQVU7b0JBQ1ZnQixLQUFLO29CQUNMQyxNQUFNO2dCQUNSLEdBQUdiO2dCQUNILE9BQ0UsV0FBVyxHQUNYLG9EQUFvRDtnQkFDcEQscURBQXFEO2dCQUNyRHRJLE1BQU0sQ0FBQyxVQUFVLENBQUNvSixhQUFhLENBQUMsT0FBTztvQkFDckNDLFVBQVUsQ0FBQztvQkFDWEMsV0FBV1g7b0JBQ1hZLE9BQU9WO29CQUNQVyxLQUFLLFNBQVNBLElBQUlDLElBQUk7d0JBQ3BCaEMsT0FBT2pCLFdBQVcsR0FBR2lEO29CQUN2QjtnQkFDRixHQUFHM0I7WUFFUDtRQUNGO0tBQUU7QUFDSixFQUFFOUgsT0FBTzBKLGFBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbXBvbmVudC9Ub29sdGlwQm91bmRpbmdCb3guanM/ZmE2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVG9vbHRpcEJvdW5kaW5nQm94ID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3RyYW5zbGF0ZSA9IHJlcXVpcmUoXCIuLi91dGlsL3Rvb2x0aXAvdHJhbnNsYXRlXCIpO1xuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBFUFNJTE9OID0gMTtcbnZhciBUb29sdGlwQm91bmRpbmdCb3ggPSBleHBvcnRzLlRvb2x0aXBCb3VuZGluZ0JveCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcbiAgZnVuY3Rpb24gVG9vbHRpcEJvdW5kaW5nQm94KCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbHRpcEJvdW5kaW5nQm94KTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBUb29sdGlwQm91bmRpbmdCb3gsIFtdLmNvbmNhdChhcmdzKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInN0YXRlXCIsIHtcbiAgICAgIGRpc21pc3NlZDogZmFsc2UsXG4gICAgICBkaXNtaXNzZWRBdENvb3JkaW5hdGU6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgIGxhc3RCb3VuZGluZ0JveDoge1xuICAgICAgICB3aWR0aDogLTEsXG4gICAgICAgIGhlaWdodDogLTFcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyRjb29yZGluYXQsIF90aGlzJHByb3BzJGNvb3JkaW5hdDIsIF90aGlzJHByb3BzJGNvb3JkaW5hdDMsIF90aGlzJHByb3BzJGNvb3JkaW5hdDQ7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBkaXNtaXNzZWQ6IHRydWUsXG4gICAgICAgICAgZGlzbWlzc2VkQXRDb29yZGluYXRlOiB7XG4gICAgICAgICAgICB4OiAoX3RoaXMkcHJvcHMkY29vcmRpbmF0ID0gKF90aGlzJHByb3BzJGNvb3JkaW5hdDIgPSBfdGhpcy5wcm9wcy5jb29yZGluYXRlKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wcyRjb29yZGluYXQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRjb29yZGluYXQyLngpICE9PSBudWxsICYmIF90aGlzJHByb3BzJGNvb3JkaW5hdCAhPT0gdm9pZCAwID8gX3RoaXMkcHJvcHMkY29vcmRpbmF0IDogMCxcbiAgICAgICAgICAgIHk6IChfdGhpcyRwcm9wcyRjb29yZGluYXQzID0gKF90aGlzJHByb3BzJGNvb3JkaW5hdDQgPSBfdGhpcy5wcm9wcy5jb29yZGluYXRlKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wcyRjb29yZGluYXQ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRjb29yZGluYXQ0LnkpICE9PSBudWxsICYmIF90aGlzJHByb3BzJGNvb3JkaW5hdDMgIT09IHZvaWQgMCA/IF90aGlzJHByb3BzJGNvb3JkaW5hdDMgOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKFRvb2x0aXBCb3VuZGluZ0JveCwgX1B1cmVDb21wb25lbnQpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFRvb2x0aXBCb3VuZGluZ0JveCwgW3tcbiAgICBrZXk6IFwidXBkYXRlQkJveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCQm94KCkge1xuICAgICAgaWYgKHRoaXMud3JhcHBlck5vZGUgJiYgdGhpcy53cmFwcGVyTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgICAgdmFyIGJveCA9IHRoaXMud3JhcHBlck5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChNYXRoLmFicyhib3gud2lkdGggLSB0aGlzLnN0YXRlLmxhc3RCb3VuZGluZ0JveC53aWR0aCkgPiBFUFNJTE9OIHx8IE1hdGguYWJzKGJveC5oZWlnaHQgLSB0aGlzLnN0YXRlLmxhc3RCb3VuZGluZ0JveC5oZWlnaHQpID4gRVBTSUxPTikge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgbGFzdEJvdW5kaW5nQm94OiB7XG4gICAgICAgICAgICAgIHdpZHRoOiBib3gud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogYm94LmhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUubGFzdEJvdW5kaW5nQm94LndpZHRoICE9PSAtMSB8fCB0aGlzLnN0YXRlLmxhc3RCb3VuZGluZ0JveC5oZWlnaHQgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGxhc3RCb3VuZGluZ0JveDoge1xuICAgICAgICAgICAgd2lkdGg6IC0xLFxuICAgICAgICAgICAgaGVpZ2h0OiAtMVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gICAgICB0aGlzLnVwZGF0ZUJCb3goKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRjb29yZGluYXQ1LCBfdGhpcyRwcm9wcyRjb29yZGluYXQ2O1xuICAgICAgaWYgKHRoaXMucHJvcHMuYWN0aXZlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQkJveCgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN0YXRlLmRpc21pc3NlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKChfdGhpcyRwcm9wcyRjb29yZGluYXQ1ID0gdGhpcy5wcm9wcy5jb29yZGluYXRlKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wcyRjb29yZGluYXQ1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRjb29yZGluYXQ1LngpICE9PSB0aGlzLnN0YXRlLmRpc21pc3NlZEF0Q29vcmRpbmF0ZS54IHx8ICgoX3RoaXMkcHJvcHMkY29vcmRpbmF0NiA9IHRoaXMucHJvcHMuY29vcmRpbmF0ZSkgPT09IG51bGwgfHwgX3RoaXMkcHJvcHMkY29vcmRpbmF0NiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkY29vcmRpbmF0Ni55KSAhPT0gdGhpcy5zdGF0ZS5kaXNtaXNzZWRBdENvb3JkaW5hdGUueSkge1xuICAgICAgICB0aGlzLnN0YXRlLmRpc21pc3NlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBhY3RpdmUgPSBfdGhpcyRwcm9wcy5hY3RpdmUsXG4gICAgICAgIGFsbG93RXNjYXBlVmlld0JveCA9IF90aGlzJHByb3BzLmFsbG93RXNjYXBlVmlld0JveCxcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb24gPSBfdGhpcyRwcm9wcy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nID0gX3RoaXMkcHJvcHMuYW5pbWF0aW9uRWFzaW5nLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBjb29yZGluYXRlID0gX3RoaXMkcHJvcHMuY29vcmRpbmF0ZSxcbiAgICAgICAgaGFzUGF5bG9hZCA9IF90aGlzJHByb3BzLmhhc1BheWxvYWQsXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHMuaXNBbmltYXRpb25BY3RpdmUsXG4gICAgICAgIG9mZnNldCA9IF90aGlzJHByb3BzLm9mZnNldCxcbiAgICAgICAgcG9zaXRpb24gPSBfdGhpcyRwcm9wcy5wb3NpdGlvbixcbiAgICAgICAgcmV2ZXJzZURpcmVjdGlvbiA9IF90aGlzJHByb3BzLnJldmVyc2VEaXJlY3Rpb24sXG4gICAgICAgIHVzZVRyYW5zbGF0ZTNkID0gX3RoaXMkcHJvcHMudXNlVHJhbnNsYXRlM2QsXG4gICAgICAgIHZpZXdCb3ggPSBfdGhpcyRwcm9wcy52aWV3Qm94LFxuICAgICAgICB3cmFwcGVyU3R5bGUgPSBfdGhpcyRwcm9wcy53cmFwcGVyU3R5bGU7XG4gICAgICB2YXIgX2dldFRvb2x0aXBUcmFuc2xhdGUgPSAoMCwgX3RyYW5zbGF0ZS5nZXRUb29sdGlwVHJhbnNsYXRlKSh7XG4gICAgICAgICAgYWxsb3dFc2NhcGVWaWV3Qm94OiBhbGxvd0VzY2FwZVZpZXdCb3gsXG4gICAgICAgICAgY29vcmRpbmF0ZTogY29vcmRpbmF0ZSxcbiAgICAgICAgICBvZmZzZXRUb3BMZWZ0OiBvZmZzZXQsXG4gICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgIHJldmVyc2VEaXJlY3Rpb246IHJldmVyc2VEaXJlY3Rpb24sXG4gICAgICAgICAgdG9vbHRpcEJveDogdGhpcy5zdGF0ZS5sYXN0Qm91bmRpbmdCb3gsXG4gICAgICAgICAgdXNlVHJhbnNsYXRlM2Q6IHVzZVRyYW5zbGF0ZTNkLFxuICAgICAgICAgIHZpZXdCb3g6IHZpZXdCb3hcbiAgICAgICAgfSksXG4gICAgICAgIGNzc0NsYXNzZXMgPSBfZ2V0VG9vbHRpcFRyYW5zbGF0ZS5jc3NDbGFzc2VzLFxuICAgICAgICBjc3NQcm9wZXJ0aWVzID0gX2dldFRvb2x0aXBUcmFuc2xhdGUuY3NzUHJvcGVydGllcztcbiAgICAgIHZhciBvdXRlclN0eWxlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgdHJhbnNpdGlvbjogaXNBbmltYXRpb25BY3RpdmUgJiYgYWN0aXZlID8gXCJ0cmFuc2Zvcm0gXCIuY29uY2F0KGFuaW1hdGlvbkR1cmF0aW9uLCBcIm1zIFwiKS5jb25jYXQoYW5pbWF0aW9uRWFzaW5nKSA6IHVuZGVmaW5lZFxuICAgICAgfSwgY3NzUHJvcGVydGllcyksIHt9LCB7XG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgdmlzaWJpbGl0eTogIXRoaXMuc3RhdGUuZGlzbWlzc2VkICYmIGFjdGl2ZSAmJiBoYXNQYXlsb2FkID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH0sIHdyYXBwZXJTdHlsZSk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgIC8vIFRoaXMgZWxlbWVudCBhbGxvdyBsaXN0ZW5pbmcgdG8gdGhlIGBFc2NhcGVgIGtleS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWNoYXJ0cy9yZWNoYXJ0cy9wdWxsLzI5MjVcbiAgICAgICAgX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICB0YWJJbmRleDogLTEsXG4gICAgICAgICAgY2xhc3NOYW1lOiBjc3NDbGFzc2VzLFxuICAgICAgICAgIHN0eWxlOiBvdXRlclN0eWxlLFxuICAgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKG5vZGUpIHtcbiAgICAgICAgICAgIF90aGlzMi53cmFwcGVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBjaGlsZHJlbilcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG59KF9yZWFjdC5QdXJlQ29tcG9uZW50KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJUb29sdGlwQm91bmRpbmdCb3giLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfdHJhbnNsYXRlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaSIsInNldCIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJiaW5kIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIm9iaiIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiRVBTSUxPTiIsIl9QdXJlQ29tcG9uZW50IiwiX3RoaXMiLCJfbGVuIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImNvbmNhdCIsImRpc21pc3NlZCIsImRpc21pc3NlZEF0Q29vcmRpbmF0ZSIsIngiLCJ5IiwibGFzdEJvdW5kaW5nQm94Iiwid2lkdGgiLCJoZWlnaHQiLCJldmVudCIsIl90aGlzJHByb3BzJGNvb3JkaW5hdCIsIl90aGlzJHByb3BzJGNvb3JkaW5hdDIiLCJfdGhpcyRwcm9wcyRjb29yZGluYXQzIiwiX3RoaXMkcHJvcHMkY29vcmRpbmF0NCIsInNldFN0YXRlIiwiY29vcmRpbmF0ZSIsInVwZGF0ZUJCb3giLCJ3cmFwcGVyTm9kZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJveCIsIk1hdGgiLCJhYnMiLCJzdGF0ZSIsImNvbXBvbmVudERpZE1vdW50IiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlS2V5RG93biIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNvbXBvbmVudERpZFVwZGF0ZSIsIl90aGlzJHByb3BzJGNvb3JkaW5hdDUiLCJfdGhpcyRwcm9wcyRjb29yZGluYXQ2IiwiYWN0aXZlIiwicmVuZGVyIiwiX3RoaXMyIiwiX3RoaXMkcHJvcHMiLCJhbGxvd0VzY2FwZVZpZXdCb3giLCJhbmltYXRpb25EdXJhdGlvbiIsImFuaW1hdGlvbkVhc2luZyIsImNoaWxkcmVuIiwiaGFzUGF5bG9hZCIsImlzQW5pbWF0aW9uQWN0aXZlIiwib2Zmc2V0IiwicG9zaXRpb24iLCJyZXZlcnNlRGlyZWN0aW9uIiwidXNlVHJhbnNsYXRlM2QiLCJ2aWV3Qm94Iiwid3JhcHBlclN0eWxlIiwiX2dldFRvb2x0aXBUcmFuc2xhdGUiLCJnZXRUb29sdGlwVHJhbnNsYXRlIiwib2Zmc2V0VG9wTGVmdCIsInRvb2x0aXBCb3giLCJjc3NDbGFzc2VzIiwiY3NzUHJvcGVydGllcyIsIm91dGVyU3R5bGUiLCJ0cmFuc2l0aW9uIiwidW5kZWZpbmVkIiwicG9pbnRlckV2ZW50cyIsInZpc2liaWxpdHkiLCJ0b3AiLCJsZWZ0IiwiY3JlYXRlRWxlbWVudCIsInRhYkluZGV4IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJyZWYiLCJub2RlIiwiUHVyZUNvbXBvbmVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/component/TooltipBoundingBox.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/container/Layer.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/container/Layer.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Layer = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"children\",\n    \"className\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nvar Layer = exports.Layer = /*#__PURE__*/ _react[\"default\"].forwardRef(function(props, ref) {\n    var children = props.children, className = props.className, others = _objectWithoutProperties(props, _excluded);\n    var layerClass = (0, _clsx[\"default\"])(\"recharts-layer\", className);\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", _extends({\n        className: layerClass\n    }, (0, _ReactUtils.filterProps)(others, true), {\n        ref: ref\n    }), children);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbnRhaW5lci9MYXllci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsYUFBYSxHQUFHLEtBQUs7QUFDckIsSUFBSUcsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxRQUFRRix1QkFBdUJDLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlFLGNBQWNGLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJRyxZQUFZO0lBQUM7SUFBWTtDQUFZO0FBQ3pDLFNBQVNKLHVCQUF1QkssR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRTtJQUFhQSxXQUFXYixPQUFPYyxNQUFNLEdBQUdkLE9BQU9jLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQUUsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQUUsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUFFLElBQUlwQixPQUFPc0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osUUFBUUMsTUFBTTtvQkFBRUwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFBRTtZQUFFO1FBQUU7UUFBRSxPQUFPTDtJQUFRO0lBQUcsT0FBT0gsU0FBU1ksS0FBSyxDQUFDLElBQUksRUFBRVA7QUFBWTtBQUNsVixTQUFTUSx5QkFBeUJOLE1BQU0sRUFBRU8sUUFBUTtJQUFJLElBQUlQLFVBQVUsTUFBTSxPQUFPLENBQUM7SUFBRyxJQUFJSixTQUFTWSw4QkFBOEJSLFFBQVFPO0lBQVcsSUFBSU4sS0FBS0o7SUFBRyxJQUFJakIsT0FBTzZCLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsbUJBQW1COUIsT0FBTzZCLHFCQUFxQixDQUFDVDtRQUFTLElBQUtILElBQUksR0FBR0EsSUFBSWEsaUJBQWlCWCxNQUFNLEVBQUVGLElBQUs7WUFBRUksTUFBTVMsZ0JBQWdCLENBQUNiLEVBQUU7WUFBRSxJQUFJVSxTQUFTSSxPQUFPLENBQUNWLFFBQVEsR0FBRztZQUFVLElBQUksQ0FBQ3JCLE9BQU9zQixTQUFTLENBQUNVLG9CQUFvQixDQUFDUixJQUFJLENBQUNKLFFBQVFDLE1BQU07WUFBVUwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtRQUFFO0lBQUU7SUFBRSxPQUFPTDtBQUFRO0FBQzNlLFNBQVNZLDhCQUE4QlIsTUFBTSxFQUFFTyxRQUFRO0lBQUksSUFBSVAsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUFHLElBQUlKLFNBQVMsQ0FBQztJQUFHLElBQUssSUFBSUssT0FBT0QsT0FBUTtRQUFFLElBQUlwQixPQUFPc0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osUUFBUUMsTUFBTTtZQUFFLElBQUlNLFNBQVNJLE9BQU8sQ0FBQ1YsUUFBUSxHQUFHO1lBQVVMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7UUFBRTtJQUFFO0lBQUUsT0FBT0w7QUFBUTtBQUN0UixJQUFJWixRQUFRRixhQUFhLEdBQUcsV0FBVyxHQUFFRyxNQUFNLENBQUMsVUFBVSxDQUFDNEIsVUFBVSxDQUFDLFNBQVVDLEtBQUssRUFBRUMsR0FBRztJQUN4RixJQUFJQyxXQUFXRixNQUFNRSxRQUFRLEVBQzNCQyxZQUFZSCxNQUFNRyxTQUFTLEVBQzNCQyxTQUFTWix5QkFBeUJRLE9BQU94QjtJQUMzQyxJQUFJNkIsYUFBYSxDQUFDLEdBQUcvQixLQUFLLENBQUMsVUFBVSxFQUFFLGtCQUFrQjZCO0lBQ3pELE9BQU8sV0FBVyxHQUFFaEMsTUFBTSxDQUFDLFVBQVUsQ0FBQ21DLGFBQWEsQ0FBQyxLQUFLM0IsU0FBUztRQUNoRXdCLFdBQVdFO0lBQ2IsR0FBRyxDQUFDLEdBQUc5QixZQUFZZ0MsV0FBVyxFQUFFSCxRQUFRLE9BQU87UUFDN0NILEtBQUtBO0lBQ1AsSUFBSUM7QUFDTiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29udGFpbmVyL0xheWVyLmpzPzc2NTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkxheWVyID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcbnZhciBfZXhjbHVkZWQgPSBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiXTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIExheWVyID0gZXhwb3J0cy5MYXllciA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgIG90aGVycyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkKTtcbiAgdmFyIGxheWVyQ2xhc3MgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtbGF5ZXInLCBjbGFzc05hbWUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogbGF5ZXJDbGFzc1xuICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKG90aGVycywgdHJ1ZSksIHtcbiAgICByZWY6IHJlZlxuICB9KSwgY2hpbGRyZW4pO1xufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTGF5ZXIiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9jbHN4IiwiX1JlYWN0VXRpbHMiLCJfZXhjbHVkZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJmb3J3YXJkUmVmIiwicHJvcHMiLCJyZWYiLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsIm90aGVycyIsImxheWVyQ2xhc3MiLCJjcmVhdGVFbGVtZW50IiwiZmlsdGVyUHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/container/Layer.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/container/Surface.js":
/*!********************************************************!*\
  !*** ./node_modules/recharts/lib/container/Surface.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Surface = Surface;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"children\",\n    \"width\",\n    \"height\",\n    \"viewBox\",\n    \"className\",\n    \"style\",\n    \"title\",\n    \"desc\"\n];\n/**\n * @fileOverview Surface\n */ function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction Surface(props) {\n    var children = props.children, width = props.width, height = props.height, viewBox = props.viewBox, className = props.className, style = props.style, title = props.title, desc = props.desc, others = _objectWithoutProperties(props, _excluded);\n    var svgView = viewBox || {\n        width: width,\n        height: height,\n        x: 0,\n        y: 0\n    };\n    var layerClass = (0, _clsx[\"default\"])(\"recharts-surface\", className);\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"svg\", _extends({}, (0, _ReactUtils.filterProps)(others, true, \"svg\"), {\n        className: layerClass,\n        width: width,\n        height: height,\n        style: style,\n        viewBox: \"\".concat(svgView.x, \" \").concat(svgView.y, \" \").concat(svgView.width, \" \").concat(svgView.height)\n    }), /*#__PURE__*/ _react[\"default\"].createElement(\"title\", null, title), /*#__PURE__*/ _react[\"default\"].createElement(\"desc\", null, desc), children);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbnRhaW5lci9TdXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxlQUFlLEdBQUdFO0FBQ2xCLElBQUlDLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDbkQsSUFBSUMsUUFBUUYsdUJBQXVCQyxtQkFBT0EsQ0FBQyxrQkFBTTtBQUNqRCxJQUFJRSxjQUFjRixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSUcsWUFBWTtJQUFDO0lBQVk7SUFBUztJQUFVO0lBQVc7SUFBYTtJQUFTO0lBQVM7Q0FBTztBQUNqRzs7Q0FFQyxHQUNELFNBQVNKLHVCQUF1QkssR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRTtJQUFhQSxXQUFXYixPQUFPYyxNQUFNLEdBQUdkLE9BQU9jLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQUUsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQUUsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUFFLElBQUlwQixPQUFPc0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osUUFBUUMsTUFBTTtvQkFBRUwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFBRTtZQUFFO1FBQUU7UUFBRSxPQUFPTDtJQUFRO0lBQUcsT0FBT0gsU0FBU1ksS0FBSyxDQUFDLElBQUksRUFBRVA7QUFBWTtBQUNsVixTQUFTUSx5QkFBeUJOLE1BQU0sRUFBRU8sUUFBUTtJQUFJLElBQUlQLFVBQVUsTUFBTSxPQUFPLENBQUM7SUFBRyxJQUFJSixTQUFTWSw4QkFBOEJSLFFBQVFPO0lBQVcsSUFBSU4sS0FBS0o7SUFBRyxJQUFJakIsT0FBTzZCLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsbUJBQW1COUIsT0FBTzZCLHFCQUFxQixDQUFDVDtRQUFTLElBQUtILElBQUksR0FBR0EsSUFBSWEsaUJBQWlCWCxNQUFNLEVBQUVGLElBQUs7WUFBRUksTUFBTVMsZ0JBQWdCLENBQUNiLEVBQUU7WUFBRSxJQUFJVSxTQUFTSSxPQUFPLENBQUNWLFFBQVEsR0FBRztZQUFVLElBQUksQ0FBQ3JCLE9BQU9zQixTQUFTLENBQUNVLG9CQUFvQixDQUFDUixJQUFJLENBQUNKLFFBQVFDLE1BQU07WUFBVUwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtRQUFFO0lBQUU7SUFBRSxPQUFPTDtBQUFRO0FBQzNlLFNBQVNZLDhCQUE4QlIsTUFBTSxFQUFFTyxRQUFRO0lBQUksSUFBSVAsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUFHLElBQUlKLFNBQVMsQ0FBQztJQUFHLElBQUssSUFBSUssT0FBT0QsT0FBUTtRQUFFLElBQUlwQixPQUFPc0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osUUFBUUMsTUFBTTtZQUFFLElBQUlNLFNBQVNJLE9BQU8sQ0FBQ1YsUUFBUSxHQUFHO1lBQVVMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7UUFBRTtJQUFFO0lBQUUsT0FBT0w7QUFBUTtBQUN0UixTQUFTWixRQUFRNkIsS0FBSztJQUNwQixJQUFJQyxXQUFXRCxNQUFNQyxRQUFRLEVBQzNCQyxRQUFRRixNQUFNRSxLQUFLLEVBQ25CQyxTQUFTSCxNQUFNRyxNQUFNLEVBQ3JCQyxVQUFVSixNQUFNSSxPQUFPLEVBQ3ZCQyxZQUFZTCxNQUFNSyxTQUFTLEVBQzNCQyxRQUFRTixNQUFNTSxLQUFLLEVBQ25CQyxRQUFRUCxNQUFNTyxLQUFLLEVBQ25CQyxPQUFPUixNQUFNUSxJQUFJLEVBQ2pCQyxTQUFTaEIseUJBQXlCTyxPQUFPdkI7SUFDM0MsSUFBSWlDLFVBQVVOLFdBQVc7UUFDdkJGLE9BQU9BO1FBQ1BDLFFBQVFBO1FBQ1JRLEdBQUc7UUFDSEMsR0FBRztJQUNMO0lBQ0EsSUFBSUMsYUFBYSxDQUFDLEdBQUd0QyxLQUFLLENBQUMsVUFBVSxFQUFFLG9CQUFvQjhCO0lBQzNELE9BQU8sV0FBVyxHQUFFakMsTUFBTSxDQUFDLFVBQVUsQ0FBQzBDLGFBQWEsQ0FBQyxPQUFPbEMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHSixZQUFZdUMsV0FBVyxFQUFFTixRQUFRLE1BQU0sUUFBUTtRQUN6SEosV0FBV1E7UUFDWFgsT0FBT0E7UUFDUEMsUUFBUUE7UUFDUkcsT0FBT0E7UUFDUEYsU0FBUyxHQUFHWSxNQUFNLENBQUNOLFFBQVFDLENBQUMsRUFBRSxLQUFLSyxNQUFNLENBQUNOLFFBQVFFLENBQUMsRUFBRSxLQUFLSSxNQUFNLENBQUNOLFFBQVFSLEtBQUssRUFBRSxLQUFLYyxNQUFNLENBQUNOLFFBQVFQLE1BQU07SUFDNUcsSUFBSSxXQUFXLEdBQUUvQixNQUFNLENBQUMsVUFBVSxDQUFDMEMsYUFBYSxDQUFDLFNBQVMsTUFBTVAsUUFBUSxXQUFXLEdBQUVuQyxNQUFNLENBQUMsVUFBVSxDQUFDMEMsYUFBYSxDQUFDLFFBQVEsTUFBTU4sT0FBT1A7QUFDNUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbnRhaW5lci9TdXJmYWNlLmpzPzg1NTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlN1cmZhY2UgPSBTdXJmYWNlO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcbnZhciBfZXhjbHVkZWQgPSBbXCJjaGlsZHJlblwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwidmlld0JveFwiLCBcImNsYXNzTmFtZVwiLCBcInN0eWxlXCIsIFwidGl0bGVcIiwgXCJkZXNjXCJdO1xuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFN1cmZhY2VcbiAqL1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBTdXJmYWNlKHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgIHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxuICAgIHZpZXdCb3ggPSBwcm9wcy52aWV3Qm94LFxuICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgIHRpdGxlID0gcHJvcHMudGl0bGUsXG4gICAgZGVzYyA9IHByb3BzLmRlc2MsXG4gICAgb3RoZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xuICB2YXIgc3ZnVmlldyA9IHZpZXdCb3ggfHwge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgdmFyIGxheWVyQ2xhc3MgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtc3VyZmFjZScsIGNsYXNzTmFtZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIF9leHRlbmRzKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKG90aGVycywgdHJ1ZSwgJ3N2ZycpLCB7XG4gICAgY2xhc3NOYW1lOiBsYXllckNsYXNzLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgdmlld0JveDogXCJcIi5jb25jYXQoc3ZnVmlldy54LCBcIiBcIikuY29uY2F0KHN2Z1ZpZXcueSwgXCIgXCIpLmNvbmNhdChzdmdWaWV3LndpZHRoLCBcIiBcIikuY29uY2F0KHN2Z1ZpZXcuaGVpZ2h0KVxuICB9KSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInRpdGxlXCIsIG51bGwsIHRpdGxlKSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRlc2NcIiwgbnVsbCwgZGVzYyksIGNoaWxkcmVuKTtcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTdXJmYWNlIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfY2xzeCIsIl9SZWFjdFV0aWxzIiwiX2V4Y2x1ZGVkIiwib2JqIiwiX19lc01vZHVsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwicHJvcHMiLCJjaGlsZHJlbiIsIndpZHRoIiwiaGVpZ2h0Iiwidmlld0JveCIsImNsYXNzTmFtZSIsInN0eWxlIiwidGl0bGUiLCJkZXNjIiwib3RoZXJzIiwic3ZnVmlldyIsIngiLCJ5IiwibGF5ZXJDbGFzcyIsImNyZWF0ZUVsZW1lbnQiLCJmaWx0ZXJQcm9wcyIsImNvbmNhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/container/Surface.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/context/chartLayoutContext.js":
/*!*****************************************************************!*\
  !*** ./node_modules/recharts/lib/context/chartLayoutContext.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useYAxisWithFiniteDomainOrRandom = exports.useYAxisOrThrow = exports.useXAxisOrThrow = exports.useViewBox = exports.useOffset = exports.useClipPathId = exports.useChartWidth = exports.useChartHeight = exports.useArbitraryYAxis = exports.useArbitraryXAxis = exports.YAxisContext = exports.XAxisContext = exports.ViewBoxContext = exports.OffsetContext = exports.ClipPathIdContext = exports.ChartWidthContext = exports.ChartLayoutContextProvider = exports.ChartHeightContext = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _tinyInvariant = _interopRequireDefault(__webpack_require__(/*! tiny-invariant */ \"tiny-invariant\"));\nvar _find = _interopRequireDefault(__webpack_require__(/*! lodash/find */ \"lodash/find\"));\nvar _every = _interopRequireDefault(__webpack_require__(/*! lodash/every */ \"lodash/every\"));\nvar _calculateViewBox = __webpack_require__(/*! ../util/calculateViewBox */ \"./node_modules/recharts/lib/util/calculateViewBox.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nvar XAxisContext = exports.XAxisContext = /*#__PURE__*/ (0, _react.createContext)(undefined);\nvar YAxisContext = exports.YAxisContext = /*#__PURE__*/ (0, _react.createContext)(undefined);\nvar ViewBoxContext = exports.ViewBoxContext = /*#__PURE__*/ (0, _react.createContext)(undefined);\nvar OffsetContext = exports.OffsetContext = /*#__PURE__*/ (0, _react.createContext)({});\nvar ClipPathIdContext = exports.ClipPathIdContext = /*#__PURE__*/ (0, _react.createContext)(undefined);\nvar ChartHeightContext = exports.ChartHeightContext = /*#__PURE__*/ (0, _react.createContext)(0);\nvar ChartWidthContext = exports.ChartWidthContext = /*#__PURE__*/ (0, _react.createContext)(0);\n/**\n * Will add all the properties required to render all individual Recharts components into a React Context.\n *\n * If you want to read these properties, see the collection of hooks exported from this file.\n *\n * @param {object} props CategoricalChartState, plus children\n * @returns {ReactElement} React Context Provider\n */ var ChartLayoutContextProvider = exports.ChartLayoutContextProvider = function ChartLayoutContextProvider(props) {\n    var _props$state = props.state, xAxisMap = _props$state.xAxisMap, yAxisMap = _props$state.yAxisMap, offset = _props$state.offset, clipPathId = props.clipPathId, children = props.children, width = props.width, height = props.height;\n    /**\n   * Perhaps we should compute this property when reading? Let's see what is more often used\n   */ var viewBox = (0, _calculateViewBox.calculateViewBox)(offset);\n    /*\n   * This pretends to be a single context but actually is split into multiple smaller ones.\n   * Why?\n   * Because one React Context only allows to set one value.\n   * But we need to set multiple values.\n   * If we do that with one context, then we force re-render on components that might not even be interested\n   * in the part of the state that has changed.\n   *\n   * By splitting into smaller contexts, we allow each components to be optimized and only re-render when its dependencies change.\n   *\n   * To actually achieve the optimal re-render, it is necessary to use React.memo().\n   * See the test file for details.\n   */ return /*#__PURE__*/ _react[\"default\"].createElement(XAxisContext.Provider, {\n        value: xAxisMap\n    }, /*#__PURE__*/ _react[\"default\"].createElement(YAxisContext.Provider, {\n        value: yAxisMap\n    }, /*#__PURE__*/ _react[\"default\"].createElement(OffsetContext.Provider, {\n        value: offset\n    }, /*#__PURE__*/ _react[\"default\"].createElement(ViewBoxContext.Provider, {\n        value: viewBox\n    }, /*#__PURE__*/ _react[\"default\"].createElement(ClipPathIdContext.Provider, {\n        value: clipPathId\n    }, /*#__PURE__*/ _react[\"default\"].createElement(ChartHeightContext.Provider, {\n        value: height\n    }, /*#__PURE__*/ _react[\"default\"].createElement(ChartWidthContext.Provider, {\n        value: width\n    }, children)))))));\n};\nvar useClipPathId = exports.useClipPathId = function useClipPathId() {\n    return (0, _react.useContext)(ClipPathIdContext);\n};\nfunction getKeysForDebug(object) {\n    var keys = Object.keys(object);\n    if (keys.length === 0) {\n        return \"There are no available ids.\";\n    }\n    return \"Available ids are: \".concat(keys, \".\");\n}\n/**\n * This either finds and returns Axis by the specified ID, or throws an exception if an axis with this ID does not exist.\n *\n * @param xAxisId identifier of the axis - it's either autogenerated ('0'), or passed via `id` prop as <XAxis id='foo' />\n * @returns axis configuration object\n * @throws Error if no axis with this ID exists\n */ var useXAxisOrThrow = exports.useXAxisOrThrow = function useXAxisOrThrow(xAxisId) {\n    var xAxisMap = (0, _react.useContext)(XAxisContext);\n    !(xAxisMap != null) ?  true ? (0, _tinyInvariant[\"default\"])(false, \"Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?\") : 0 : void 0;\n    var xAxis = xAxisMap[xAxisId];\n    !(xAxis != null) ?  true ? (0, _tinyInvariant[\"default\"])(false, 'Could not find xAxis by id \"'.concat(xAxisId, '\" [').concat(_typeof(xAxisId), \"]. \").concat(getKeysForDebug(xAxisMap))) : 0 : void 0;\n    return xAxis;\n};\n/**\n * This will find an arbitrary first XAxis. If there's exactly one it always returns that one\n * - but if there are multiple then it can return any of those.\n *\n * If you want specific XAxis out of multiple then prefer using useXAxisOrThrow\n *\n * @returns X axisOptions, or undefined - if there are no X axes\n */ var useArbitraryXAxis = exports.useArbitraryXAxis = function useArbitraryXAxis() {\n    var xAxisMap = (0, _react.useContext)(XAxisContext);\n    return (0, _DataUtils.getAnyElementOfObject)(xAxisMap);\n};\n/**\n * This will find an arbitrary first YAxis. If there's exactly one it always returns that one\n * - but if there are multiple then it can return any of those.\n *\n * If you want specific YAxis out of multiple then prefer using useXAxisOrThrow\n *\n * @returns Y axisOptions, or undefined - if there are no Y axes\n */ var useArbitraryYAxis = exports.useArbitraryYAxis = function useArbitraryYAxis() {\n    var yAxisMap = (0, _react.useContext)(YAxisContext);\n    return (0, _DataUtils.getAnyElementOfObject)(yAxisMap);\n};\n/**\n * This hooks will:\n * 1st attempt to find an YAxis that has all elements in its domain finite\n * If no such axis exists, it will return an arbitrary YAxis\n * if there are no Y axes then it returns undefined\n *\n * @returns Either Y axisOptions, or undefined if there are no Y axes\n */ var useYAxisWithFiniteDomainOrRandom = exports.useYAxisWithFiniteDomainOrRandom = function useYAxisWithFiniteDomainOrRandom() {\n    var yAxisMap = (0, _react.useContext)(YAxisContext);\n    var yAxisWithFiniteDomain = (0, _find[\"default\"])(yAxisMap, function(axis) {\n        return (0, _every[\"default\"])(axis.domain, Number.isFinite);\n    });\n    return yAxisWithFiniteDomain || (0, _DataUtils.getAnyElementOfObject)(yAxisMap);\n};\n/**\n * This either finds and returns Axis by the specified ID, or throws an exception if an axis with this ID does not exist.\n *\n * @param yAxisId identifier of the axis - it's either autogenerated ('0'), or passed via `id` prop as <YAxis id='foo' />\n * @returns axis configuration object\n * @throws Error if no axis with this ID exists\n */ var useYAxisOrThrow = exports.useYAxisOrThrow = function useYAxisOrThrow(yAxisId) {\n    var yAxisMap = (0, _react.useContext)(YAxisContext);\n    !(yAxisMap != null) ?  true ? (0, _tinyInvariant[\"default\"])(false, \"Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?\") : 0 : void 0;\n    var yAxis = yAxisMap[yAxisId];\n    !(yAxis != null) ?  true ? (0, _tinyInvariant[\"default\"])(false, 'Could not find yAxis by id \"'.concat(yAxisId, '\" [').concat(_typeof(yAxisId), \"]. \").concat(getKeysForDebug(yAxisMap))) : 0 : void 0;\n    return yAxis;\n};\nvar useViewBox = exports.useViewBox = function useViewBox() {\n    var viewBox = (0, _react.useContext)(ViewBoxContext);\n    return viewBox;\n};\nvar useOffset = exports.useOffset = function useOffset() {\n    return (0, _react.useContext)(OffsetContext);\n};\nvar useChartWidth = exports.useChartWidth = function useChartWidth() {\n    return (0, _react.useContext)(ChartWidthContext);\n};\nvar useChartHeight = exports.useChartHeight = function useChartHeight() {\n    return (0, _react.useContext)(ChartHeightContext);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL2NvbnRleHQvY2hhcnRMYXlvdXRDb250ZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCx3Q0FBd0MsR0FBR0EsdUJBQXVCLEdBQUdBLHVCQUF1QixHQUFHQSxrQkFBa0IsR0FBR0EsaUJBQWlCLEdBQUdBLHFCQUFxQixHQUFHQSxxQkFBcUIsR0FBR0Esc0JBQXNCLEdBQUdBLHlCQUF5QixHQUFHQSx5QkFBeUIsR0FBR0Esb0JBQW9CLEdBQUdBLG9CQUFvQixHQUFHQSxzQkFBc0IsR0FBR0EscUJBQXFCLEdBQUdBLHlCQUF5QixHQUFHQSx5QkFBeUIsR0FBR0Esa0NBQWtDLEdBQUdBLDBCQUEwQixHQUFHLEtBQUs7QUFDdmUsSUFBSW9CLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsaUJBQWlCQyx1QkFBdUJGLG1CQUFPQSxDQUFDLHNDQUFnQjtBQUNwRSxJQUFJRyxRQUFRRCx1QkFBdUJGLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3hELElBQUlJLFNBQVNGLHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDMUQsSUFBSUssb0JBQW9CTCxtQkFBT0EsQ0FBQyxzRkFBMEI7QUFDMUQsSUFBSU0sYUFBYU4sbUJBQU9BLENBQUMsd0VBQW1CO0FBQzVDLFNBQVNFLHVCQUF1QkssR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSx5QkFBeUJDLENBQUM7SUFBSSxJQUFJLGNBQWMsT0FBT0MsU0FBUyxPQUFPO0lBQU0sSUFBSUMsSUFBSSxJQUFJRCxXQUFXRSxJQUFJLElBQUlGO0lBQVcsT0FBTyxDQUFDRiwyQkFBMkIsU0FBU0EseUJBQXlCQyxDQUFDO1FBQUksT0FBT0EsSUFBSUcsSUFBSUQ7SUFBRyxHQUFHRjtBQUFJO0FB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QU9pRCxVQUFVLEVBQUVsRDtBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvY29udGV4dC9jaGFydExheW91dENvbnRleHQuanM/NTY3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudXNlWUF4aXNXaXRoRmluaXRlRG9tYWluT3JSYW5kb20gPSBleHBvcnRzLnVzZVlBeGlzT3JUaHJvdyA9IGV4cG9ydHMudXNlWEF4aXNPclRocm93ID0gZXhwb3J0cy51c2VWaWV3Qm94ID0gZXhwb3J0cy51c2VPZmZzZXQgPSBleHBvcnRzLnVzZUNsaXBQYXRoSWQgPSBleHBvcnRzLnVzZUNoYXJ0V2lkdGggPSBleHBvcnRzLnVzZUNoYXJ0SGVpZ2h0ID0gZXhwb3J0cy51c2VBcmJpdHJhcnlZQXhpcyA9IGV4cG9ydHMudXNlQXJiaXRyYXJ5WEF4aXMgPSBleHBvcnRzLllBeGlzQ29udGV4dCA9IGV4cG9ydHMuWEF4aXNDb250ZXh0ID0gZXhwb3J0cy5WaWV3Qm94Q29udGV4dCA9IGV4cG9ydHMuT2Zmc2V0Q29udGV4dCA9IGV4cG9ydHMuQ2xpcFBhdGhJZENvbnRleHQgPSBleHBvcnRzLkNoYXJ0V2lkdGhDb250ZXh0ID0gZXhwb3J0cy5DaGFydExheW91dENvbnRleHRQcm92aWRlciA9IGV4cG9ydHMuQ2hhcnRIZWlnaHRDb250ZXh0ID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3RpbnlJbnZhcmlhbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJ0aW55LWludmFyaWFudFwiKSk7XG52YXIgX2ZpbmQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZmluZFwiKSk7XG52YXIgX2V2ZXJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2V2ZXJ5XCIpKTtcbnZhciBfY2FsY3VsYXRlVmlld0JveCA9IHJlcXVpcmUoXCIuLi91dGlsL2NhbGN1bGF0ZVZpZXdCb3hcIik7XG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG52YXIgWEF4aXNDb250ZXh0ID0gZXhwb3J0cy5YQXhpc0NvbnRleHQgPSAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jcmVhdGVDb250ZXh0KSh1bmRlZmluZWQpO1xudmFyIFlBeGlzQ29udGV4dCA9IGV4cG9ydHMuWUF4aXNDb250ZXh0ID0gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY3JlYXRlQ29udGV4dCkodW5kZWZpbmVkKTtcbnZhciBWaWV3Qm94Q29udGV4dCA9IGV4cG9ydHMuVmlld0JveENvbnRleHQgPSAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jcmVhdGVDb250ZXh0KSh1bmRlZmluZWQpO1xudmFyIE9mZnNldENvbnRleHQgPSBleHBvcnRzLk9mZnNldENvbnRleHQgPSAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jcmVhdGVDb250ZXh0KSh7fSk7XG52YXIgQ2xpcFBhdGhJZENvbnRleHQgPSBleHBvcnRzLkNsaXBQYXRoSWRDb250ZXh0ID0gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY3JlYXRlQ29udGV4dCkodW5kZWZpbmVkKTtcbnZhciBDaGFydEhlaWdodENvbnRleHQgPSBleHBvcnRzLkNoYXJ0SGVpZ2h0Q29udGV4dCA9IC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNyZWF0ZUNvbnRleHQpKDApO1xudmFyIENoYXJ0V2lkdGhDb250ZXh0ID0gZXhwb3J0cy5DaGFydFdpZHRoQ29udGV4dCA9IC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNyZWF0ZUNvbnRleHQpKDApO1xuXG4vKipcbiAqIFdpbGwgYWRkIGFsbCB0aGUgcHJvcGVydGllcyByZXF1aXJlZCB0byByZW5kZXIgYWxsIGluZGl2aWR1YWwgUmVjaGFydHMgY29tcG9uZW50cyBpbnRvIGEgUmVhY3QgQ29udGV4dC5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byByZWFkIHRoZXNlIHByb3BlcnRpZXMsIHNlZSB0aGUgY29sbGVjdGlvbiBvZiBob29rcyBleHBvcnRlZCBmcm9tIHRoaXMgZmlsZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgQ2F0ZWdvcmljYWxDaGFydFN0YXRlLCBwbHVzIGNoaWxkcmVuXG4gKiBAcmV0dXJucyB7UmVhY3RFbGVtZW50fSBSZWFjdCBDb250ZXh0IFByb3ZpZGVyXG4gKi9cbnZhciBDaGFydExheW91dENvbnRleHRQcm92aWRlciA9IGV4cG9ydHMuQ2hhcnRMYXlvdXRDb250ZXh0UHJvdmlkZXIgPSBmdW5jdGlvbiBDaGFydExheW91dENvbnRleHRQcm92aWRlcihwcm9wcykge1xuICB2YXIgX3Byb3BzJHN0YXRlID0gcHJvcHMuc3RhdGUsXG4gICAgeEF4aXNNYXAgPSBfcHJvcHMkc3RhdGUueEF4aXNNYXAsXG4gICAgeUF4aXNNYXAgPSBfcHJvcHMkc3RhdGUueUF4aXNNYXAsXG4gICAgb2Zmc2V0ID0gX3Byb3BzJHN0YXRlLm9mZnNldCxcbiAgICBjbGlwUGF0aElkID0gcHJvcHMuY2xpcFBhdGhJZCxcbiAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgIHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0O1xuXG4gIC8qKlxuICAgKiBQZXJoYXBzIHdlIHNob3VsZCBjb21wdXRlIHRoaXMgcHJvcGVydHkgd2hlbiByZWFkaW5nPyBMZXQncyBzZWUgd2hhdCBpcyBtb3JlIG9mdGVuIHVzZWRcbiAgICovXG4gIHZhciB2aWV3Qm94ID0gKDAsIF9jYWxjdWxhdGVWaWV3Qm94LmNhbGN1bGF0ZVZpZXdCb3gpKG9mZnNldCk7XG5cbiAgLypcbiAgICogVGhpcyBwcmV0ZW5kcyB0byBiZSBhIHNpbmdsZSBjb250ZXh0IGJ1dCBhY3R1YWxseSBpcyBzcGxpdCBpbnRvIG11bHRpcGxlIHNtYWxsZXIgb25lcy5cbiAgICogV2h5P1xuICAgKiBCZWNhdXNlIG9uZSBSZWFjdCBDb250ZXh0IG9ubHkgYWxsb3dzIHRvIHNldCBvbmUgdmFsdWUuXG4gICAqIEJ1dCB3ZSBuZWVkIHRvIHNldCBtdWx0aXBsZSB2YWx1ZXMuXG4gICAqIElmIHdlIGRvIHRoYXQgd2l0aCBvbmUgY29udGV4dCwgdGhlbiB3ZSBmb3JjZSByZS1yZW5kZXIgb24gY29tcG9uZW50cyB0aGF0IG1pZ2h0IG5vdCBldmVuIGJlIGludGVyZXN0ZWRcbiAgICogaW4gdGhlIHBhcnQgb2YgdGhlIHN0YXRlIHRoYXQgaGFzIGNoYW5nZWQuXG4gICAqXG4gICAqIEJ5IHNwbGl0dGluZyBpbnRvIHNtYWxsZXIgY29udGV4dHMsIHdlIGFsbG93IGVhY2ggY29tcG9uZW50cyB0byBiZSBvcHRpbWl6ZWQgYW5kIG9ubHkgcmUtcmVuZGVyIHdoZW4gaXRzIGRlcGVuZGVuY2llcyBjaGFuZ2UuXG4gICAqXG4gICAqIFRvIGFjdHVhbGx5IGFjaGlldmUgdGhlIG9wdGltYWwgcmUtcmVuZGVyLCBpdCBpcyBuZWNlc3NhcnkgdG8gdXNlIFJlYWN0Lm1lbW8oKS5cbiAgICogU2VlIHRoZSB0ZXN0IGZpbGUgZm9yIGRldGFpbHMuXG4gICAqL1xuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChYQXhpc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogeEF4aXNNYXBcbiAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChZQXhpc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogeUF4aXNNYXBcbiAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChPZmZzZXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG9mZnNldFxuICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFZpZXdCb3hDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHZpZXdCb3hcbiAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChDbGlwUGF0aElkQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjbGlwUGF0aElkXG4gIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQ2hhcnRIZWlnaHRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGhlaWdodFxuICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KENoYXJ0V2lkdGhDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHdpZHRoXG4gIH0sIGNoaWxkcmVuKSkpKSkpKTtcbn07XG52YXIgdXNlQ2xpcFBhdGhJZCA9IGV4cG9ydHMudXNlQ2xpcFBhdGhJZCA9IGZ1bmN0aW9uIHVzZUNsaXBQYXRoSWQoKSB7XG4gIHJldHVybiAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKENsaXBQYXRoSWRDb250ZXh0KTtcbn07XG5mdW5jdGlvbiBnZXRLZXlzRm9yRGVidWcob2JqZWN0KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdUaGVyZSBhcmUgbm8gYXZhaWxhYmxlIGlkcy4nO1xuICB9XG4gIHJldHVybiBcIkF2YWlsYWJsZSBpZHMgYXJlOiBcIi5jb25jYXQoa2V5cywgXCIuXCIpO1xufVxuXG4vKipcbiAqIFRoaXMgZWl0aGVyIGZpbmRzIGFuZCByZXR1cm5zIEF4aXMgYnkgdGhlIHNwZWNpZmllZCBJRCwgb3IgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBhbiBheGlzIHdpdGggdGhpcyBJRCBkb2VzIG5vdCBleGlzdC5cbiAqXG4gKiBAcGFyYW0geEF4aXNJZCBpZGVudGlmaWVyIG9mIHRoZSBheGlzIC0gaXQncyBlaXRoZXIgYXV0b2dlbmVyYXRlZCAoJzAnKSwgb3IgcGFzc2VkIHZpYSBgaWRgIHByb3AgYXMgPFhBeGlzIGlkPSdmb28nIC8+XG4gKiBAcmV0dXJucyBheGlzIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKiBAdGhyb3dzIEVycm9yIGlmIG5vIGF4aXMgd2l0aCB0aGlzIElEIGV4aXN0c1xuICovXG52YXIgdXNlWEF4aXNPclRocm93ID0gZXhwb3J0cy51c2VYQXhpc09yVGhyb3cgPSBmdW5jdGlvbiB1c2VYQXhpc09yVGhyb3coeEF4aXNJZCkge1xuICB2YXIgeEF4aXNNYXAgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKFhBeGlzQ29udGV4dCk7XG4gICEoeEF4aXNNYXAgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAoMCwgX3RpbnlJbnZhcmlhbnRbXCJkZWZhdWx0XCJdKShmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIFJlY2hhcnRzIGNvbnRleHQ7IGFyZSB5b3Ugc3VyZSB0aGlzIGlzIHJlbmRlcmVkIGluc2lkZSBhIFJlY2hhcnRzIHdyYXBwZXIgY29tcG9uZW50PycpIDogKDAsIF90aW55SW52YXJpYW50W1wiZGVmYXVsdFwiXSkoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgeEF4aXMgPSB4QXhpc01hcFt4QXhpc0lkXTtcbiAgISh4QXhpcyAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/ICgwLCBfdGlueUludmFyaWFudFtcImRlZmF1bHRcIl0pKGZhbHNlLCBcIkNvdWxkIG5vdCBmaW5kIHhBeGlzIGJ5IGlkIFxcXCJcIi5jb25jYXQoeEF4aXNJZCwgXCJcXFwiIFtcIikuY29uY2F0KF90eXBlb2YoeEF4aXNJZCksIFwiXS4gXCIpLmNvbmNhdChnZXRLZXlzRm9yRGVidWcoeEF4aXNNYXApKSkgOiAoMCwgX3RpbnlJbnZhcmlhbnRbXCJkZWZhdWx0XCJdKShmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiB4QXhpcztcbn07XG5cbi8qKlxuICogVGhpcyB3aWxsIGZpbmQgYW4gYXJiaXRyYXJ5IGZpcnN0IFhBeGlzLiBJZiB0aGVyZSdzIGV4YWN0bHkgb25lIGl0IGFsd2F5cyByZXR1cm5zIHRoYXQgb25lXG4gKiAtIGJ1dCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgdGhlbiBpdCBjYW4gcmV0dXJuIGFueSBvZiB0aG9zZS5cbiAqXG4gKiBJZiB5b3Ugd2FudCBzcGVjaWZpYyBYQXhpcyBvdXQgb2YgbXVsdGlwbGUgdGhlbiBwcmVmZXIgdXNpbmcgdXNlWEF4aXNPclRocm93XG4gKlxuICogQHJldHVybnMgWCBheGlzT3B0aW9ucywgb3IgdW5kZWZpbmVkIC0gaWYgdGhlcmUgYXJlIG5vIFggYXhlc1xuICovXG52YXIgdXNlQXJiaXRyYXJ5WEF4aXMgPSBleHBvcnRzLnVzZUFyYml0cmFyeVhBeGlzID0gZnVuY3Rpb24gdXNlQXJiaXRyYXJ5WEF4aXMoKSB7XG4gIHZhciB4QXhpc01hcCA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoWEF4aXNDb250ZXh0KTtcbiAgcmV0dXJuICgwLCBfRGF0YVV0aWxzLmdldEFueUVsZW1lbnRPZk9iamVjdCkoeEF4aXNNYXApO1xufTtcblxuLyoqXG4gKiBUaGlzIHdpbGwgZmluZCBhbiBhcmJpdHJhcnkgZmlyc3QgWUF4aXMuIElmIHRoZXJlJ3MgZXhhY3RseSBvbmUgaXQgYWx3YXlzIHJldHVybnMgdGhhdCBvbmVcbiAqIC0gYnV0IGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB0aGVuIGl0IGNhbiByZXR1cm4gYW55IG9mIHRob3NlLlxuICpcbiAqIElmIHlvdSB3YW50IHNwZWNpZmljIFlBeGlzIG91dCBvZiBtdWx0aXBsZSB0aGVuIHByZWZlciB1c2luZyB1c2VYQXhpc09yVGhyb3dcbiAqXG4gKiBAcmV0dXJucyBZIGF4aXNPcHRpb25zLCBvciB1bmRlZmluZWQgLSBpZiB0aGVyZSBhcmUgbm8gWSBheGVzXG4gKi9cbnZhciB1c2VBcmJpdHJhcnlZQXhpcyA9IGV4cG9ydHMudXNlQXJiaXRyYXJ5WUF4aXMgPSBmdW5jdGlvbiB1c2VBcmJpdHJhcnlZQXhpcygpIHtcbiAgdmFyIHlBeGlzTWFwID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShZQXhpc0NvbnRleHQpO1xuICByZXR1cm4gKDAsIF9EYXRhVXRpbHMuZ2V0QW55RWxlbWVudE9mT2JqZWN0KSh5QXhpc01hcCk7XG59O1xuXG4vKipcbiAqIFRoaXMgaG9va3Mgd2lsbDpcbiAqIDFzdCBhdHRlbXB0IHRvIGZpbmQgYW4gWUF4aXMgdGhhdCBoYXMgYWxsIGVsZW1lbnRzIGluIGl0cyBkb21haW4gZmluaXRlXG4gKiBJZiBubyBzdWNoIGF4aXMgZXhpc3RzLCBpdCB3aWxsIHJldHVybiBhbiBhcmJpdHJhcnkgWUF4aXNcbiAqIGlmIHRoZXJlIGFyZSBubyBZIGF4ZXMgdGhlbiBpdCByZXR1cm5zIHVuZGVmaW5lZFxuICpcbiAqIEByZXR1cm5zIEVpdGhlciBZIGF4aXNPcHRpb25zLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG5vIFkgYXhlc1xuICovXG52YXIgdXNlWUF4aXNXaXRoRmluaXRlRG9tYWluT3JSYW5kb20gPSBleHBvcnRzLnVzZVlBeGlzV2l0aEZpbml0ZURvbWFpbk9yUmFuZG9tID0gZnVuY3Rpb24gdXNlWUF4aXNXaXRoRmluaXRlRG9tYWluT3JSYW5kb20oKSB7XG4gIHZhciB5QXhpc01hcCA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoWUF4aXNDb250ZXh0KTtcbiAgdmFyIHlBeGlzV2l0aEZpbml0ZURvbWFpbiA9ICgwLCBfZmluZFtcImRlZmF1bHRcIl0pKHlBeGlzTWFwLCBmdW5jdGlvbiAoYXhpcykge1xuICAgIHJldHVybiAoMCwgX2V2ZXJ5W1wiZGVmYXVsdFwiXSkoYXhpcy5kb21haW4sIE51bWJlci5pc0Zpbml0ZSk7XG4gIH0pO1xuICByZXR1cm4geUF4aXNXaXRoRmluaXRlRG9tYWluIHx8ICgwLCBfRGF0YVV0aWxzLmdldEFueUVsZW1lbnRPZk9iamVjdCkoeUF4aXNNYXApO1xufTtcblxuLyoqXG4gKiBUaGlzIGVpdGhlciBmaW5kcyBhbmQgcmV0dXJucyBBeGlzIGJ5IHRoZSBzcGVjaWZpZWQgSUQsIG9yIHRocm93cyBhbiBleGNlcHRpb24gaWYgYW4gYXhpcyB3aXRoIHRoaXMgSUQgZG9lcyBub3QgZXhpc3QuXG4gKlxuICogQHBhcmFtIHlBeGlzSWQgaWRlbnRpZmllciBvZiB0aGUgYXhpcyAtIGl0J3MgZWl0aGVyIGF1dG9nZW5lcmF0ZWQgKCcwJyksIG9yIHBhc3NlZCB2aWEgYGlkYCBwcm9wIGFzIDxZQXhpcyBpZD0nZm9vJyAvPlxuICogQHJldHVybnMgYXhpcyBjb25maWd1cmF0aW9uIG9iamVjdFxuICogQHRocm93cyBFcnJvciBpZiBubyBheGlzIHdpdGggdGhpcyBJRCBleGlzdHNcbiAqL1xudmFyIHVzZVlBeGlzT3JUaHJvdyA9IGV4cG9ydHMudXNlWUF4aXNPclRocm93ID0gZnVuY3Rpb24gdXNlWUF4aXNPclRocm93KHlBeGlzSWQpIHtcbiAgdmFyIHlBeGlzTWFwID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShZQXhpc0NvbnRleHQpO1xuICAhKHlBeGlzTWFwICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gKDAsIF90aW55SW52YXJpYW50W1wiZGVmYXVsdFwiXSkoZmFsc2UsICdDb3VsZCBub3QgZmluZCBSZWNoYXJ0cyBjb250ZXh0OyBhcmUgeW91IHN1cmUgdGhpcyBpcyByZW5kZXJlZCBpbnNpZGUgYSBSZWNoYXJ0cyB3cmFwcGVyIGNvbXBvbmVudD8nKSA6ICgwLCBfdGlueUludmFyaWFudFtcImRlZmF1bHRcIl0pKGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIHlBeGlzID0geUF4aXNNYXBbeUF4aXNJZF07XG4gICEoeUF4aXMgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAoMCwgX3RpbnlJbnZhcmlhbnRbXCJkZWZhdWx0XCJdKShmYWxzZSwgXCJDb3VsZCBub3QgZmluZCB5QXhpcyBieSBpZCBcXFwiXCIuY29uY2F0KHlBeGlzSWQsIFwiXFxcIiBbXCIpLmNvbmNhdChfdHlwZW9mKHlBeGlzSWQpLCBcIl0uIFwiKS5jb25jYXQoZ2V0S2V5c0ZvckRlYnVnKHlBeGlzTWFwKSkpIDogKDAsIF90aW55SW52YXJpYW50W1wiZGVmYXVsdFwiXSkoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4geUF4aXM7XG59O1xudmFyIHVzZVZpZXdCb3ggPSBleHBvcnRzLnVzZVZpZXdCb3ggPSBmdW5jdGlvbiB1c2VWaWV3Qm94KCkge1xuICB2YXIgdmlld0JveCA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoVmlld0JveENvbnRleHQpO1xuICByZXR1cm4gdmlld0JveDtcbn07XG52YXIgdXNlT2Zmc2V0ID0gZXhwb3J0cy51c2VPZmZzZXQgPSBmdW5jdGlvbiB1c2VPZmZzZXQoKSB7XG4gIHJldHVybiAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKE9mZnNldENvbnRleHQpO1xufTtcbnZhciB1c2VDaGFydFdpZHRoID0gZXhwb3J0cy51c2VDaGFydFdpZHRoID0gZnVuY3Rpb24gdXNlQ2hhcnRXaWR0aCgpIHtcbiAgcmV0dXJuICgwLCBfcmVhY3QudXNlQ29udGV4dCkoQ2hhcnRXaWR0aENvbnRleHQpO1xufTtcbnZhciB1c2VDaGFydEhlaWdodCA9IGV4cG9ydHMudXNlQ2hhcnRIZWlnaHQgPSBmdW5jdGlvbiB1c2VDaGFydEhlaWdodCgpIHtcbiAgcmV0dXJuICgwLCBfcmVhY3QudXNlQ29udGV4dCkoQ2hhcnRIZWlnaHRDb250ZXh0KTtcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXNlWUF4aXNXaXRoRmluaXRlRG9tYWluT3JSYW5kb20iLCJ1c2VZQXhpc09yVGhyb3ciLCJ1c2VYQXhpc09yVGhyb3ciLCJ1c2VWaWV3Qm94IiwidXNlT2Zmc2V0IiwidXNlQ2xpcFBhdGhJZCIsInVzZUNoYXJ0V2lkdGgiLCJ1c2VDaGFydEhlaWdodCIsInVzZUFyYml0cmFyeVlBeGlzIiwidXNlQXJiaXRyYXJ5WEF4aXMiLCJZQXhpc0NvbnRleHQiLCJYQXhpc0NvbnRleHQiLCJWaWV3Qm94Q29udGV4dCIsIk9mZnNldENvbnRleHQiLCJDbGlwUGF0aElkQ29udGV4dCIsIkNoYXJ0V2lkdGhDb250ZXh0IiwiQ2hhcnRMYXlvdXRDb250ZXh0UHJvdmlkZXIiLCJDaGFydEhlaWdodENvbnRleHQiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfdGlueUludmFyaWFudCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfZmluZCIsIl9ldmVyeSIsIl9jYWxjdWxhdGVWaWV3Qm94IiwiX0RhdGFVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsImNyZWF0ZUNvbnRleHQiLCJ1bmRlZmluZWQiLCJwcm9wcyIsIl9wcm9wcyRzdGF0ZSIsInN0YXRlIiwieEF4aXNNYXAiLCJ5QXhpc01hcCIsIm9mZnNldCIsImNsaXBQYXRoSWQiLCJjaGlsZHJlbiIsIndpZHRoIiwiaGVpZ2h0Iiwidmlld0JveCIsImNhbGN1bGF0ZVZpZXdCb3giLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ1c2VDb250ZXh0IiwiZ2V0S2V5c0ZvckRlYnVnIiwib2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImNvbmNhdCIsInhBeGlzSWQiLCJwcm9jZXNzIiwieEF4aXMiLCJnZXRBbnlFbGVtZW50T2ZPYmplY3QiLCJ5QXhpc1dpdGhGaW5pdGVEb21haW4iLCJheGlzIiwiZG9tYWluIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ5QXhpc0lkIiwieUF4aXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/context/chartLayoutContext.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/recharts/lib/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Area\", ({\n    enumerable: true,\n    get: function get() {\n        return _Area.Area;\n    }\n}));\nObject.defineProperty(exports, \"AreaChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _AreaChart.AreaChart;\n    }\n}));\nObject.defineProperty(exports, \"Bar\", ({\n    enumerable: true,\n    get: function get() {\n        return _Bar.Bar;\n    }\n}));\nObject.defineProperty(exports, \"BarChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _BarChart.BarChart;\n    }\n}));\nObject.defineProperty(exports, \"Brush\", ({\n    enumerable: true,\n    get: function get() {\n        return _Brush.Brush;\n    }\n}));\nObject.defineProperty(exports, \"CartesianAxis\", ({\n    enumerable: true,\n    get: function get() {\n        return _CartesianAxis.CartesianAxis;\n    }\n}));\nObject.defineProperty(exports, \"CartesianGrid\", ({\n    enumerable: true,\n    get: function get() {\n        return _CartesianGrid.CartesianGrid;\n    }\n}));\nObject.defineProperty(exports, \"Cell\", ({\n    enumerable: true,\n    get: function get() {\n        return _Cell.Cell;\n    }\n}));\nObject.defineProperty(exports, \"ComposedChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _ComposedChart.ComposedChart;\n    }\n}));\nObject.defineProperty(exports, \"Cross\", ({\n    enumerable: true,\n    get: function get() {\n        return _Cross.Cross;\n    }\n}));\nObject.defineProperty(exports, \"Curve\", ({\n    enumerable: true,\n    get: function get() {\n        return _Curve.Curve;\n    }\n}));\nObject.defineProperty(exports, \"Customized\", ({\n    enumerable: true,\n    get: function get() {\n        return _Customized.Customized;\n    }\n}));\nObject.defineProperty(exports, \"DefaultLegendContent\", ({\n    enumerable: true,\n    get: function get() {\n        return _DefaultLegendContent.DefaultLegendContent;\n    }\n}));\nObject.defineProperty(exports, \"DefaultTooltipContent\", ({\n    enumerable: true,\n    get: function get() {\n        return _DefaultTooltipContent.DefaultTooltipContent;\n    }\n}));\nObject.defineProperty(exports, \"Dot\", ({\n    enumerable: true,\n    get: function get() {\n        return _Dot.Dot;\n    }\n}));\nObject.defineProperty(exports, \"ErrorBar\", ({\n    enumerable: true,\n    get: function get() {\n        return _ErrorBar.ErrorBar;\n    }\n}));\nObject.defineProperty(exports, \"Funnel\", ({\n    enumerable: true,\n    get: function get() {\n        return _Funnel.Funnel;\n    }\n}));\nObject.defineProperty(exports, \"FunnelChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _FunnelChart.FunnelChart;\n    }\n}));\nObject.defineProperty(exports, \"Global\", ({\n    enumerable: true,\n    get: function get() {\n        return _Global.Global;\n    }\n}));\nObject.defineProperty(exports, \"Label\", ({\n    enumerable: true,\n    get: function get() {\n        return _Label.Label;\n    }\n}));\nObject.defineProperty(exports, \"LabelList\", ({\n    enumerable: true,\n    get: function get() {\n        return _LabelList.LabelList;\n    }\n}));\nObject.defineProperty(exports, \"Layer\", ({\n    enumerable: true,\n    get: function get() {\n        return _Layer.Layer;\n    }\n}));\nObject.defineProperty(exports, \"Legend\", ({\n    enumerable: true,\n    get: function get() {\n        return _Legend.Legend;\n    }\n}));\nObject.defineProperty(exports, \"Line\", ({\n    enumerable: true,\n    get: function get() {\n        return _Line.Line;\n    }\n}));\nObject.defineProperty(exports, \"LineChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _LineChart.LineChart;\n    }\n}));\nObject.defineProperty(exports, \"Pie\", ({\n    enumerable: true,\n    get: function get() {\n        return _Pie.Pie;\n    }\n}));\nObject.defineProperty(exports, \"PieChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _PieChart.PieChart;\n    }\n}));\nObject.defineProperty(exports, \"PolarAngleAxis\", ({\n    enumerable: true,\n    get: function get() {\n        return _PolarAngleAxis.PolarAngleAxis;\n    }\n}));\nObject.defineProperty(exports, \"PolarGrid\", ({\n    enumerable: true,\n    get: function get() {\n        return _PolarGrid.PolarGrid;\n    }\n}));\nObject.defineProperty(exports, \"PolarRadiusAxis\", ({\n    enumerable: true,\n    get: function get() {\n        return _PolarRadiusAxis.PolarRadiusAxis;\n    }\n}));\nObject.defineProperty(exports, \"Polygon\", ({\n    enumerable: true,\n    get: function get() {\n        return _Polygon.Polygon;\n    }\n}));\nObject.defineProperty(exports, \"Radar\", ({\n    enumerable: true,\n    get: function get() {\n        return _Radar.Radar;\n    }\n}));\nObject.defineProperty(exports, \"RadarChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _RadarChart.RadarChart;\n    }\n}));\nObject.defineProperty(exports, \"RadialBar\", ({\n    enumerable: true,\n    get: function get() {\n        return _RadialBar.RadialBar;\n    }\n}));\nObject.defineProperty(exports, \"RadialBarChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _RadialBarChart.RadialBarChart;\n    }\n}));\nObject.defineProperty(exports, \"Rectangle\", ({\n    enumerable: true,\n    get: function get() {\n        return _Rectangle.Rectangle;\n    }\n}));\nObject.defineProperty(exports, \"ReferenceArea\", ({\n    enumerable: true,\n    get: function get() {\n        return _ReferenceArea.ReferenceArea;\n    }\n}));\nObject.defineProperty(exports, \"ReferenceDot\", ({\n    enumerable: true,\n    get: function get() {\n        return _ReferenceDot.ReferenceDot;\n    }\n}));\nObject.defineProperty(exports, \"ReferenceLine\", ({\n    enumerable: true,\n    get: function get() {\n        return _ReferenceLine.ReferenceLine;\n    }\n}));\nObject.defineProperty(exports, \"ResponsiveContainer\", ({\n    enumerable: true,\n    get: function get() {\n        return _ResponsiveContainer.ResponsiveContainer;\n    }\n}));\nObject.defineProperty(exports, \"Sankey\", ({\n    enumerable: true,\n    get: function get() {\n        return _Sankey.Sankey;\n    }\n}));\nObject.defineProperty(exports, \"Scatter\", ({\n    enumerable: true,\n    get: function get() {\n        return _Scatter.Scatter;\n    }\n}));\nObject.defineProperty(exports, \"ScatterChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _ScatterChart.ScatterChart;\n    }\n}));\nObject.defineProperty(exports, \"Sector\", ({\n    enumerable: true,\n    get: function get() {\n        return _Sector.Sector;\n    }\n}));\nObject.defineProperty(exports, \"SunburstChart\", ({\n    enumerable: true,\n    get: function get() {\n        return _SunburstChart.SunburstChart;\n    }\n}));\nObject.defineProperty(exports, \"Surface\", ({\n    enumerable: true,\n    get: function get() {\n        return _Surface.Surface;\n    }\n}));\nObject.defineProperty(exports, \"Symbols\", ({\n    enumerable: true,\n    get: function get() {\n        return _Symbols.Symbols;\n    }\n}));\nObject.defineProperty(exports, \"Text\", ({\n    enumerable: true,\n    get: function get() {\n        return _Text.Text;\n    }\n}));\nObject.defineProperty(exports, \"Tooltip\", ({\n    enumerable: true,\n    get: function get() {\n        return _Tooltip.Tooltip;\n    }\n}));\nObject.defineProperty(exports, \"Trapezoid\", ({\n    enumerable: true,\n    get: function get() {\n        return _Trapezoid.Trapezoid;\n    }\n}));\nObject.defineProperty(exports, \"Treemap\", ({\n    enumerable: true,\n    get: function get() {\n        return _Treemap.Treemap;\n    }\n}));\nObject.defineProperty(exports, \"XAxis\", ({\n    enumerable: true,\n    get: function get() {\n        return _XAxis.XAxis;\n    }\n}));\nObject.defineProperty(exports, \"YAxis\", ({\n    enumerable: true,\n    get: function get() {\n        return _YAxis.YAxis;\n    }\n}));\nObject.defineProperty(exports, \"ZAxis\", ({\n    enumerable: true,\n    get: function get() {\n        return _ZAxis.ZAxis;\n    }\n}));\nvar _Surface = __webpack_require__(/*! ./container/Surface */ \"./node_modules/recharts/lib/container/Surface.js\");\nvar _Layer = __webpack_require__(/*! ./container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _Legend = __webpack_require__(/*! ./component/Legend */ \"./node_modules/recharts/lib/component/Legend.js\");\nvar _DefaultLegendContent = __webpack_require__(/*! ./component/DefaultLegendContent */ \"./node_modules/recharts/lib/component/DefaultLegendContent.js\");\nvar _Tooltip = __webpack_require__(/*! ./component/Tooltip */ \"./node_modules/recharts/lib/component/Tooltip.js\");\nvar _DefaultTooltipContent = __webpack_require__(/*! ./component/DefaultTooltipContent */ \"./node_modules/recharts/lib/component/DefaultTooltipContent.js\");\nvar _ResponsiveContainer = __webpack_require__(/*! ./component/ResponsiveContainer */ \"./node_modules/recharts/lib/component/ResponsiveContainer.js\");\nvar _Cell = __webpack_require__(/*! ./component/Cell */ \"./node_modules/recharts/lib/component/Cell.js\");\nvar _Text = __webpack_require__(/*! ./component/Text */ \"./node_modules/recharts/lib/component/Text.js\");\nvar _Label = __webpack_require__(/*! ./component/Label */ \"./node_modules/recharts/lib/component/Label.js\");\nvar _LabelList = __webpack_require__(/*! ./component/LabelList */ \"./node_modules/recharts/lib/component/LabelList.js\");\nvar _Customized = __webpack_require__(/*! ./component/Customized */ \"./node_modules/recharts/lib/component/Customized.js\");\nvar _Sector = __webpack_require__(/*! ./shape/Sector */ \"./node_modules/recharts/lib/shape/Sector.js\");\nvar _Curve = __webpack_require__(/*! ./shape/Curve */ \"./node_modules/recharts/lib/shape/Curve.js\");\nvar _Rectangle = __webpack_require__(/*! ./shape/Rectangle */ \"./node_modules/recharts/lib/shape/Rectangle.js\");\nvar _Polygon = __webpack_require__(/*! ./shape/Polygon */ \"./node_modules/recharts/lib/shape/Polygon.js\");\nvar _Dot = __webpack_require__(/*! ./shape/Dot */ \"./node_modules/recharts/lib/shape/Dot.js\");\nvar _Cross = __webpack_require__(/*! ./shape/Cross */ \"./node_modules/recharts/lib/shape/Cross.js\");\nvar _Symbols = __webpack_require__(/*! ./shape/Symbols */ \"./node_modules/recharts/lib/shape/Symbols.js\");\nvar _PolarGrid = __webpack_require__(/*! ./polar/PolarGrid */ \"./node_modules/recharts/lib/polar/PolarGrid.js\");\nvar _PolarRadiusAxis = __webpack_require__(/*! ./polar/PolarRadiusAxis */ \"./node_modules/recharts/lib/polar/PolarRadiusAxis.js\");\nvar _PolarAngleAxis = __webpack_require__(/*! ./polar/PolarAngleAxis */ \"./node_modules/recharts/lib/polar/PolarAngleAxis.js\");\nvar _Pie = __webpack_require__(/*! ./polar/Pie */ \"./node_modules/recharts/lib/polar/Pie.js\");\nvar _Radar = __webpack_require__(/*! ./polar/Radar */ \"./node_modules/recharts/lib/polar/Radar.js\");\nvar _RadialBar = __webpack_require__(/*! ./polar/RadialBar */ \"./node_modules/recharts/lib/polar/RadialBar.js\");\nvar _Brush = __webpack_require__(/*! ./cartesian/Brush */ \"./node_modules/recharts/lib/cartesian/Brush.js\");\nvar _ReferenceLine = __webpack_require__(/*! ./cartesian/ReferenceLine */ \"./node_modules/recharts/lib/cartesian/ReferenceLine.js\");\nvar _ReferenceDot = __webpack_require__(/*! ./cartesian/ReferenceDot */ \"./node_modules/recharts/lib/cartesian/ReferenceDot.js\");\nvar _ReferenceArea = __webpack_require__(/*! ./cartesian/ReferenceArea */ \"./node_modules/recharts/lib/cartesian/ReferenceArea.js\");\nvar _CartesianAxis = __webpack_require__(/*! ./cartesian/CartesianAxis */ \"./node_modules/recharts/lib/cartesian/CartesianAxis.js\");\nvar _CartesianGrid = __webpack_require__(/*! ./cartesian/CartesianGrid */ \"./node_modules/recharts/lib/cartesian/CartesianGrid.js\");\nvar _Line = __webpack_require__(/*! ./cartesian/Line */ \"./node_modules/recharts/lib/cartesian/Line.js\");\nvar _Area = __webpack_require__(/*! ./cartesian/Area */ \"./node_modules/recharts/lib/cartesian/Area.js\");\nvar _Bar = __webpack_require__(/*! ./cartesian/Bar */ \"./node_modules/recharts/lib/cartesian/Bar.js\");\nvar _Scatter = __webpack_require__(/*! ./cartesian/Scatter */ \"./node_modules/recharts/lib/cartesian/Scatter.js\");\nvar _XAxis = __webpack_require__(/*! ./cartesian/XAxis */ \"./node_modules/recharts/lib/cartesian/XAxis.js\");\nvar _YAxis = __webpack_require__(/*! ./cartesian/YAxis */ \"./node_modules/recharts/lib/cartesian/YAxis.js\");\nvar _ZAxis = __webpack_require__(/*! ./cartesian/ZAxis */ \"./node_modules/recharts/lib/cartesian/ZAxis.js\");\nvar _ErrorBar = __webpack_require__(/*! ./cartesian/ErrorBar */ \"./node_modules/recharts/lib/cartesian/ErrorBar.js\");\nvar _LineChart = __webpack_require__(/*! ./chart/LineChart */ \"./node_modules/recharts/lib/chart/LineChart.js\");\nvar _BarChart = __webpack_require__(/*! ./chart/BarChart */ \"./node_modules/recharts/lib/chart/BarChart.js\");\nvar _PieChart = __webpack_require__(/*! ./chart/PieChart */ \"./node_modules/recharts/lib/chart/PieChart.js\");\nvar _Treemap = __webpack_require__(/*! ./chart/Treemap */ \"./node_modules/recharts/lib/chart/Treemap.js\");\nvar _Sankey = __webpack_require__(/*! ./chart/Sankey */ \"./node_modules/recharts/lib/chart/Sankey.js\");\nvar _RadarChart = __webpack_require__(/*! ./chart/RadarChart */ \"./node_modules/recharts/lib/chart/RadarChart.js\");\nvar _ScatterChart = __webpack_require__(/*! ./chart/ScatterChart */ \"./node_modules/recharts/lib/chart/ScatterChart.js\");\nvar _AreaChart = __webpack_require__(/*! ./chart/AreaChart */ \"./node_modules/recharts/lib/chart/AreaChart.js\");\nvar _RadialBarChart = __webpack_require__(/*! ./chart/RadialBarChart */ \"./node_modules/recharts/lib/chart/RadialBarChart.js\");\nvar _ComposedChart = __webpack_require__(/*! ./chart/ComposedChart */ \"./node_modules/recharts/lib/chart/ComposedChart.js\");\nvar _SunburstChart = __webpack_require__(/*! ./chart/SunburstChart */ \"./node_modules/recharts/lib/chart/SunburstChart.js\");\nvar _Funnel = __webpack_require__(/*! ./numberAxis/Funnel */ \"./node_modules/recharts/lib/numberAxis/Funnel.js\");\nvar _FunnelChart = __webpack_require__(/*! ./chart/FunnelChart */ \"./node_modules/recharts/lib/chart/FunnelChart.js\");\nvar _Trapezoid = __webpack_require__(/*! ./shape/Trapezoid */ \"./node_modules/recharts/lib/shape/Trapezoid.js\");\nvar _Global = __webpack_require__(/*! ./util/Global */ \"./node_modules/recharts/lib/util/Global.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QW1CO0FBQ3hDLElBQUk5RSxZQUFZOEUsbUJBQU9BLENBQUMsK0VBQXNCO0FBQzlDLElBQUk1RCxhQUFhNEQsbUJBQU9BLENBQUMseUVBQW1CO0FBQzVDLElBQUl0RyxZQUFZc0csbUJBQU9BLENBQUMsdUVBQWtCO0FBQzFDLElBQUl4RCxZQUFZd0QsbUJBQU9BLENBQUMsdUVBQWtCO0FBQzFDLElBQUlSLFdBQVdRLG1CQUFPQSxDQUFDLHFFQUFpQjtBQUN4QyxJQUFJNUIsVUFBVTRCLG1CQUFPQSxDQUFDLG1FQUFnQjtBQUN0QyxJQUFJNUMsY0FBYzRDLG1CQUFPQSxDQUFDLDJFQUFvQjtBQUM5QyxJQUFJeEIsZ0JBQWdCd0IsbUJBQU9BLENBQUMsK0VBQXNCO0FBQ2xELElBQUkxRyxhQUFhMEcsbUJBQU9BLENBQUMseUVBQW1CO0FBQzVDLElBQUl4QyxrQkFBa0J3QyxtQkFBT0EsQ0FBQyxtRkFBd0I7QUFDdEQsSUFBSTVGLGlCQUFpQjRGLG1CQUFPQSxDQUFDLGlGQUF1QjtBQUNwRCxJQUFJcEIsaUJBQWlCb0IsbUJBQU9BLENBQUMsaUZBQXVCO0FBQ3BELElBQUk1RSxVQUFVNEUsbUJBQU9BLENBQUMsNkVBQXFCO0FBQzNDLElBQUkxRSxlQUFlMEUsbUJBQU9BLENBQUMsNkVBQXFCO0FBQ2hELElBQUlWLGFBQWFVLG1CQUFPQSxDQUFDLHlFQUFtQjtBQUM1QyxJQUFJeEUsVUFBVXdFLG1CQUFPQSxDQUFDLGlFQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9pbmRleC5qcz8wYjdlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXJlYVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfQXJlYS5BcmVhO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFyZWFDaGFydFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfQXJlYUNoYXJ0LkFyZWFDaGFydDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Jhci5CYXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFyQ2hhcnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0JhckNoYXJ0LkJhckNoYXJ0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJydXNoXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9CcnVzaC5CcnVzaDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYXJ0ZXNpYW5BeGlzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9DYXJ0ZXNpYW5BeGlzLkNhcnRlc2lhbkF4aXM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FydGVzaWFuR3JpZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfQ2FydGVzaWFuR3JpZC5DYXJ0ZXNpYW5HcmlkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNlbGxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0NlbGwuQ2VsbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb21wb3NlZENoYXJ0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Db21wb3NlZENoYXJ0LkNvbXBvc2VkQ2hhcnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ3Jvc3NcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Nyb3NzLkNyb3NzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkN1cnZlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9DdXJ2ZS5DdXJ2ZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDdXN0b21pemVkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9DdXN0b21pemVkLkN1c3RvbWl6ZWQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVmYXVsdExlZ2VuZENvbnRlbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0RlZmF1bHRMZWdlbmRDb250ZW50LkRlZmF1bHRMZWdlbmRDb250ZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRlZmF1bHRUb29sdGlwQ29udGVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfRGVmYXVsdFRvb2x0aXBDb250ZW50LkRlZmF1bHRUb29sdGlwQ29udGVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEb3RcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0RvdC5Eb3Q7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JCYXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Vycm9yQmFyLkVycm9yQmFyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZ1bm5lbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfRnVubmVsLkZ1bm5lbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGdW5uZWxDaGFydFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfRnVubmVsQ2hhcnQuRnVubmVsQ2hhcnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR2xvYmFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9HbG9iYWwuR2xvYmFsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxhYmVsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9MYWJlbC5MYWJlbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMYWJlbExpc3RcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0xhYmVsTGlzdC5MYWJlbExpc3Q7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGF5ZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0xheWVyLkxheWVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxlZ2VuZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfTGVnZW5kLkxlZ2VuZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMaW5lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9MaW5lLkxpbmU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGluZUNoYXJ0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9MaW5lQ2hhcnQuTGluZUNoYXJ0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBpZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUGllLlBpZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQaWVDaGFydFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUGllQ2hhcnQuUGllQ2hhcnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUG9sYXJBbmdsZUF4aXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1BvbGFyQW5nbGVBeGlzLlBvbGFyQW5nbGVBeGlzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBvbGFyR3JpZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUG9sYXJHcmlkLlBvbGFyR3JpZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQb2xhclJhZGl1c0F4aXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1BvbGFyUmFkaXVzQXhpcy5Qb2xhclJhZGl1c0F4aXM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUG9seWdvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUG9seWdvbi5Qb2x5Z29uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJhZGFyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9SYWRhci5SYWRhcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSYWRhckNoYXJ0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9SYWRhckNoYXJ0LlJhZGFyQ2hhcnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmFkaWFsQmFyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9SYWRpYWxCYXIuUmFkaWFsQmFyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJhZGlhbEJhckNoYXJ0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9SYWRpYWxCYXJDaGFydC5SYWRpYWxCYXJDaGFydDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZWN0YW5nbGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1JlY3RhbmdsZS5SZWN0YW5nbGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVmZXJlbmNlQXJlYVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUmVmZXJlbmNlQXJlYS5SZWZlcmVuY2VBcmVhO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlZmVyZW5jZURvdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUmVmZXJlbmNlRG90LlJlZmVyZW5jZURvdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZWZlcmVuY2VMaW5lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9SZWZlcmVuY2VMaW5lLlJlZmVyZW5jZUxpbmU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzcG9uc2l2ZUNvbnRhaW5lclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUmVzcG9uc2l2ZUNvbnRhaW5lci5SZXNwb25zaXZlQ29udGFpbmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNhbmtleVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfU2Fua2V5LlNhbmtleTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTY2F0dGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9TY2F0dGVyLlNjYXR0ZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NhdHRlckNoYXJ0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9TY2F0dGVyQ2hhcnQuU2NhdHRlckNoYXJ0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlY3RvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfU2VjdG9yLlNlY3RvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdW5idXJzdENoYXJ0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9TdW5idXJzdENoYXJ0LlN1bmJ1cnN0Q2hhcnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3VyZmFjZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfU3VyZmFjZS5TdXJmYWNlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN5bWJvbHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1N5bWJvbHMuU3ltYm9scztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUZXh0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9UZXh0LlRleHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVG9vbHRpcFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfVG9vbHRpcC5Ub29sdGlwO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYXBlem9pZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfVHJhcGV6b2lkLlRyYXBlem9pZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmVlbWFwXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9UcmVlbWFwLlRyZWVtYXA7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWEF4aXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1hBeGlzLlhBeGlzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIllBeGlzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9ZQXhpcy5ZQXhpcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJaQXhpc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfWkF4aXMuWkF4aXM7XG4gIH1cbn0pO1xudmFyIF9TdXJmYWNlID0gcmVxdWlyZShcIi4vY29udGFpbmVyL1N1cmZhY2VcIik7XG52YXIgX0xheWVyID0gcmVxdWlyZShcIi4vY29udGFpbmVyL0xheWVyXCIpO1xudmFyIF9MZWdlbmQgPSByZXF1aXJlKFwiLi9jb21wb25lbnQvTGVnZW5kXCIpO1xudmFyIF9EZWZhdWx0TGVnZW5kQ29udGVudCA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudC9EZWZhdWx0TGVnZW5kQ29udGVudFwiKTtcbnZhciBfVG9vbHRpcCA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudC9Ub29sdGlwXCIpO1xudmFyIF9EZWZhdWx0VG9vbHRpcENvbnRlbnQgPSByZXF1aXJlKFwiLi9jb21wb25lbnQvRGVmYXVsdFRvb2x0aXBDb250ZW50XCIpO1xudmFyIF9SZXNwb25zaXZlQ29udGFpbmVyID0gcmVxdWlyZShcIi4vY29tcG9uZW50L1Jlc3BvbnNpdmVDb250YWluZXJcIik7XG52YXIgX0NlbGwgPSByZXF1aXJlKFwiLi9jb21wb25lbnQvQ2VsbFwiKTtcbnZhciBfVGV4dCA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudC9UZXh0XCIpO1xudmFyIF9MYWJlbCA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudC9MYWJlbFwiKTtcbnZhciBfTGFiZWxMaXN0ID0gcmVxdWlyZShcIi4vY29tcG9uZW50L0xhYmVsTGlzdFwiKTtcbnZhciBfQ3VzdG9taXplZCA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudC9DdXN0b21pemVkXCIpO1xudmFyIF9TZWN0b3IgPSByZXF1aXJlKFwiLi9zaGFwZS9TZWN0b3JcIik7XG52YXIgX0N1cnZlID0gcmVxdWlyZShcIi4vc2hhcGUvQ3VydmVcIik7XG52YXIgX1JlY3RhbmdsZSA9IHJlcXVpcmUoXCIuL3NoYXBlL1JlY3RhbmdsZVwiKTtcbnZhciBfUG9seWdvbiA9IHJlcXVpcmUoXCIuL3NoYXBlL1BvbHlnb25cIik7XG52YXIgX0RvdCA9IHJlcXVpcmUoXCIuL3NoYXBlL0RvdFwiKTtcbnZhciBfQ3Jvc3MgPSByZXF1aXJlKFwiLi9zaGFwZS9Dcm9zc1wiKTtcbnZhciBfU3ltYm9scyA9IHJlcXVpcmUoXCIuL3NoYXBlL1N5bWJvbHNcIik7XG52YXIgX1BvbGFyR3JpZCA9IHJlcXVpcmUoXCIuL3BvbGFyL1BvbGFyR3JpZFwiKTtcbnZhciBfUG9sYXJSYWRpdXNBeGlzID0gcmVxdWlyZShcIi4vcG9sYXIvUG9sYXJSYWRpdXNBeGlzXCIpO1xudmFyIF9Qb2xhckFuZ2xlQXhpcyA9IHJlcXVpcmUoXCIuL3BvbGFyL1BvbGFyQW5nbGVBeGlzXCIpO1xudmFyIF9QaWUgPSByZXF1aXJlKFwiLi9wb2xhci9QaWVcIik7XG52YXIgX1JhZGFyID0gcmVxdWlyZShcIi4vcG9sYXIvUmFkYXJcIik7XG52YXIgX1JhZGlhbEJhciA9IHJlcXVpcmUoXCIuL3BvbGFyL1JhZGlhbEJhclwiKTtcbnZhciBfQnJ1c2ggPSByZXF1aXJlKFwiLi9jYXJ0ZXNpYW4vQnJ1c2hcIik7XG52YXIgX1JlZmVyZW5jZUxpbmUgPSByZXF1aXJlKFwiLi9jYXJ0ZXNpYW4vUmVmZXJlbmNlTGluZVwiKTtcbnZhciBfUmVmZXJlbmNlRG90ID0gcmVxdWlyZShcIi4vY2FydGVzaWFuL1JlZmVyZW5jZURvdFwiKTtcbnZhciBfUmVmZXJlbmNlQXJlYSA9IHJlcXVpcmUoXCIuL2NhcnRlc2lhbi9SZWZlcmVuY2VBcmVhXCIpO1xudmFyIF9DYXJ0ZXNpYW5BeGlzID0gcmVxdWlyZShcIi4vY2FydGVzaWFuL0NhcnRlc2lhbkF4aXNcIik7XG52YXIgX0NhcnRlc2lhbkdyaWQgPSByZXF1aXJlKFwiLi9jYXJ0ZXNpYW4vQ2FydGVzaWFuR3JpZFwiKTtcbnZhciBfTGluZSA9IHJlcXVpcmUoXCIuL2NhcnRlc2lhbi9MaW5lXCIpO1xudmFyIF9BcmVhID0gcmVxdWlyZShcIi4vY2FydGVzaWFuL0FyZWFcIik7XG52YXIgX0JhciA9IHJlcXVpcmUoXCIuL2NhcnRlc2lhbi9CYXJcIik7XG52YXIgX1NjYXR0ZXIgPSByZXF1aXJlKFwiLi9jYXJ0ZXNpYW4vU2NhdHRlclwiKTtcbnZhciBfWEF4aXMgPSByZXF1aXJlKFwiLi9jYXJ0ZXNpYW4vWEF4aXNcIik7XG52YXIgX1lBeGlzID0gcmVxdWlyZShcIi4vY2FydGVzaWFuL1lBeGlzXCIpO1xudmFyIF9aQXhpcyA9IHJlcXVpcmUoXCIuL2NhcnRlc2lhbi9aQXhpc1wiKTtcbnZhciBfRXJyb3JCYXIgPSByZXF1aXJlKFwiLi9jYXJ0ZXNpYW4vRXJyb3JCYXJcIik7XG52YXIgX0xpbmVDaGFydCA9IHJlcXVpcmUoXCIuL2NoYXJ0L0xpbmVDaGFydFwiKTtcbnZhciBfQmFyQ2hhcnQgPSByZXF1aXJlKFwiLi9jaGFydC9CYXJDaGFydFwiKTtcbnZhciBfUGllQ2hhcnQgPSByZXF1aXJlKFwiLi9jaGFydC9QaWVDaGFydFwiKTtcbnZhciBfVHJlZW1hcCA9IHJlcXVpcmUoXCIuL2NoYXJ0L1RyZWVtYXBcIik7XG52YXIgX1NhbmtleSA9IHJlcXVpcmUoXCIuL2NoYXJ0L1NhbmtleVwiKTtcbnZhciBfUmFkYXJDaGFydCA9IHJlcXVpcmUoXCIuL2NoYXJ0L1JhZGFyQ2hhcnRcIik7XG52YXIgX1NjYXR0ZXJDaGFydCA9IHJlcXVpcmUoXCIuL2NoYXJ0L1NjYXR0ZXJDaGFydFwiKTtcbnZhciBfQXJlYUNoYXJ0ID0gcmVxdWlyZShcIi4vY2hhcnQvQXJlYUNoYXJ0XCIpO1xudmFyIF9SYWRpYWxCYXJDaGFydCA9IHJlcXVpcmUoXCIuL2NoYXJ0L1JhZGlhbEJhckNoYXJ0XCIpO1xudmFyIF9Db21wb3NlZENoYXJ0ID0gcmVxdWlyZShcIi4vY2hhcnQvQ29tcG9zZWRDaGFydFwiKTtcbnZhciBfU3VuYnVyc3RDaGFydCA9IHJlcXVpcmUoXCIuL2NoYXJ0L1N1bmJ1cnN0Q2hhcnRcIik7XG52YXIgX0Z1bm5lbCA9IHJlcXVpcmUoXCIuL251bWJlckF4aXMvRnVubmVsXCIpO1xudmFyIF9GdW5uZWxDaGFydCA9IHJlcXVpcmUoXCIuL2NoYXJ0L0Z1bm5lbENoYXJ0XCIpO1xudmFyIF9UcmFwZXpvaWQgPSByZXF1aXJlKFwiLi9zaGFwZS9UcmFwZXpvaWRcIik7XG52YXIgX0dsb2JhbCA9IHJlcXVpcmUoXCIuL3V0aWwvR2xvYmFsXCIpOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfQXJlYSIsIkFyZWEiLCJfQXJlYUNoYXJ0IiwiQXJlYUNoYXJ0IiwiX0JhciIsIkJhciIsIl9CYXJDaGFydCIsIkJhckNoYXJ0IiwiX0JydXNoIiwiQnJ1c2giLCJfQ2FydGVzaWFuQXhpcyIsIkNhcnRlc2lhbkF4aXMiLCJfQ2FydGVzaWFuR3JpZCIsIkNhcnRlc2lhbkdyaWQiLCJfQ2VsbCIsIkNlbGwiLCJfQ29tcG9zZWRDaGFydCIsIkNvbXBvc2VkQ2hhcnQiLCJfQ3Jvc3MiLCJDcm9zcyIsIl9DdXJ2ZSIsIkN1cnZlIiwiX0N1c3RvbWl6ZWQiLCJDdXN0b21pemVkIiwiX0RlZmF1bHRMZWdlbmRDb250ZW50IiwiRGVmYXVsdExlZ2VuZENvbnRlbnQiLCJfRGVmYXVsdFRvb2x0aXBDb250ZW50IiwiRGVmYXVsdFRvb2x0aXBDb250ZW50IiwiX0RvdCIsIkRvdCIsIl9FcnJvckJhciIsIkVycm9yQmFyIiwiX0Z1bm5lbCIsIkZ1bm5lbCIsIl9GdW5uZWxDaGFydCIsIkZ1bm5lbENoYXJ0IiwiX0dsb2JhbCIsIkdsb2JhbCIsIl9MYWJlbCIsIkxhYmVsIiwiX0xhYmVsTGlzdCIsIkxhYmVsTGlzdCIsIl9MYXllciIsIkxheWVyIiwiX0xlZ2VuZCIsIkxlZ2VuZCIsIl9MaW5lIiwiTGluZSIsIl9MaW5lQ2hhcnQiLCJMaW5lQ2hhcnQiLCJfUGllIiwiUGllIiwiX1BpZUNoYXJ0IiwiUGllQ2hhcnQiLCJfUG9sYXJBbmdsZUF4aXMiLCJQb2xhckFuZ2xlQXhpcyIsIl9Qb2xhckdyaWQiLCJQb2xhckdyaWQiLCJfUG9sYXJSYWRpdXNBeGlzIiwiUG9sYXJSYWRpdXNBeGlzIiwiX1BvbHlnb24iLCJQb2x5Z29uIiwiX1JhZGFyIiwiUmFkYXIiLCJfUmFkYXJDaGFydCIsIlJhZGFyQ2hhcnQiLCJfUmFkaWFsQmFyIiwiUmFkaWFsQmFyIiwiX1JhZGlhbEJhckNoYXJ0IiwiUmFkaWFsQmFyQ2hhcnQiLCJfUmVjdGFuZ2xlIiwiUmVjdGFuZ2xlIiwiX1JlZmVyZW5jZUFyZWEiLCJSZWZlcmVuY2VBcmVhIiwiX1JlZmVyZW5jZURvdCIsIlJlZmVyZW5jZURvdCIsIl9SZWZlcmVuY2VMaW5lIiwiUmVmZXJlbmNlTGluZSIsIl9SZXNwb25zaXZlQ29udGFpbmVyIiwiUmVzcG9uc2l2ZUNvbnRhaW5lciIsIl9TYW5rZXkiLCJTYW5rZXkiLCJfU2NhdHRlciIsIlNjYXR0ZXIiLCJfU2NhdHRlckNoYXJ0IiwiU2NhdHRlckNoYXJ0IiwiX1NlY3RvciIsIlNlY3RvciIsIl9TdW5idXJzdENoYXJ0IiwiU3VuYnVyc3RDaGFydCIsIl9TdXJmYWNlIiwiU3VyZmFjZSIsIl9TeW1ib2xzIiwiU3ltYm9scyIsIl9UZXh0IiwiVGV4dCIsIl9Ub29sdGlwIiwiVG9vbHRpcCIsIl9UcmFwZXpvaWQiLCJUcmFwZXpvaWQiLCJfVHJlZW1hcCIsIlRyZWVtYXAiLCJfWEF4aXMiLCJYQXhpcyIsIl9ZQXhpcyIsIllBeGlzIiwiX1pBeGlzIiwiWkF4aXMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/index.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/numberAxis/Funnel.js":
/*!********************************************************!*\
  !*** ./node_modules/recharts/lib/numberAxis/Funnel.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Funnel = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _isNumber = _interopRequireDefault(__webpack_require__(/*! lodash/isNumber */ \"lodash/isNumber\"));\nvar _isString = _interopRequireDefault(__webpack_require__(/*! lodash/isString */ \"lodash/isString\"));\nvar _omit = _interopRequireDefault(__webpack_require__(/*! lodash/omit */ \"lodash/omit\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"./node_modules/recharts/lib/component/LabelList.js\");\nvar _Cell = __webpack_require__(/*! ../component/Cell */ \"./node_modules/recharts/lib/component/Cell.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"./node_modules/recharts/lib/util/Global.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"./node_modules/recharts/lib/util/types.js\");\nvar _FunnelUtils = __webpack_require__(/*! ../util/FunnelUtils */ \"./node_modules/recharts/lib/util/FunnelUtils.js\");\nvar _Funnel;\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Render sectors of a funnel\n */ \nvar Funnel = exports.Funnel = /*#__PURE__*/ function(_PureComponent) {\n    function Funnel() {\n        var _this;\n        _classCallCheck(this, Funnel);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Funnel, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            isAnimationFinished: false\n        });\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            var onAnimationEnd = _this.props.onAnimationEnd;\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationEnd)) {\n                onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            var onAnimationStart = _this.props.onAnimationStart;\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationStart)) {\n                onAnimationStart();\n            }\n        });\n        return _this;\n    }\n    _inherits(Funnel, _PureComponent);\n    return _createClass(Funnel, [\n        {\n            key: \"isActiveIndex\",\n            value: function isActiveIndex(i) {\n                var activeIndex = this.props.activeIndex;\n                if (Array.isArray(activeIndex)) {\n                    return activeIndex.indexOf(i) !== -1;\n                }\n                return i === activeIndex;\n            }\n        },\n        {\n            key: \"renderTrapezoidsStatically\",\n            value: function renderTrapezoidsStatically(trapezoids) {\n                var _this2 = this;\n                var _this$props = this.props, shape = _this$props.shape, activeShape = _this$props.activeShape;\n                return trapezoids.map(function(entry, i) {\n                    var trapezoidOptions = _this2.isActiveIndex(i) ? activeShape : shape;\n                    var trapezoidProps = _objectSpread(_objectSpread({}, entry), {}, {\n                        isActive: _this2.isActiveIndex(i),\n                        stroke: entry.stroke\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        className: \"recharts-funnel-trapezoid\"\n                    }, (0, _types.adaptEventsOfChild)(_this2.props, entry, i), {\n                        key: \"trapezoid-\".concat(entry === null || entry === void 0 ? void 0 : entry.x, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.y, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.name, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.value),\n                        role: \"img\"\n                    }), /*#__PURE__*/ _react[\"default\"].createElement(_FunnelUtils.FunnelTrapezoid, _extends({\n                        option: trapezoidOptions\n                    }, trapezoidProps)));\n                });\n            }\n        },\n        {\n            key: \"renderTrapezoidsWithAnimation\",\n            value: function renderTrapezoidsWithAnimation() {\n                var _this3 = this;\n                var _this$props2 = this.props, trapezoids = _this$props2.trapezoids, isAnimationActive = _this$props2.isAnimationActive, animationBegin = _this$props2.animationBegin, animationDuration = _this$props2.animationDuration, animationEasing = _this$props2.animationEasing, animationId = _this$props2.animationId;\n                var prevTrapezoids = this.state.prevTrapezoids;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"funnel-\".concat(animationId),\n                    onAnimationStart: this.handleAnimationStart,\n                    onAnimationEnd: this.handleAnimationEnd\n                }, function(_ref) {\n                    var t = _ref.t;\n                    var stepData = trapezoids.map(function(entry, index) {\n                        var prev = prevTrapezoids && prevTrapezoids[index];\n                        if (prev) {\n                            var _interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry.x);\n                            var _interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry.y);\n                            var _interpolatorUpperWidth = (0, _DataUtils.interpolateNumber)(prev.upperWidth, entry.upperWidth);\n                            var _interpolatorLowerWidth = (0, _DataUtils.interpolateNumber)(prev.lowerWidth, entry.lowerWidth);\n                            var _interpolatorHeight = (0, _DataUtils.interpolateNumber)(prev.height, entry.height);\n                            return _objectSpread(_objectSpread({}, entry), {}, {\n                                x: _interpolatorX(t),\n                                y: _interpolatorY(t),\n                                upperWidth: _interpolatorUpperWidth(t),\n                                lowerWidth: _interpolatorLowerWidth(t),\n                                height: _interpolatorHeight(t)\n                            });\n                        }\n                        var interpolatorX = (0, _DataUtils.interpolateNumber)(entry.x + entry.upperWidth / 2, entry.x);\n                        var interpolatorY = (0, _DataUtils.interpolateNumber)(entry.y + entry.height / 2, entry.y);\n                        var interpolatorUpperWidth = (0, _DataUtils.interpolateNumber)(0, entry.upperWidth);\n                        var interpolatorLowerWidth = (0, _DataUtils.interpolateNumber)(0, entry.lowerWidth);\n                        var interpolatorHeight = (0, _DataUtils.interpolateNumber)(0, entry.height);\n                        return _objectSpread(_objectSpread({}, entry), {}, {\n                            x: interpolatorX(t),\n                            y: interpolatorY(t),\n                            upperWidth: interpolatorUpperWidth(t),\n                            lowerWidth: interpolatorLowerWidth(t),\n                            height: interpolatorHeight(t)\n                        });\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, null, _this3.renderTrapezoidsStatically(stepData));\n                });\n            }\n        },\n        {\n            key: \"renderTrapezoids\",\n            value: function renderTrapezoids() {\n                var _this$props3 = this.props, trapezoids = _this$props3.trapezoids, isAnimationActive = _this$props3.isAnimationActive;\n                var prevTrapezoids = this.state.prevTrapezoids;\n                if (isAnimationActive && trapezoids && trapezoids.length && (!prevTrapezoids || !(0, _isEqual[\"default\"])(prevTrapezoids, trapezoids))) {\n                    return this.renderTrapezoidsWithAnimation();\n                }\n                return this.renderTrapezoidsStatically(trapezoids);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props4 = this.props, hide = _this$props4.hide, trapezoids = _this$props4.trapezoids, className = _this$props4.className, isAnimationActive = _this$props4.isAnimationActive;\n                var isAnimationFinished = this.state.isAnimationFinished;\n                if (hide || !trapezoids || !trapezoids.length) {\n                    return null;\n                }\n                var layerClass = (0, _clsx[\"default\"])(\"recharts-trapezoids\", className);\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass\n                }, this.renderTrapezoids(), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, trapezoids));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curTrapezoids: nextProps.trapezoids,\n                        prevTrapezoids: prevState.curTrapezoids\n                    };\n                }\n                if (nextProps.trapezoids !== prevState.curTrapezoids) {\n                    return {\n                        curTrapezoids: nextProps.trapezoids\n                    };\n                }\n                return null;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_Funnel = Funnel;\n_defineProperty(Funnel, \"displayName\", \"Funnel\");\n_defineProperty(Funnel, \"defaultProps\", {\n    stroke: \"#fff\",\n    fill: \"#808080\",\n    legendType: \"rect\",\n    labelLine: true,\n    hide: false,\n    isAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 400,\n    animationDuration: 1500,\n    animationEasing: \"ease\",\n    nameKey: \"name\",\n    lastShapeType: \"triangle\"\n});\n_defineProperty(Funnel, \"getRealFunnelData\", function(item) {\n    var _item$props = item.props, data = _item$props.data, children = _item$props.children;\n    var presentationProps = (0, _ReactUtils.filterProps)(item.props, false);\n    var cells = (0, _ReactUtils.findAllByType)(children, _Cell.Cell);\n    if (data && data.length) {\n        return data.map(function(entry, index) {\n            return _objectSpread(_objectSpread(_objectSpread({\n                payload: entry\n            }, presentationProps), entry), cells && cells[index] && cells[index].props);\n        });\n    }\n    if (cells && cells.length) {\n        return cells.map(function(cell) {\n            return _objectSpread(_objectSpread({}, presentationProps), cell.props);\n        });\n    }\n    return [];\n});\n_defineProperty(Funnel, \"getRealWidthHeight\", function(item, offset) {\n    var customWidth = item.props.width;\n    var width = offset.width, height = offset.height, left = offset.left, right = offset.right, top = offset.top, bottom = offset.bottom;\n    var realHeight = height;\n    var realWidth = width;\n    if ((0, _isNumber[\"default\"])(customWidth)) {\n        realWidth = customWidth;\n    } else if ((0, _isString[\"default\"])(customWidth)) {\n        realWidth = realWidth * parseFloat(customWidth) / 100;\n    }\n    return {\n        realWidth: realWidth - left - right - 50,\n        realHeight: realHeight - bottom - top,\n        offsetX: (width - realWidth) / 2,\n        offsetY: (height - realHeight) / 2\n    };\n});\n_defineProperty(Funnel, \"getComposedData\", function(_ref2) {\n    var item = _ref2.item, offset = _ref2.offset;\n    var funnelData = _Funnel.getRealFunnelData(item);\n    var _item$props2 = item.props, dataKey = _item$props2.dataKey, nameKey = _item$props2.nameKey, tooltipType = _item$props2.tooltipType, lastShapeType = _item$props2.lastShapeType, reversed = _item$props2.reversed;\n    var left = offset.left, top = offset.top;\n    var _Funnel$getRealWidthH = _Funnel.getRealWidthHeight(item, offset), realHeight = _Funnel$getRealWidthH.realHeight, realWidth = _Funnel$getRealWidthH.realWidth, offsetX = _Funnel$getRealWidthH.offsetX, offsetY = _Funnel$getRealWidthH.offsetY;\n    var maxValue = Math.max.apply(null, funnelData.map(function(entry) {\n        return (0, _ChartUtils.getValueByDataKey)(entry, dataKey, 0);\n    }));\n    var len = funnelData.length;\n    var rowHeight = realHeight / len;\n    var parentViewBox = {\n        x: offset.left,\n        y: offset.top,\n        width: offset.width,\n        height: offset.height\n    };\n    var trapezoids = funnelData.map(function(entry, i) {\n        var rawVal = (0, _ChartUtils.getValueByDataKey)(entry, dataKey, 0);\n        var name = (0, _ChartUtils.getValueByDataKey)(entry, nameKey, i);\n        var val = rawVal;\n        var nextVal;\n        if (i !== len - 1) {\n            nextVal = (0, _ChartUtils.getValueByDataKey)(funnelData[i + 1], dataKey, 0);\n            if (nextVal instanceof Array) {\n                var _nextVal = nextVal;\n                var _nextVal2 = _slicedToArray(_nextVal, 1);\n                nextVal = _nextVal2[0];\n            }\n        } else if (rawVal instanceof Array && rawVal.length === 2) {\n            var _rawVal = _slicedToArray(rawVal, 2);\n            val = _rawVal[0];\n            nextVal = _rawVal[1];\n        } else if (lastShapeType === \"rectangle\") {\n            nextVal = val;\n        } else {\n            nextVal = 0;\n        }\n        var x = (maxValue - val) * realWidth / (2 * maxValue) + top + 25 + offsetX;\n        var y = rowHeight * i + left + offsetY;\n        var upperWidth = val / maxValue * realWidth;\n        var lowerWidth = nextVal / maxValue * realWidth;\n        var tooltipPayload = [\n            {\n                name: name,\n                value: val,\n                payload: entry,\n                dataKey: dataKey,\n                type: tooltipType\n            }\n        ];\n        var tooltipPosition = {\n            x: x + upperWidth / 2,\n            y: y + rowHeight / 2\n        };\n        return _objectSpread(_objectSpread({\n            x: x,\n            y: y,\n            width: Math.max(upperWidth, lowerWidth),\n            upperWidth: upperWidth,\n            lowerWidth: lowerWidth,\n            height: rowHeight,\n            name: name,\n            val: val,\n            tooltipPayload: tooltipPayload,\n            tooltipPosition: tooltipPosition\n        }, (0, _omit[\"default\"])(entry, \"width\")), {}, {\n            payload: entry,\n            parentViewBox: parentViewBox,\n            labelViewBox: {\n                x: x + (upperWidth - lowerWidth) / 4,\n                y: y,\n                width: Math.abs(upperWidth - lowerWidth) / 2 + Math.min(upperWidth, lowerWidth),\n                height: rowHeight\n            }\n        });\n    });\n    if (reversed) {\n        trapezoids = trapezoids.map(function(entry, index) {\n            var newY = entry.y - index * rowHeight + (len - 1 - index) * rowHeight;\n            return _objectSpread(_objectSpread({}, entry), {}, {\n                upperWidth: entry.lowerWidth,\n                lowerWidth: entry.upperWidth,\n                x: entry.x - (entry.lowerWidth - entry.upperWidth) / 2,\n                y: entry.y - index * rowHeight + (len - 1 - index) * rowHeight,\n                tooltipPosition: _objectSpread(_objectSpread({}, entry.tooltipPosition), {}, {\n                    y: newY + rowHeight / 2\n                }),\n                labelViewBox: _objectSpread(_objectSpread({}, entry.labelViewBox), {}, {\n                    y: newY\n                })\n            });\n        });\n    }\n    return {\n        trapezoids: trapezoids,\n        data: funnelData\n    };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL251bWJlckF4aXMvRnVubmVsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxjQUFjLEdBQUcsS0FBSztBQUN0QixJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLGVBQWVDLHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDaEUsSUFBSUcsY0FBY0QsdUJBQXVCRixtQkFBT0EsQ0FBQyw0Q0FBbUI7QUFDcEUsSUFBSUksWUFBWUYsdUJBQXVCRixtQkFBT0EsQ0FBQyx3Q0FBaUI7QUFDaEUsSUFBSUssWUFBWUgsdUJBQXVCRixtQkFBT0EsQ0FBQyx3Q0FBaUI7QUFDaEUsSUFBSU0sUUFBUUosdUJBQXVCRixtQkFBT0EsQ0FBQyxnQ0FBYTtBQUN4RCxJQUFJTyxXQUFXTCx1QkFBdUJGLG1CQUFPQSxDQUFDLHNDQUFnQjtBQUM5RCxJQUFJUSxRQUFRTix1QkFBdUJGLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlTLFNBQVNULG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJVSxhQUFhVixtQkFBT0EsQ0FBQyxrRkFBd0I7QUFDakQsSUFBSVcsUUFBUVgsbUJBQU9BLENBQUMsd0VBQW1CO0FBQ3ZDLElBQUlZLGNBQWNaLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJYSxVQUFVYixtQkFBT0EsQ0FBQyxrRUFBZ0I7QUFDdEMsSUFBSWMsYUFBYWQsbUJBQU9BLENBQUMsd0VBQW1CO0FBQzVDLElBQUllLGNBQWNmLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJZ0IsU0FBU2hCLG1CQUFPQSxDQUFDLGdFQUFlO0FBQ3BDLElBQUlpQixlQUFlakIsbUJBQU9BLENBQUMsNEVBQXFCO0FBQ2hELElBQUlrQjtBQUNKLFNBQVNoQix1QkFBdUJpQixHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFB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QUFDLEdBQUdzQixRQUFReUUsWUFBWSxDQUFDN0wsTUFBTSxJQUFJb0gsS0FBSSxJQUFLeUU7Z0JBQ3JEVSxpQkFBaUIvSyxjQUFjQSxjQUFjLENBQUMsR0FBRzRELE1BQU1tSCxlQUFlLEdBQUcsQ0FBQyxHQUFHO29CQUMzRXpHLEdBQUc2RyxPQUFPZCxZQUFZO2dCQUN4QjtnQkFDQVcsY0FBY2hMLGNBQWNBLGNBQWMsQ0FBQyxHQUFHNEQsTUFBTW9ILFlBQVksR0FBRyxDQUFDLEdBQUc7b0JBQ3JFMUcsR0FBRzZHO2dCQUNMO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBTztRQUNMN0gsWUFBWUE7UUFDWjZFLE1BQU1zQjtJQUNSO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL251bWJlckF4aXMvRnVubmVsLmpzPzQyNjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkZ1bm5lbCA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yZWFjdFNtb290aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LXNtb290aFwiKSk7XG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XG52YXIgX2lzTnVtYmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzTnVtYmVyXCIpKTtcbnZhciBfaXNTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNTdHJpbmdcIikpO1xudmFyIF9vbWl0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL29taXRcIikpO1xudmFyIF9pc0VxdWFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRXF1YWxcIikpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX0xheWVyID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9MYXllclwiKTtcbnZhciBfTGFiZWxMaXN0ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbExpc3RcIik7XG52YXIgX0NlbGwgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L0NlbGxcIik7XG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xudmFyIF9HbG9iYWwgPSByZXF1aXJlKFwiLi4vdXRpbC9HbG9iYWxcIik7XG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4uL3V0aWwvdHlwZXNcIik7XG52YXIgX0Z1bm5lbFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRnVubmVsVXRpbHNcIik7XG52YXIgX0Z1bm5lbDtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxuICogQGZpbGVPdmVydmlldyBSZW5kZXIgc2VjdG9ycyBvZiBhIGZ1bm5lbFxuICovXG52YXIgRnVubmVsID0gZXhwb3J0cy5GdW5uZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIEZ1bm5lbCgpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bm5lbCk7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgRnVubmVsLCBbXS5jb25jYXQoYXJncykpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiBmYWxzZVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25FbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9uQW5pbWF0aW9uRW5kID0gX3RoaXMucHJvcHMub25BbmltYXRpb25FbmQ7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9uQW5pbWF0aW9uRW5kKSkge1xuICAgICAgICBvbkFuaW1hdGlvbkVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25TdGFydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb25BbmltYXRpb25TdGFydCA9IF90aGlzLnByb3BzLm9uQW5pbWF0aW9uU3RhcnQ7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvbkFuaW1hdGlvblN0YXJ0KSkge1xuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhGdW5uZWwsIF9QdXJlQ29tcG9uZW50KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhGdW5uZWwsIFt7XG4gICAga2V5OiBcImlzQWN0aXZlSW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNBY3RpdmVJbmRleChpKSB7XG4gICAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLnByb3BzLmFjdGl2ZUluZGV4O1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWN0aXZlSW5kZXgpKSB7XG4gICAgICAgIHJldHVybiBhY3RpdmVJbmRleC5pbmRleE9mKGkpICE9PSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpID09PSBhY3RpdmVJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyVHJhcGV6b2lkc1N0YXRpY2FsbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVHJhcGV6b2lkc1N0YXRpY2FsbHkodHJhcGV6b2lkcykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBzaGFwZSA9IF90aGlzJHByb3BzLnNoYXBlLFxuICAgICAgICBhY3RpdmVTaGFwZSA9IF90aGlzJHByb3BzLmFjdGl2ZVNoYXBlO1xuICAgICAgcmV0dXJuIHRyYXBlem9pZHMubWFwKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xuICAgICAgICB2YXIgdHJhcGV6b2lkT3B0aW9ucyA9IF90aGlzMi5pc0FjdGl2ZUluZGV4KGkpID8gYWN0aXZlU2hhcGUgOiBzaGFwZTtcbiAgICAgICAgdmFyIHRyYXBlem9pZFByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XG4gICAgICAgICAgaXNBY3RpdmU6IF90aGlzMi5pc0FjdGl2ZUluZGV4KGkpLFxuICAgICAgICAgIHN0cm9rZTogZW50cnkuc3Ryb2tlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIF9leHRlbmRzKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtZnVubmVsLXRyYXBlem9pZFwiXG4gICAgICAgIH0sICgwLCBfdHlwZXMuYWRhcHRFdmVudHNPZkNoaWxkKShfdGhpczIucHJvcHMsIGVudHJ5LCBpKSwge1xuICAgICAgICAgIGtleTogXCJ0cmFwZXpvaWQtXCIuY29uY2F0KGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS54LCBcIi1cIikuY29uY2F0KGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS55LCBcIi1cIikuY29uY2F0KGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS5uYW1lLCBcIi1cIikuY29uY2F0KGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS52YWx1ZSksXG4gICAgICAgICAgcm9sZTogXCJpbWdcIlxuICAgICAgICB9KSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfRnVubmVsVXRpbHMuRnVubmVsVHJhcGV6b2lkLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgb3B0aW9uOiB0cmFwZXpvaWRPcHRpb25zXG4gICAgICAgIH0sIHRyYXBlem9pZFByb3BzKSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclRyYXBlem9pZHNXaXRoQW5pbWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRyYXBlem9pZHNXaXRoQW5pbWF0aW9uKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgdHJhcGV6b2lkcyA9IF90aGlzJHByb3BzMi50cmFwZXpvaWRzLFxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzMi5pc0FuaW1hdGlvbkFjdGl2ZSxcbiAgICAgICAgYW5pbWF0aW9uQmVnaW4gPSBfdGhpcyRwcm9wczIuYW5pbWF0aW9uQmVnaW4sXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uID0gX3RoaXMkcHJvcHMyLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICBhbmltYXRpb25FYXNpbmcgPSBfdGhpcyRwcm9wczIuYW5pbWF0aW9uRWFzaW5nLFxuICAgICAgICBhbmltYXRpb25JZCA9IF90aGlzJHByb3BzMi5hbmltYXRpb25JZDtcbiAgICAgIHZhciBwcmV2VHJhcGV6b2lkcyA9IHRoaXMuc3RhdGUucHJldlRyYXBlem9pZHM7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfcmVhY3RTbW9vdGhbXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgIGJlZ2luOiBhbmltYXRpb25CZWdpbixcbiAgICAgICAgZHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICBpc0FjdGl2ZTogaXNBbmltYXRpb25BY3RpdmUsXG4gICAgICAgIGVhc2luZzogYW5pbWF0aW9uRWFzaW5nLFxuICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgdDogMFxuICAgICAgICB9LFxuICAgICAgICB0bzoge1xuICAgICAgICAgIHQ6IDFcbiAgICAgICAgfSxcbiAgICAgICAga2V5OiBcImZ1bm5lbC1cIi5jb25jYXQoYW5pbWF0aW9uSWQpLFxuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0OiB0aGlzLmhhbmRsZUFuaW1hdGlvblN0YXJ0LFxuICAgICAgICBvbkFuaW1hdGlvbkVuZDogdGhpcy5oYW5kbGVBbmltYXRpb25FbmRcbiAgICAgIH0sIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciB0ID0gX3JlZi50O1xuICAgICAgICB2YXIgc3RlcERhdGEgPSB0cmFwZXpvaWRzLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XG4gICAgICAgICAgdmFyIHByZXYgPSBwcmV2VHJhcGV6b2lkcyAmJiBwcmV2VHJhcGV6b2lkc1tpbmRleF07XG4gICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIHZhciBfaW50ZXJwb2xhdG9yWCA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2LngsIGVudHJ5LngpO1xuICAgICAgICAgICAgdmFyIF9pbnRlcnBvbGF0b3JZID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXYueSwgZW50cnkueSk7XG4gICAgICAgICAgICB2YXIgX2ludGVycG9sYXRvclVwcGVyV2lkdGggPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi51cHBlcldpZHRoLCBlbnRyeS51cHBlcldpZHRoKTtcbiAgICAgICAgICAgIHZhciBfaW50ZXJwb2xhdG9yTG93ZXJXaWR0aCA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2Lmxvd2VyV2lkdGgsIGVudHJ5Lmxvd2VyV2lkdGgpO1xuICAgICAgICAgICAgdmFyIF9pbnRlcnBvbGF0b3JIZWlnaHQgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi5oZWlnaHQsIGVudHJ5LmhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XG4gICAgICAgICAgICAgIHg6IF9pbnRlcnBvbGF0b3JYKHQpLFxuICAgICAgICAgICAgICB5OiBfaW50ZXJwb2xhdG9yWSh0KSxcbiAgICAgICAgICAgICAgdXBwZXJXaWR0aDogX2ludGVycG9sYXRvclVwcGVyV2lkdGgodCksXG4gICAgICAgICAgICAgIGxvd2VyV2lkdGg6IF9pbnRlcnBvbGF0b3JMb3dlcldpZHRoKHQpLFxuICAgICAgICAgICAgICBoZWlnaHQ6IF9pbnRlcnBvbGF0b3JIZWlnaHQodClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yWCA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShlbnRyeS54ICsgZW50cnkudXBwZXJXaWR0aCAvIDIsIGVudHJ5LngpO1xuICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JZID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKGVudHJ5LnkgKyBlbnRyeS5oZWlnaHQgLyAyLCBlbnRyeS55KTtcbiAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yVXBwZXJXaWR0aCA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKSgwLCBlbnRyeS51cHBlcldpZHRoKTtcbiAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yTG93ZXJXaWR0aCA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKSgwLCBlbnRyeS5sb3dlcldpZHRoKTtcbiAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9ySGVpZ2h0ID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKDAsIGVudHJ5LmhlaWdodCk7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xuICAgICAgICAgICAgeDogaW50ZXJwb2xhdG9yWCh0KSxcbiAgICAgICAgICAgIHk6IGludGVycG9sYXRvclkodCksXG4gICAgICAgICAgICB1cHBlcldpZHRoOiBpbnRlcnBvbGF0b3JVcHBlcldpZHRoKHQpLFxuICAgICAgICAgICAgbG93ZXJXaWR0aDogaW50ZXJwb2xhdG9yTG93ZXJXaWR0aCh0KSxcbiAgICAgICAgICAgIGhlaWdodDogaW50ZXJwb2xhdG9ySGVpZ2h0KHQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIG51bGwsIF90aGlzMy5yZW5kZXJUcmFwZXpvaWRzU3RhdGljYWxseShzdGVwRGF0YSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclRyYXBlem9pZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVHJhcGV6b2lkcygpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICB0cmFwZXpvaWRzID0gX3RoaXMkcHJvcHMzLnRyYXBlem9pZHMsXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHMzLmlzQW5pbWF0aW9uQWN0aXZlO1xuICAgICAgdmFyIHByZXZUcmFwZXpvaWRzID0gdGhpcy5zdGF0ZS5wcmV2VHJhcGV6b2lkcztcbiAgICAgIGlmIChpc0FuaW1hdGlvbkFjdGl2ZSAmJiB0cmFwZXpvaWRzICYmIHRyYXBlem9pZHMubGVuZ3RoICYmICghcHJldlRyYXBlem9pZHMgfHwgISgwLCBfaXNFcXVhbFtcImRlZmF1bHRcIl0pKHByZXZUcmFwZXpvaWRzLCB0cmFwZXpvaWRzKSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVHJhcGV6b2lkc1dpdGhBbmltYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclRyYXBlem9pZHNTdGF0aWNhbGx5KHRyYXBlem9pZHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgIGhpZGUgPSBfdGhpcyRwcm9wczQuaGlkZSxcbiAgICAgICAgdHJhcGV6b2lkcyA9IF90aGlzJHByb3BzNC50cmFwZXpvaWRzLFxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczQuY2xhc3NOYW1lLFxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzNC5pc0FuaW1hdGlvbkFjdGl2ZTtcbiAgICAgIHZhciBpc0FuaW1hdGlvbkZpbmlzaGVkID0gdGhpcy5zdGF0ZS5pc0FuaW1hdGlvbkZpbmlzaGVkO1xuICAgICAgaWYgKGhpZGUgfHwgIXRyYXBlem9pZHMgfHwgIXRyYXBlem9pZHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGxheWVyQ2xhc3MgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtdHJhcGV6b2lkcycsIGNsYXNzTmFtZSk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBsYXllckNsYXNzXG4gICAgICB9LCB0aGlzLnJlbmRlclRyYXBlem9pZHMoKSwgKCFpc0FuaW1hdGlvbkFjdGl2ZSB8fCBpc0FuaW1hdGlvbkZpbmlzaGVkKSAmJiBfTGFiZWxMaXN0LkxhYmVsTGlzdC5yZW5kZXJDYWxsQnlQYXJlbnQodGhpcy5wcm9wcywgdHJhcGV6b2lkcykpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuYW5pbWF0aW9uSWQgIT09IHByZXZTdGF0ZS5wcmV2QW5pbWF0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcmV2QW5pbWF0aW9uSWQ6IG5leHRQcm9wcy5hbmltYXRpb25JZCxcbiAgICAgICAgICBjdXJUcmFwZXpvaWRzOiBuZXh0UHJvcHMudHJhcGV6b2lkcyxcbiAgICAgICAgICBwcmV2VHJhcGV6b2lkczogcHJldlN0YXRlLmN1clRyYXBlem9pZHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0UHJvcHMudHJhcGV6b2lkcyAhPT0gcHJldlN0YXRlLmN1clRyYXBlem9pZHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjdXJUcmFwZXpvaWRzOiBuZXh0UHJvcHMudHJhcGV6b2lkc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XSk7XG59KF9yZWFjdC5QdXJlQ29tcG9uZW50KTtcbl9GdW5uZWwgPSBGdW5uZWw7XG5fZGVmaW5lUHJvcGVydHkoRnVubmVsLCBcImRpc3BsYXlOYW1lXCIsICdGdW5uZWwnKTtcbl9kZWZpbmVQcm9wZXJ0eShGdW5uZWwsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgc3Ryb2tlOiAnI2ZmZicsXG4gIGZpbGw6ICcjODA4MDgwJyxcbiAgbGVnZW5kVHlwZTogJ3JlY3QnLFxuICBsYWJlbExpbmU6IHRydWUsXG4gIGhpZGU6IGZhbHNlLFxuICBpc0FuaW1hdGlvbkFjdGl2ZTogIV9HbG9iYWwuR2xvYmFsLmlzU3NyLFxuICBhbmltYXRpb25CZWdpbjogNDAwLFxuICBhbmltYXRpb25EdXJhdGlvbjogMTUwMCxcbiAgYW5pbWF0aW9uRWFzaW5nOiAnZWFzZScsXG4gIG5hbWVLZXk6ICduYW1lJyxcbiAgbGFzdFNoYXBlVHlwZTogJ3RyaWFuZ2xlJ1xufSk7XG5fZGVmaW5lUHJvcGVydHkoRnVubmVsLCBcImdldFJlYWxGdW5uZWxEYXRhXCIsIGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBfaXRlbSRwcm9wcyA9IGl0ZW0ucHJvcHMsXG4gICAgZGF0YSA9IF9pdGVtJHByb3BzLmRhdGEsXG4gICAgY2hpbGRyZW4gPSBfaXRlbSRwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIHByZXNlbnRhdGlvblByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShpdGVtLnByb3BzLCBmYWxzZSk7XG4gIHZhciBjZWxscyA9ICgwLCBfUmVhY3RVdGlscy5maW5kQWxsQnlUeXBlKShjaGlsZHJlbiwgX0NlbGwuQ2VsbCk7XG4gIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGRhdGEubWFwKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIHBheWxvYWQ6IGVudHJ5XG4gICAgICB9LCBwcmVzZW50YXRpb25Qcm9wcyksIGVudHJ5KSwgY2VsbHMgJiYgY2VsbHNbaW5kZXhdICYmIGNlbGxzW2luZGV4XS5wcm9wcyk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGNlbGxzICYmIGNlbGxzLmxlbmd0aCkge1xuICAgIHJldHVybiBjZWxscy5tYXAoZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByZXNlbnRhdGlvblByb3BzKSwgY2VsbC5wcm9wcyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFtdO1xufSk7XG5fZGVmaW5lUHJvcGVydHkoRnVubmVsLCBcImdldFJlYWxXaWR0aEhlaWdodFwiLCBmdW5jdGlvbiAoaXRlbSwgb2Zmc2V0KSB7XG4gIHZhciBjdXN0b21XaWR0aCA9IGl0ZW0ucHJvcHMud2lkdGg7XG4gIHZhciB3aWR0aCA9IG9mZnNldC53aWR0aCxcbiAgICBoZWlnaHQgPSBvZmZzZXQuaGVpZ2h0LFxuICAgIGxlZnQgPSBvZmZzZXQubGVmdCxcbiAgICByaWdodCA9IG9mZnNldC5yaWdodCxcbiAgICB0b3AgPSBvZmZzZXQudG9wLFxuICAgIGJvdHRvbSA9IG9mZnNldC5ib3R0b207XG4gIHZhciByZWFsSGVpZ2h0ID0gaGVpZ2h0O1xuICB2YXIgcmVhbFdpZHRoID0gd2lkdGg7XG4gIGlmICgoMCwgX2lzTnVtYmVyW1wiZGVmYXVsdFwiXSkoY3VzdG9tV2lkdGgpKSB7XG4gICAgcmVhbFdpZHRoID0gY3VzdG9tV2lkdGg7XG4gIH0gZWxzZSBpZiAoKDAsIF9pc1N0cmluZ1tcImRlZmF1bHRcIl0pKGN1c3RvbVdpZHRoKSkge1xuICAgIHJlYWxXaWR0aCA9IHJlYWxXaWR0aCAqIHBhcnNlRmxvYXQoY3VzdG9tV2lkdGgpIC8gMTAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVhbFdpZHRoOiByZWFsV2lkdGggLSBsZWZ0IC0gcmlnaHQgLSA1MCxcbiAgICByZWFsSGVpZ2h0OiByZWFsSGVpZ2h0IC0gYm90dG9tIC0gdG9wLFxuICAgIG9mZnNldFg6ICh3aWR0aCAtIHJlYWxXaWR0aCkgLyAyLFxuICAgIG9mZnNldFk6IChoZWlnaHQgLSByZWFsSGVpZ2h0KSAvIDJcbiAgfTtcbn0pO1xuX2RlZmluZVByb3BlcnR5KEZ1bm5lbCwgXCJnZXRDb21wb3NlZERhdGFcIiwgZnVuY3Rpb24gKF9yZWYyKSB7XG4gIHZhciBpdGVtID0gX3JlZjIuaXRlbSxcbiAgICBvZmZzZXQgPSBfcmVmMi5vZmZzZXQ7XG4gIHZhciBmdW5uZWxEYXRhID0gX0Z1bm5lbC5nZXRSZWFsRnVubmVsRGF0YShpdGVtKTtcbiAgdmFyIF9pdGVtJHByb3BzMiA9IGl0ZW0ucHJvcHMsXG4gICAgZGF0YUtleSA9IF9pdGVtJHByb3BzMi5kYXRhS2V5LFxuICAgIG5hbWVLZXkgPSBfaXRlbSRwcm9wczIubmFtZUtleSxcbiAgICB0b29sdGlwVHlwZSA9IF9pdGVtJHByb3BzMi50b29sdGlwVHlwZSxcbiAgICBsYXN0U2hhcGVUeXBlID0gX2l0ZW0kcHJvcHMyLmxhc3RTaGFwZVR5cGUsXG4gICAgcmV2ZXJzZWQgPSBfaXRlbSRwcm9wczIucmV2ZXJzZWQ7XG4gIHZhciBsZWZ0ID0gb2Zmc2V0LmxlZnQsXG4gICAgdG9wID0gb2Zmc2V0LnRvcDtcbiAgdmFyIF9GdW5uZWwkZ2V0UmVhbFdpZHRoSCA9IF9GdW5uZWwuZ2V0UmVhbFdpZHRoSGVpZ2h0KGl0ZW0sIG9mZnNldCksXG4gICAgcmVhbEhlaWdodCA9IF9GdW5uZWwkZ2V0UmVhbFdpZHRoSC5yZWFsSGVpZ2h0LFxuICAgIHJlYWxXaWR0aCA9IF9GdW5uZWwkZ2V0UmVhbFdpZHRoSC5yZWFsV2lkdGgsXG4gICAgb2Zmc2V0WCA9IF9GdW5uZWwkZ2V0UmVhbFdpZHRoSC5vZmZzZXRYLFxuICAgIG9mZnNldFkgPSBfRnVubmVsJGdldFJlYWxXaWR0aEgub2Zmc2V0WTtcbiAgdmFyIG1heFZhbHVlID0gTWF0aC5tYXguYXBwbHkobnVsbCwgZnVubmVsRGF0YS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkoZW50cnksIGRhdGFLZXksIDApO1xuICB9KSk7XG4gIHZhciBsZW4gPSBmdW5uZWxEYXRhLmxlbmd0aDtcbiAgdmFyIHJvd0hlaWdodCA9IHJlYWxIZWlnaHQgLyBsZW47XG4gIHZhciBwYXJlbnRWaWV3Qm94ID0ge1xuICAgIHg6IG9mZnNldC5sZWZ0LFxuICAgIHk6IG9mZnNldC50b3AsXG4gICAgd2lkdGg6IG9mZnNldC53aWR0aCxcbiAgICBoZWlnaHQ6IG9mZnNldC5oZWlnaHRcbiAgfTtcbiAgdmFyIHRyYXBlem9pZHMgPSBmdW5uZWxEYXRhLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgICB2YXIgcmF3VmFsID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgZGF0YUtleSwgMCk7XG4gICAgdmFyIG5hbWUgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0VmFsdWVCeURhdGFLZXkpKGVudHJ5LCBuYW1lS2V5LCBpKTtcbiAgICB2YXIgdmFsID0gcmF3VmFsO1xuICAgIHZhciBuZXh0VmFsO1xuICAgIGlmIChpICE9PSBsZW4gLSAxKSB7XG4gICAgICBuZXh0VmFsID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShmdW5uZWxEYXRhW2kgKyAxXSwgZGF0YUtleSwgMCk7XG4gICAgICBpZiAobmV4dFZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHZhciBfbmV4dFZhbCA9IG5leHRWYWw7XG4gICAgICAgIHZhciBfbmV4dFZhbDIgPSBfc2xpY2VkVG9BcnJheShfbmV4dFZhbCwgMSk7XG4gICAgICAgIG5leHRWYWwgPSBfbmV4dFZhbDJbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyYXdWYWwgaW5zdGFuY2VvZiBBcnJheSAmJiByYXdWYWwubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgX3Jhd1ZhbCA9IF9zbGljZWRUb0FycmF5KHJhd1ZhbCwgMik7XG4gICAgICB2YWwgPSBfcmF3VmFsWzBdO1xuICAgICAgbmV4dFZhbCA9IF9yYXdWYWxbMV07XG4gICAgfSBlbHNlIGlmIChsYXN0U2hhcGVUeXBlID09PSAncmVjdGFuZ2xlJykge1xuICAgICAgbmV4dFZhbCA9IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFZhbCA9IDA7XG4gICAgfVxuICAgIHZhciB4ID0gKG1heFZhbHVlIC0gdmFsKSAqIHJlYWxXaWR0aCAvICgyICogbWF4VmFsdWUpICsgdG9wICsgMjUgKyBvZmZzZXRYO1xuICAgIHZhciB5ID0gcm93SGVpZ2h0ICogaSArIGxlZnQgKyBvZmZzZXRZO1xuICAgIHZhciB1cHBlcldpZHRoID0gdmFsIC8gbWF4VmFsdWUgKiByZWFsV2lkdGg7XG4gICAgdmFyIGxvd2VyV2lkdGggPSBuZXh0VmFsIC8gbWF4VmFsdWUgKiByZWFsV2lkdGg7XG4gICAgdmFyIHRvb2x0aXBQYXlsb2FkID0gW3tcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsLFxuICAgICAgcGF5bG9hZDogZW50cnksXG4gICAgICBkYXRhS2V5OiBkYXRhS2V5LFxuICAgICAgdHlwZTogdG9vbHRpcFR5cGVcbiAgICB9XTtcbiAgICB2YXIgdG9vbHRpcFBvc2l0aW9uID0ge1xuICAgICAgeDogeCArIHVwcGVyV2lkdGggLyAyLFxuICAgICAgeTogeSArIHJvd0hlaWdodCAvIDJcbiAgICB9O1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB3aWR0aDogTWF0aC5tYXgodXBwZXJXaWR0aCwgbG93ZXJXaWR0aCksXG4gICAgICB1cHBlcldpZHRoOiB1cHBlcldpZHRoLFxuICAgICAgbG93ZXJXaWR0aDogbG93ZXJXaWR0aCxcbiAgICAgIGhlaWdodDogcm93SGVpZ2h0LFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbDogdmFsLFxuICAgICAgdG9vbHRpcFBheWxvYWQ6IHRvb2x0aXBQYXlsb2FkLFxuICAgICAgdG9vbHRpcFBvc2l0aW9uOiB0b29sdGlwUG9zaXRpb25cbiAgICB9LCAoMCwgX29taXRbXCJkZWZhdWx0XCJdKShlbnRyeSwgJ3dpZHRoJykpLCB7fSwge1xuICAgICAgcGF5bG9hZDogZW50cnksXG4gICAgICBwYXJlbnRWaWV3Qm94OiBwYXJlbnRWaWV3Qm94LFxuICAgICAgbGFiZWxWaWV3Qm94OiB7XG4gICAgICAgIHg6IHggKyAodXBwZXJXaWR0aCAtIGxvd2VyV2lkdGgpIC8gNCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgd2lkdGg6IE1hdGguYWJzKHVwcGVyV2lkdGggLSBsb3dlcldpZHRoKSAvIDIgKyBNYXRoLm1pbih1cHBlcldpZHRoLCBsb3dlcldpZHRoKSxcbiAgICAgICAgaGVpZ2h0OiByb3dIZWlnaHRcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIGlmIChyZXZlcnNlZCkge1xuICAgIHRyYXBlem9pZHMgPSB0cmFwZXpvaWRzLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XG4gICAgICB2YXIgbmV3WSA9IGVudHJ5LnkgLSBpbmRleCAqIHJvd0hlaWdodCArIChsZW4gLSAxIC0gaW5kZXgpICogcm93SGVpZ2h0O1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xuICAgICAgICB1cHBlcldpZHRoOiBlbnRyeS5sb3dlcldpZHRoLFxuICAgICAgICBsb3dlcldpZHRoOiBlbnRyeS51cHBlcldpZHRoLFxuICAgICAgICB4OiBlbnRyeS54IC0gKGVudHJ5Lmxvd2VyV2lkdGggLSBlbnRyeS51cHBlcldpZHRoKSAvIDIsXG4gICAgICAgIHk6IGVudHJ5LnkgLSBpbmRleCAqIHJvd0hlaWdodCArIChsZW4gLSAxIC0gaW5kZXgpICogcm93SGVpZ2h0LFxuICAgICAgICB0b29sdGlwUG9zaXRpb246IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkudG9vbHRpcFBvc2l0aW9uKSwge30sIHtcbiAgICAgICAgICB5OiBuZXdZICsgcm93SGVpZ2h0IC8gMlxuICAgICAgICB9KSxcbiAgICAgICAgbGFiZWxWaWV3Qm94OiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5LmxhYmVsVmlld0JveCksIHt9LCB7XG4gICAgICAgICAgeTogbmV3WVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0cmFwZXpvaWRzOiB0cmFwZXpvaWRzLFxuICAgIGRhdGE6IGZ1bm5lbERhdGFcbiAgfTtcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkZ1bm5lbCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9yZWFjdFNtb290aCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfaXNGdW5jdGlvbiIsIl9pc051bWJlciIsIl9pc1N0cmluZyIsIl9vbWl0IiwiX2lzRXF1YWwiLCJfY2xzeCIsIl9MYXllciIsIl9MYWJlbExpc3QiLCJfQ2VsbCIsIl9SZWFjdFV0aWxzIiwiX0dsb2JhbCIsIl9EYXRhVXRpbHMiLCJfQ2hhcnRVdGlscyIsIl90eXBlcyIsIl9GdW5uZWxVdGlscyIsIl9GdW5uZWwiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJsZW4iLCJsZW5ndGgiLCJhcnIyIiwibCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZiIsIm5leHQiLCJkb25lIiwicHVzaCIsImlzQXJyYXkiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJrZXkiLCJhcHBseSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiX1B1cmVDb21wb25lbnQiLCJfdGhpcyIsIl9sZW4iLCJhcmdzIiwiX2tleSIsImNvbmNhdCIsImlzQW5pbWF0aW9uRmluaXNoZWQiLCJvbkFuaW1hdGlvbkVuZCIsInNldFN0YXRlIiwib25BbmltYXRpb25TdGFydCIsImlzQWN0aXZlSW5kZXgiLCJhY3RpdmVJbmRleCIsImluZGV4T2YiLCJyZW5kZXJUcmFwZXpvaWRzU3RhdGljYWxseSIsInRyYXBlem9pZHMiLCJfdGhpczIiLCJfdGhpcyRwcm9wcyIsInNoYXBlIiwiYWN0aXZlU2hhcGUiLCJtYXAiLCJlbnRyeSIsInRyYXBlem9pZE9wdGlvbnMiLCJ0cmFwZXpvaWRQcm9wcyIsImlzQWN0aXZlIiwic3Ryb2tlIiwiY3JlYXRlRWxlbWVudCIsIkxheWVyIiwiY2xhc3NOYW1lIiwiYWRhcHRFdmVudHNPZkNoaWxkIiwieCIsInkiLCJyb2xlIiwiRnVubmVsVHJhcGV6b2lkIiwib3B0aW9uIiwicmVuZGVyVHJhcGV6b2lkc1dpdGhBbmltYXRpb24iLCJfdGhpczMiLCJfdGhpcyRwcm9wczIiLCJpc0FuaW1hdGlvbkFjdGl2ZSIsImFuaW1hdGlvbkJlZ2luIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJhbmltYXRpb25FYXNpbmciLCJhbmltYXRpb25JZCIsInByZXZUcmFwZXpvaWRzIiwic3RhdGUiLCJiZWdpbiIsImR1cmF0aW9uIiwiZWFzaW5nIiwidG8iLCJoYW5kbGVBbmltYXRpb25TdGFydCIsImhhbmRsZUFuaW1hdGlvbkVuZCIsIl9yZWYiLCJzdGVwRGF0YSIsImluZGV4IiwicHJldiIsIl9pbnRlcnBvbGF0b3JYIiwiaW50ZXJwb2xhdGVOdW1iZXIiLCJfaW50ZXJwb2xhdG9yWSIsIl9pbnRlcnBvbGF0b3JVcHBlcldpZHRoIiwidXBwZXJXaWR0aCIsIl9pbnRlcnBvbGF0b3JMb3dlcldpZHRoIiwibG93ZXJXaWR0aCIsIl9pbnRlcnBvbGF0b3JIZWlnaHQiLCJoZWlnaHQiLCJpbnRlcnBvbGF0b3JYIiwiaW50ZXJwb2xhdG9yWSIsImludGVycG9sYXRvclVwcGVyV2lkdGgiLCJpbnRlcnBvbGF0b3JMb3dlcldpZHRoIiwiaW50ZXJwb2xhdG9ySGVpZ2h0IiwicmVuZGVyVHJhcGV6b2lkcyIsIl90aGlzJHByb3BzMyIsInJlbmRlciIsIl90aGlzJHByb3BzNCIsImhpZGUiLCJsYXllckNsYXNzIiwiTGFiZWxMaXN0IiwicmVuZGVyQ2FsbEJ5UGFyZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibmV4dFByb3BzIiwicHJldlN0YXRlIiwicHJldkFuaW1hdGlvbklkIiwiY3VyVHJhcGV6b2lkcyIsIlB1cmVDb21wb25lbnQiLCJmaWxsIiwibGVnZW5kVHlwZSIsImxhYmVsTGluZSIsIkdsb2JhbCIsImlzU3NyIiwibmFtZUtleSIsImxhc3RTaGFwZVR5cGUiLCJpdGVtIiwiX2l0ZW0kcHJvcHMiLCJkYXRhIiwiY2hpbGRyZW4iLCJwcmVzZW50YXRpb25Qcm9wcyIsImZpbHRlclByb3BzIiwiY2VsbHMiLCJmaW5kQWxsQnlUeXBlIiwiQ2VsbCIsInBheWxvYWQiLCJjZWxsIiwib2Zmc2V0IiwiY3VzdG9tV2lkdGgiLCJ3aWR0aCIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsInJlYWxIZWlnaHQiLCJyZWFsV2lkdGgiLCJwYXJzZUZsb2F0Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJfcmVmMiIsImZ1bm5lbERhdGEiLCJnZXRSZWFsRnVubmVsRGF0YSIsIl9pdGVtJHByb3BzMiIsImRhdGFLZXkiLCJ0b29sdGlwVHlwZSIsInJldmVyc2VkIiwiX0Z1bm5lbCRnZXRSZWFsV2lkdGhIIiwiZ2V0UmVhbFdpZHRoSGVpZ2h0IiwibWF4VmFsdWUiLCJNYXRoIiwibWF4IiwiZ2V0VmFsdWVCeURhdGFLZXkiLCJyb3dIZWlnaHQiLCJwYXJlbnRWaWV3Qm94IiwicmF3VmFsIiwidmFsIiwibmV4dFZhbCIsIl9uZXh0VmFsIiwiX25leHRWYWwyIiwiX3Jhd1ZhbCIsInRvb2x0aXBQYXlsb2FkIiwidHlwZSIsInRvb2x0aXBQb3NpdGlvbiIsImxhYmVsVmlld0JveCIsImFicyIsIm1pbiIsIm5ld1kiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/numberAxis/Funnel.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/polar/Pie.js":
/*!************************************************!*\
  !*** ./node_modules/recharts/lib/polar/Pie.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Pie = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _Curve = __webpack_require__(/*! ../shape/Curve */ \"./node_modules/recharts/lib/shape/Curve.js\");\nvar _Text = __webpack_require__(/*! ../component/Text */ \"./node_modules/recharts/lib/component/Text.js\");\nvar _Label = __webpack_require__(/*! ../component/Label */ \"./node_modules/recharts/lib/component/Label.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"./node_modules/recharts/lib/component/LabelList.js\");\nvar _Cell = __webpack_require__(/*! ../component/Cell */ \"./node_modules/recharts/lib/component/Cell.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"./node_modules/recharts/lib/util/Global.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _LogUtils = __webpack_require__(/*! ../util/LogUtils */ \"./node_modules/recharts/lib/util/LogUtils.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"./node_modules/recharts/lib/util/types.js\");\nvar _ActiveShapeUtils = __webpack_require__(/*! ../util/ActiveShapeUtils */ \"./node_modules/recharts/lib/util/ActiveShapeUtils.js\");\nvar _Pie;\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Render sectors of a pie\n */ \nvar Pie = exports.Pie = /*#__PURE__*/ function(_PureComponent) {\n    function Pie(props) {\n        var _this;\n        _classCallCheck(this, Pie);\n        _this = _callSuper(this, Pie, [\n            props\n        ]);\n        _defineProperty(_this, \"pieRef\", null);\n        _defineProperty(_this, \"sectorRefs\", []);\n        _defineProperty(_this, \"id\", (0, _DataUtils.uniqueId)(\"recharts-pie-\"));\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            var onAnimationEnd = _this.props.onAnimationEnd;\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationEnd)) {\n                onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            var onAnimationStart = _this.props.onAnimationStart;\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationStart)) {\n                onAnimationStart();\n            }\n        });\n        _this.state = {\n            isAnimationFinished: !props.isAnimationActive,\n            prevIsAnimationActive: props.isAnimationActive,\n            prevAnimationId: props.animationId,\n            sectorToFocus: 0\n        };\n        return _this;\n    }\n    _inherits(Pie, _PureComponent);\n    return _createClass(Pie, [\n        {\n            key: \"isActiveIndex\",\n            value: function isActiveIndex(i) {\n                var activeIndex = this.props.activeIndex;\n                if (Array.isArray(activeIndex)) {\n                    return activeIndex.indexOf(i) !== -1;\n                }\n                return i === activeIndex;\n            }\n        },\n        {\n            key: \"hasActiveIndex\",\n            value: function hasActiveIndex() {\n                var activeIndex = this.props.activeIndex;\n                return Array.isArray(activeIndex) ? activeIndex.length !== 0 : activeIndex || activeIndex === 0;\n            }\n        },\n        {\n            key: \"renderLabels\",\n            value: function renderLabels(sectors) {\n                var isAnimationActive = this.props.isAnimationActive;\n                if (isAnimationActive && !this.state.isAnimationFinished) {\n                    return null;\n                }\n                var _this$props = this.props, label = _this$props.label, labelLine = _this$props.labelLine, dataKey = _this$props.dataKey, valueKey = _this$props.valueKey;\n                var pieProps = (0, _ReactUtils.filterProps)(this.props, false);\n                var customLabelProps = (0, _ReactUtils.filterProps)(label, false);\n                var customLabelLineProps = (0, _ReactUtils.filterProps)(labelLine, false);\n                var offsetRadius = label && label.offsetRadius || 20;\n                var labels = sectors.map(function(entry, i) {\n                    var midAngle = (entry.startAngle + entry.endAngle) / 2;\n                    var endPoint = (0, _PolarUtils.polarToCartesian)(entry.cx, entry.cy, entry.outerRadius + offsetRadius, midAngle);\n                    var labelProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, pieProps), entry), {}, {\n                        stroke: \"none\"\n                    }, customLabelProps), {}, {\n                        index: i,\n                        textAnchor: Pie.getTextAnchor(endPoint.x, entry.cx)\n                    }, endPoint);\n                    var lineProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, pieProps), entry), {}, {\n                        fill: \"none\",\n                        stroke: entry.fill\n                    }, customLabelLineProps), {}, {\n                        index: i,\n                        points: [\n                            (0, _PolarUtils.polarToCartesian)(entry.cx, entry.cy, entry.outerRadius, midAngle),\n                            endPoint\n                        ]\n                    });\n                    var realDataKey = dataKey;\n                    // TODO: compatible to lower versions\n                    if ((0, _isNil[\"default\"])(dataKey) && (0, _isNil[\"default\"])(valueKey)) {\n                        realDataKey = \"value\";\n                    } else if ((0, _isNil[\"default\"])(dataKey)) {\n                        realDataKey = valueKey;\n                    }\n                    return(/*#__PURE__*/ // eslint-disable-next-line react/no-array-index-key\n                    _react[\"default\"].createElement(_Layer.Layer, {\n                        key: \"label-\".concat(entry.startAngle, \"-\").concat(entry.endAngle, \"-\").concat(entry.midAngle, \"-\").concat(i)\n                    }, labelLine && Pie.renderLabelLineItem(labelLine, lineProps, \"line\"), Pie.renderLabelItem(label, labelProps, (0, _ChartUtils.getValueByDataKey)(entry, realDataKey))));\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-pie-labels\"\n                }, labels);\n            }\n        },\n        {\n            key: \"renderSectorsStatically\",\n            value: function renderSectorsStatically(sectors) {\n                var _this2 = this;\n                var _this$props2 = this.props, activeShape = _this$props2.activeShape, blendStroke = _this$props2.blendStroke, inactiveShapeProp = _this$props2.inactiveShape;\n                return sectors.map(function(entry, i) {\n                    if ((entry === null || entry === void 0 ? void 0 : entry.startAngle) === 0 && (entry === null || entry === void 0 ? void 0 : entry.endAngle) === 0 && sectors.length !== 1) return null;\n                    var isActive = _this2.isActiveIndex(i);\n                    var inactiveShape = inactiveShapeProp && _this2.hasActiveIndex() ? inactiveShapeProp : null;\n                    var sectorOptions = isActive ? activeShape : inactiveShape;\n                    var sectorProps = _objectSpread(_objectSpread({}, entry), {}, {\n                        stroke: blendStroke ? entry.fill : entry.stroke,\n                        tabIndex: -1\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        ref: function ref(_ref) {\n                            if (_ref && !_this2.sectorRefs.includes(_ref)) {\n                                _this2.sectorRefs.push(_ref);\n                            }\n                        },\n                        tabIndex: -1,\n                        className: \"recharts-pie-sector\"\n                    }, (0, _types.adaptEventsOfChild)(_this2.props, entry, i), {\n                        // eslint-disable-next-line react/no-array-index-key\n                        key: \"sector-\".concat(entry === null || entry === void 0 ? void 0 : entry.startAngle, \"-\").concat(entry === null || entry === void 0 ? void 0 : entry.endAngle, \"-\").concat(entry.midAngle, \"-\").concat(i)\n                    }), /*#__PURE__*/ _react[\"default\"].createElement(_ActiveShapeUtils.Shape, _extends({\n                        option: sectorOptions,\n                        isActive: isActive,\n                        shapeType: \"sector\"\n                    }, sectorProps)));\n                });\n            }\n        },\n        {\n            key: \"renderSectorsWithAnimation\",\n            value: function renderSectorsWithAnimation() {\n                var _this3 = this;\n                var _this$props3 = this.props, sectors = _this$props3.sectors, isAnimationActive = _this$props3.isAnimationActive, animationBegin = _this$props3.animationBegin, animationDuration = _this$props3.animationDuration, animationEasing = _this$props3.animationEasing, animationId = _this$props3.animationId;\n                var _this$state = this.state, prevSectors = _this$state.prevSectors, prevIsAnimationActive = _this$state.prevIsAnimationActive;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"pie-\".concat(animationId, \"-\").concat(prevIsAnimationActive),\n                    onAnimationStart: this.handleAnimationStart,\n                    onAnimationEnd: this.handleAnimationEnd\n                }, function(_ref2) {\n                    var t = _ref2.t;\n                    var stepData = [];\n                    var first = sectors && sectors[0];\n                    var curAngle = first.startAngle;\n                    sectors.forEach(function(entry, index) {\n                        var prev = prevSectors && prevSectors[index];\n                        var paddingAngle = index > 0 ? (0, _get[\"default\"])(entry, \"paddingAngle\", 0) : 0;\n                        if (prev) {\n                            var angleIp = (0, _DataUtils.interpolateNumber)(prev.endAngle - prev.startAngle, entry.endAngle - entry.startAngle);\n                            var latest = _objectSpread(_objectSpread({}, entry), {}, {\n                                startAngle: curAngle + paddingAngle,\n                                endAngle: curAngle + angleIp(t) + paddingAngle\n                            });\n                            stepData.push(latest);\n                            curAngle = latest.endAngle;\n                        } else {\n                            var endAngle = entry.endAngle, startAngle = entry.startAngle;\n                            var interpolatorAngle = (0, _DataUtils.interpolateNumber)(0, endAngle - startAngle);\n                            var deltaAngle = interpolatorAngle(t);\n                            var _latest = _objectSpread(_objectSpread({}, entry), {}, {\n                                startAngle: curAngle + paddingAngle,\n                                endAngle: curAngle + deltaAngle + paddingAngle\n                            });\n                            stepData.push(_latest);\n                            curAngle = _latest.endAngle;\n                        }\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, null, _this3.renderSectorsStatically(stepData));\n                });\n            }\n        },\n        {\n            key: \"attachKeyboardHandlers\",\n            value: function attachKeyboardHandlers(pieRef) {\n                var _this4 = this;\n                // eslint-disable-next-line no-param-reassign\n                pieRef.onkeydown = function(e) {\n                    if (!e.altKey) {\n                        switch(e.key){\n                            case \"ArrowLeft\":\n                                {\n                                    var next = ++_this4.state.sectorToFocus % _this4.sectorRefs.length;\n                                    _this4.sectorRefs[next].focus();\n                                    _this4.setState({\n                                        sectorToFocus: next\n                                    });\n                                    break;\n                                }\n                            case \"ArrowRight\":\n                                {\n                                    var _next = --_this4.state.sectorToFocus < 0 ? _this4.sectorRefs.length - 1 : _this4.state.sectorToFocus % _this4.sectorRefs.length;\n                                    _this4.sectorRefs[_next].focus();\n                                    _this4.setState({\n                                        sectorToFocus: _next\n                                    });\n                                    break;\n                                }\n                            case \"Escape\":\n                                {\n                                    _this4.sectorRefs[_this4.state.sectorToFocus].blur();\n                                    _this4.setState({\n                                        sectorToFocus: 0\n                                    });\n                                    break;\n                                }\n                            default:\n                                {\n                                // There is nothing to do here\n                                }\n                        }\n                    }\n                };\n            }\n        },\n        {\n            key: \"renderSectors\",\n            value: function renderSectors() {\n                var _this$props4 = this.props, sectors = _this$props4.sectors, isAnimationActive = _this$props4.isAnimationActive;\n                var prevSectors = this.state.prevSectors;\n                if (isAnimationActive && sectors && sectors.length && (!prevSectors || !(0, _isEqual[\"default\"])(prevSectors, sectors))) {\n                    return this.renderSectorsWithAnimation();\n                }\n                return this.renderSectorsStatically(sectors);\n            }\n        },\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                if (this.pieRef) {\n                    this.attachKeyboardHandlers(this.pieRef);\n                }\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this5 = this;\n                var _this$props5 = this.props, hide = _this$props5.hide, sectors = _this$props5.sectors, className = _this$props5.className, label = _this$props5.label, cx = _this$props5.cx, cy = _this$props5.cy, innerRadius = _this$props5.innerRadius, outerRadius = _this$props5.outerRadius, isAnimationActive = _this$props5.isAnimationActive;\n                var isAnimationFinished = this.state.isAnimationFinished;\n                if (hide || !sectors || !sectors.length || !(0, _DataUtils.isNumber)(cx) || !(0, _DataUtils.isNumber)(cy) || !(0, _DataUtils.isNumber)(innerRadius) || !(0, _DataUtils.isNumber)(outerRadius)) {\n                    return null;\n                }\n                var layerClass = (0, _clsx[\"default\"])(\"recharts-pie\", className);\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    tabIndex: this.props.rootTabIndex,\n                    className: layerClass,\n                    ref: function ref(_ref3) {\n                        _this5.pieRef = _ref3;\n                    }\n                }, this.renderSectors(), label && this.renderLabels(sectors), _Label.Label.renderCallByParent(this.props, null, false), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, sectors, false));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (prevState.prevIsAnimationActive !== nextProps.isAnimationActive) {\n                    return {\n                        prevIsAnimationActive: nextProps.isAnimationActive,\n                        prevAnimationId: nextProps.animationId,\n                        curSectors: nextProps.sectors,\n                        prevSectors: [],\n                        isAnimationFinished: true\n                    };\n                }\n                if (nextProps.isAnimationActive && nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curSectors: nextProps.sectors,\n                        prevSectors: prevState.curSectors,\n                        isAnimationFinished: true\n                    };\n                }\n                if (nextProps.sectors !== prevState.curSectors) {\n                    return {\n                        curSectors: nextProps.sectors,\n                        isAnimationFinished: true\n                    };\n                }\n                return null;\n            }\n        },\n        {\n            key: \"getTextAnchor\",\n            value: function getTextAnchor(x, cx) {\n                if (x > cx) {\n                    return \"start\";\n                }\n                if (x < cx) {\n                    return \"end\";\n                }\n                return \"middle\";\n            }\n        },\n        {\n            key: \"renderLabelLineItem\",\n            value: function renderLabelLineItem(option, props, key) {\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                }\n                if ((0, _isFunction[\"default\"])(option)) {\n                    return option(props);\n                }\n                var className = (0, _clsx[\"default\"])(\"recharts-pie-label-line\", typeof option !== \"boolean\" ? option.className : \"\");\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Curve.Curve, _extends({}, props, {\n                    key: key,\n                    type: \"linear\",\n                    className: className\n                }));\n            }\n        },\n        {\n            key: \"renderLabelItem\",\n            value: function renderLabelItem(option, props, value) {\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    return /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                }\n                var label = value;\n                if ((0, _isFunction[\"default\"])(option)) {\n                    label = option(props);\n                    if (/*#__PURE__*/ _react[\"default\"].isValidElement(label)) {\n                        return label;\n                    }\n                }\n                var className = (0, _clsx[\"default\"])(\"recharts-pie-label-text\", typeof option !== \"boolean\" && !(0, _isFunction[\"default\"])(option) ? option.className : \"\");\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({}, props, {\n                    alignmentBaseline: \"middle\",\n                    className: className\n                }), label);\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_Pie = Pie;\n_defineProperty(Pie, \"displayName\", \"Pie\");\n_defineProperty(Pie, \"defaultProps\", {\n    stroke: \"#fff\",\n    fill: \"#808080\",\n    legendType: \"rect\",\n    cx: \"50%\",\n    cy: \"50%\",\n    startAngle: 0,\n    endAngle: 360,\n    innerRadius: 0,\n    outerRadius: \"80%\",\n    paddingAngle: 0,\n    labelLine: true,\n    hide: false,\n    minAngle: 0,\n    isAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 400,\n    animationDuration: 1500,\n    animationEasing: \"ease\",\n    nameKey: \"name\",\n    blendStroke: false,\n    rootTabIndex: 0\n});\n_defineProperty(Pie, \"parseDeltaAngle\", function(startAngle, endAngle) {\n    var sign = (0, _DataUtils.mathSign)(endAngle - startAngle);\n    var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);\n    return sign * deltaAngle;\n});\n_defineProperty(Pie, \"getRealPieData\", function(itemProps) {\n    var data = itemProps.data, children = itemProps.children;\n    var presentationProps = (0, _ReactUtils.filterProps)(itemProps, false);\n    var cells = (0, _ReactUtils.findAllByType)(children, _Cell.Cell);\n    if (data && data.length) {\n        return data.map(function(entry, index) {\n            return _objectSpread(_objectSpread(_objectSpread({\n                payload: entry\n            }, presentationProps), entry), cells && cells[index] && cells[index].props);\n        });\n    }\n    if (cells && cells.length) {\n        return cells.map(function(cell) {\n            return _objectSpread(_objectSpread({}, presentationProps), cell.props);\n        });\n    }\n    return [];\n});\n_defineProperty(Pie, \"parseCoordinateOfPie\", function(itemProps, offset) {\n    var top = offset.top, left = offset.left, width = offset.width, height = offset.height;\n    var maxPieRadius = (0, _PolarUtils.getMaxRadius)(width, height);\n    var cx = left + (0, _DataUtils.getPercentValue)(itemProps.cx, width, width / 2);\n    var cy = top + (0, _DataUtils.getPercentValue)(itemProps.cy, height, height / 2);\n    var innerRadius = (0, _DataUtils.getPercentValue)(itemProps.innerRadius, maxPieRadius, 0);\n    var outerRadius = (0, _DataUtils.getPercentValue)(itemProps.outerRadius, maxPieRadius, maxPieRadius * 0.8);\n    var maxRadius = itemProps.maxRadius || Math.sqrt(width * width + height * height) / 2;\n    return {\n        cx: cx,\n        cy: cy,\n        innerRadius: innerRadius,\n        outerRadius: outerRadius,\n        maxRadius: maxRadius\n    };\n});\n_defineProperty(Pie, \"getComposedData\", function(_ref4) {\n    var item = _ref4.item, offset = _ref4.offset;\n    var itemProps = item.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n    var pieData = _Pie.getRealPieData(itemProps);\n    if (!pieData || !pieData.length) {\n        return null;\n    }\n    var cornerRadius = itemProps.cornerRadius, startAngle = itemProps.startAngle, endAngle = itemProps.endAngle, paddingAngle = itemProps.paddingAngle, dataKey = itemProps.dataKey, nameKey = itemProps.nameKey, valueKey = itemProps.valueKey, tooltipType = itemProps.tooltipType;\n    var minAngle = Math.abs(itemProps.minAngle);\n    var coordinate = _Pie.parseCoordinateOfPie(itemProps, offset);\n    var deltaAngle = _Pie.parseDeltaAngle(startAngle, endAngle);\n    var absDeltaAngle = Math.abs(deltaAngle);\n    var realDataKey = dataKey;\n    if ((0, _isNil[\"default\"])(dataKey) && (0, _isNil[\"default\"])(valueKey)) {\n        (0, _LogUtils.warn)(false, 'Use \"dataKey\" to specify the value of pie,\\n      the props \"valueKey\" will be deprecated in 1.1.0');\n        realDataKey = \"value\";\n    } else if ((0, _isNil[\"default\"])(dataKey)) {\n        (0, _LogUtils.warn)(false, 'Use \"dataKey\" to specify the value of pie,\\n      the props \"valueKey\" will be deprecated in 1.1.0');\n        realDataKey = valueKey;\n    }\n    var notZeroItemCount = pieData.filter(function(entry) {\n        return (0, _ChartUtils.getValueByDataKey)(entry, realDataKey, 0) !== 0;\n    }).length;\n    var totalPadingAngle = (absDeltaAngle >= 360 ? notZeroItemCount : notZeroItemCount - 1) * paddingAngle;\n    var realTotalAngle = absDeltaAngle - notZeroItemCount * minAngle - totalPadingAngle;\n    var sum = pieData.reduce(function(result, entry) {\n        var val = (0, _ChartUtils.getValueByDataKey)(entry, realDataKey, 0);\n        return result + ((0, _DataUtils.isNumber)(val) ? val : 0);\n    }, 0);\n    var sectors;\n    if (sum > 0) {\n        var prev;\n        sectors = pieData.map(function(entry, i) {\n            var val = (0, _ChartUtils.getValueByDataKey)(entry, realDataKey, 0);\n            var name = (0, _ChartUtils.getValueByDataKey)(entry, nameKey, i);\n            var percent = ((0, _DataUtils.isNumber)(val) ? val : 0) / sum;\n            var tempStartAngle;\n            if (i) {\n                tempStartAngle = prev.endAngle + (0, _DataUtils.mathSign)(deltaAngle) * paddingAngle * (val !== 0 ? 1 : 0);\n            } else {\n                tempStartAngle = startAngle;\n            }\n            var tempEndAngle = tempStartAngle + (0, _DataUtils.mathSign)(deltaAngle) * ((val !== 0 ? minAngle : 0) + percent * realTotalAngle);\n            var midAngle = (tempStartAngle + tempEndAngle) / 2;\n            var middleRadius = (coordinate.innerRadius + coordinate.outerRadius) / 2;\n            var tooltipPayload = [\n                {\n                    name: name,\n                    value: val,\n                    payload: entry,\n                    dataKey: realDataKey,\n                    type: tooltipType\n                }\n            ];\n            var tooltipPosition = (0, _PolarUtils.polarToCartesian)(coordinate.cx, coordinate.cy, middleRadius, midAngle);\n            prev = _objectSpread(_objectSpread(_objectSpread({\n                percent: percent,\n                cornerRadius: cornerRadius,\n                name: name,\n                tooltipPayload: tooltipPayload,\n                midAngle: midAngle,\n                middleRadius: middleRadius,\n                tooltipPosition: tooltipPosition\n            }, entry), coordinate), {}, {\n                value: (0, _ChartUtils.getValueByDataKey)(entry, realDataKey),\n                startAngle: tempStartAngle,\n                endAngle: tempEndAngle,\n                payload: entry,\n                paddingAngle: (0, _DataUtils.mathSign)(deltaAngle) * paddingAngle\n            });\n            return prev;\n        });\n    }\n    return _objectSpread(_objectSpread({}, coordinate), {}, {\n        sectors: sectors,\n        data: pieData\n    });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3BvbGFyL1BpZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsV0FBVyxHQUFHLEtBQUs7QUFDbkIsSUFBSUcsU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyxlQUFlQyx1QkFBdUJGLG1CQUFPQSxDQUFDLGtDQUFjO0FBQ2hFLElBQUlHLE9BQU9ELHVCQUF1QkYsbUJBQU9BLENBQUMsOEJBQVk7QUFDdEQsSUFBSUksV0FBV0YsdUJBQXVCRixtQkFBT0EsQ0FBQyxzQ0FBZ0I7QUFDOUQsSUFBSUssU0FBU0gsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJTSxjQUFjSix1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJTyxRQUFRTCx1QkFBdUJGLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlRLFNBQVNSLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJUyxTQUFTVCxtQkFBT0EsQ0FBQyxrRUFBZ0I7QUFDckMsSUFBSVUsUUFBUVYsbUJBQU9BLENBQUMsd0VBQW1CO0FBQ3ZDLElBQUlXLFNBQVNYLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJWSxhQUFhWixtQkFBT0EsQ0FBQyxrRkFBd0I7QUFDakQsSUFBSWEsUUFBUWIsbUJBQU9BLENBQUMsd0VBQW1CO0FBQ3ZDLElBQUljLGNBQWNkLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJZSxVQUFVZixtQkFBT0EsQ0FBQyxrRUFBZ0I7QUFDdEMsSUFBSWdCLGNBQWNoQixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSWlCLGFBQWFqQixtQkFBT0EsQ0FBQyx3RUFBbUI7QUFDNUMsSUFBSWtCLGNBQWNsQixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSW1CLFlBQVluQixtQkFBT0EsQ0FBQyxzRUFB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V3hELFdBQVcsR0FBR3dELFdBQVd4SSxXQUFXLElBQUk7WUFDdkUsSUFBSXlKLGlCQUFpQjtnQkFBQztvQkFDcEJMLE1BQU1BO29CQUNOeFMsT0FBT3VTO29CQUNQL0IsU0FBUzVIO29CQUNUVCxTQUFTMkI7b0JBQ1RxRixNQUFNd0M7Z0JBQ1I7YUFBRTtZQUNGLElBQUltQixrQkFBa0IsQ0FBQyxHQUFHMVIsWUFBWTZILGdCQUFnQixFQUFFMkksV0FBVzFJLEVBQUUsRUFBRTBJLFdBQVd6SSxFQUFFLEVBQUV5SixjQUFjL0o7WUFDcEcrRCxPQUFPMUksY0FBY0EsY0FBY0EsY0FBYztnQkFDL0N1TyxTQUFTQTtnQkFDVGYsY0FBY0E7Z0JBQ2RjLE1BQU1BO2dCQUNOSyxnQkFBZ0JBO2dCQUNoQmhLLFVBQVVBO2dCQUNWK0osY0FBY0E7Z0JBQ2RFLGlCQUFpQkE7WUFDbkIsR0FBR2xLLFFBQVFnSixhQUFhLENBQUMsR0FBRztnQkFDMUI1UixPQUFPLENBQUMsR0FBR3NCLFlBQVk4SSxpQkFBaUIsRUFBRXhCLE9BQU9rQjtnQkFDakRoQixZQUFZNEo7Z0JBQ1ozSixVQUFVNEo7Z0JBQ1ZuQyxTQUFTNUg7Z0JBQ1RpRSxjQUFjLENBQUMsR0FBR3hMLFdBQVd3TyxRQUFRLEVBQUUzQyxjQUFjTDtZQUN2RDtZQUNBLE9BQU9EO1FBQ1Q7SUFDRjtJQUNBLE9BQU8xSSxjQUFjQSxjQUFjLENBQUMsR0FBRzBOLGFBQWEsQ0FBQyxHQUFHO1FBQ3REN0osU0FBU0E7UUFDVG1JLE1BQU1zQjtJQUNSO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3BvbGFyL1BpZS5qcz8wOGMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5QaWUgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcmVhY3RTbW9vdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1zbW9vdGhcIikpO1xudmFyIF9nZXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZ2V0XCIpKTtcbnZhciBfaXNFcXVhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0VxdWFsXCIpKTtcbnZhciBfaXNOaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNOaWxcIikpO1xudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX0xheWVyID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9MYXllclwiKTtcbnZhciBfQ3VydmUgPSByZXF1aXJlKFwiLi4vc2hhcGUvQ3VydmVcIik7XG52YXIgX1RleHQgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L1RleHRcIik7XG52YXIgX0xhYmVsID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbFwiKTtcbnZhciBfTGFiZWxMaXN0ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbExpc3RcIik7XG52YXIgX0NlbGwgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L0NlbGxcIik7XG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xudmFyIF9HbG9iYWwgPSByZXF1aXJlKFwiLi4vdXRpbC9HbG9iYWxcIik7XG52YXIgX1BvbGFyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Qb2xhclV0aWxzXCIpO1xudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XG52YXIgX0NoYXJ0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9DaGFydFV0aWxzXCIpO1xudmFyIF9Mb2dVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0xvZ1V0aWxzXCIpO1xudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi91dGlsL3R5cGVzXCIpO1xudmFyIF9BY3RpdmVTaGFwZVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQWN0aXZlU2hhcGVVdGlsc1wiKTtcbnZhciBfUGllO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxuICogQGZpbGVPdmVydmlldyBSZW5kZXIgc2VjdG9ycyBvZiBhIHBpZVxuICovXG52YXIgUGllID0gZXhwb3J0cy5QaWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIFBpZShwcm9wcykge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGllKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgUGllLCBbcHJvcHNdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicGllUmVmXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJzZWN0b3JSZWZzXCIsIFtdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaWRcIiwgKDAsIF9EYXRhVXRpbHMudW5pcXVlSWQpKCdyZWNoYXJ0cy1waWUtJykpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25FbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9uQW5pbWF0aW9uRW5kID0gX3RoaXMucHJvcHMub25BbmltYXRpb25FbmQ7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9uQW5pbWF0aW9uRW5kKSkge1xuICAgICAgICBvbkFuaW1hdGlvbkVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVBbmltYXRpb25TdGFydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb25BbmltYXRpb25TdGFydCA9IF90aGlzLnByb3BzLm9uQW5pbWF0aW9uU3RhcnQ7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvbkFuaW1hdGlvblN0YXJ0KSkge1xuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiAhcHJvcHMuaXNBbmltYXRpb25BY3RpdmUsXG4gICAgICBwcmV2SXNBbmltYXRpb25BY3RpdmU6IHByb3BzLmlzQW5pbWF0aW9uQWN0aXZlLFxuICAgICAgcHJldkFuaW1hdGlvbklkOiBwcm9wcy5hbmltYXRpb25JZCxcbiAgICAgIHNlY3RvclRvRm9jdXM6IDBcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoUGllLCBfUHVyZUNvbXBvbmVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUGllLCBbe1xuICAgIGtleTogXCJpc0FjdGl2ZUluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQWN0aXZlSW5kZXgoaSkge1xuICAgICAgdmFyIGFjdGl2ZUluZGV4ID0gdGhpcy5wcm9wcy5hY3RpdmVJbmRleDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFjdGl2ZUluZGV4KSkge1xuICAgICAgICByZXR1cm4gYWN0aXZlSW5kZXguaW5kZXhPZihpKSAhPT0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gaSA9PT0gYWN0aXZlSW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0FjdGl2ZUluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0FjdGl2ZUluZGV4KCkge1xuICAgICAgdmFyIGFjdGl2ZUluZGV4ID0gdGhpcy5wcm9wcy5hY3RpdmVJbmRleDtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFjdGl2ZUluZGV4KSA/IGFjdGl2ZUluZGV4Lmxlbmd0aCAhPT0gMCA6IGFjdGl2ZUluZGV4IHx8IGFjdGl2ZUluZGV4ID09PSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTGFiZWxzKHNlY3RvcnMpIHtcbiAgICAgIHZhciBpc0FuaW1hdGlvbkFjdGl2ZSA9IHRoaXMucHJvcHMuaXNBbmltYXRpb25BY3RpdmU7XG4gICAgICBpZiAoaXNBbmltYXRpb25BY3RpdmUgJiYgIXRoaXMuc3RhdGUuaXNBbmltYXRpb25GaW5pc2hlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGxhYmVsID0gX3RoaXMkcHJvcHMubGFiZWwsXG4gICAgICAgIGxhYmVsTGluZSA9IF90aGlzJHByb3BzLmxhYmVsTGluZSxcbiAgICAgICAgZGF0YUtleSA9IF90aGlzJHByb3BzLmRhdGFLZXksXG4gICAgICAgIHZhbHVlS2V5ID0gX3RoaXMkcHJvcHMudmFsdWVLZXk7XG4gICAgICB2YXIgcGllUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIGZhbHNlKTtcbiAgICAgIHZhciBjdXN0b21MYWJlbFByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShsYWJlbCwgZmFsc2UpO1xuICAgICAgdmFyIGN1c3RvbUxhYmVsTGluZVByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShsYWJlbExpbmUsIGZhbHNlKTtcbiAgICAgIHZhciBvZmZzZXRSYWRpdXMgPSBsYWJlbCAmJiBsYWJlbC5vZmZzZXRSYWRpdXMgfHwgMjA7XG4gICAgICB2YXIgbGFiZWxzID0gc2VjdG9ycy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gICAgICAgIHZhciBtaWRBbmdsZSA9IChlbnRyeS5zdGFydEFuZ2xlICsgZW50cnkuZW5kQW5nbGUpIC8gMjtcbiAgICAgICAgdmFyIGVuZFBvaW50ID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGVudHJ5LmN4LCBlbnRyeS5jeSwgZW50cnkub3V0ZXJSYWRpdXMgKyBvZmZzZXRSYWRpdXMsIG1pZEFuZ2xlKTtcbiAgICAgICAgdmFyIGxhYmVsUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwaWVQcm9wcyksIGVudHJ5KSwge30sIHtcbiAgICAgICAgICBzdHJva2U6ICdub25lJ1xuICAgICAgICB9LCBjdXN0b21MYWJlbFByb3BzKSwge30sIHtcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiBQaWUuZ2V0VGV4dEFuY2hvcihlbmRQb2ludC54LCBlbnRyeS5jeClcbiAgICAgICAgfSwgZW5kUG9pbnQpO1xuICAgICAgICB2YXIgbGluZVByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGllUHJvcHMpLCBlbnRyeSksIHt9LCB7XG4gICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgIHN0cm9rZTogZW50cnkuZmlsbFxuICAgICAgICB9LCBjdXN0b21MYWJlbExpbmVQcm9wcyksIHt9LCB7XG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgcG9pbnRzOiBbKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGVudHJ5LmN4LCBlbnRyeS5jeSwgZW50cnkub3V0ZXJSYWRpdXMsIG1pZEFuZ2xlKSwgZW5kUG9pbnRdXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcmVhbERhdGFLZXkgPSBkYXRhS2V5O1xuICAgICAgICAvLyBUT0RPOiBjb21wYXRpYmxlIHRvIGxvd2VyIHZlcnNpb25zXG4gICAgICAgIGlmICgoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoZGF0YUtleSkgJiYgKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKHZhbHVlS2V5KSkge1xuICAgICAgICAgIHJlYWxEYXRhS2V5ID0gJ3ZhbHVlJztcbiAgICAgICAgfSBlbHNlIGlmICgoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoZGF0YUtleSkpIHtcbiAgICAgICAgICByZWFsRGF0YUtleSA9IHZhbHVlS2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcbiAgICAgICAgICBfcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XG4gICAgICAgICAgICBrZXk6IFwibGFiZWwtXCIuY29uY2F0KGVudHJ5LnN0YXJ0QW5nbGUsIFwiLVwiKS5jb25jYXQoZW50cnkuZW5kQW5nbGUsIFwiLVwiKS5jb25jYXQoZW50cnkubWlkQW5nbGUsIFwiLVwiKS5jb25jYXQoaSlcbiAgICAgICAgICB9LCBsYWJlbExpbmUgJiYgUGllLnJlbmRlckxhYmVsTGluZUl0ZW0obGFiZWxMaW5lLCBsaW5lUHJvcHMsICdsaW5lJyksIFBpZS5yZW5kZXJMYWJlbEl0ZW0obGFiZWwsIGxhYmVsUHJvcHMsICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkoZW50cnksIHJlYWxEYXRhS2V5KSkpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtcGllLWxhYmVsc1wiXG4gICAgICB9LCBsYWJlbHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJTZWN0b3JzU3RhdGljYWxseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJTZWN0b3JzU3RhdGljYWxseShzZWN0b3JzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBhY3RpdmVTaGFwZSA9IF90aGlzJHByb3BzMi5hY3RpdmVTaGFwZSxcbiAgICAgICAgYmxlbmRTdHJva2UgPSBfdGhpcyRwcm9wczIuYmxlbmRTdHJva2UsXG4gICAgICAgIGluYWN0aXZlU2hhcGVQcm9wID0gX3RoaXMkcHJvcHMyLmluYWN0aXZlU2hhcGU7XG4gICAgICByZXR1cm4gc2VjdG9ycy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gICAgICAgIGlmICgoZW50cnkgPT09IG51bGwgfHwgZW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVudHJ5LnN0YXJ0QW5nbGUpID09PSAwICYmIChlbnRyeSA9PT0gbnVsbCB8fCBlbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW50cnkuZW5kQW5nbGUpID09PSAwICYmIHNlY3RvcnMubGVuZ3RoICE9PSAxKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGlzQWN0aXZlID0gX3RoaXMyLmlzQWN0aXZlSW5kZXgoaSk7XG4gICAgICAgIHZhciBpbmFjdGl2ZVNoYXBlID0gaW5hY3RpdmVTaGFwZVByb3AgJiYgX3RoaXMyLmhhc0FjdGl2ZUluZGV4KCkgPyBpbmFjdGl2ZVNoYXBlUHJvcCA6IG51bGw7XG4gICAgICAgIHZhciBzZWN0b3JPcHRpb25zID0gaXNBY3RpdmUgPyBhY3RpdmVTaGFwZSA6IGluYWN0aXZlU2hhcGU7XG4gICAgICAgIHZhciBzZWN0b3JQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xuICAgICAgICAgIHN0cm9rZTogYmxlbmRTdHJva2UgPyBlbnRyeS5maWxsIDogZW50cnkuc3Ryb2tlLFxuICAgICAgICAgIHRhYkluZGV4OiAtMVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYoX3JlZikge1xuICAgICAgICAgICAgaWYgKF9yZWYgJiYgIV90aGlzMi5zZWN0b3JSZWZzLmluY2x1ZGVzKF9yZWYpKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5zZWN0b3JSZWZzLnB1c2goX3JlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0YWJJbmRleDogLTEsXG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXBpZS1zZWN0b3JcIlxuICAgICAgICB9LCAoMCwgX3R5cGVzLmFkYXB0RXZlbnRzT2ZDaGlsZCkoX3RoaXMyLnByb3BzLCBlbnRyeSwgaSksIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICAgICAga2V5OiBcInNlY3Rvci1cIi5jb25jYXQoZW50cnkgPT09IG51bGwgfHwgZW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVudHJ5LnN0YXJ0QW5nbGUsIFwiLVwiKS5jb25jYXQoZW50cnkgPT09IG51bGwgfHwgZW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVudHJ5LmVuZEFuZ2xlLCBcIi1cIikuY29uY2F0KGVudHJ5Lm1pZEFuZ2xlLCBcIi1cIikuY29uY2F0KGkpXG4gICAgICAgIH0pLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9BY3RpdmVTaGFwZVV0aWxzLlNoYXBlLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgb3B0aW9uOiBzZWN0b3JPcHRpb25zLFxuICAgICAgICAgIGlzQWN0aXZlOiBpc0FjdGl2ZSxcbiAgICAgICAgICBzaGFwZVR5cGU6IFwic2VjdG9yXCJcbiAgICAgICAgfSwgc2VjdG9yUHJvcHMpKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyU2VjdG9yc1dpdGhBbmltYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyU2VjdG9yc1dpdGhBbmltYXRpb24oKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICBzZWN0b3JzID0gX3RoaXMkcHJvcHMzLnNlY3RvcnMsXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHMzLmlzQW5pbWF0aW9uQWN0aXZlLFxuICAgICAgICBhbmltYXRpb25CZWdpbiA9IF90aGlzJHByb3BzMy5hbmltYXRpb25CZWdpbixcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb24gPSBfdGhpcyRwcm9wczMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZyA9IF90aGlzJHByb3BzMy5hbmltYXRpb25FYXNpbmcsXG4gICAgICAgIGFuaW1hdGlvbklkID0gX3RoaXMkcHJvcHMzLmFuaW1hdGlvbklkO1xuICAgICAgdmFyIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgcHJldlNlY3RvcnMgPSBfdGhpcyRzdGF0ZS5wcmV2U2VjdG9ycyxcbiAgICAgICAgcHJldklzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkc3RhdGUucHJldklzQW5pbWF0aW9uQWN0aXZlO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JlYWN0U21vb3RoW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICBiZWdpbjogYW5pbWF0aW9uQmVnaW4sXG4gICAgICAgIGR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgaXNBY3RpdmU6IGlzQW5pbWF0aW9uQWN0aXZlLFxuICAgICAgICBlYXNpbmc6IGFuaW1hdGlvbkVhc2luZyxcbiAgICAgICAgZnJvbToge1xuICAgICAgICAgIHQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgdG86IHtcbiAgICAgICAgICB0OiAxXG4gICAgICAgIH0sXG4gICAgICAgIGtleTogXCJwaWUtXCIuY29uY2F0KGFuaW1hdGlvbklkLCBcIi1cIikuY29uY2F0KHByZXZJc0FuaW1hdGlvbkFjdGl2ZSksXG4gICAgICAgIG9uQW5pbWF0aW9uU3RhcnQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uU3RhcnQsXG4gICAgICAgIG9uQW5pbWF0aW9uRW5kOiB0aGlzLmhhbmRsZUFuaW1hdGlvbkVuZFxuICAgICAgfSwgZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciB0ID0gX3JlZjIudDtcbiAgICAgICAgdmFyIHN0ZXBEYXRhID0gW107XG4gICAgICAgIHZhciBmaXJzdCA9IHNlY3RvcnMgJiYgc2VjdG9yc1swXTtcbiAgICAgICAgdmFyIGN1ckFuZ2xlID0gZmlyc3Quc3RhcnRBbmdsZTtcbiAgICAgICAgc2VjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgcHJldiA9IHByZXZTZWN0b3JzICYmIHByZXZTZWN0b3JzW2luZGV4XTtcbiAgICAgICAgICB2YXIgcGFkZGluZ0FuZ2xlID0gaW5kZXggPiAwID8gKDAsIF9nZXRbXCJkZWZhdWx0XCJdKShlbnRyeSwgJ3BhZGRpbmdBbmdsZScsIDApIDogMDtcbiAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgdmFyIGFuZ2xlSXAgPSAoMCwgX0RhdGFVdGlscy5pbnRlcnBvbGF0ZU51bWJlcikocHJldi5lbmRBbmdsZSAtIHByZXYuc3RhcnRBbmdsZSwgZW50cnkuZW5kQW5nbGUgLSBlbnRyeS5zdGFydEFuZ2xlKTtcbiAgICAgICAgICAgIHZhciBsYXRlc3QgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcbiAgICAgICAgICAgICAgc3RhcnRBbmdsZTogY3VyQW5nbGUgKyBwYWRkaW5nQW5nbGUsXG4gICAgICAgICAgICAgIGVuZEFuZ2xlOiBjdXJBbmdsZSArIGFuZ2xlSXAodCkgKyBwYWRkaW5nQW5nbGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RlcERhdGEucHVzaChsYXRlc3QpO1xuICAgICAgICAgICAgY3VyQW5nbGUgPSBsYXRlc3QuZW5kQW5nbGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IGVudHJ5LmVuZEFuZ2xlLFxuICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gZW50cnkuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JBbmdsZSA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKSgwLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgdmFyIGRlbHRhQW5nbGUgPSBpbnRlcnBvbGF0b3JBbmdsZSh0KTtcbiAgICAgICAgICAgIHZhciBfbGF0ZXN0ID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XG4gICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IGN1ckFuZ2xlICsgcGFkZGluZ0FuZ2xlLFxuICAgICAgICAgICAgICBlbmRBbmdsZTogY3VyQW5nbGUgKyBkZWx0YUFuZ2xlICsgcGFkZGluZ0FuZ2xlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0ZXBEYXRhLnB1c2goX2xhdGVzdCk7XG4gICAgICAgICAgICBjdXJBbmdsZSA9IF9sYXRlc3QuZW5kQW5nbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCBudWxsLCBfdGhpczMucmVuZGVyU2VjdG9yc1N0YXRpY2FsbHkoc3RlcERhdGEpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdHRhY2hLZXlib2FyZEhhbmRsZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaEtleWJvYXJkSGFuZGxlcnMocGllUmVmKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgcGllUmVmLm9ua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZS5hbHRLZXkpIHtcbiAgICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSArK190aGlzNC5zdGF0ZS5zZWN0b3JUb0ZvY3VzICUgX3RoaXM0LnNlY3RvclJlZnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIF90aGlzNC5zZWN0b3JSZWZzW25leHRdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgX3RoaXM0LnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgIHNlY3RvclRvRm9jdXM6IG5leHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX25leHQgPSAtLV90aGlzNC5zdGF0ZS5zZWN0b3JUb0ZvY3VzIDwgMCA/IF90aGlzNC5zZWN0b3JSZWZzLmxlbmd0aCAtIDEgOiBfdGhpczQuc3RhdGUuc2VjdG9yVG9Gb2N1cyAlIF90aGlzNC5zZWN0b3JSZWZzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBfdGhpczQuc2VjdG9yUmVmc1tfbmV4dF0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBfdGhpczQuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgc2VjdG9yVG9Gb2N1czogX25leHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF90aGlzNC5zZWN0b3JSZWZzW190aGlzNC5zdGF0ZS5zZWN0b3JUb0ZvY3VzXS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgX3RoaXM0LnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgIHNlY3RvclRvRm9jdXM6IDBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vdGhpbmcgdG8gZG8gaGVyZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJTZWN0b3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclNlY3RvcnMoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgc2VjdG9ycyA9IF90aGlzJHByb3BzNC5zZWN0b3JzLFxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzNC5pc0FuaW1hdGlvbkFjdGl2ZTtcbiAgICAgIHZhciBwcmV2U2VjdG9ycyA9IHRoaXMuc3RhdGUucHJldlNlY3RvcnM7XG4gICAgICBpZiAoaXNBbmltYXRpb25BY3RpdmUgJiYgc2VjdG9ycyAmJiBzZWN0b3JzLmxlbmd0aCAmJiAoIXByZXZTZWN0b3JzIHx8ICEoMCwgX2lzRXF1YWxbXCJkZWZhdWx0XCJdKShwcmV2U2VjdG9ycywgc2VjdG9ycykpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclNlY3RvcnNXaXRoQW5pbWF0aW9uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJTZWN0b3JzU3RhdGljYWxseShzZWN0b3JzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBpZiAodGhpcy5waWVSZWYpIHtcbiAgICAgICAgdGhpcy5hdHRhY2hLZXlib2FyZEhhbmRsZXJzKHRoaXMucGllUmVmKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXG4gICAgICAgIGhpZGUgPSBfdGhpcyRwcm9wczUuaGlkZSxcbiAgICAgICAgc2VjdG9ycyA9IF90aGlzJHByb3BzNS5zZWN0b3JzLFxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczUuY2xhc3NOYW1lLFxuICAgICAgICBsYWJlbCA9IF90aGlzJHByb3BzNS5sYWJlbCxcbiAgICAgICAgY3ggPSBfdGhpcyRwcm9wczUuY3gsXG4gICAgICAgIGN5ID0gX3RoaXMkcHJvcHM1LmN5LFxuICAgICAgICBpbm5lclJhZGl1cyA9IF90aGlzJHByb3BzNS5pbm5lclJhZGl1cyxcbiAgICAgICAgb3V0ZXJSYWRpdXMgPSBfdGhpcyRwcm9wczUub3V0ZXJSYWRpdXMsXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHM1LmlzQW5pbWF0aW9uQWN0aXZlO1xuICAgICAgdmFyIGlzQW5pbWF0aW9uRmluaXNoZWQgPSB0aGlzLnN0YXRlLmlzQW5pbWF0aW9uRmluaXNoZWQ7XG4gICAgICBpZiAoaGlkZSB8fCAhc2VjdG9ycyB8fCAhc2VjdG9ycy5sZW5ndGggfHwgISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShjeCkgfHwgISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShjeSkgfHwgISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShpbm5lclJhZGl1cykgfHwgISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShvdXRlclJhZGl1cykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbGF5ZXJDbGFzcyA9ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1waWUnLCBjbGFzc05hbWUpO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XG4gICAgICAgIHRhYkluZGV4OiB0aGlzLnByb3BzLnJvb3RUYWJJbmRleCxcbiAgICAgICAgY2xhc3NOYW1lOiBsYXllckNsYXNzLFxuICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihfcmVmMykge1xuICAgICAgICAgIF90aGlzNS5waWVSZWYgPSBfcmVmMztcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5yZW5kZXJTZWN0b3JzKCksIGxhYmVsICYmIHRoaXMucmVuZGVyTGFiZWxzKHNlY3RvcnMpLCBfTGFiZWwuTGFiZWwucmVuZGVyQ2FsbEJ5UGFyZW50KHRoaXMucHJvcHMsIG51bGwsIGZhbHNlKSwgKCFpc0FuaW1hdGlvbkFjdGl2ZSB8fCBpc0FuaW1hdGlvbkZpbmlzaGVkKSAmJiBfTGFiZWxMaXN0LkxhYmVsTGlzdC5yZW5kZXJDYWxsQnlQYXJlbnQodGhpcy5wcm9wcywgc2VjdG9ycywgZmFsc2UpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICBpZiAocHJldlN0YXRlLnByZXZJc0FuaW1hdGlvbkFjdGl2ZSAhPT0gbmV4dFByb3BzLmlzQW5pbWF0aW9uQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJldklzQW5pbWF0aW9uQWN0aXZlOiBuZXh0UHJvcHMuaXNBbmltYXRpb25BY3RpdmUsXG4gICAgICAgICAgcHJldkFuaW1hdGlvbklkOiBuZXh0UHJvcHMuYW5pbWF0aW9uSWQsXG4gICAgICAgICAgY3VyU2VjdG9yczogbmV4dFByb3BzLnNlY3RvcnMsXG4gICAgICAgICAgcHJldlNlY3RvcnM6IFtdLFxuICAgICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0UHJvcHMuaXNBbmltYXRpb25BY3RpdmUgJiYgbmV4dFByb3BzLmFuaW1hdGlvbklkICE9PSBwcmV2U3RhdGUucHJldkFuaW1hdGlvbklkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJldkFuaW1hdGlvbklkOiBuZXh0UHJvcHMuYW5pbWF0aW9uSWQsXG4gICAgICAgICAgY3VyU2VjdG9yczogbmV4dFByb3BzLnNlY3RvcnMsXG4gICAgICAgICAgcHJldlNlY3RvcnM6IHByZXZTdGF0ZS5jdXJTZWN0b3JzLFxuICAgICAgICAgIGlzQW5pbWF0aW9uRmluaXNoZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0UHJvcHMuc2VjdG9ycyAhPT0gcHJldlN0YXRlLmN1clNlY3RvcnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjdXJTZWN0b3JzOiBuZXh0UHJvcHMuc2VjdG9ycyxcbiAgICAgICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGV4dEFuY2hvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0QW5jaG9yKHgsIGN4KSB7XG4gICAgICBpZiAoeCA+IGN4KSB7XG4gICAgICAgIHJldHVybiAnc3RhcnQnO1xuICAgICAgfVxuICAgICAgaWYgKHggPCBjeCkge1xuICAgICAgICByZXR1cm4gJ2VuZCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ21pZGRsZSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckxhYmVsTGluZUl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTGFiZWxMaW5lSXRlbShvcHRpb24sIHByb3BzLCBrZXkpIHtcbiAgICAgIGlmICggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uaXNWYWxpZEVsZW1lbnQob3B0aW9uKSkge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KG9wdGlvbiwgcHJvcHMpO1xuICAgICAgfVxuICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9wdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbihwcm9wcyk7XG4gICAgICB9XG4gICAgICB2YXIgY2xhc3NOYW1lID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXBpZS1sYWJlbC1saW5lJywgdHlwZW9mIG9wdGlvbiAhPT0gJ2Jvb2xlYW4nID8gb3B0aW9uLmNsYXNzTmFtZSA6ICcnKTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9DdXJ2ZS5DdXJ2ZSwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB0eXBlOiBcImxpbmVhclwiLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJMYWJlbEl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTGFiZWxJdGVtKG9wdGlvbiwgcHJvcHMsIHZhbHVlKSB7XG4gICAgICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KG9wdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChvcHRpb24sIHByb3BzKTtcbiAgICAgIH1cbiAgICAgIHZhciBsYWJlbCA9IHZhbHVlO1xuICAgICAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9wdGlvbikpIHtcbiAgICAgICAgbGFiZWwgPSBvcHRpb24ocHJvcHMpO1xuICAgICAgICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KGxhYmVsKSkge1xuICAgICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNsYXNzTmFtZSA9ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1waWUtbGFiZWwtdGV4dCcsIHR5cGVvZiBvcHRpb24gIT09ICdib29sZWFuJyAmJiAhKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob3B0aW9uKSA/IG9wdGlvbi5jbGFzc05hbWUgOiAnJyk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfVGV4dC5UZXh0LCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgICAgYWxpZ25tZW50QmFzZWxpbmU6IFwibWlkZGxlXCIsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgICB9KSwgbGFiZWwpO1xuICAgIH1cbiAgfV0pO1xufShfcmVhY3QuUHVyZUNvbXBvbmVudCk7XG5fUGllID0gUGllO1xuX2RlZmluZVByb3BlcnR5KFBpZSwgXCJkaXNwbGF5TmFtZVwiLCAnUGllJyk7XG5fZGVmaW5lUHJvcGVydHkoUGllLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIHN0cm9rZTogJyNmZmYnLFxuICBmaWxsOiAnIzgwODA4MCcsXG4gIGxlZ2VuZFR5cGU6ICdyZWN0JyxcbiAgY3g6ICc1MCUnLFxuICBjeTogJzUwJScsXG4gIHN0YXJ0QW5nbGU6IDAsXG4gIGVuZEFuZ2xlOiAzNjAsXG4gIGlubmVyUmFkaXVzOiAwLFxuICBvdXRlclJhZGl1czogJzgwJScsXG4gIHBhZGRpbmdBbmdsZTogMCxcbiAgbGFiZWxMaW5lOiB0cnVlLFxuICBoaWRlOiBmYWxzZSxcbiAgbWluQW5nbGU6IDAsXG4gIGlzQW5pbWF0aW9uQWN0aXZlOiAhX0dsb2JhbC5HbG9iYWwuaXNTc3IsXG4gIGFuaW1hdGlvbkJlZ2luOiA0MDAsXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiAxNTAwLFxuICBhbmltYXRpb25FYXNpbmc6ICdlYXNlJyxcbiAgbmFtZUtleTogJ25hbWUnLFxuICBibGVuZFN0cm9rZTogZmFsc2UsXG4gIHJvb3RUYWJJbmRleDogMFxufSk7XG5fZGVmaW5lUHJvcGVydHkoUGllLCBcInBhcnNlRGVsdGFBbmdsZVwiLCBmdW5jdGlvbiAoc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcbiAgdmFyIHNpZ24gPSAoMCwgX0RhdGFVdGlscy5tYXRoU2lnbikoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgdmFyIGRlbHRhQW5nbGUgPSBNYXRoLm1pbihNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpLCAzNjApO1xuICByZXR1cm4gc2lnbiAqIGRlbHRhQW5nbGU7XG59KTtcbl9kZWZpbmVQcm9wZXJ0eShQaWUsIFwiZ2V0UmVhbFBpZURhdGFcIiwgZnVuY3Rpb24gKGl0ZW1Qcm9wcykge1xuICB2YXIgZGF0YSA9IGl0ZW1Qcm9wcy5kYXRhLFxuICAgIGNoaWxkcmVuID0gaXRlbVByb3BzLmNoaWxkcmVuO1xuICB2YXIgcHJlc2VudGF0aW9uUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKGl0ZW1Qcm9wcywgZmFsc2UpO1xuICB2YXIgY2VsbHMgPSAoMCwgX1JlYWN0VXRpbHMuZmluZEFsbEJ5VHlwZSkoY2hpbGRyZW4sIF9DZWxsLkNlbGwpO1xuICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBwYXlsb2FkOiBlbnRyeVxuICAgICAgfSwgcHJlc2VudGF0aW9uUHJvcHMpLCBlbnRyeSksIGNlbGxzICYmIGNlbGxzW2luZGV4XSAmJiBjZWxsc1tpbmRleF0ucHJvcHMpO1xuICAgIH0pO1xuICB9XG4gIGlmIChjZWxscyAmJiBjZWxscy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2VsbHMubWFwKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcmVzZW50YXRpb25Qcm9wcyksIGNlbGwucHJvcHMpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBbXTtcbn0pO1xuX2RlZmluZVByb3BlcnR5KFBpZSwgXCJwYXJzZUNvb3JkaW5hdGVPZlBpZVwiLCBmdW5jdGlvbiAoaXRlbVByb3BzLCBvZmZzZXQpIHtcbiAgdmFyIHRvcCA9IG9mZnNldC50b3AsXG4gICAgbGVmdCA9IG9mZnNldC5sZWZ0LFxuICAgIHdpZHRoID0gb2Zmc2V0LndpZHRoLFxuICAgIGhlaWdodCA9IG9mZnNldC5oZWlnaHQ7XG4gIHZhciBtYXhQaWVSYWRpdXMgPSAoMCwgX1BvbGFyVXRpbHMuZ2V0TWF4UmFkaXVzKSh3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIGN4ID0gbGVmdCArICgwLCBfRGF0YVV0aWxzLmdldFBlcmNlbnRWYWx1ZSkoaXRlbVByb3BzLmN4LCB3aWR0aCwgd2lkdGggLyAyKTtcbiAgdmFyIGN5ID0gdG9wICsgKDAsIF9EYXRhVXRpbHMuZ2V0UGVyY2VudFZhbHVlKShpdGVtUHJvcHMuY3ksIGhlaWdodCwgaGVpZ2h0IC8gMik7XG4gIHZhciBpbm5lclJhZGl1cyA9ICgwLCBfRGF0YVV0aWxzLmdldFBlcmNlbnRWYWx1ZSkoaXRlbVByb3BzLmlubmVyUmFkaXVzLCBtYXhQaWVSYWRpdXMsIDApO1xuICB2YXIgb3V0ZXJSYWRpdXMgPSAoMCwgX0RhdGFVdGlscy5nZXRQZXJjZW50VmFsdWUpKGl0ZW1Qcm9wcy5vdXRlclJhZGl1cywgbWF4UGllUmFkaXVzLCBtYXhQaWVSYWRpdXMgKiAwLjgpO1xuICB2YXIgbWF4UmFkaXVzID0gaXRlbVByb3BzLm1heFJhZGl1cyB8fCBNYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCkgLyAyO1xuICByZXR1cm4ge1xuICAgIGN4OiBjeCxcbiAgICBjeTogY3ksXG4gICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcbiAgICBtYXhSYWRpdXM6IG1heFJhZGl1c1xuICB9O1xufSk7XG5fZGVmaW5lUHJvcGVydHkoUGllLCBcImdldENvbXBvc2VkRGF0YVwiLCBmdW5jdGlvbiAoX3JlZjQpIHtcbiAgdmFyIGl0ZW0gPSBfcmVmNC5pdGVtLFxuICAgIG9mZnNldCA9IF9yZWY0Lm9mZnNldDtcbiAgdmFyIGl0ZW1Qcm9wcyA9IGl0ZW0udHlwZS5kZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbS50eXBlLmRlZmF1bHRQcm9wcyksIGl0ZW0ucHJvcHMpIDogaXRlbS5wcm9wcztcbiAgdmFyIHBpZURhdGEgPSBfUGllLmdldFJlYWxQaWVEYXRhKGl0ZW1Qcm9wcyk7XG4gIGlmICghcGllRGF0YSB8fCAhcGllRGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgY29ybmVyUmFkaXVzID0gaXRlbVByb3BzLmNvcm5lclJhZGl1cyxcbiAgICBzdGFydEFuZ2xlID0gaXRlbVByb3BzLnN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGUgPSBpdGVtUHJvcHMuZW5kQW5nbGUsXG4gICAgcGFkZGluZ0FuZ2xlID0gaXRlbVByb3BzLnBhZGRpbmdBbmdsZSxcbiAgICBkYXRhS2V5ID0gaXRlbVByb3BzLmRhdGFLZXksXG4gICAgbmFtZUtleSA9IGl0ZW1Qcm9wcy5uYW1lS2V5LFxuICAgIHZhbHVlS2V5ID0gaXRlbVByb3BzLnZhbHVlS2V5LFxuICAgIHRvb2x0aXBUeXBlID0gaXRlbVByb3BzLnRvb2x0aXBUeXBlO1xuICB2YXIgbWluQW5nbGUgPSBNYXRoLmFicyhpdGVtUHJvcHMubWluQW5nbGUpO1xuICB2YXIgY29vcmRpbmF0ZSA9IF9QaWUucGFyc2VDb29yZGluYXRlT2ZQaWUoaXRlbVByb3BzLCBvZmZzZXQpO1xuICB2YXIgZGVsdGFBbmdsZSA9IF9QaWUucGFyc2VEZWx0YUFuZ2xlKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgdmFyIGFic0RlbHRhQW5nbGUgPSBNYXRoLmFicyhkZWx0YUFuZ2xlKTtcbiAgdmFyIHJlYWxEYXRhS2V5ID0gZGF0YUtleTtcbiAgaWYgKCgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShkYXRhS2V5KSAmJiAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkodmFsdWVLZXkpKSB7XG4gICAgKDAsIF9Mb2dVdGlscy53YXJuKShmYWxzZSwgXCJVc2UgXFxcImRhdGFLZXlcXFwiIHRvIHNwZWNpZnkgdGhlIHZhbHVlIG9mIHBpZSxcXG4gICAgICB0aGUgcHJvcHMgXFxcInZhbHVlS2V5XFxcIiB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gMS4xLjBcIik7XG4gICAgcmVhbERhdGFLZXkgPSAndmFsdWUnO1xuICB9IGVsc2UgaWYgKCgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShkYXRhS2V5KSkge1xuICAgICgwLCBfTG9nVXRpbHMud2FybikoZmFsc2UsIFwiVXNlIFxcXCJkYXRhS2V5XFxcIiB0byBzcGVjaWZ5IHRoZSB2YWx1ZSBvZiBwaWUsXFxuICAgICAgdGhlIHByb3BzIFxcXCJ2YWx1ZUtleVxcXCIgd2lsbCBiZSBkZXByZWNhdGVkIGluIDEuMS4wXCIpO1xuICAgIHJlYWxEYXRhS2V5ID0gdmFsdWVLZXk7XG4gIH1cbiAgdmFyIG5vdFplcm9JdGVtQ291bnQgPSBwaWVEYXRhLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgcmVhbERhdGFLZXksIDApICE9PSAwO1xuICB9KS5sZW5ndGg7XG4gIHZhciB0b3RhbFBhZGluZ0FuZ2xlID0gKGFic0RlbHRhQW5nbGUgPj0gMzYwID8gbm90WmVyb0l0ZW1Db3VudCA6IG5vdFplcm9JdGVtQ291bnQgLSAxKSAqIHBhZGRpbmdBbmdsZTtcbiAgdmFyIHJlYWxUb3RhbEFuZ2xlID0gYWJzRGVsdGFBbmdsZSAtIG5vdFplcm9JdGVtQ291bnQgKiBtaW5BbmdsZSAtIHRvdGFsUGFkaW5nQW5nbGU7XG4gIHZhciBzdW0gPSBwaWVEYXRhLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBlbnRyeSkge1xuICAgIHZhciB2YWwgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0VmFsdWVCeURhdGFLZXkpKGVudHJ5LCByZWFsRGF0YUtleSwgMCk7XG4gICAgcmV0dXJuIHJlc3VsdCArICgoMCwgX0RhdGFVdGlscy5pc051bWJlcikodmFsKSA/IHZhbCA6IDApO1xuICB9LCAwKTtcbiAgdmFyIHNlY3RvcnM7XG4gIGlmIChzdW0gPiAwKSB7XG4gICAgdmFyIHByZXY7XG4gICAgc2VjdG9ycyA9IHBpZURhdGEubWFwKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xuICAgICAgdmFyIHZhbCA9ICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkoZW50cnksIHJlYWxEYXRhS2V5LCAwKTtcbiAgICAgIHZhciBuYW1lID0gKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgbmFtZUtleSwgaSk7XG4gICAgICB2YXIgcGVyY2VudCA9ICgoMCwgX0RhdGFVdGlscy5pc051bWJlcikodmFsKSA/IHZhbCA6IDApIC8gc3VtO1xuICAgICAgdmFyIHRlbXBTdGFydEFuZ2xlO1xuICAgICAgaWYgKGkpIHtcbiAgICAgICAgdGVtcFN0YXJ0QW5nbGUgPSBwcmV2LmVuZEFuZ2xlICsgKDAsIF9EYXRhVXRpbHMubWF0aFNpZ24pKGRlbHRhQW5nbGUpICogcGFkZGluZ0FuZ2xlICogKHZhbCAhPT0gMCA/IDEgOiAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBTdGFydEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICAgIH1cbiAgICAgIHZhciB0ZW1wRW5kQW5nbGUgPSB0ZW1wU3RhcnRBbmdsZSArICgwLCBfRGF0YVV0aWxzLm1hdGhTaWduKShkZWx0YUFuZ2xlKSAqICgodmFsICE9PSAwID8gbWluQW5nbGUgOiAwKSArIHBlcmNlbnQgKiByZWFsVG90YWxBbmdsZSk7XG4gICAgICB2YXIgbWlkQW5nbGUgPSAodGVtcFN0YXJ0QW5nbGUgKyB0ZW1wRW5kQW5nbGUpIC8gMjtcbiAgICAgIHZhciBtaWRkbGVSYWRpdXMgPSAoY29vcmRpbmF0ZS5pbm5lclJhZGl1cyArIGNvb3JkaW5hdGUub3V0ZXJSYWRpdXMpIC8gMjtcbiAgICAgIHZhciB0b29sdGlwUGF5bG9hZCA9IFt7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgIHBheWxvYWQ6IGVudHJ5LFxuICAgICAgICBkYXRhS2V5OiByZWFsRGF0YUtleSxcbiAgICAgICAgdHlwZTogdG9vbHRpcFR5cGVcbiAgICAgIH1dO1xuICAgICAgdmFyIHRvb2x0aXBQb3NpdGlvbiA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjb29yZGluYXRlLmN4LCBjb29yZGluYXRlLmN5LCBtaWRkbGVSYWRpdXMsIG1pZEFuZ2xlKTtcbiAgICAgIHByZXYgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIHBlcmNlbnQ6IHBlcmNlbnQsXG4gICAgICAgIGNvcm5lclJhZGl1czogY29ybmVyUmFkaXVzLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0b29sdGlwUGF5bG9hZDogdG9vbHRpcFBheWxvYWQsXG4gICAgICAgIG1pZEFuZ2xlOiBtaWRBbmdsZSxcbiAgICAgICAgbWlkZGxlUmFkaXVzOiBtaWRkbGVSYWRpdXMsXG4gICAgICAgIHRvb2x0aXBQb3NpdGlvbjogdG9vbHRpcFBvc2l0aW9uXG4gICAgICB9LCBlbnRyeSksIGNvb3JkaW5hdGUpLCB7fSwge1xuICAgICAgICB2YWx1ZTogKDAsIF9DaGFydFV0aWxzLmdldFZhbHVlQnlEYXRhS2V5KShlbnRyeSwgcmVhbERhdGFLZXkpLFxuICAgICAgICBzdGFydEFuZ2xlOiB0ZW1wU3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGU6IHRlbXBFbmRBbmdsZSxcbiAgICAgICAgcGF5bG9hZDogZW50cnksXG4gICAgICAgIHBhZGRpbmdBbmdsZTogKDAsIF9EYXRhVXRpbHMubWF0aFNpZ24pKGRlbHRhQW5nbGUpICogcGFkZGluZ0FuZ2xlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNvb3JkaW5hdGUpLCB7fSwge1xuICAgIHNlY3RvcnM6IHNlY3RvcnMsXG4gICAgZGF0YTogcGllRGF0YVxuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlBpZSIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9yZWFjdFNtb290aCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfZ2V0IiwiX2lzRXF1YWwiLCJfaXNOaWwiLCJfaXNGdW5jdGlvbiIsIl9jbHN4IiwiX0xheWVyIiwiX0N1cnZlIiwiX1RleHQiLCJfTGFiZWwiLCJfTGFiZWxMaXN0IiwiX0NlbGwiLCJfUmVhY3RVdGlscyIsIl9HbG9iYWwiLCJfUG9sYXJVdGlscyIsIl9EYXRhVXRpbHMiLCJfQ2hhcnRVdGlscyIsIl9Mb2dVdGlscyIsIl90eXBlcyIsIl9BY3RpdmVTaGFwZVV0aWxzIiwiX1BpZSIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImFwcGx5Iiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiX1B1cmVDb21wb25lbnQiLCJfdGhpcyIsInVuaXF1ZUlkIiwib25BbmltYXRpb25FbmQiLCJzZXRTdGF0ZSIsImlzQW5pbWF0aW9uRmluaXNoZWQiLCJvbkFuaW1hdGlvblN0YXJ0Iiwic3RhdGUiLCJpc0FuaW1hdGlvbkFjdGl2ZSIsInByZXZJc0FuaW1hdGlvbkFjdGl2ZSIsInByZXZBbmltYXRpb25JZCIsImFuaW1hdGlvbklkIiwic2VjdG9yVG9Gb2N1cyIsImlzQWN0aXZlSW5kZXgiLCJhY3RpdmVJbmRleCIsIkFycmF5IiwiaXNBcnJheSIsImluZGV4T2YiLCJoYXNBY3RpdmVJbmRleCIsInJlbmRlckxhYmVscyIsInNlY3RvcnMiLCJfdGhpcyRwcm9wcyIsImxhYmVsIiwibGFiZWxMaW5lIiwiZGF0YUtleSIsInZhbHVlS2V5IiwicGllUHJvcHMiLCJmaWx0ZXJQcm9wcyIsImN1c3RvbUxhYmVsUHJvcHMiLCJjdXN0b21MYWJlbExpbmVQcm9wcyIsIm9mZnNldFJhZGl1cyIsImxhYmVscyIsIm1hcCIsImVudHJ5IiwibWlkQW5nbGUiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJlbmRQb2ludCIsInBvbGFyVG9DYXJ0ZXNpYW4iLCJjeCIsImN5Iiwib3V0ZXJSYWRpdXMiLCJsYWJlbFByb3BzIiwic3Ryb2tlIiwiaW5kZXgiLCJ0ZXh0QW5jaG9yIiwiZ2V0VGV4dEFuY2hvciIsIngiLCJsaW5lUHJvcHMiLCJmaWxsIiwicG9pbnRzIiwicmVhbERhdGFLZXkiLCJjcmVhdGVFbGVtZW50IiwiTGF5ZXIiLCJjb25jYXQiLCJyZW5kZXJMYWJlbExpbmVJdGVtIiwicmVuZGVyTGFiZWxJdGVtIiwiZ2V0VmFsdWVCeURhdGFLZXkiLCJjbGFzc05hbWUiLCJyZW5kZXJTZWN0b3JzU3RhdGljYWxseSIsIl90aGlzMiIsIl90aGlzJHByb3BzMiIsImFjdGl2ZVNoYXBlIiwiYmxlbmRTdHJva2UiLCJpbmFjdGl2ZVNoYXBlUHJvcCIsImluYWN0aXZlU2hhcGUiLCJpc0FjdGl2ZSIsInNlY3Rvck9wdGlvbnMiLCJzZWN0b3JQcm9wcyIsInRhYkluZGV4IiwicmVmIiwiX3JlZiIsInNlY3RvclJlZnMiLCJpbmNsdWRlcyIsImFkYXB0RXZlbnRzT2ZDaGlsZCIsIlNoYXBlIiwib3B0aW9uIiwic2hhcGVUeXBlIiwicmVuZGVyU2VjdG9yc1dpdGhBbmltYXRpb24iLCJfdGhpczMiLCJfdGhpcyRwcm9wczMiLCJhbmltYXRpb25CZWdpbiIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRWFzaW5nIiwiX3RoaXMkc3RhdGUiLCJwcmV2U2VjdG9ycyIsImJlZ2luIiwiZHVyYXRpb24iLCJlYXNpbmciLCJmcm9tIiwidG8iLCJoYW5kbGVBbmltYXRpb25TdGFydCIsImhhbmRsZUFuaW1hdGlvbkVuZCIsIl9yZWYyIiwic3RlcERhdGEiLCJmaXJzdCIsImN1ckFuZ2xlIiwicHJldiIsInBhZGRpbmdBbmdsZSIsImFuZ2xlSXAiLCJpbnRlcnBvbGF0ZU51bWJlciIsImxhdGVzdCIsImludGVycG9sYXRvckFuZ2xlIiwiZGVsdGFBbmdsZSIsIl9sYXRlc3QiLCJhdHRhY2hLZXlib2FyZEhhbmRsZXJzIiwicGllUmVmIiwiX3RoaXM0Iiwib25rZXlkb3duIiwiYWx0S2V5IiwibmV4dCIsImZvY3VzIiwiX25leHQiLCJibHVyIiwicmVuZGVyU2VjdG9ycyIsIl90aGlzJHByb3BzNCIsImNvbXBvbmVudERpZE1vdW50IiwicmVuZGVyIiwiX3RoaXM1IiwiX3RoaXMkcHJvcHM1IiwiaGlkZSIsImlubmVyUmFkaXVzIiwiaXNOdW1iZXIiLCJsYXllckNsYXNzIiwicm9vdFRhYkluZGV4IiwiX3JlZjMiLCJMYWJlbCIsInJlbmRlckNhbGxCeVBhcmVudCIsIkxhYmVsTGlzdCIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIm5leHRQcm9wcyIsInByZXZTdGF0ZSIsImN1clNlY3RvcnMiLCJpc1ZhbGlkRWxlbWVudCIsImNsb25lRWxlbWVudCIsIkN1cnZlIiwidHlwZSIsIlRleHQiLCJhbGlnbm1lbnRCYXNlbGluZSIsIlB1cmVDb21wb25lbnQiLCJsZWdlbmRUeXBlIiwibWluQW5nbGUiLCJHbG9iYWwiLCJpc1NzciIsIm5hbWVLZXkiLCJzaWduIiwibWF0aFNpZ24iLCJNYXRoIiwibWluIiwiYWJzIiwiaXRlbVByb3BzIiwiZGF0YSIsImNoaWxkcmVuIiwicHJlc2VudGF0aW9uUHJvcHMiLCJjZWxscyIsImZpbmRBbGxCeVR5cGUiLCJDZWxsIiwicGF5bG9hZCIsImNlbGwiLCJvZmZzZXQiLCJ0b3AiLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJtYXhQaWVSYWRpdXMiLCJnZXRNYXhSYWRpdXMiLCJnZXRQZXJjZW50VmFsdWUiLCJtYXhSYWRpdXMiLCJzcXJ0IiwiX3JlZjQiLCJpdGVtIiwiZGVmYXVsdFByb3BzIiwidW5kZWZpbmVkIiwicGllRGF0YSIsImdldFJlYWxQaWVEYXRhIiwiY29ybmVyUmFkaXVzIiwidG9vbHRpcFR5cGUiLCJjb29yZGluYXRlIiwicGFyc2VDb29yZGluYXRlT2ZQaWUiLCJwYXJzZURlbHRhQW5nbGUiLCJhYnNEZWx0YUFuZ2xlIiwid2FybiIsIm5vdFplcm9JdGVtQ291bnQiLCJ0b3RhbFBhZGluZ0FuZ2xlIiwicmVhbFRvdGFsQW5nbGUiLCJzdW0iLCJyZWR1Y2UiLCJyZXN1bHQiLCJ2YWwiLCJuYW1lIiwicGVyY2VudCIsInRlbXBTdGFydEFuZ2xlIiwidGVtcEVuZEFuZ2xlIiwibWlkZGxlUmFkaXVzIiwidG9vbHRpcFBheWxvYWQiLCJ0b29sdGlwUG9zaXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/polar/Pie.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/polar/PolarAngleAxis.js":
/*!***********************************************************!*\
  !*** ./node_modules/recharts/lib/polar/PolarAngleAxis.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PolarAngleAxis = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _Dot = __webpack_require__(/*! ../shape/Dot */ \"./node_modules/recharts/lib/shape/Dot.js\");\nvar _Polygon = __webpack_require__(/*! ../shape/Polygon */ \"./node_modules/recharts/lib/shape/Polygon.js\");\nvar _Text = __webpack_require__(/*! ../component/Text */ \"./node_modules/recharts/lib/component/Text.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"./node_modules/recharts/lib/util/types.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"./node_modules/recharts/lib/util/PolarUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Axis of radial direction\n */ \nvar RADIAN = Math.PI / 180;\nvar eps = 1e-5;\nvar PolarAngleAxis = exports.PolarAngleAxis = /*#__PURE__*/ function(_PureComponent) {\n    function PolarAngleAxis() {\n        _classCallCheck(this, PolarAngleAxis);\n        return _callSuper(this, PolarAngleAxis, arguments);\n    }\n    _inherits(PolarAngleAxis, _PureComponent);\n    return _createClass(PolarAngleAxis, [\n        {\n            key: \"getTickLineCoord\",\n            value: /**\n     * Calculate the coordinate of line endpoint\n     * @param  {Object} data The Data if ticks\n     * @return {Object} (x0, y0): The start point of text,\n     *                  (x1, y1): The end point close to text,\n     *                  (x2, y2): The end point close to axis\n     */ function getTickLineCoord(data) {\n                var _this$props = this.props, cx = _this$props.cx, cy = _this$props.cy, radius = _this$props.radius, orientation = _this$props.orientation, tickSize = _this$props.tickSize;\n                var tickLineSize = tickSize || 8;\n                var p1 = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, data.coordinate);\n                var p2 = (0, _PolarUtils.polarToCartesian)(cx, cy, radius + (orientation === \"inner\" ? -1 : 1) * tickLineSize, data.coordinate);\n                return {\n                    x1: p1.x,\n                    y1: p1.y,\n                    x2: p2.x,\n                    y2: p2.y\n                };\n            }\n        },\n        {\n            key: \"getTickTextAnchor\",\n            value: function getTickTextAnchor(data) {\n                var orientation = this.props.orientation;\n                var cos = Math.cos(-data.coordinate * RADIAN);\n                var textAnchor;\n                if (cos > eps) {\n                    textAnchor = orientation === \"outer\" ? \"start\" : \"end\";\n                } else if (cos < -eps) {\n                    textAnchor = orientation === \"outer\" ? \"end\" : \"start\";\n                } else {\n                    textAnchor = \"middle\";\n                }\n                return textAnchor;\n            }\n        },\n        {\n            key: \"renderAxisLine\",\n            value: function renderAxisLine() {\n                var _this$props2 = this.props, cx = _this$props2.cx, cy = _this$props2.cy, radius = _this$props2.radius, axisLine = _this$props2.axisLine, axisLineType = _this$props2.axisLineType;\n                var props = _objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(this.props, false)), {}, {\n                    fill: \"none\"\n                }, (0, _ReactUtils.filterProps)(axisLine, false));\n                if (axisLineType === \"circle\") {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Dot.Dot, _extends({\n                        className: \"recharts-polar-angle-axis-line\"\n                    }, props, {\n                        cx: cx,\n                        cy: cy,\n                        r: radius\n                    }));\n                }\n                var ticks = this.props.ticks;\n                var points = ticks.map(function(entry) {\n                    return (0, _PolarUtils.polarToCartesian)(cx, cy, radius, entry.coordinate);\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Polygon.Polygon, _extends({\n                    className: \"recharts-polar-angle-axis-line\"\n                }, props, {\n                    points: points\n                }));\n            }\n        },\n        {\n            key: \"renderTicks\",\n            value: function renderTicks() {\n                var _this = this;\n                var _this$props3 = this.props, ticks = _this$props3.ticks, tick = _this$props3.tick, tickLine = _this$props3.tickLine, tickFormatter = _this$props3.tickFormatter, stroke = _this$props3.stroke;\n                var axisProps = (0, _ReactUtils.filterProps)(this.props, false);\n                var customTickProps = (0, _ReactUtils.filterProps)(tick, false);\n                var tickLineProps = _objectSpread(_objectSpread({}, axisProps), {}, {\n                    fill: \"none\"\n                }, (0, _ReactUtils.filterProps)(tickLine, false));\n                var items = ticks.map(function(entry, i) {\n                    var lineCoord = _this.getTickLineCoord(entry);\n                    var textAnchor = _this.getTickTextAnchor(entry);\n                    var tickProps = _objectSpread(_objectSpread(_objectSpread({\n                        textAnchor: textAnchor\n                    }, axisProps), {}, {\n                        stroke: \"none\",\n                        fill: stroke\n                    }, customTickProps), {}, {\n                        index: i,\n                        payload: entry,\n                        x: lineCoord.x2,\n                        y: lineCoord.y2\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        className: (0, _clsx[\"default\"])(\"recharts-polar-angle-axis-tick\", (0, _PolarUtils.getTickClassName)(tick)),\n                        key: \"tick-\".concat(entry.coordinate)\n                    }, (0, _types.adaptEventsOfChild)(_this.props, entry, i)), tickLine && /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({\n                        className: \"recharts-polar-angle-axis-tick-line\"\n                    }, tickLineProps, lineCoord)), tick && PolarAngleAxis.renderTickItem(tick, tickProps, tickFormatter ? tickFormatter(entry.value, i) : entry.value));\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-polar-angle-axis-ticks\"\n                }, items);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props4 = this.props, ticks = _this$props4.ticks, radius = _this$props4.radius, axisLine = _this$props4.axisLine;\n                if (radius <= 0 || !ticks || !ticks.length) {\n                    return null;\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: (0, _clsx[\"default\"])(\"recharts-polar-angle-axis\", this.props.className)\n                }, axisLine && this.renderAxisLine(), this.renderTicks());\n            }\n        }\n    ], [\n        {\n            key: \"renderTickItem\",\n            value: function renderTickItem(option, props, value) {\n                var tickItem;\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    tickItem = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                } else if ((0, _isFunction[\"default\"])(option)) {\n                    tickItem = option(props);\n                } else {\n                    tickItem = /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({}, props, {\n                        className: \"recharts-polar-angle-axis-tick-value\"\n                    }), value);\n                }\n                return tickItem;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(PolarAngleAxis, \"displayName\", \"PolarAngleAxis\");\n_defineProperty(PolarAngleAxis, \"axisType\", \"angleAxis\");\n_defineProperty(PolarAngleAxis, \"defaultProps\", {\n    type: \"category\",\n    angleAxisId: 0,\n    scale: \"auto\",\n    cx: 0,\n    cy: 0,\n    orientation: \"outer\",\n    axisLine: true,\n    tickLine: true,\n    tickSize: 8,\n    tick: true,\n    hide: false,\n    allowDuplicatedCategory: true\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3BvbGFyL1BvbGFyQW5nbGVBeGlzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCLElBQUlHLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsY0FBY0MsdUJBQXVCRixtQkFBT0EsQ0FBQyw0Q0FBbUI7QUFDcEUsSUFBSUcsUUFBUUQsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQkFBTTtBQUNqRCxJQUFJSSxTQUFTSixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDekMsSUFBSUssT0FBT0wsbUJBQU9BLENBQUMsOERBQWM7QUFDakMsSUFBSU0sV0FBV04sbUJBQU9BLENBQUMsc0VBQWtCO0FBQ3pDLElBQUlPLFFBQVFQLG1CQUFPQSxDQUFDLHdFQUFtQjtBQUN2QyxJQUFJUSxTQUFTUixtQkFBT0EsQ0FBQyxnRUFBZTtBQUNwQyxJQUFJUyxjQUFjVCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSVUsY0FBY1YsbUJBQU9BLENBQUMsMEVBQW9CO0FBQzlDLFNBQVNFLHVCQUF1QlMsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSx5QkFBeUJDLENBQUM7SUFBSSxJQUFJLGNBQWMsT0FBT0MsU0FBUyxPQUFPO0lBQU0sSUFBSUMsSUFBSSxJQUFJRCxXQUFXRSxJQUFJLElBQUlGO0lBQVcsT0FBTyxDQUFDRiwyQkFBMkIsU0FBU0EseUJBQXlCQyxDQUFDO1FBQUksT0FBT0EsSUFBSUcsSUFBSUQ7SUFBRyxHQUFHRjtBQUFJO0FBQ25PLFNBQVNmLHdCQUF3QmUsQ0FBQyxFQUFFRSxDQUFDO0lBQUksSUFBSSxDQUFDQSxLQUFLRixLQUFLQSxFQUFFRixVQUFVLEVBQUUsT0FBT0U7SUFBRyxJQUFJ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QyxHQUFHeUIsT0FBTzt3QkFDdEZrRSxXQUFXO29CQUNiLElBQUlsSTtnQkFDTjtnQkFDQSxPQUFPK0o7WUFDVDtRQUNGO0tBQUU7QUFDSixFQUFFN0osT0FBT2lLLGFBQWE7QUFDdEIzRyxnQkFBZ0J2RCxnQkFBZ0IsZUFBZTtBQUMvQ3VELGdCQUFnQnZELGdCQUFnQixZQUFZO0FBQzVDdUQsZ0JBQWdCdkQsZ0JBQWdCLGdCQUFnQjtJQUM5Q21LLE1BQU07SUFDTkMsYUFBYTtJQUNiQyxPQUFPO0lBQ1AvRCxJQUFJO0lBQ0pDLElBQUk7SUFDSkUsYUFBYTtJQUNia0IsVUFBVTtJQUNWZ0IsVUFBVTtJQUNWakMsVUFBVTtJQUNWZ0MsTUFBTTtJQUNONEIsTUFBTTtJQUNOQyx5QkFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3BvbGFyL1BvbGFyQW5nbGVBeGlzLmpzP2M0NzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlBvbGFyQW5nbGVBeGlzID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfTGF5ZXIgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0xheWVyXCIpO1xudmFyIF9Eb3QgPSByZXF1aXJlKFwiLi4vc2hhcGUvRG90XCIpO1xudmFyIF9Qb2x5Z29uID0gcmVxdWlyZShcIi4uL3NoYXBlL1BvbHlnb25cIik7XG52YXIgX1RleHQgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L1RleHRcIik7XG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4uL3V0aWwvdHlwZXNcIik7XG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xudmFyIF9Qb2xhclV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUG9sYXJVdGlsc1wiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKipcbiAqIEBmaWxlT3ZlcnZpZXcgQXhpcyBvZiByYWRpYWwgZGlyZWN0aW9uXG4gKi9cbnZhciBSQURJQU4gPSBNYXRoLlBJIC8gMTgwO1xudmFyIGVwcyA9IDFlLTU7XG52YXIgUG9sYXJBbmdsZUF4aXMgPSBleHBvcnRzLlBvbGFyQW5nbGVBeGlzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBmdW5jdGlvbiBQb2xhckFuZ2xlQXhpcygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9sYXJBbmdsZUF4aXMpO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIFBvbGFyQW5nbGVBeGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhQb2xhckFuZ2xlQXhpcywgX1B1cmVDb21wb25lbnQpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFBvbGFyQW5nbGVBeGlzLCBbe1xuICAgIGtleTogXCJnZXRUaWNrTGluZUNvb3JkXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb29yZGluYXRlIG9mIGxpbmUgZW5kcG9pbnRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgVGhlIERhdGEgaWYgdGlja3NcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICh4MCwgeTApOiBUaGUgc3RhcnQgcG9pbnQgb2YgdGV4dCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICh4MSwgeTEpOiBUaGUgZW5kIHBvaW50IGNsb3NlIHRvIHRleHQsXG4gICAgICogICAgICAgICAgICAgICAgICAoeDIsIHkyKTogVGhlIGVuZCBwb2ludCBjbG9zZSB0byBheGlzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VGlja0xpbmVDb29yZChkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjeCA9IF90aGlzJHByb3BzLmN4LFxuICAgICAgICBjeSA9IF90aGlzJHByb3BzLmN5LFxuICAgICAgICByYWRpdXMgPSBfdGhpcyRwcm9wcy5yYWRpdXMsXG4gICAgICAgIG9yaWVudGF0aW9uID0gX3RoaXMkcHJvcHMub3JpZW50YXRpb24sXG4gICAgICAgIHRpY2tTaXplID0gX3RoaXMkcHJvcHMudGlja1NpemU7XG4gICAgICB2YXIgdGlja0xpbmVTaXplID0gdGlja1NpemUgfHwgODtcbiAgICAgIHZhciBwMSA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIHJhZGl1cywgZGF0YS5jb29yZGluYXRlKTtcbiAgICAgIHZhciBwMiA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIHJhZGl1cyArIChvcmllbnRhdGlvbiA9PT0gJ2lubmVyJyA/IC0xIDogMSkgKiB0aWNrTGluZVNpemUsIGRhdGEuY29vcmRpbmF0ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogcDEueCxcbiAgICAgICAgeTE6IHAxLnksXG4gICAgICAgIHgyOiBwMi54LFxuICAgICAgICB5MjogcDIueVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRleHQtYW5jaG9yIG9mIGVhY2ggdGlja1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBEYXRhIG9mIHRpY2tzXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0ZXh0LWFuY2hvclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFRpY2tUZXh0QW5jaG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpY2tUZXh0QW5jaG9yKGRhdGEpIHtcbiAgICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMucHJvcHMub3JpZW50YXRpb247XG4gICAgICB2YXIgY29zID0gTWF0aC5jb3MoLWRhdGEuY29vcmRpbmF0ZSAqIFJBRElBTik7XG4gICAgICB2YXIgdGV4dEFuY2hvcjtcbiAgICAgIGlmIChjb3MgPiBlcHMpIHtcbiAgICAgICAgdGV4dEFuY2hvciA9IG9yaWVudGF0aW9uID09PSAnb3V0ZXInID8gJ3N0YXJ0JyA6ICdlbmQnO1xuICAgICAgfSBlbHNlIGlmIChjb3MgPCAtZXBzKSB7XG4gICAgICAgIHRleHRBbmNob3IgPSBvcmllbnRhdGlvbiA9PT0gJ291dGVyJyA/ICdlbmQnIDogJ3N0YXJ0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHRBbmNob3IgPSAnbWlkZGxlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0QW5jaG9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJBeGlzTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJBeGlzTGluZSgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBjeCA9IF90aGlzJHByb3BzMi5jeCxcbiAgICAgICAgY3kgPSBfdGhpcyRwcm9wczIuY3ksXG4gICAgICAgIHJhZGl1cyA9IF90aGlzJHByb3BzMi5yYWRpdXMsXG4gICAgICAgIGF4aXNMaW5lID0gX3RoaXMkcHJvcHMyLmF4aXNMaW5lLFxuICAgICAgICBheGlzTGluZVR5cGUgPSBfdGhpcyRwcm9wczIuYXhpc0xpbmVUeXBlO1xuICAgICAgdmFyIHByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIGZhbHNlKSksIHt9LCB7XG4gICAgICAgIGZpbGw6ICdub25lJ1xuICAgICAgfSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShheGlzTGluZSwgZmFsc2UpKTtcbiAgICAgIGlmIChheGlzTGluZVR5cGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9Eb3QuRG90LCBfZXh0ZW5kcyh7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXBvbGFyLWFuZ2xlLWF4aXMtbGluZVwiXG4gICAgICAgIH0sIHByb3BzLCB7XG4gICAgICAgICAgY3g6IGN4LFxuICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICByOiByYWRpdXNcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgdmFyIHRpY2tzID0gdGhpcy5wcm9wcy50aWNrcztcbiAgICAgIHZhciBwb2ludHMgPSB0aWNrcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCByYWRpdXMsIGVudHJ5LmNvb3JkaW5hdGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfUG9seWdvbi5Qb2x5Z29uLCBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1wb2xhci1hbmdsZS1heGlzLWxpbmVcIlxuICAgICAgfSwgcHJvcHMsIHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyVGlja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVGlja3MoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHRpY2tzID0gX3RoaXMkcHJvcHMzLnRpY2tzLFxuICAgICAgICB0aWNrID0gX3RoaXMkcHJvcHMzLnRpY2ssXG4gICAgICAgIHRpY2tMaW5lID0gX3RoaXMkcHJvcHMzLnRpY2tMaW5lLFxuICAgICAgICB0aWNrRm9ybWF0dGVyID0gX3RoaXMkcHJvcHMzLnRpY2tGb3JtYXR0ZXIsXG4gICAgICAgIHN0cm9rZSA9IF90aGlzJHByb3BzMy5zdHJva2U7XG4gICAgICB2YXIgYXhpc1Byb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aGlzLnByb3BzLCBmYWxzZSk7XG4gICAgICB2YXIgY3VzdG9tVGlja1Byb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aWNrLCBmYWxzZSk7XG4gICAgICB2YXIgdGlja0xpbmVQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYXhpc1Byb3BzKSwge30sIHtcbiAgICAgICAgZmlsbDogJ25vbmUnXG4gICAgICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRpY2tMaW5lLCBmYWxzZSkpO1xuICAgICAgdmFyIGl0ZW1zID0gdGlja3MubWFwKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xuICAgICAgICB2YXIgbGluZUNvb3JkID0gX3RoaXMuZ2V0VGlja0xpbmVDb29yZChlbnRyeSk7XG4gICAgICAgIHZhciB0ZXh0QW5jaG9yID0gX3RoaXMuZ2V0VGlja1RleHRBbmNob3IoZW50cnkpO1xuICAgICAgICB2YXIgdGlja1Byb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3JcbiAgICAgICAgfSwgYXhpc1Byb3BzKSwge30sIHtcbiAgICAgICAgICBzdHJva2U6ICdub25lJyxcbiAgICAgICAgICBmaWxsOiBzdHJva2VcbiAgICAgICAgfSwgY3VzdG9tVGlja1Byb3BzKSwge30sIHtcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBwYXlsb2FkOiBlbnRyeSxcbiAgICAgICAgICB4OiBsaW5lQ29vcmQueDIsXG4gICAgICAgICAgeTogbGluZUNvb3JkLnkyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIF9leHRlbmRzKHtcbiAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1wb2xhci1hbmdsZS1heGlzLXRpY2snLCAoMCwgX1BvbGFyVXRpbHMuZ2V0VGlja0NsYXNzTmFtZSkodGljaykpLFxuICAgICAgICAgIGtleTogXCJ0aWNrLVwiLmNvbmNhdChlbnRyeS5jb29yZGluYXRlKVxuICAgICAgICB9LCAoMCwgX3R5cGVzLmFkYXB0RXZlbnRzT2ZDaGlsZCkoX3RoaXMucHJvcHMsIGVudHJ5LCBpKSksIHRpY2tMaW5lICYmIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIF9leHRlbmRzKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtcG9sYXItYW5nbGUtYXhpcy10aWNrLWxpbmVcIlxuICAgICAgICB9LCB0aWNrTGluZVByb3BzLCBsaW5lQ29vcmQpKSwgdGljayAmJiBQb2xhckFuZ2xlQXhpcy5yZW5kZXJUaWNrSXRlbSh0aWNrLCB0aWNrUHJvcHMsIHRpY2tGb3JtYXR0ZXIgPyB0aWNrRm9ybWF0dGVyKGVudHJ5LnZhbHVlLCBpKSA6IGVudHJ5LnZhbHVlKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtcG9sYXItYW5nbGUtYXhpcy10aWNrc1wiXG4gICAgICB9LCBpdGVtcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgdGlja3MgPSBfdGhpcyRwcm9wczQudGlja3MsXG4gICAgICAgIHJhZGl1cyA9IF90aGlzJHByb3BzNC5yYWRpdXMsXG4gICAgICAgIGF4aXNMaW5lID0gX3RoaXMkcHJvcHM0LmF4aXNMaW5lO1xuICAgICAgaWYgKHJhZGl1cyA8PSAwIHx8ICF0aWNrcyB8fCAhdGlja3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XG4gICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXBvbGFyLWFuZ2xlLWF4aXMnLCB0aGlzLnByb3BzLmNsYXNzTmFtZSlcbiAgICAgIH0sIGF4aXNMaW5lICYmIHRoaXMucmVuZGVyQXhpc0xpbmUoKSwgdGhpcy5yZW5kZXJUaWNrcygpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJyZW5kZXJUaWNrSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJUaWNrSXRlbShvcHRpb24sIHByb3BzLCB2YWx1ZSkge1xuICAgICAgdmFyIHRpY2tJdGVtO1xuICAgICAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChvcHRpb24pKSB7XG4gICAgICAgIHRpY2tJdGVtID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KG9wdGlvbiwgcHJvcHMpO1xuICAgICAgfSBlbHNlIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvcHRpb24pKSB7XG4gICAgICAgIHRpY2tJdGVtID0gb3B0aW9uKHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpY2tJdGVtID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfVGV4dC5UZXh0LCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtcG9sYXItYW5nbGUtYXhpcy10aWNrLXZhbHVlXCJcbiAgICAgICAgfSksIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aWNrSXRlbTtcbiAgICB9XG4gIH1dKTtcbn0oX3JlYWN0LlB1cmVDb21wb25lbnQpO1xuX2RlZmluZVByb3BlcnR5KFBvbGFyQW5nbGVBeGlzLCBcImRpc3BsYXlOYW1lXCIsICdQb2xhckFuZ2xlQXhpcycpO1xuX2RlZmluZVByb3BlcnR5KFBvbGFyQW5nbGVBeGlzLCBcImF4aXNUeXBlXCIsICdhbmdsZUF4aXMnKTtcbl9kZWZpbmVQcm9wZXJ0eShQb2xhckFuZ2xlQXhpcywgXCJkZWZhdWx0UHJvcHNcIiwge1xuICB0eXBlOiAnY2F0ZWdvcnknLFxuICBhbmdsZUF4aXNJZDogMCxcbiAgc2NhbGU6ICdhdXRvJyxcbiAgY3g6IDAsXG4gIGN5OiAwLFxuICBvcmllbnRhdGlvbjogJ291dGVyJyxcbiAgYXhpc0xpbmU6IHRydWUsXG4gIHRpY2tMaW5lOiB0cnVlLFxuICB0aWNrU2l6ZTogOCxcbiAgdGljazogdHJ1ZSxcbiAgaGlkZTogZmFsc2UsXG4gIGFsbG93RHVwbGljYXRlZENhdGVnb3J5OiB0cnVlXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQb2xhckFuZ2xlQXhpcyIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9pc0Z1bmN0aW9uIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9jbHN4IiwiX0xheWVyIiwiX0RvdCIsIl9Qb2x5Z29uIiwiX1RleHQiLCJfdHlwZXMiLCJfUmVhY3RVdGlscyIsIl9Qb2xhclV0aWxzIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfdHlwZW9mIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaSIsInNldCIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiYXBwbHkiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJCb29sZWFuIiwidmFsdWVPZiIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJSQURJQU4iLCJNYXRoIiwiUEkiLCJlcHMiLCJfUHVyZUNvbXBvbmVudCIsImdldFRpY2tMaW5lQ29vcmQiLCJkYXRhIiwiX3RoaXMkcHJvcHMiLCJjeCIsImN5IiwicmFkaXVzIiwib3JpZW50YXRpb24iLCJ0aWNrU2l6ZSIsInRpY2tMaW5lU2l6ZSIsInAxIiwicG9sYXJUb0NhcnRlc2lhbiIsImNvb3JkaW5hdGUiLCJwMiIsIngxIiwieCIsInkxIiwieSIsIngyIiwieTIiLCJnZXRUaWNrVGV4dEFuY2hvciIsImNvcyIsInRleHRBbmNob3IiLCJyZW5kZXJBeGlzTGluZSIsIl90aGlzJHByb3BzMiIsImF4aXNMaW5lIiwiYXhpc0xpbmVUeXBlIiwiZmlsdGVyUHJvcHMiLCJmaWxsIiwiY3JlYXRlRWxlbWVudCIsIkRvdCIsImNsYXNzTmFtZSIsInRpY2tzIiwicG9pbnRzIiwibWFwIiwiZW50cnkiLCJQb2x5Z29uIiwicmVuZGVyVGlja3MiLCJfdGhpcyIsIl90aGlzJHByb3BzMyIsInRpY2siLCJ0aWNrTGluZSIsInRpY2tGb3JtYXR0ZXIiLCJzdHJva2UiLCJheGlzUHJvcHMiLCJjdXN0b21UaWNrUHJvcHMiLCJ0aWNrTGluZVByb3BzIiwiaXRlbXMiLCJsaW5lQ29vcmQiLCJ0aWNrUHJvcHMiLCJpbmRleCIsInBheWxvYWQiLCJMYXllciIsImdldFRpY2tDbGFzc05hbWUiLCJjb25jYXQiLCJhZGFwdEV2ZW50c09mQ2hpbGQiLCJyZW5kZXJUaWNrSXRlbSIsInJlbmRlciIsIl90aGlzJHByb3BzNCIsIm9wdGlvbiIsInRpY2tJdGVtIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJUZXh0IiwiUHVyZUNvbXBvbmVudCIsInR5cGUiLCJhbmdsZUF4aXNJZCIsInNjYWxlIiwiaGlkZSIsImFsbG93RHVwbGljYXRlZENhdGVnb3J5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/polar/PolarAngleAxis.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/polar/PolarGrid.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/polar/PolarGrid.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PolarGrid = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"cx\",\n    \"cy\",\n    \"innerRadius\",\n    \"outerRadius\",\n    \"gridType\",\n    \"radialLines\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Polar Grid\n */ \nvar getPolygonPath = function getPolygonPath(radius, cx, cy, polarAngles) {\n    var path = \"\";\n    polarAngles.forEach(function(angle, i) {\n        var point = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, angle);\n        if (i) {\n            path += \"L \".concat(point.x, \",\").concat(point.y);\n        } else {\n            path += \"M \".concat(point.x, \",\").concat(point.y);\n        }\n    });\n    path += \"Z\";\n    return path;\n};\n// Draw axis of radial line\nvar PolarAngles = function PolarAngles(props) {\n    var cx = props.cx, cy = props.cy, innerRadius = props.innerRadius, outerRadius = props.outerRadius, polarAngles = props.polarAngles, radialLines = props.radialLines;\n    if (!polarAngles || !polarAngles.length || !radialLines) {\n        return null;\n    }\n    var polarAnglesProps = _objectSpread({\n        stroke: \"#ccc\"\n    }, (0, _ReactUtils.filterProps)(props, false));\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-polar-grid-angle\"\n    }, polarAngles.map(function(entry) {\n        var start = (0, _PolarUtils.polarToCartesian)(cx, cy, innerRadius, entry);\n        var end = (0, _PolarUtils.polarToCartesian)(cx, cy, outerRadius, entry);\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({}, polarAnglesProps, {\n            key: \"line-\".concat(entry),\n            x1: start.x,\n            y1: start.y,\n            x2: end.x,\n            y2: end.y\n        }));\n    }));\n};\n// Draw concentric circles\nvar ConcentricCircle = function ConcentricCircle(props) {\n    var cx = props.cx, cy = props.cy, radius = props.radius, index = props.index;\n    var concentricCircleProps = _objectSpread(_objectSpread({\n        stroke: \"#ccc\"\n    }, (0, _ReactUtils.filterProps)(props, false)), {}, {\n        fill: \"none\"\n    });\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"circle\", _extends({}, concentricCircleProps, {\n        className: (0, _clsx[\"default\"])(\"recharts-polar-grid-concentric-circle\", props.className),\n        key: \"circle-\".concat(index),\n        cx: cx,\n        cy: cy,\n        r: radius\n    }));\n};\n// Draw concentric polygons\nvar ConcentricPolygon = function ConcentricPolygon(props) {\n    var radius = props.radius, index = props.index;\n    var concentricPolygonProps = _objectSpread(_objectSpread({\n        stroke: \"#ccc\"\n    }, (0, _ReactUtils.filterProps)(props, false)), {}, {\n        fill: \"none\"\n    });\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, concentricPolygonProps, {\n        className: (0, _clsx[\"default\"])(\"recharts-polar-grid-concentric-polygon\", props.className),\n        key: \"path-\".concat(index),\n        d: getPolygonPath(radius, props.cx, props.cy, props.polarAngles)\n    }));\n};\n// Draw concentric axis\n// TODO Optimize the name\nvar ConcentricPath = function ConcentricPath(props) {\n    var polarRadius = props.polarRadius, gridType = props.gridType;\n    if (!polarRadius || !polarRadius.length) {\n        return null;\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-polar-grid-concentric\"\n    }, polarRadius.map(function(entry, i) {\n        var key = i;\n        if (gridType === \"circle\") return /*#__PURE__*/ _react[\"default\"].createElement(ConcentricCircle, _extends({\n            key: key\n        }, props, {\n            radius: entry,\n            index: i\n        }));\n        return /*#__PURE__*/ _react[\"default\"].createElement(ConcentricPolygon, _extends({\n            key: key\n        }, props, {\n            radius: entry,\n            index: i\n        }));\n    }));\n};\nvar PolarGrid = exports.PolarGrid = function PolarGrid(_ref) {\n    var _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? 0 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? 0 : _ref$cy, _ref$innerRadius = _ref.innerRadius, innerRadius = _ref$innerRadius === void 0 ? 0 : _ref$innerRadius, _ref$outerRadius = _ref.outerRadius, outerRadius = _ref$outerRadius === void 0 ? 0 : _ref$outerRadius, _ref$gridType = _ref.gridType, gridType = _ref$gridType === void 0 ? \"polygon\" : _ref$gridType, _ref$radialLines = _ref.radialLines, radialLines = _ref$radialLines === void 0 ? true : _ref$radialLines, props = _objectWithoutProperties(_ref, _excluded);\n    if (outerRadius <= 0) {\n        return null;\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n        className: \"recharts-polar-grid\"\n    }, /*#__PURE__*/ _react[\"default\"].createElement(PolarAngles, _extends({\n        cx: cx,\n        cy: cy,\n        innerRadius: innerRadius,\n        outerRadius: outerRadius,\n        gridType: gridType,\n        radialLines: radialLines\n    }, props)), /*#__PURE__*/ _react[\"default\"].createElement(ConcentricPath, _extends({\n        cx: cx,\n        cy: cy,\n        innerRadius: innerRadius,\n        outerRadius: outerRadius,\n        gridType: gridType,\n        radialLines: radialLines\n    }, props)));\n};\nPolarGrid.displayName = \"PolarGrid\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3BvbGFyL1BvbGFyR3JpZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixJQUFJRyxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ25ELElBQUlDLFFBQVFGLHVCQUF1QkMsbUJBQU9BLENBQUMsa0JBQU07QUFDakQsSUFBSUUsY0FBY0YsbUJBQU9BLENBQUMsMEVBQW9CO0FBQzlDLElBQUlHLGNBQWNILG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJSSxZQUFZO0lBQUM7SUFBTTtJQUFNO0lBQWU7SUFBZTtJQUFZO0NBQWM7QUFDckYsU0FBU0wsdUJBQXVCTSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSyx5QkFBeUJDLE1BQU0sRUFBRUMsUUFBUTtJQUFJLElBQUlELFVBQVUsTUFBTSxPQUFPLENBQUM7SUFBRyxJQUFJRSxTQUFTQyw4QkFBOEJILFFBQVFDO0lBQVcsSUFBSUcsS0FBS0M7SUFBRyxJQUFJMUIsT0FBTzJCLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsbUJBQW1CNUIsT0FBTzJCLHFCQUFxQixDQUFDTjtRQUFTLElBQUtLLElBQUksR0FB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SzFCLFdBQVcsRUFDbkNBLGNBQWM2QixxQkFBcUIsS0FBSyxJQUFJLElBQUlBLGtCQUNoREMsbUJBQW1CSixLQUFLekIsV0FBVyxFQUNuQ0EsY0FBYzZCLHFCQUFxQixLQUFLLElBQUksSUFBSUEsa0JBQ2hEQyxnQkFBZ0JMLEtBQUtELFFBQVEsRUFDN0JBLFdBQVdNLGtCQUFrQixLQUFLLElBQUksWUFBWUEsZUFDbERDLG1CQUFtQk4sS0FBS3hCLFdBQVcsRUFDbkNBLGNBQWM4QixxQkFBcUIsS0FBSyxJQUFJLE9BQU9BLGtCQUNuRGpDLFFBQVF0RCx5QkFBeUJpRixNQUFNMUY7SUFDekMsSUFBSWlFLGVBQWUsR0FBRztRQUNwQixPQUFPO0lBQ1Q7SUFDQSxPQUFPLFdBQVcsR0FBRXZFLE1BQU0sQ0FBQyxVQUFVLENBQUM0RSxhQUFhLENBQUMsS0FBSztRQUN2REMsV0FBVztJQUNiLEdBQUcsV0FBVyxHQUFFN0UsTUFBTSxDQUFDLFVBQVUsQ0FBQzRFLGFBQWEsQ0FBQ1IsYUFBYXZDLFNBQVM7UUFDcEU2QixJQUFJQTtRQUNKQyxJQUFJQTtRQUNKVyxhQUFhQTtRQUNiQyxhQUFhQTtRQUNid0IsVUFBVUE7UUFDVnZCLGFBQWFBO0lBQ2YsR0FBR0gsU0FBUyxXQUFXLEdBQUVyRSxNQUFNLENBQUMsVUFBVSxDQUFDNEUsYUFBYSxDQUFDaUIsZ0JBQWdCaEUsU0FBUztRQUNoRjZCLElBQUlBO1FBQ0pDLElBQUlBO1FBQ0pXLGFBQWFBO1FBQ2JDLGFBQWFBO1FBQ2J3QixVQUFVQTtRQUNWdkIsYUFBYUE7SUFDZixHQUFHSDtBQUNMO0FBQ0F0RSxVQUFVd0csV0FBVyxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9wb2xhci9Qb2xhckdyaWQuanM/Zjc4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUG9sYXJHcmlkID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xudmFyIF9Qb2xhclV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUG9sYXJVdGlsc1wiKTtcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XG52YXIgX2V4Y2x1ZGVkID0gW1wiY3hcIiwgXCJjeVwiLCBcImlubmVyUmFkaXVzXCIsIFwib3V0ZXJSYWRpdXNcIiwgXCJncmlkVHlwZVwiLCBcInJhZGlhbExpbmVzXCJdO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKipcbiAqIEBmaWxlT3ZlcnZpZXcgUG9sYXIgR3JpZFxuICovXG52YXIgZ2V0UG9seWdvblBhdGggPSBmdW5jdGlvbiBnZXRQb2x5Z29uUGF0aChyYWRpdXMsIGN4LCBjeSwgcG9sYXJBbmdsZXMpIHtcbiAgdmFyIHBhdGggPSAnJztcbiAgcG9sYXJBbmdsZXMuZm9yRWFjaChmdW5jdGlvbiAoYW5nbGUsIGkpIHtcbiAgICB2YXIgcG9pbnQgPSAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCByYWRpdXMsIGFuZ2xlKTtcbiAgICBpZiAoaSkge1xuICAgICAgcGF0aCArPSBcIkwgXCIuY29uY2F0KHBvaW50LngsIFwiLFwiKS5jb25jYXQocG9pbnQueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggKz0gXCJNIFwiLmNvbmNhdChwb2ludC54LCBcIixcIikuY29uY2F0KHBvaW50LnkpO1xuICAgIH1cbiAgfSk7XG4gIHBhdGggKz0gJ1onO1xuICByZXR1cm4gcGF0aDtcbn07XG5cbi8vIERyYXcgYXhpcyBvZiByYWRpYWwgbGluZVxudmFyIFBvbGFyQW5nbGVzID0gZnVuY3Rpb24gUG9sYXJBbmdsZXMocHJvcHMpIHtcbiAgdmFyIGN4ID0gcHJvcHMuY3gsXG4gICAgY3kgPSBwcm9wcy5jeSxcbiAgICBpbm5lclJhZGl1cyA9IHByb3BzLmlubmVyUmFkaXVzLFxuICAgIG91dGVyUmFkaXVzID0gcHJvcHMub3V0ZXJSYWRpdXMsXG4gICAgcG9sYXJBbmdsZXMgPSBwcm9wcy5wb2xhckFuZ2xlcyxcbiAgICByYWRpYWxMaW5lcyA9IHByb3BzLnJhZGlhbExpbmVzO1xuICBpZiAoIXBvbGFyQW5nbGVzIHx8ICFwb2xhckFuZ2xlcy5sZW5ndGggfHwgIXJhZGlhbExpbmVzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHBvbGFyQW5nbGVzUHJvcHMgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICBzdHJva2U6ICcjY2NjJ1xuICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHByb3BzLCBmYWxzZSkpO1xuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1wb2xhci1ncmlkLWFuZ2xlXCJcbiAgfSwgcG9sYXJBbmdsZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHZhciBzdGFydCA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIGlubmVyUmFkaXVzLCBlbnRyeSk7XG4gICAgdmFyIGVuZCA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIG91dGVyUmFkaXVzLCBlbnRyeSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIF9leHRlbmRzKHt9LCBwb2xhckFuZ2xlc1Byb3BzLCB7XG4gICAgICBrZXk6IFwibGluZS1cIi5jb25jYXQoZW50cnkpLFxuICAgICAgeDE6IHN0YXJ0LngsXG4gICAgICB5MTogc3RhcnQueSxcbiAgICAgIHgyOiBlbmQueCxcbiAgICAgIHkyOiBlbmQueVxuICAgIH0pKTtcbiAgfSkpO1xufTtcblxuLy8gRHJhdyBjb25jZW50cmljIGNpcmNsZXNcbnZhciBDb25jZW50cmljQ2lyY2xlID0gZnVuY3Rpb24gQ29uY2VudHJpY0NpcmNsZShwcm9wcykge1xuICB2YXIgY3ggPSBwcm9wcy5jeCxcbiAgICBjeSA9IHByb3BzLmN5LFxuICAgIHJhZGl1cyA9IHByb3BzLnJhZGl1cyxcbiAgICBpbmRleCA9IHByb3BzLmluZGV4O1xuICB2YXIgY29uY2VudHJpY0NpcmNsZVByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICBzdHJva2U6ICcjY2NjJ1xuICB9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHByb3BzLCBmYWxzZSkpLCB7fSwge1xuICAgIGZpbGw6ICdub25lJ1xuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwgX2V4dGVuZHMoe30sIGNvbmNlbnRyaWNDaXJjbGVQcm9wcywge1xuICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXBvbGFyLWdyaWQtY29uY2VudHJpYy1jaXJjbGUnLCBwcm9wcy5jbGFzc05hbWUpLFxuICAgIGtleTogXCJjaXJjbGUtXCIuY29uY2F0KGluZGV4KSxcbiAgICBjeDogY3gsXG4gICAgY3k6IGN5LFxuICAgIHI6IHJhZGl1c1xuICB9KSk7XG59O1xuXG4vLyBEcmF3IGNvbmNlbnRyaWMgcG9seWdvbnNcbnZhciBDb25jZW50cmljUG9seWdvbiA9IGZ1bmN0aW9uIENvbmNlbnRyaWNQb2x5Z29uKHByb3BzKSB7XG4gIHZhciByYWRpdXMgPSBwcm9wcy5yYWRpdXMsXG4gICAgaW5kZXggPSBwcm9wcy5pbmRleDtcbiAgdmFyIGNvbmNlbnRyaWNQb2x5Z29uUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgIHN0cm9rZTogJyNjY2MnXG4gIH0sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykocHJvcHMsIGZhbHNlKSksIHt9LCB7XG4gICAgZmlsbDogJ25vbmUnXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBhdGhcIiwgX2V4dGVuZHMoe30sIGNvbmNlbnRyaWNQb2x5Z29uUHJvcHMsIHtcbiAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1wb2xhci1ncmlkLWNvbmNlbnRyaWMtcG9seWdvbicsIHByb3BzLmNsYXNzTmFtZSksXG4gICAga2V5OiBcInBhdGgtXCIuY29uY2F0KGluZGV4KSxcbiAgICBkOiBnZXRQb2x5Z29uUGF0aChyYWRpdXMsIHByb3BzLmN4LCBwcm9wcy5jeSwgcHJvcHMucG9sYXJBbmdsZXMpXG4gIH0pKTtcbn07XG5cbi8vIERyYXcgY29uY2VudHJpYyBheGlzXG4vLyBUT0RPIE9wdGltaXplIHRoZSBuYW1lXG52YXIgQ29uY2VudHJpY1BhdGggPSBmdW5jdGlvbiBDb25jZW50cmljUGF0aChwcm9wcykge1xuICB2YXIgcG9sYXJSYWRpdXMgPSBwcm9wcy5wb2xhclJhZGl1cyxcbiAgICBncmlkVHlwZSA9IHByb3BzLmdyaWRUeXBlO1xuICBpZiAoIXBvbGFyUmFkaXVzIHx8ICFwb2xhclJhZGl1cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1wb2xhci1ncmlkLWNvbmNlbnRyaWNcIlxuICB9LCBwb2xhclJhZGl1cy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gICAgdmFyIGtleSA9IGk7XG4gICAgaWYgKGdyaWRUeXBlID09PSAnY2lyY2xlJykgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQ29uY2VudHJpY0NpcmNsZSwgX2V4dGVuZHMoe1xuICAgICAga2V5OiBrZXlcbiAgICB9LCBwcm9wcywge1xuICAgICAgcmFkaXVzOiBlbnRyeSxcbiAgICAgIGluZGV4OiBpXG4gICAgfSkpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KENvbmNlbnRyaWNQb2x5Z29uLCBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IGtleVxuICAgIH0sIHByb3BzLCB7XG4gICAgICByYWRpdXM6IGVudHJ5LFxuICAgICAgaW5kZXg6IGlcbiAgICB9KSk7XG4gIH0pKTtcbn07XG52YXIgUG9sYXJHcmlkID0gZXhwb3J0cy5Qb2xhckdyaWQgPSBmdW5jdGlvbiBQb2xhckdyaWQoX3JlZikge1xuICB2YXIgX3JlZiRjeCA9IF9yZWYuY3gsXG4gICAgY3ggPSBfcmVmJGN4ID09PSB2b2lkIDAgPyAwIDogX3JlZiRjeCxcbiAgICBfcmVmJGN5ID0gX3JlZi5jeSxcbiAgICBjeSA9IF9yZWYkY3kgPT09IHZvaWQgMCA/IDAgOiBfcmVmJGN5LFxuICAgIF9yZWYkaW5uZXJSYWRpdXMgPSBfcmVmLmlubmVyUmFkaXVzLFxuICAgIGlubmVyUmFkaXVzID0gX3JlZiRpbm5lclJhZGl1cyA9PT0gdm9pZCAwID8gMCA6IF9yZWYkaW5uZXJSYWRpdXMsXG4gICAgX3JlZiRvdXRlclJhZGl1cyA9IF9yZWYub3V0ZXJSYWRpdXMsXG4gICAgb3V0ZXJSYWRpdXMgPSBfcmVmJG91dGVyUmFkaXVzID09PSB2b2lkIDAgPyAwIDogX3JlZiRvdXRlclJhZGl1cyxcbiAgICBfcmVmJGdyaWRUeXBlID0gX3JlZi5ncmlkVHlwZSxcbiAgICBncmlkVHlwZSA9IF9yZWYkZ3JpZFR5cGUgPT09IHZvaWQgMCA/ICdwb2x5Z29uJyA6IF9yZWYkZ3JpZFR5cGUsXG4gICAgX3JlZiRyYWRpYWxMaW5lcyA9IF9yZWYucmFkaWFsTGluZXMsXG4gICAgcmFkaWFsTGluZXMgPSBfcmVmJHJhZGlhbExpbmVzID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRyYWRpYWxMaW5lcyxcbiAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuICBpZiAob3V0ZXJSYWRpdXMgPD0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXBvbGFyLWdyaWRcIlxuICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFBvbGFyQW5nbGVzLCBfZXh0ZW5kcyh7XG4gICAgY3g6IGN4LFxuICAgIGN5OiBjeSxcbiAgICBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG4gICAgb3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuICAgIGdyaWRUeXBlOiBncmlkVHlwZSxcbiAgICByYWRpYWxMaW5lczogcmFkaWFsTGluZXNcbiAgfSwgcHJvcHMpKSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChDb25jZW50cmljUGF0aCwgX2V4dGVuZHMoe1xuICAgIGN4OiBjeCxcbiAgICBjeTogY3ksXG4gICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcbiAgICBncmlkVHlwZTogZ3JpZFR5cGUsXG4gICAgcmFkaWFsTGluZXM6IHJhZGlhbExpbmVzXG4gIH0sIHByb3BzKSkpO1xufTtcblBvbGFyR3JpZC5kaXNwbGF5TmFtZSA9ICdQb2xhckdyaWQnOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlBvbGFyR3JpZCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2Nsc3giLCJfUG9sYXJVdGlscyIsIl9SZWFjdFV0aWxzIiwiX2V4Y2x1ZGVkIiwib2JqIiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZSIsImV4Y2x1ZGVkIiwidGFyZ2V0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJrZXkiLCJpIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImxlbmd0aCIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImNhbGwiLCJoYXNPd25Qcm9wZXJ0eSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsImFyZ3VtZW50cyIsImFwcGx5Iiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJnZXRQb2x5Z29uUGF0aCIsInJhZGl1cyIsImN4IiwiY3kiLCJwb2xhckFuZ2xlcyIsInBhdGgiLCJhbmdsZSIsInBvaW50IiwicG9sYXJUb0NhcnRlc2lhbiIsImNvbmNhdCIsIngiLCJ5IiwiUG9sYXJBbmdsZXMiLCJwcm9wcyIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJyYWRpYWxMaW5lcyIsInBvbGFyQW5nbGVzUHJvcHMiLCJzdHJva2UiLCJmaWx0ZXJQcm9wcyIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJtYXAiLCJlbnRyeSIsInN0YXJ0IiwiZW5kIiwieDEiLCJ5MSIsIngyIiwieTIiLCJDb25jZW50cmljQ2lyY2xlIiwiaW5kZXgiLCJjb25jZW50cmljQ2lyY2xlUHJvcHMiLCJmaWxsIiwiQ29uY2VudHJpY1BvbHlnb24iLCJjb25jZW50cmljUG9seWdvblByb3BzIiwiZCIsIkNvbmNlbnRyaWNQYXRoIiwicG9sYXJSYWRpdXMiLCJncmlkVHlwZSIsIl9yZWYiLCJfcmVmJGN4IiwiX3JlZiRjeSIsIl9yZWYkaW5uZXJSYWRpdXMiLCJfcmVmJG91dGVyUmFkaXVzIiwiX3JlZiRncmlkVHlwZSIsIl9yZWYkcmFkaWFsTGluZXMiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/polar/PolarGrid.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/polar/PolarRadiusAxis.js":
/*!************************************************************!*\
  !*** ./node_modules/recharts/lib/polar/PolarRadiusAxis.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PolarRadiusAxis = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _maxBy = _interopRequireDefault(__webpack_require__(/*! lodash/maxBy */ \"lodash/maxBy\"));\nvar _minBy = _interopRequireDefault(__webpack_require__(/*! lodash/minBy */ \"lodash/minBy\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _Text = __webpack_require__(/*! ../component/Text */ \"./node_modules/recharts/lib/component/Text.js\");\nvar _Label = __webpack_require__(/*! ../component/Label */ \"./node_modules/recharts/lib/component/Label.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"./node_modules/recharts/lib/util/types.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"cx\",\n    \"cy\",\n    \"angle\",\n    \"ticks\",\n    \"axisLine\"\n], _excluded2 = [\n    \"ticks\",\n    \"tick\",\n    \"angle\",\n    \"tickFormatter\",\n    \"stroke\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview The axis of polar coordinate system\n */ \nvar PolarRadiusAxis = exports.PolarRadiusAxis = /*#__PURE__*/ function(_PureComponent) {\n    function PolarRadiusAxis() {\n        _classCallCheck(this, PolarRadiusAxis);\n        return _callSuper(this, PolarRadiusAxis, arguments);\n    }\n    _inherits(PolarRadiusAxis, _PureComponent);\n    return _createClass(PolarRadiusAxis, [\n        {\n            key: \"getTickValueCoord\",\n            value: /**\n     * Calculate the coordinate of tick\n     * @param  {Number} coordinate The radius of tick\n     * @return {Object} (x, y)\n     */ function getTickValueCoord(_ref) {\n                var coordinate = _ref.coordinate;\n                var _this$props = this.props, angle = _this$props.angle, cx = _this$props.cx, cy = _this$props.cy;\n                return (0, _PolarUtils.polarToCartesian)(cx, cy, coordinate, angle);\n            }\n        },\n        {\n            key: \"getTickTextAnchor\",\n            value: function getTickTextAnchor() {\n                var orientation = this.props.orientation;\n                var textAnchor;\n                switch(orientation){\n                    case \"left\":\n                        textAnchor = \"end\";\n                        break;\n                    case \"right\":\n                        textAnchor = \"start\";\n                        break;\n                    default:\n                        textAnchor = \"middle\";\n                        break;\n                }\n                return textAnchor;\n            }\n        },\n        {\n            key: \"getViewBox\",\n            value: function getViewBox() {\n                var _this$props2 = this.props, cx = _this$props2.cx, cy = _this$props2.cy, angle = _this$props2.angle, ticks = _this$props2.ticks;\n                var maxRadiusTick = (0, _maxBy[\"default\"])(ticks, function(entry) {\n                    return entry.coordinate || 0;\n                });\n                var minRadiusTick = (0, _minBy[\"default\"])(ticks, function(entry) {\n                    return entry.coordinate || 0;\n                });\n                return {\n                    cx: cx,\n                    cy: cy,\n                    startAngle: angle,\n                    endAngle: angle,\n                    innerRadius: minRadiusTick.coordinate || 0,\n                    outerRadius: maxRadiusTick.coordinate || 0\n                };\n            }\n        },\n        {\n            key: \"renderAxisLine\",\n            value: function renderAxisLine() {\n                var _this$props3 = this.props, cx = _this$props3.cx, cy = _this$props3.cy, angle = _this$props3.angle, ticks = _this$props3.ticks, axisLine = _this$props3.axisLine, others = _objectWithoutProperties(_this$props3, _excluded);\n                var extent = ticks.reduce(function(result, entry) {\n                    return [\n                        Math.min(result[0], entry.coordinate),\n                        Math.max(result[1], entry.coordinate)\n                    ];\n                }, [\n                    Infinity,\n                    -Infinity\n                ]);\n                var point0 = (0, _PolarUtils.polarToCartesian)(cx, cy, extent[0], angle);\n                var point1 = (0, _PolarUtils.polarToCartesian)(cx, cy, extent[1], angle);\n                var props = _objectSpread(_objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(others, false)), {}, {\n                    fill: \"none\"\n                }, (0, _ReactUtils.filterProps)(axisLine, false)), {}, {\n                    x1: point0.x,\n                    y1: point0.y,\n                    x2: point1.x,\n                    y2: point1.y\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"line\", _extends({\n                    className: \"recharts-polar-radius-axis-line\"\n                }, props));\n            }\n        },\n        {\n            key: \"renderTicks\",\n            value: function renderTicks() {\n                var _this = this;\n                var _this$props4 = this.props, ticks = _this$props4.ticks, tick = _this$props4.tick, angle = _this$props4.angle, tickFormatter = _this$props4.tickFormatter, stroke = _this$props4.stroke, others = _objectWithoutProperties(_this$props4, _excluded2);\n                var textAnchor = this.getTickTextAnchor();\n                var axisProps = (0, _ReactUtils.filterProps)(others, false);\n                var customTickProps = (0, _ReactUtils.filterProps)(tick, false);\n                var items = ticks.map(function(entry, i) {\n                    var coord = _this.getTickValueCoord(entry);\n                    var tickProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread({\n                        textAnchor: textAnchor,\n                        transform: \"rotate(\".concat(90 - angle, \", \").concat(coord.x, \", \").concat(coord.y, \")\")\n                    }, axisProps), {}, {\n                        stroke: \"none\",\n                        fill: stroke\n                    }, customTickProps), {}, {\n                        index: i\n                    }, coord), {}, {\n                        payload: entry\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, _extends({\n                        className: (0, _clsx[\"default\"])(\"recharts-polar-radius-axis-tick\", (0, _PolarUtils.getTickClassName)(tick)),\n                        key: \"tick-\".concat(entry.coordinate)\n                    }, (0, _types.adaptEventsOfChild)(_this.props, entry, i)), PolarRadiusAxis.renderTickItem(tick, tickProps, tickFormatter ? tickFormatter(entry.value, i) : entry.value));\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-polar-radius-axis-ticks\"\n                }, items);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props5 = this.props, ticks = _this$props5.ticks, axisLine = _this$props5.axisLine, tick = _this$props5.tick;\n                if (!ticks || !ticks.length) {\n                    return null;\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: (0, _clsx[\"default\"])(\"recharts-polar-radius-axis\", this.props.className)\n                }, axisLine && this.renderAxisLine(), tick && this.renderTicks(), _Label.Label.renderCallByParent(this.props, this.getViewBox()));\n            }\n        }\n    ], [\n        {\n            key: \"renderTickItem\",\n            value: function renderTickItem(option, props, value) {\n                var tickItem;\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    tickItem = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                } else if ((0, _isFunction[\"default\"])(option)) {\n                    tickItem = option(props);\n                } else {\n                    tickItem = /*#__PURE__*/ _react[\"default\"].createElement(_Text.Text, _extends({}, props, {\n                        className: \"recharts-polar-radius-axis-tick-value\"\n                    }), value);\n                }\n                return tickItem;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(PolarRadiusAxis, \"displayName\", \"PolarRadiusAxis\");\n_defineProperty(PolarRadiusAxis, \"axisType\", \"radiusAxis\");\n_defineProperty(PolarRadiusAxis, \"defaultProps\", {\n    type: \"number\",\n    radiusAxisId: 0,\n    cx: 0,\n    cy: 0,\n    angle: 0,\n    orientation: \"right\",\n    stroke: \"#ccc\",\n    axisLine: true,\n    tick: true,\n    tickCount: 5,\n    allowDataOverflow: false,\n    scale: \"auto\",\n    allowDuplicatedCategory: true\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3BvbGFyL1BvbGFyUmFkaXVzQXhpcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsdUJBQXVCLEdBQUcsS0FBSztBQUMvQixJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLFNBQVNDLHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDMUQsSUFBSUcsU0FBU0QsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJSSxjQUFjRix1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJSyxRQUFRSCx1QkFBdUJGLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlNLFFBQVFOLG1CQUFPQSxDQUFDLHdFQUFtQjtBQUN2QyxJQUFJTyxTQUFTUCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDekMsSUFBSVEsU0FBU1IsbUJBQU9BLENBQUMsMEVBQW9CO0FBQ3pDLElBQUlTLGNBQWNULG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJVSxTQUFTVixtQkFBT0EsQ0FBQyxnRUFBZTtBQUNwQyxJQUFJVyxjQUFjWCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSVksWUFBWTtJQUFDO0lBQU07SUFBTTtJQUFTO0lBQVM7Q0FBVyxFQUN4REMsYUFBYTtJQUFDO0lBQVM7SUFBUTtJQUFTO0lBQWlCO0NBQVM7QUFDcEUsU0FBU1gsdUJBQXVCWSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLHlCQUF5QkMsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLE9BQU87SUFBTSxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx5QkFB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RXFLLFNBQVM7b0JBQzlDQyxXQUFXRCxPQUFPcEc7Z0JBQ3BCLE9BQU87b0JBQ0xxRyxXQUFXLFdBQVcsR0FBRTVLLE1BQU0sQ0FBQyxVQUFVLENBQUNpSixhQUFhLENBQUN6SSxNQUFNdUssSUFBSSxFQUFFdkksU0FBUyxDQUFDLEdBQUcrQixPQUFPO3dCQUN0RjJFLFdBQVc7b0JBQ2IsSUFBSXBKO2dCQUNOO2dCQUNBLE9BQU84SztZQUNUO1FBQ0Y7S0FBRTtBQUNKLEVBQUU1SyxPQUFPZ0wsYUFBYTtBQUN0QnZILGdCQUFnQjFELGlCQUFpQixlQUFlO0FBQ2hEMEQsZ0JBQWdCMUQsaUJBQWlCLFlBQVk7QUFDN0MwRCxnQkFBZ0IxRCxpQkFBaUIsZ0JBQWdCO0lBQy9Da0wsTUFBTTtJQUNOQyxjQUFjO0lBQ2R0RSxJQUFJO0lBQ0pDLElBQUk7SUFDSkYsT0FBTztJQUNQSyxhQUFhO0lBQ2J3QyxRQUFRO0lBQ1IxQixVQUFVO0lBQ1Z3QixNQUFNO0lBQ042QixXQUFXO0lBQ1hDLG1CQUFtQjtJQUNuQkMsT0FBTztJQUNQQyx5QkFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3BvbGFyL1BvbGFyUmFkaXVzQXhpcy5qcz8yNWI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Qb2xhclJhZGl1c0F4aXMgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfbWF4QnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvbWF4QnlcIikpO1xudmFyIF9taW5CeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9taW5CeVwiKSk7XG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfVGV4dCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvVGV4dFwiKTtcbnZhciBfTGFiZWwgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L0xhYmVsXCIpO1xudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XG52YXIgX1BvbGFyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Qb2xhclV0aWxzXCIpO1xudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi91dGlsL3R5cGVzXCIpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcbnZhciBfZXhjbHVkZWQgPSBbXCJjeFwiLCBcImN5XCIsIFwiYW5nbGVcIiwgXCJ0aWNrc1wiLCBcImF4aXNMaW5lXCJdLFxuICBfZXhjbHVkZWQyID0gW1widGlja3NcIiwgXCJ0aWNrXCIsIFwiYW5nbGVcIiwgXCJ0aWNrRm9ybWF0dGVyXCIsIFwic3Ryb2tlXCJdO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gbnVsbDsgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCB0ID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoZSkgeyByZXR1cm4gZSA/IHQgOiByOyB9KShlKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgcikgeyBpZiAoIXIgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBcImRlZmF1bHRcIjogZSB9OyB2YXIgdCA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShyKTsgaWYgKHQgJiYgdC5oYXMoZSkpIHJldHVybiB0LmdldChlKTsgdmFyIG4gPSB7IF9fcHJvdG9fXzogbnVsbCB9LCBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIHUgaW4gZSkgaWYgKFwiZGVmYXVsdFwiICE9PSB1ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuW1wiZGVmYXVsdFwiXSA9IGUsIHQgJiYgdC5zZXQoZSwgbiksIG47IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKipcbiAqIEBmaWxlT3ZlcnZpZXcgVGhlIGF4aXMgb2YgcG9sYXIgY29vcmRpbmF0ZSBzeXN0ZW1cbiAqL1xudmFyIFBvbGFyUmFkaXVzQXhpcyA9IGV4cG9ydHMuUG9sYXJSYWRpdXNBeGlzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBmdW5jdGlvbiBQb2xhclJhZGl1c0F4aXMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvbGFyUmFkaXVzQXhpcyk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgUG9sYXJSYWRpdXNBeGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhQb2xhclJhZGl1c0F4aXMsIF9QdXJlQ29tcG9uZW50KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhQb2xhclJhZGl1c0F4aXMsIFt7XG4gICAga2V5OiBcImdldFRpY2tWYWx1ZUNvb3JkXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb29yZGluYXRlIG9mIHRpY2tcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvb3JkaW5hdGUgVGhlIHJhZGl1cyBvZiB0aWNrXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAoeCwgeSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRUaWNrVmFsdWVDb29yZChfcmVmKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZSA9IF9yZWYuY29vcmRpbmF0ZTtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGFuZ2xlID0gX3RoaXMkcHJvcHMuYW5nbGUsXG4gICAgICAgIGN4ID0gX3RoaXMkcHJvcHMuY3gsXG4gICAgICAgIGN5ID0gX3RoaXMkcHJvcHMuY3k7XG4gICAgICByZXR1cm4gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgY29vcmRpbmF0ZSwgYW5nbGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUaWNrVGV4dEFuY2hvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaWNrVGV4dEFuY2hvcigpIHtcbiAgICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMucHJvcHMub3JpZW50YXRpb247XG4gICAgICB2YXIgdGV4dEFuY2hvcjtcbiAgICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgdGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHRBbmNob3I7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFZpZXdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Vmlld0JveCgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBjeCA9IF90aGlzJHByb3BzMi5jeCxcbiAgICAgICAgY3kgPSBfdGhpcyRwcm9wczIuY3ksXG4gICAgICAgIGFuZ2xlID0gX3RoaXMkcHJvcHMyLmFuZ2xlLFxuICAgICAgICB0aWNrcyA9IF90aGlzJHByb3BzMi50aWNrcztcbiAgICAgIHZhciBtYXhSYWRpdXNUaWNrID0gKDAsIF9tYXhCeVtcImRlZmF1bHRcIl0pKHRpY2tzLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LmNvb3JkaW5hdGUgfHwgMDtcbiAgICAgIH0pO1xuICAgICAgdmFyIG1pblJhZGl1c1RpY2sgPSAoMCwgX21pbkJ5W1wiZGVmYXVsdFwiXSkodGlja3MsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICByZXR1cm4gZW50cnkuY29vcmRpbmF0ZSB8fCAwO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjeDogY3gsXG4gICAgICAgIGN5OiBjeSxcbiAgICAgICAgc3RhcnRBbmdsZTogYW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBhbmdsZSxcbiAgICAgICAgaW5uZXJSYWRpdXM6IG1pblJhZGl1c1RpY2suY29vcmRpbmF0ZSB8fCAwLFxuICAgICAgICBvdXRlclJhZGl1czogbWF4UmFkaXVzVGljay5jb29yZGluYXRlIHx8IDBcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckF4aXNMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckF4aXNMaW5lKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGN4ID0gX3RoaXMkcHJvcHMzLmN4LFxuICAgICAgICBjeSA9IF90aGlzJHByb3BzMy5jeSxcbiAgICAgICAgYW5nbGUgPSBfdGhpcyRwcm9wczMuYW5nbGUsXG4gICAgICAgIHRpY2tzID0gX3RoaXMkcHJvcHMzLnRpY2tzLFxuICAgICAgICBheGlzTGluZSA9IF90aGlzJHByb3BzMy5heGlzTGluZSxcbiAgICAgICAgb3RoZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzMywgX2V4Y2x1ZGVkKTtcbiAgICAgIHZhciBleHRlbnQgPSB0aWNrcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIFtNYXRoLm1pbihyZXN1bHRbMF0sIGVudHJ5LmNvb3JkaW5hdGUpLCBNYXRoLm1heChyZXN1bHRbMV0sIGVudHJ5LmNvb3JkaW5hdGUpXTtcbiAgICAgIH0sIFtJbmZpbml0eSwgLUluZmluaXR5XSk7XG4gICAgICB2YXIgcG9pbnQwID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgZXh0ZW50WzBdLCBhbmdsZSk7XG4gICAgICB2YXIgcG9pbnQxID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgZXh0ZW50WzFdLCBhbmdsZSk7XG4gICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShvdGhlcnMsIGZhbHNlKSksIHt9LCB7XG4gICAgICAgIGZpbGw6ICdub25lJ1xuICAgICAgfSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShheGlzTGluZSwgZmFsc2UpKSwge30sIHtcbiAgICAgICAgeDE6IHBvaW50MC54LFxuICAgICAgICB5MTogcG9pbnQwLnksXG4gICAgICAgIHgyOiBwb2ludDEueCxcbiAgICAgICAgeTI6IHBvaW50MS55XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwibGluZVwiLCBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1wb2xhci1yYWRpdXMtYXhpcy1saW5lXCJcbiAgICAgIH0sIHByb3BzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclRpY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRpY2tzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICB0aWNrcyA9IF90aGlzJHByb3BzNC50aWNrcyxcbiAgICAgICAgdGljayA9IF90aGlzJHByb3BzNC50aWNrLFxuICAgICAgICBhbmdsZSA9IF90aGlzJHByb3BzNC5hbmdsZSxcbiAgICAgICAgdGlja0Zvcm1hdHRlciA9IF90aGlzJHByb3BzNC50aWNrRm9ybWF0dGVyLFxuICAgICAgICBzdHJva2UgPSBfdGhpcyRwcm9wczQuc3Ryb2tlLFxuICAgICAgICBvdGhlcnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHM0LCBfZXhjbHVkZWQyKTtcbiAgICAgIHZhciB0ZXh0QW5jaG9yID0gdGhpcy5nZXRUaWNrVGV4dEFuY2hvcigpO1xuICAgICAgdmFyIGF4aXNQcm9wcyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykob3RoZXJzLCBmYWxzZSk7XG4gICAgICB2YXIgY3VzdG9tVGlja1Byb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aWNrLCBmYWxzZSk7XG4gICAgICB2YXIgaXRlbXMgPSB0aWNrcy5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gICAgICAgIHZhciBjb29yZCA9IF90aGlzLmdldFRpY2tWYWx1ZUNvb3JkKGVudHJ5KTtcbiAgICAgICAgdmFyIHRpY2tQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IsXG4gICAgICAgICAgdHJhbnNmb3JtOiBcInJvdGF0ZShcIi5jb25jYXQoOTAgLSBhbmdsZSwgXCIsIFwiKS5jb25jYXQoY29vcmQueCwgXCIsIFwiKS5jb25jYXQoY29vcmQueSwgXCIpXCIpXG4gICAgICAgIH0sIGF4aXNQcm9wcyksIHt9LCB7XG4gICAgICAgICAgc3Ryb2tlOiAnbm9uZScsXG4gICAgICAgICAgZmlsbDogc3Ryb2tlXG4gICAgICAgIH0sIGN1c3RvbVRpY2tQcm9wcyksIHt9LCB7XG4gICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgfSwgY29vcmQpLCB7fSwge1xuICAgICAgICAgIHBheWxvYWQ6IGVudHJ5XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIF9leHRlbmRzKHtcbiAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1wb2xhci1yYWRpdXMtYXhpcy10aWNrJywgKDAsIF9Qb2xhclV0aWxzLmdldFRpY2tDbGFzc05hbWUpKHRpY2spKSxcbiAgICAgICAgICBrZXk6IFwidGljay1cIi5jb25jYXQoZW50cnkuY29vcmRpbmF0ZSlcbiAgICAgICAgfSwgKDAsIF90eXBlcy5hZGFwdEV2ZW50c09mQ2hpbGQpKF90aGlzLnByb3BzLCBlbnRyeSwgaSkpLCBQb2xhclJhZGl1c0F4aXMucmVuZGVyVGlja0l0ZW0odGljaywgdGlja1Byb3BzLCB0aWNrRm9ybWF0dGVyID8gdGlja0Zvcm1hdHRlcihlbnRyeS52YWx1ZSwgaSkgOiBlbnRyeS52YWx1ZSkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXBvbGFyLXJhZGl1cy1heGlzLXRpY2tzXCJcbiAgICAgIH0sIGl0ZW1zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczUgPSB0aGlzLnByb3BzLFxuICAgICAgICB0aWNrcyA9IF90aGlzJHByb3BzNS50aWNrcyxcbiAgICAgICAgYXhpc0xpbmUgPSBfdGhpcyRwcm9wczUuYXhpc0xpbmUsXG4gICAgICAgIHRpY2sgPSBfdGhpcyRwcm9wczUudGljaztcbiAgICAgIGlmICghdGlja3MgfHwgIXRpY2tzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xuICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1wb2xhci1yYWRpdXMtYXhpcycsIHRoaXMucHJvcHMuY2xhc3NOYW1lKVxuICAgICAgfSwgYXhpc0xpbmUgJiYgdGhpcy5yZW5kZXJBeGlzTGluZSgpLCB0aWNrICYmIHRoaXMucmVuZGVyVGlja3MoKSwgX0xhYmVsLkxhYmVsLnJlbmRlckNhbGxCeVBhcmVudCh0aGlzLnByb3BzLCB0aGlzLmdldFZpZXdCb3goKSkpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInJlbmRlclRpY2tJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRpY2tJdGVtKG9wdGlvbiwgcHJvcHMsIHZhbHVlKSB7XG4gICAgICB2YXIgdGlja0l0ZW07XG4gICAgICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KG9wdGlvbikpIHtcbiAgICAgICAgdGlja0l0ZW0gPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQob3B0aW9uLCBwcm9wcyk7XG4gICAgICB9IGVsc2UgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9wdGlvbikpIHtcbiAgICAgICAgdGlja0l0ZW0gPSBvcHRpb24ocHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlja0l0ZW0gPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9UZXh0LlRleHQsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1wb2xhci1yYWRpdXMtYXhpcy10aWNrLXZhbHVlXCJcbiAgICAgICAgfSksIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aWNrSXRlbTtcbiAgICB9XG4gIH1dKTtcbn0oX3JlYWN0LlB1cmVDb21wb25lbnQpO1xuX2RlZmluZVByb3BlcnR5KFBvbGFyUmFkaXVzQXhpcywgXCJkaXNwbGF5TmFtZVwiLCAnUG9sYXJSYWRpdXNBeGlzJyk7XG5fZGVmaW5lUHJvcGVydHkoUG9sYXJSYWRpdXNBeGlzLCBcImF4aXNUeXBlXCIsICdyYWRpdXNBeGlzJyk7XG5fZGVmaW5lUHJvcGVydHkoUG9sYXJSYWRpdXNBeGlzLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIHR5cGU6ICdudW1iZXInLFxuICByYWRpdXNBeGlzSWQ6IDAsXG4gIGN4OiAwLFxuICBjeTogMCxcbiAgYW5nbGU6IDAsXG4gIG9yaWVudGF0aW9uOiAncmlnaHQnLFxuICBzdHJva2U6ICcjY2NjJyxcbiAgYXhpc0xpbmU6IHRydWUsXG4gIHRpY2s6IHRydWUsXG4gIHRpY2tDb3VudDogNSxcbiAgYWxsb3dEYXRhT3ZlcmZsb3c6IGZhbHNlLFxuICBzY2FsZTogJ2F1dG8nLFxuICBhbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeTogdHJ1ZVxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUG9sYXJSYWRpdXNBeGlzIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX21heEJ5IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9taW5CeSIsIl9pc0Z1bmN0aW9uIiwiX2Nsc3giLCJfVGV4dCIsIl9MYWJlbCIsIl9MYXllciIsIl9Qb2xhclV0aWxzIiwiX3R5cGVzIiwiX1JlYWN0VXRpbHMiLCJfZXhjbHVkZWQiLCJfZXhjbHVkZWQyIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfdHlwZW9mIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaSIsInNldCIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiYXBwbHkiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJzb3VyY2VTeW1ib2xLZXlzIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInAiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIl9QdXJlQ29tcG9uZW50IiwiZ2V0VGlja1ZhbHVlQ29vcmQiLCJfcmVmIiwiY29vcmRpbmF0ZSIsIl90aGlzJHByb3BzIiwiYW5nbGUiLCJjeCIsImN5IiwicG9sYXJUb0NhcnRlc2lhbiIsImdldFRpY2tUZXh0QW5jaG9yIiwib3JpZW50YXRpb24iLCJ0ZXh0QW5jaG9yIiwiZ2V0Vmlld0JveCIsIl90aGlzJHByb3BzMiIsInRpY2tzIiwibWF4UmFkaXVzVGljayIsImVudHJ5IiwibWluUmFkaXVzVGljayIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJyZW5kZXJBeGlzTGluZSIsIl90aGlzJHByb3BzMyIsImF4aXNMaW5lIiwib3RoZXJzIiwiZXh0ZW50IiwicmVkdWNlIiwicmVzdWx0IiwiTWF0aCIsIm1pbiIsIm1heCIsIkluZmluaXR5IiwicG9pbnQwIiwicG9pbnQxIiwiZmlsdGVyUHJvcHMiLCJmaWxsIiwieDEiLCJ4IiwieTEiLCJ5IiwieDIiLCJ5MiIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJyZW5kZXJUaWNrcyIsIl90aGlzIiwiX3RoaXMkcHJvcHM0IiwidGljayIsInRpY2tGb3JtYXR0ZXIiLCJzdHJva2UiLCJheGlzUHJvcHMiLCJjdXN0b21UaWNrUHJvcHMiLCJpdGVtcyIsIm1hcCIsImNvb3JkIiwidGlja1Byb3BzIiwidHJhbnNmb3JtIiwiY29uY2F0IiwiaW5kZXgiLCJwYXlsb2FkIiwiTGF5ZXIiLCJnZXRUaWNrQ2xhc3NOYW1lIiwiYWRhcHRFdmVudHNPZkNoaWxkIiwicmVuZGVyVGlja0l0ZW0iLCJyZW5kZXIiLCJfdGhpcyRwcm9wczUiLCJMYWJlbCIsInJlbmRlckNhbGxCeVBhcmVudCIsIm9wdGlvbiIsInRpY2tJdGVtIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJUZXh0IiwiUHVyZUNvbXBvbmVudCIsInR5cGUiLCJyYWRpdXNBeGlzSWQiLCJ0aWNrQ291bnQiLCJhbGxvd0RhdGFPdmVyZmxvdyIsInNjYWxlIiwiYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/polar/PolarRadiusAxis.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/polar/Radar.js":
/*!**************************************************!*\
  !*** ./node_modules/recharts/lib/polar/Radar.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Radar = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _last = _interopRequireDefault(__webpack_require__(/*! lodash/last */ \"lodash/last\"));\nvar _first = _interopRequireDefault(__webpack_require__(/*! lodash/first */ \"lodash/first\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"./node_modules/recharts/lib/util/Global.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _Polygon = __webpack_require__(/*! ../shape/Polygon */ \"./node_modules/recharts/lib/shape/Polygon.js\");\nvar _Dot = __webpack_require__(/*! ../shape/Dot */ \"./node_modules/recharts/lib/shape/Dot.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"./node_modules/recharts/lib/component/LabelList.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"key\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Radar\n */ \nvar Radar = exports.Radar = /*#__PURE__*/ function(_PureComponent) {\n    function Radar() {\n        var _this;\n        _classCallCheck(this, Radar);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, Radar, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            isAnimationFinished: false\n        });\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            var onAnimationEnd = _this.props.onAnimationEnd;\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationEnd)) {\n                onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            var onAnimationStart = _this.props.onAnimationStart;\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationStart)) {\n                onAnimationStart();\n            }\n        });\n        _defineProperty(_this, \"handleMouseEnter\", function(e) {\n            var onMouseEnter = _this.props.onMouseEnter;\n            if (onMouseEnter) {\n                onMouseEnter(_this.props, e);\n            }\n        });\n        _defineProperty(_this, \"handleMouseLeave\", function(e) {\n            var onMouseLeave = _this.props.onMouseLeave;\n            if (onMouseLeave) {\n                onMouseLeave(_this.props, e);\n            }\n        });\n        return _this;\n    }\n    _inherits(Radar, _PureComponent);\n    return _createClass(Radar, [\n        {\n            key: \"renderDots\",\n            value: function renderDots(points) {\n                var _this$props = this.props, dot = _this$props.dot, dataKey = _this$props.dataKey;\n                var baseProps = (0, _ReactUtils.filterProps)(this.props, false);\n                var customDotProps = (0, _ReactUtils.filterProps)(dot, true);\n                var dots = points.map(function(entry, i) {\n                    var dotProps = _objectSpread(_objectSpread(_objectSpread({\n                        key: \"dot-\".concat(i),\n                        r: 3\n                    }, baseProps), customDotProps), {}, {\n                        dataKey: dataKey,\n                        cx: entry.x,\n                        cy: entry.y,\n                        index: i,\n                        payload: entry\n                    });\n                    return Radar.renderDotItem(dot, dotProps);\n                });\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-radar-dots\"\n                }, dots);\n            }\n        },\n        {\n            key: \"renderPolygonStatically\",\n            value: function renderPolygonStatically(points) {\n                var _this$props2 = this.props, shape = _this$props2.shape, dot = _this$props2.dot, isRange = _this$props2.isRange, baseLinePoints = _this$props2.baseLinePoints, connectNulls = _this$props2.connectNulls;\n                var radar;\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(shape)) {\n                    radar = /*#__PURE__*/ _react[\"default\"].cloneElement(shape, _objectSpread(_objectSpread({}, this.props), {}, {\n                        points: points\n                    }));\n                } else if ((0, _isFunction[\"default\"])(shape)) {\n                    radar = shape(_objectSpread(_objectSpread({}, this.props), {}, {\n                        points: points\n                    }));\n                } else {\n                    radar = /*#__PURE__*/ _react[\"default\"].createElement(_Polygon.Polygon, _extends({}, (0, _ReactUtils.filterProps)(this.props, true), {\n                        onMouseEnter: this.handleMouseEnter,\n                        onMouseLeave: this.handleMouseLeave,\n                        points: points,\n                        baseLinePoints: isRange ? baseLinePoints : null,\n                        connectNulls: connectNulls\n                    }));\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-radar-polygon\"\n                }, radar, dot ? this.renderDots(points) : null);\n            }\n        },\n        {\n            key: \"renderPolygonWithAnimation\",\n            value: function renderPolygonWithAnimation() {\n                var _this2 = this;\n                var _this$props3 = this.props, points = _this$props3.points, isAnimationActive = _this$props3.isAnimationActive, animationBegin = _this$props3.animationBegin, animationDuration = _this$props3.animationDuration, animationEasing = _this$props3.animationEasing, animationId = _this$props3.animationId;\n                var prevPoints = this.state.prevPoints;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"radar-\".concat(animationId),\n                    onAnimationEnd: this.handleAnimationEnd,\n                    onAnimationStart: this.handleAnimationStart\n                }, function(_ref) {\n                    var t = _ref.t;\n                    var prevPointsDiffFactor = prevPoints && prevPoints.length / points.length;\n                    var stepData = points.map(function(entry, index) {\n                        var prev = prevPoints && prevPoints[Math.floor(index * prevPointsDiffFactor)];\n                        if (prev) {\n                            var _interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry.x);\n                            var _interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry.y);\n                            return _objectSpread(_objectSpread({}, entry), {}, {\n                                x: _interpolatorX(t),\n                                y: _interpolatorY(t)\n                            });\n                        }\n                        var interpolatorX = (0, _DataUtils.interpolateNumber)(entry.cx, entry.x);\n                        var interpolatorY = (0, _DataUtils.interpolateNumber)(entry.cy, entry.y);\n                        return _objectSpread(_objectSpread({}, entry), {}, {\n                            x: interpolatorX(t),\n                            y: interpolatorY(t)\n                        });\n                    });\n                    return _this2.renderPolygonStatically(stepData);\n                });\n            }\n        },\n        {\n            key: \"renderPolygon\",\n            value: function renderPolygon() {\n                var _this$props4 = this.props, points = _this$props4.points, isAnimationActive = _this$props4.isAnimationActive, isRange = _this$props4.isRange;\n                var prevPoints = this.state.prevPoints;\n                if (isAnimationActive && points && points.length && !isRange && (!prevPoints || !(0, _isEqual[\"default\"])(prevPoints, points))) {\n                    return this.renderPolygonWithAnimation();\n                }\n                return this.renderPolygonStatically(points);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props5 = this.props, hide = _this$props5.hide, className = _this$props5.className, points = _this$props5.points, isAnimationActive = _this$props5.isAnimationActive;\n                if (hide || !points || !points.length) {\n                    return null;\n                }\n                var isAnimationFinished = this.state.isAnimationFinished;\n                var layerClass = (0, _clsx[\"default\"])(\"recharts-radar\", className);\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass\n                }, this.renderPolygon(), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, points));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curPoints: nextProps.points,\n                        prevPoints: prevState.curPoints\n                    };\n                }\n                if (nextProps.points !== prevState.curPoints) {\n                    return {\n                        curPoints: nextProps.points\n                    };\n                }\n                return null;\n            }\n        },\n        {\n            key: \"renderDotItem\",\n            value: function renderDotItem(option, props) {\n                var dotItem;\n                if (/*#__PURE__*/ _react[\"default\"].isValidElement(option)) {\n                    dotItem = /*#__PURE__*/ _react[\"default\"].cloneElement(option, props);\n                } else if ((0, _isFunction[\"default\"])(option)) {\n                    dotItem = option(props);\n                } else {\n                    var key = props.key, dotProps = _objectWithoutProperties(props, _excluded);\n                    dotItem = /*#__PURE__*/ _react[\"default\"].createElement(_Dot.Dot, _extends({}, dotProps, {\n                        key: key,\n                        className: (0, _clsx[\"default\"])(\"recharts-radar-dot\", typeof option !== \"boolean\" ? option.className : \"\")\n                    }));\n                }\n                return dotItem;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(Radar, \"displayName\", \"Radar\");\n_defineProperty(Radar, \"defaultProps\", {\n    angleAxisId: 0,\n    radiusAxisId: 0,\n    hide: false,\n    activeDot: true,\n    dot: false,\n    legendType: \"rect\",\n    isAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 0,\n    animationDuration: 1500,\n    animationEasing: \"ease\"\n});\n_defineProperty(Radar, \"getComposedData\", function(_ref2) {\n    var radiusAxis = _ref2.radiusAxis, angleAxis = _ref2.angleAxis, displayedData = _ref2.displayedData, dataKey = _ref2.dataKey, bandSize = _ref2.bandSize;\n    var cx = angleAxis.cx, cy = angleAxis.cy;\n    var isRange = false;\n    var points = [];\n    var angleBandSize = angleAxis.type !== \"number\" ? bandSize !== null && bandSize !== void 0 ? bandSize : 0 : 0;\n    displayedData.forEach(function(entry, i) {\n        var name = (0, _ChartUtils.getValueByDataKey)(entry, angleAxis.dataKey, i);\n        var value = (0, _ChartUtils.getValueByDataKey)(entry, dataKey);\n        var angle = angleAxis.scale(name) + angleBandSize;\n        var pointValue = Array.isArray(value) ? (0, _last[\"default\"])(value) : value;\n        var radius = (0, _isNil[\"default\"])(pointValue) ? undefined : radiusAxis.scale(pointValue);\n        if (Array.isArray(value) && value.length >= 2) {\n            isRange = true;\n        }\n        points.push(_objectSpread(_objectSpread({}, (0, _PolarUtils.polarToCartesian)(cx, cy, radius, angle)), {}, {\n            name: name,\n            value: value,\n            cx: cx,\n            cy: cy,\n            radius: radius,\n            angle: angle,\n            payload: entry\n        }));\n    });\n    var baseLinePoints = [];\n    if (isRange) {\n        points.forEach(function(point) {\n            if (Array.isArray(point.value)) {\n                var baseValue = (0, _first[\"default\"])(point.value);\n                var radius = (0, _isNil[\"default\"])(baseValue) ? undefined : radiusAxis.scale(baseValue);\n                baseLinePoints.push(_objectSpread(_objectSpread({}, point), {}, {\n                    radius: radius\n                }, (0, _PolarUtils.polarToCartesian)(cx, cy, radius, point.angle)));\n            } else {\n                baseLinePoints.push(point);\n            }\n        });\n    }\n    return {\n        points: points,\n        isRange: isRange,\n        baseLinePoints: baseLinePoints\n    };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3BvbGFyL1JhZGFyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxhQUFhLEdBQUcsS0FBSztBQUNyQixJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLGVBQWVDLHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDaEUsSUFBSUcsU0FBU0QsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJSSxRQUFRRix1QkFBdUJGLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3hELElBQUlLLFNBQVNILHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDMUQsSUFBSU0sV0FBV0osdUJBQXVCRixtQkFBT0EsQ0FBQyxzQ0FBZ0I7QUFDOUQsSUFBSU8sY0FBY0wsdUJBQXVCRixtQkFBT0EsQ0FBQyw0Q0FBbUI7QUFDcEUsSUFBSVEsUUFBUU4sdUJBQXVCRixtQkFBT0EsQ0FBQyxrQkFBTTtBQUNqRCxJQUFJUyxhQUFhVCxtQkFBT0EsQ0FBQyx3RUFBbUI7QUFDNUMsSUFBSVUsVUFBVVYsbUJBQU9BLENBQUMsa0VBQWdCO0FBQ3RDLElBQUlXLGNBQWNYLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJWSxjQUFjWixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSWEsV0FBV2IsbUJBQU9BLENBQUMsc0VBQWtCO0FBQ3pDLElBQUljLE9BQU9kLG1CQUFPQSxDQUFDLDhEQUFjO0FBQ2pDLElBQUllLFNBQVNmLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUN6QyxJQUFJZ0IsYUFBYWhCLG1CQUFPQSxDQUFDLGtGQUF3QjtBQUNqRCxJQUFJaUIsY0FBY2pCLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJa0IsWUFBWTtJQUFDO0NBQU07QUFDdkIsU0FBU2hCLHVCQUF1QmlCLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UseUJBQXlCQyxDQUFDO0lBQUksSUFBSSxjQUFjLE9BQU9DLFNBQVMsT0FBTztJQUFNLElBQUlDLElBQUksSUFBSUQsV0FBV0UsSUFBSSxJQUFJRjtJQUFXLE9BQU8sQ0FBQ0YsMkJBQTJCLFNBQVNBLHlCQUF5QkMsQ0FBQztRQUFJLE9BQU9BLElBQUlHLElBQUlEO0lBQUcsR0FBR0Y7QUFBSTtBQUNuTyxTQUFTdkIsd0JBQXdCdUIsQ0FBQyxFQUFFRSxDQUFDO0lBQUksSUFBSSxDQUFDQSxLQUFLRixLQUFLQSxFQUFFRixVQUFVLEVBQUUsT0FBT0U7SUFBRyxJQUFJLFNBQVNBLEtBQUssWUFBWUksUUFBUUosTUFBTSxjQUFjLE9BQU9BLEdBQUcsT0FBTztRQUFFLFdBQVdBO0lBQUU7SUFBRyxJQUFJRyxJQUFJSix5QkFBeUJHO0lBQUksSUFBSUMsS0FBS0EsRUFBRUUsR0FBRyxDQUFDTCxJQUFJLE9BQU9HLEVBQUVHLEdBQUcsQ0FBQ047SUFBSSxJQUFJTyxJQUFJO1FBQUVDLFdBQVc7SUFBSyxHQUFHQyxJQUFJdEMsT0FBT0MsY0FBYyxJQUFJRCxPQUFPdUMsd0JBQXdCO0lBQUUsSUFBSyxJQUFJQyxLQUFLWCxFQUFHLElBQUksY0FBY1csS0FBSyxFQUFDLEdBQUVDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDYixHQUFHVyxJQUFJO1FBQUUsSUFBSUcsSUFBSUwsSUFBSXRDLE9BQU91Qyx3QkFBd0IsQ0FBQ1YsR0FBR1csS0FBSztRQUFNRyxLQUFNQSxDQUFBQSxFQUFFUixHQUFHLElBQUlRLEVBQUVDLEdBQUcsSUFBSTVDLE9BQU9DLGNBQWMsQ0FBQ21DLEdBQUdJLEdBQUdHLEtBQUtQLENBQUMsQ0FBQ0ksRUFBRSxHQUFHWCxDQUFDLENBQUNXLEVBQUU7SUFBRTtJQUFFLE9BQU9KLENBQUMsQ0FBQyxVQUFVLEdBQUdQLEdBQUdHLEtBQUtBLEVBQUVZLEdBQUcsQ0FBQ2YsR0FBR08sSUFBSUE7QUFBRztBQUN6a0IsU0FBU0gsUUFBUVksQ0FBQztJQUFJO0lBQTJCLE9BQU9aLFVBQVUsY0FBYyxPQUFPYSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHWixRQUFRWTtBQUFJO0FBQzdULFNBQVNLLHlCQUF5QkMsTUFBTSxFQUFFQyxRQUFRO0lBQUksSUFBSUQsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUFHLElBQUlFLFNBQVNDLDhCQUE4QkgsUUFBUUM7SUFBVyxJQUFJRyxLQUFLWjtJQUFHLElBQUkzQyxPQUFPd0QscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxtQkFBbUJ6RCxPQUFPd0QscUJBQXFCLENBQUNMO1FBQVMsSUFBS1IsSUFBSSxHQUFHQSxJQUFJYyxpQkFBaUJDLE1BQU0sRUFBRWYsSUFBSztZQUFFWSxNQUFNRSxnQkFBZ0IsQ0FBQ2QsRUFBRTtZQUFFLElBQUlTLFNBQVNPLE9BQU8sQ0FBQ0osUUFBUSxHQUFHO1lBQVUsSUFBSSxDQUFDdkQsT0FBT2lELFNBQVMsQ0FBQ1csb0JBQW9CLENBQUNsQixJQUFJLENBQUNTLFFBQVFJLE1BQU07WUFBVUYsTUFBTSxDQUFDRSxJQUFJLEdBQUdKLE1BQU0sQ0FBQ0ksSUFBSTtRQUFFO0lBQUU7SUFBRSxPQUFPRjtBQUFRO0FBQzNlLFNBQVNDLDhCQUE4QkgsTUFBTSxFQUFFQyxRQUFRO0lBQUksSUFBSUQsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUFHLElBQUlFLFNBQVMsQ0FBQztJQUFHLElBQUssSUFBSUUsT0FBT0osT0FBUTtRQUFFLElBQUluRCxPQUFPaUQsU0FBUyxDQUFDUixjQUFjLENBQUNDLElBQUksQ0FBQ1MsUUFBUUksTUFBTTtZQUFFLElBQUlILFNBQVNPLE9BQU8sQ0FBQ0osUUFBUSxHQUFHO1lBQVVGLE1BQU0sQ0FBQ0UsSUFBSSxHQUFHSixNQUFNLENBQUNJLElBQUk7UUFBRTtJQUFFO0lBQUUsT0FBT0Y7QUFBUTtBQUN0UixTQUFTUTtJQUFhQSxXQUFXN0QsT0FBTzhELE1BQU0sR0FBRzlELE9BQU84RCxNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVVixNQUFNO1FBQUksSUFBSyxJQUFJVixJQUFJLEdBQUdBLElBQUlxQixVQUFVTixNQUFNLEVBQUVmLElBQUs7WUFBRSxJQUFJUSxTQUFTYSxTQUFTLENBQUNyQixFQUFFO1lBQUUsSUFBSyxJQUFJWSxPQUFPSixPQUFRO2dCQUFFLElBQUluRCxPQUFPaUQsU0FBUyxDQUFDUixjQUFjLENBQUNDLElBQUksQ0FBQ1MsUUFBUUksTUFBTTtvQkFBRUYsTUFBTSxDQUFDRSxJQUFJLEdBQUdKLE1BQU0sQ0FBQ0ksSUFBSTtnQkFBRTtZQUFFO1FBQUU7UUFBRSxPQUFPRjtJQUFRO0lBQUcsT0FBT1EsU0FBU0ksS0FBSyxDQUFDLElBQUksRUFBRUQ7QUFBWTtBQUNsVixTQUFTRSxRQUFRckMsQ0FBQyxFQUFFRSxDQUFDO0lBQUksSUFBSUMsSUFBSWhDLE9BQU9tRSxJQUFJLENBQUN0QztJQUFJLElBQUk3QixPQUFPd0QscUJBQXFCLEVBQUU7UUFBRSxJQUFJWCxJQUFJN0MsT0FBT3dELHFCQUFxQixDQUFDM0I7UUFBSUUsS0FBTWMsQ0FBQUEsSUFBSUEsRUFBRXVCLE1BQU0sQ0FBQyxTQUFVckMsQ0FBQztZQUFJLE9BQU8vQixPQUFPdUMsd0JBQXdCLENBQUNWLEdBQUdFLEdBQUdzQyxVQUFVO1FBQUUsRUFBQyxHQUFJckMsRUFBRXNDLElBQUksQ0FBQ0wsS0FBSyxDQUFDakMsR0FBR2E7SUFBSTtJQUFFLE9BQU9iO0FBQUc7QUFDOVAsU0FBU3VDLGNBQWMxQyxDQUFDO0lBQUksSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlpQyxVQUFVTixNQUFNLEVBQUUzQixJQUFLO1FBQUUsSUFBSUMsSUFBSSxRQUFRZ0MsU0FBUyxDQUFDakMsRUFBRSxHQUFHaUMsU0FBUyxDQUFDakMsRUFBRSxHQUFHLENBQUM7UUFBR0EsSUFBSSxJQUFJbUMsUUFBUWxFLE9BQU9nQyxJQUFJLENBQUMsR0FBR3dDLE9BQU8sQ0FBQyxTQUFVekMsQ0FBQztZQUFJMEMsZ0JBQWdCNUMsR0FBR0UsR0FBR0MsQ0FBQyxDQUFDRCxFQUFFO1FBQUcsS0FBSy9CLE9BQU8wRSx5QkFBeUIsR0FBRzFFLE9BQU8yRSxnQkFBZ0IsQ0FBQzlDLEdBQUc3QixPQUFPMEUseUJBQXlCLENBQUMxQyxNQUFNa0MsUUFBUWxFLE9BQU9nQyxJQUFJd0MsT0FBTyxDQUFDLFNBQVV6QyxDQUFDO1lBQUkvQixPQUFPQyxjQUFjLENBQUM0QixHQUFHRSxHQUFHL0IsT0FBT3VDLHdCQUF3QixDQUFDUCxHQUFHRDtRQUFLO0lBQUk7SUFBRSxPQUFPRjtBQUFHO0FBQ3RiLFNBQVMrQyxnQkFBZ0JDLFFBQVEsRUFBRUMsV0FBVztJQUFJLElBQUksQ0FBRUQsQ0FBQUEsb0JBQW9CQyxXQUFVLEdBQUk7UUFBRSxNQUFNLElBQUlDLFVBQVU7SUFBc0M7QUFBRTtBQUN4SixTQUFTQyxrQkFBa0IzQixNQUFNLEVBQUU0QixLQUFLO0lBQUksSUFBSyxJQUFJdEMsSUFBSSxHQUFHQSxJQUFJc0MsTUFBTXZCLE1BQU0sRUFBRWYsSUFBSztRQUFFLElBQUl1QyxhQUFhRCxLQUFLLENBQUN0QyxFQUFFO1FBQUV1QyxXQUFXYixVQUFVLEdBQUdhLFdBQVdiLFVBQVUsSUFBSTtRQUFPYSxXQUFXQyxZQUFZLEdBQUc7UUFBTSxJQUFJLFdBQVdELFlBQVlBLFdBQVdFLFFBQVEsR0FBRztRQUFNcEYsT0FBT0MsY0FBYyxDQUFDb0QsUUFBUWdDLGVBQWVILFdBQVczQixHQUFHLEdBQUcyQjtJQUFhO0FBQUU7QUFDNVUsU0FBU0ksYUFBYVIsV0FBVyxFQUFFUyxVQUFVLEVBQUVDLFdBQVc7SUFBSSxJQUFJRCxZQUFZUCxrQkFBa0JGLFlBQVk3QixTQUFTLEVBQUVzQztJQUFhLElBQUlDLGFBQWFSLGtCQUFrQkYsYUFBYVU7SUFBY3hGLE9BQU9DLGNBQWMsQ0FBQzZFLGFBQWEsYUFBYTtRQUFFTSxVQUFVO0lBQU07SUFBSSxPQUFPTjtBQUFhO0FBQzVSLFNBQVNXLFdBQVd6RCxDQUFDLEVBQUVhLENBQUMsRUFBRWhCLENBQUM7SUFBSSxPQUFPZ0IsSUFBSTZDLGdCQUFnQjdDLElBQUk4QywyQkFBMkIzRCxHQUFHNEQsOEJBQThCQyxRQUFRQyxTQUFTLENBQUNqRCxHQUFHaEIsS0FBSyxFQUFFLEVBQUU2RCxnQkFBZ0IxRCxHQUFHZ0IsV0FBVyxJQUFJSCxFQUFFb0IsS0FBSyxDQUFDakMsR0FBR0g7QUFBSztBQUMxTSxTQUFTOEQsMkJBQTJCSSxJQUFJLEVBQUVyRCxJQUFJO0lBQUksSUFBSUEsUUFBU1QsQ0FBQUEsUUFBUVMsVUFBVSxZQUFZLE9BQU9BLFNBQVMsVUFBUyxHQUFJO1FBQUUsT0FBT0E7SUFBTSxPQUFPLElBQUlBLFNBQVMsS0FBSyxHQUFHO1FBQUUsTUFBTSxJQUFJcUMsVUFBVTtJQUE2RDtJQUFFLE9BQU9pQix1QkFBdUJEO0FBQU87QUFDL1IsU0FBU0MsdUJBQXVCRCxJQUFJO0lBQUksSUFBSUEsU0FBUyxLQUFLLEdBQUc7UUFBRSxNQUFNLElBQUlFLGVBQWU7SUFBOEQ7SUFBRSxPQUFPRjtBQUFNO0FBQ3JLLFNBQVNIO0lBQThCLElBQUk7UUFBRSxJQUFJNUQsSUFBSSxDQUFDa0UsUUFBUWpELFNBQVMsQ0FBQ2tELE9BQU8sQ0FBQ3pELElBQUksQ0FBQ21ELFFBQVFDLFNBQVMsQ0FBQ0ksU0FBUyxFQUFFLEVBQUUsWUFBYTtJQUFLLEVBQUUsT0FBT2xFLEdBQUcsQ0FBQztJQUFFLE9BQU8sQ0FBQzRELDRCQUE0QixTQUFTQTtRQUE4QixPQUFPLENBQUMsQ0FBQzVEO0lBQUc7QUFBTTtBQUNsUCxTQUFTMEQsZ0JBQWdCN0MsQ0FBQztJQUFJNkMsa0JBQWtCMUYsT0FBT29HLGNBQWMsR0FBR3BHLE9BQU9xRyxjQUFjLENBQUN0QyxJQUFJLEtBQUssU0FBUzJCLGdCQUFnQjdDLENBQUM7UUFBSSxPQUFPQSxFQUFFUixTQUFTLElBQUlyQyxPQUFPcUcsY0FBYyxDQUFDeEQ7SUFBSTtJQUFHLE9BQU82QyxnQkFBZ0I3QztBQUFJO0FBQ25OLFNBQVN5RCxVQUFVQyxRQUFRLEVBQUVDLFVBQVU7SUFBSSxJQUFJLE9BQU9BLGVBQWUsY0FBY0EsZUFBZSxNQUFNO1FBQUUsTUFBTSxJQUFJekIsVUFBVTtJQUF1RDtJQUFFd0IsU0FBU3RELFNBQVMsR0FBR2pELE9BQU95RyxNQUFNLENBQUNELGNBQWNBLFdBQVd2RCxTQUFTLEVBQUU7UUFBRUQsYUFBYTtZQUFFN0MsT0FBT29HO1lBQVVuQixVQUFVO1lBQU1ELGNBQWM7UUFBSztJQUFFO0lBQUluRixPQUFPQyxjQUFjLENBQUNzRyxVQUFVLGFBQWE7UUFBRW5CLFVBQVU7SUFBTTtJQUFJLElBQUlvQixZQUFZRSxnQkFBZ0JILFVBQVVDO0FBQWE7QUFDbmMsU0FBU0UsZ0JBQWdCN0QsQ0FBQyxFQUFFOEQsQ0FBQztJQUFJRCxrQkFBa0IxRyxPQUFPb0csY0FBYyxHQUFHcEcsT0FBT29HLGNBQWMsQ0FBQ3JDLElBQUksS0FBSyxTQUFTMkMsZ0JBQWdCN0QsQ0FBQyxFQUFFOEQsQ0FBQztRQUFJOUQsRUFBRVIsU0FBUyxHQUFHc0U7UUFBRyxPQUFPOUQ7SUFBRztJQUFHLE9BQU82RCxnQkFBZ0I3RCxHQUFHOEQ7QUFBSTtBQUN2TSxTQUFTbEMsZ0JBQWdCL0MsR0FBRyxFQUFFNkIsR0FBRyxFQUFFcEQsS0FBSztJQUFJb0QsTUFBTThCLGVBQWU5QjtJQUFNLElBQUlBLE9BQU83QixLQUFLO1FBQUUxQixPQUFPQyxjQUFjLENBQUN5QixLQUFLNkIsS0FBSztZQUFFcEQsT0FBT0E7WUFBT2tFLFlBQVk7WUFBTWMsY0FBYztZQUFNQyxVQUFVO1FBQUs7SUFBSSxPQUFPO1FBQUUxRCxHQUFHLENBQUM2QixJQUFJLEdBQUdwRDtJQUFPO0lBQUUsT0FBT3VCO0FBQUs7QUFDM08sU0FBUzJELGVBQWVyRCxDQUFDO0lBQUksSUFBSVcsSUFBSWlFLGFBQWE1RSxHQUFHO0lBQVcsT0FBTyxZQUFZQyxRQUFRVSxLQUFLQSxJQUFJQSxJQUFJO0FBQUk7QUFDNUcsU0FBU2lFLGFBQWE1RSxDQUFDLEVBQUVELENBQUM7SUFBSSxJQUFJLFlBQVlFLFFBQVFELE1BQU0sQ0FBQ0EsR0FBRyxPQUFPQTtJQUFHLElBQUlILElBQUlHLENBQUMsQ0FBQ2MsT0FBTytELFdBQVcsQ0FBQztJQUFFLElBQUksS0FBSyxNQUFNaEYsR0FBRztRQUFFLElBQUljLElBQUlkLEVBQUVhLElBQUksQ0FBQ1YsR0FBR0QsS0FBSztRQUFZLElBQUksWUFBWUUsUUFBUVUsSUFBSSxPQUFPQTtRQUFHLE1BQU0sSUFBSW9DLFVBQVU7SUFBaUQ7SUFBRSxPQUFPLENBQUMsYUFBYWhELElBQUkrRSxTQUFTQyxNQUFLLEVBQUcvRTtBQUFJLEVBQUU7O0NBRTVUO0FBQ0QsSUFBSTVCLFFBQVFGLGFBQWEsR0FBRyxXQUFXLEdBQUUsU0FBVThHLGNBQWM7SUFDL0QsU0FBUzVHO1FBQ1AsSUFBSTZHO1FBQ0pyQyxnQkFBZ0IsSUFBSSxFQUFFeEU7UUFDdEIsSUFBSyxJQUFJOEcsT0FBT2xELFVBQVVOLE1BQU0sRUFBRXlELE9BQU8sSUFBSUMsTUFBTUYsT0FBT0csT0FBTyxHQUFHQSxPQUFPSCxNQUFNRyxPQUFRO1lBQ3ZGRixJQUFJLENBQUNFLEtBQUssR0FBR3JELFNBQVMsQ0FBQ3FELEtBQUs7UUFDOUI7UUFDQUosUUFBUXhCLFdBQVcsSUFBSSxFQUFFckYsT0FBTyxFQUFFLENBQUNrSCxNQUFNLENBQUNIO1FBQzFDMUMsZ0JBQWdCd0MsT0FBTyxTQUFTO1lBQzlCTSxxQkFBcUI7UUFDdkI7UUFDQTlDLGdCQUFnQndDLE9BQU8sc0JBQXNCO1lBQzNDLElBQUlPLGlCQUFpQlAsTUFBTWhDLEtBQUssQ0FBQ3VDLGNBQWM7WUFDL0NQLE1BQU1RLFFBQVEsQ0FBQztnQkFDYkYscUJBQXFCO1lBQ3ZCO1lBQ0EsSUFBSSxDQUFDLEdBQUd6RyxXQUFXLENBQUMsVUFBVSxFQUFFMEcsaUJBQWlCO2dCQUMvQ0E7WUFDRjtRQUNGO1FBQ0EvQyxnQkFBZ0J3QyxPQUFPLHdCQUF3QjtZQUM3QyxJQUFJUyxtQkFBbUJULE1BQU1oQyxLQUFLLENBQUN5QyxnQkFBZ0I7WUFDbkRULE1BQU1RLFFBQVEsQ0FBQztnQkFDYkYscUJBQXFCO1lBQ3ZCO1lBQ0EsSUFBSSxDQUFDLEdBQUd6RyxXQUFXLENBQUMsVUFBVSxFQUFFNEcsbUJBQW1CO2dCQUNqREE7WUFDRjtRQUNGO1FBQ0FqRCxnQkFBZ0J3QyxPQUFPLG9CQUFvQixTQUFVcEYsQ0FBQztZQUNwRCxJQUFJOEYsZUFBZVYsTUFBTWhDLEtBQUssQ0FBQzBDLFlBQVk7WUFDM0MsSUFBSUEsY0FBYztnQkFDaEJBLGFBQWFWLE1BQU1oQyxLQUFLLEVBQUVwRDtZQUM1QjtRQUNGO1FBQ0E0QyxnQkFBZ0J3QyxPQUFPLG9CQUFvQixTQUFVcEYsQ0FBQztZQUNwRCxJQUFJK0YsZUFBZVgsTUFBTWhDLEtBQUssQ0FBQzJDLFlBQVk7WUFDM0MsSUFBSUEsY0FBYztnQkFDaEJBLGFBQWFYLE1BQU1oQyxLQUFLLEVBQUVwRDtZQUM1QjtRQUNGO1FBQ0EsT0FBT29GO0lBQ1Q7SUFDQVgsVUFBVWxHLE9BQU80RztJQUNqQixPQUFPMUIsYUFBYWxGLE9BQU87UUFBQztZQUMxQm1ELEtBQUs7WUFDTHBELE9BQU8sU0FBUzBILFdBQVdDLE1BQU07Z0JBQy9CLElBQUlDLGNBQWMsSUFBSSxDQUFDOUMsS0FBSyxFQUMxQitDLE1BQU1ELFlBQVlDLEdBQUcsRUFDckJDLFVBQVVGLFlBQVlFLE9BQU87Z0JBQy9CLElBQUlDLFlBQVksQ0FBQyxHQUFHMUcsWUFBWTJHLFdBQVcsRUFBRSxJQUFJLENBQUNsRCxLQUFLLEVBQUU7Z0JBQ3pELElBQUltRCxpQkFBaUIsQ0FBQyxHQUFHNUcsWUFBWTJHLFdBQVcsRUFBRUgsS0FBSztnQkFDdkQsSUFBSUssT0FBT1AsT0FBT1EsR0FBRyxDQUFDLFNBQVVDLEtBQUssRUFBRTVGLENBQUM7b0JBQ3RDLElBQUk2RixXQUFXakUsY0FBY0EsY0FBY0EsY0FBYzt3QkFDdkRoQixLQUFLLE9BQU8rRCxNQUFNLENBQUMzRTt3QkFDbkJaLEdBQUc7b0JBQ0wsR0FBR21HLFlBQVlFLGlCQUFpQixDQUFDLEdBQUc7d0JBQ2xDSCxTQUFTQTt3QkFDVFEsSUFBSUYsTUFBTUcsQ0FBQzt3QkFDWEMsSUFBSUosTUFBTUssQ0FBQzt3QkFDWEMsT0FBT2xHO3dCQUNQbUcsU0FBU1A7b0JBQ1g7b0JBQ0EsT0FBT25JLE1BQU0ySSxhQUFhLENBQUNmLEtBQUtRO2dCQUNsQztnQkFDQSxPQUFPLFdBQVcsR0FBRW5JLE1BQU0sQ0FBQyxVQUFVLENBQUMySSxhQUFhLENBQUMxSCxPQUFPMkgsS0FBSyxFQUFFO29CQUNoRUMsV0FBVztnQkFDYixHQUFHYjtZQUNMO1FBQ0Y7UUFBRztZQUNEOUUsS0FBSztZQUNMcEQsT0FBTyxTQUFTZ0osd0JBQXdCckIsTUFBTTtnQkFDNUMsSUFBSXNCLGVBQWUsSUFBSSxDQUFDbkUsS0FBSyxFQUMzQm9FLFFBQVFELGFBQWFDLEtBQUssRUFDMUJyQixNQUFNb0IsYUFBYXBCLEdBQUcsRUFDdEJzQixVQUFVRixhQUFhRSxPQUFPLEVBQzlCQyxpQkFBaUJILGFBQWFHLGNBQWMsRUFDNUNDLGVBQWVKLGFBQWFJLFlBQVk7Z0JBQzFDLElBQUlDO2dCQUNKLElBQUssV0FBVyxHQUFFcEosTUFBTSxDQUFDLFVBQVUsQ0FBQ3FKLGNBQWMsQ0FBQ0wsUUFBUTtvQkFDekRJLFFBQVEsV0FBVyxHQUFFcEosTUFBTSxDQUFDLFVBQVUsQ0FBQ3NKLFlBQVksQ0FBQ04sT0FBTzlFLGNBQWNBLGNBQWMsQ0FBQyxHQUFHLElBQUksQ0FBQ1UsS0FBSyxHQUFHLENBQUMsR0FBRzt3QkFDMUc2QyxRQUFRQTtvQkFDVjtnQkFDRixPQUFPLElBQUksQ0FBQyxHQUFHaEgsV0FBVyxDQUFDLFVBQVUsRUFBRXVJLFFBQVE7b0JBQzdDSSxRQUFRSixNQUFNOUUsY0FBY0EsY0FBYyxDQUFDLEdBQUcsSUFBSSxDQUFDVSxLQUFLLEdBQUcsQ0FBQyxHQUFHO3dCQUM3RDZDLFFBQVFBO29CQUNWO2dCQUNGLE9BQU87b0JBQ0wyQixRQUFRLFdBQVcsR0FBRXBKLE1BQU0sQ0FBQyxVQUFVLENBQUMySSxhQUFhLENBQUM1SCxTQUFTd0ksT0FBTyxFQUFFL0YsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHckMsWUFBWTJHLFdBQVcsRUFBRSxJQUFJLENBQUNsRCxLQUFLLEVBQUUsT0FBTzt3QkFDbEkwQyxjQUFjLElBQUksQ0FBQ2tDLGdCQUFnQjt3QkFDbkNqQyxjQUFjLElBQUksQ0FBQ2tDLGdCQUFnQjt3QkFDbkNoQyxRQUFRQTt3QkFDUnlCLGdCQUFnQkQsVUFBVUMsaUJBQWlCO3dCQUMzQ0MsY0FBY0E7b0JBQ2hCO2dCQUNGO2dCQUNBLE9BQU8sV0FBVyxHQUFFbkosTUFBTSxDQUFDLFVBQVUsQ0FBQzJJLGFBQWEsQ0FBQzFILE9BQU8ySCxLQUFLLEVBQUU7b0JBQ2hFQyxXQUFXO2dCQUNiLEdBQUdPLE9BQU96QixNQUFNLElBQUksQ0FBQ0gsVUFBVSxDQUFDQyxVQUFVO1lBQzVDO1FBQ0Y7UUFBRztZQUNEdkUsS0FBSztZQUNMcEQsT0FBTyxTQUFTNEo7Z0JBQ2QsSUFBSUMsU0FBUyxJQUFJO2dCQUNqQixJQUFJQyxlQUFlLElBQUksQ0FBQ2hGLEtBQUssRUFDM0I2QyxTQUFTbUMsYUFBYW5DLE1BQU0sRUFDNUJvQyxvQkFBb0JELGFBQWFDLGlCQUFpQixFQUNsREMsaUJBQWlCRixhQUFhRSxjQUFjLEVBQzVDQyxvQkFBb0JILGFBQWFHLGlCQUFpQixFQUNsREMsa0JBQWtCSixhQUFhSSxlQUFlLEVBQzlDQyxjQUFjTCxhQUFhSyxXQUFXO2dCQUN4QyxJQUFJQyxhQUFhLElBQUksQ0FBQ0MsS0FBSyxDQUFDRCxVQUFVO2dCQUN0QyxPQUFPLFdBQVcsR0FBRWxLLE1BQU0sQ0FBQyxVQUFVLENBQUMySSxhQUFhLENBQUN4SSxZQUFZLENBQUMsVUFBVSxFQUFFO29CQUMzRWlLLE9BQU9OO29CQUNQTyxVQUFVTjtvQkFDVk8sVUFBVVQ7b0JBQ1ZVLFFBQVFQO29CQUNSUSxNQUFNO3dCQUNKN0ksR0FBRztvQkFDTDtvQkFDQThJLElBQUk7d0JBQ0Y5SSxHQUFHO29CQUNMO29CQUNBdUIsS0FBSyxTQUFTK0QsTUFBTSxDQUFDZ0Q7b0JBQ3JCOUMsZ0JBQWdCLElBQUksQ0FBQ3VELGtCQUFrQjtvQkFDdkNyRCxrQkFBa0IsSUFBSSxDQUFDc0Qsb0JBQW9CO2dCQUM3QyxHQUFHLFNBQVVDLElBQUk7b0JBQ2YsSUFBSWpKLElBQUlpSixLQUFLakosQ0FBQztvQkFDZCxJQUFJa0osdUJBQXVCWCxjQUFjQSxXQUFXN0csTUFBTSxHQUFHb0UsT0FBT3BFLE1BQU07b0JBQzFFLElBQUl5SCxXQUFXckQsT0FBT1EsR0FBRyxDQUFDLFNBQVVDLEtBQUssRUFBRU0sS0FBSzt3QkFDOUMsSUFBSXVDLE9BQU9iLGNBQWNBLFVBQVUsQ0FBQ2MsS0FBS0MsS0FBSyxDQUFDekMsUUFBUXFDLHNCQUFzQjt3QkFDN0UsSUFBSUUsTUFBTTs0QkFDUixJQUFJRyxpQkFBaUIsQ0FBQyxHQUFHdkssV0FBV3dLLGlCQUFpQixFQUFFSixLQUFLMUMsQ0FBQyxFQUFFSCxNQUFNRyxDQUFDOzRCQUN0RSxJQUFJK0MsaUJBQWlCLENBQUMsR0FBR3pLLFdBQVd3SyxpQkFBaUIsRUFBRUosS0FBS3hDLENBQUMsRUFBRUwsTUFBTUssQ0FBQzs0QkFDdEUsT0FBT3JFLGNBQWNBLGNBQWMsQ0FBQyxHQUFHZ0UsUUFBUSxDQUFDLEdBQUc7Z0NBQ2pERyxHQUFHNkMsZUFBZXZKO2dDQUNsQjRHLEdBQUc2QyxlQUFleko7NEJBQ3BCO3dCQUNGO3dCQUNBLElBQUkwSixnQkFBZ0IsQ0FBQyxHQUFHMUssV0FBV3dLLGlCQUFpQixFQUFFakQsTUFBTUUsRUFBRSxFQUFFRixNQUFNRyxDQUFDO3dCQUN2RSxJQUFJaUQsZ0JBQWdCLENBQUMsR0FBRzNLLFdBQVd3SyxpQkFBaUIsRUFBRWpELE1BQU1JLEVBQUUsRUFBRUosTUFBTUssQ0FBQzt3QkFDdkUsT0FBT3JFLGNBQWNBLGNBQWMsQ0FBQyxHQUFHZ0UsUUFBUSxDQUFDLEdBQUc7NEJBQ2pERyxHQUFHZ0QsY0FBYzFKOzRCQUNqQjRHLEdBQUcrQyxjQUFjM0o7d0JBQ25CO29CQUNGO29CQUNBLE9BQU9nSSxPQUFPYix1QkFBdUIsQ0FBQ2dDO2dCQUN4QztZQUNGO1FBQ0Y7UUFBRztZQUNENUgsS0FBSztZQUNMcEQsT0FBTyxTQUFTeUw7Z0JBQ2QsSUFBSUMsZUFBZSxJQUFJLENBQUM1RyxLQUFLLEVBQzNCNkMsU0FBUytELGFBQWEvRCxNQUFNLEVBQzVCb0Msb0JBQW9CMkIsYUFBYTNCLGlCQUFpQixFQUNsRFosVUFBVXVDLGFBQWF2QyxPQUFPO2dCQUNoQyxJQUFJaUIsYUFBYSxJQUFJLENBQUNDLEtBQUssQ0FBQ0QsVUFBVTtnQkFDdEMsSUFBSUwscUJBQXFCcEMsVUFBVUEsT0FBT3BFLE1BQU0sSUFBSSxDQUFDNEYsV0FBWSxFQUFDaUIsY0FBYyxDQUFDLENBQUMsR0FBRzFKLFFBQVEsQ0FBQyxVQUFVLEVBQUUwSixZQUFZekMsT0FBTSxHQUFJO29CQUM5SCxPQUFPLElBQUksQ0FBQ2lDLDBCQUEwQjtnQkFDeEM7Z0JBQ0EsT0FBTyxJQUFJLENBQUNaLHVCQUF1QixDQUFDckI7WUFDdEM7UUFDRjtRQUFHO1lBQ0R2RSxLQUFLO1lBQ0xwRCxPQUFPLFNBQVMyTDtnQkFDZCxJQUFJQyxlQUFlLElBQUksQ0FBQzlHLEtBQUssRUFDM0IrRyxPQUFPRCxhQUFhQyxJQUFJLEVBQ3hCOUMsWUFBWTZDLGFBQWE3QyxTQUFTLEVBQ2xDcEIsU0FBU2lFLGFBQWFqRSxNQUFNLEVBQzVCb0Msb0JBQW9CNkIsYUFBYTdCLGlCQUFpQjtnQkFDcEQsSUFBSThCLFFBQVEsQ0FBQ2xFLFVBQVUsQ0FBQ0EsT0FBT3BFLE1BQU0sRUFBRTtvQkFDckMsT0FBTztnQkFDVDtnQkFDQSxJQUFJNkQsc0JBQXNCLElBQUksQ0FBQ2lELEtBQUssQ0FBQ2pELG1CQUFtQjtnQkFDeEQsSUFBSTBFLGFBQWEsQ0FBQyxHQUFHbEwsS0FBSyxDQUFDLFVBQVUsRUFBRSxrQkFBa0JtSTtnQkFDekQsT0FBTyxXQUFXLEdBQUU3SSxNQUFNLENBQUMsVUFBVSxDQUFDMkksYUFBYSxDQUFDMUgsT0FBTzJILEtBQUssRUFBRTtvQkFDaEVDLFdBQVcrQztnQkFDYixHQUFHLElBQUksQ0FBQ0wsYUFBYSxJQUFJLENBQUMsQ0FBQzFCLHFCQUFxQjNDLG1CQUFrQixLQUFNaEcsV0FBVzJLLFNBQVMsQ0FBQ0Msa0JBQWtCLENBQUMsSUFBSSxDQUFDbEgsS0FBSyxFQUFFNkM7WUFDOUg7UUFDRjtLQUFFLEVBQUU7UUFBQztZQUNIdkUsS0FBSztZQUNMcEQsT0FBTyxTQUFTaU0seUJBQXlCQyxTQUFTLEVBQUVDLFNBQVM7Z0JBQzNELElBQUlELFVBQVUvQixXQUFXLEtBQUtnQyxVQUFVQyxlQUFlLEVBQUU7b0JBQ3ZELE9BQU87d0JBQ0xBLGlCQUFpQkYsVUFBVS9CLFdBQVc7d0JBQ3RDa0MsV0FBV0gsVUFBVXZFLE1BQU07d0JBQzNCeUMsWUFBWStCLFVBQVVFLFNBQVM7b0JBQ2pDO2dCQUNGO2dCQUNBLElBQUlILFVBQVV2RSxNQUFNLEtBQUt3RSxVQUFVRSxTQUFTLEVBQUU7b0JBQzVDLE9BQU87d0JBQ0xBLFdBQVdILFVBQVV2RSxNQUFNO29CQUM3QjtnQkFDRjtnQkFDQSxPQUFPO1lBQ1Q7UUFDRjtRQUFHO1lBQ0R2RSxLQUFLO1lBQ0xwRCxPQUFPLFNBQVM0SSxjQUFjMEQsTUFBTSxFQUFFeEgsS0FBSztnQkFDekMsSUFBSXlIO2dCQUNKLElBQUssV0FBVyxHQUFFck0sTUFBTSxDQUFDLFVBQVUsQ0FBQ3FKLGNBQWMsQ0FBQytDLFNBQVM7b0JBQzFEQyxVQUFVLFdBQVcsR0FBRXJNLE1BQU0sQ0FBQyxVQUFVLENBQUNzSixZQUFZLENBQUM4QyxRQUFReEg7Z0JBQ2hFLE9BQU8sSUFBSSxDQUFDLEdBQUduRSxXQUFXLENBQUMsVUFBVSxFQUFFMkwsU0FBUztvQkFDOUNDLFVBQVVELE9BQU94SDtnQkFDbkIsT0FBTztvQkFDTCxJQUFJMUIsTUFBTTBCLE1BQU0xQixHQUFHLEVBQ2pCaUYsV0FBV3RGLHlCQUF5QitCLE9BQU94RDtvQkFDN0NpTCxVQUFVLFdBQVcsR0FBRXJNLE1BQU0sQ0FBQyxVQUFVLENBQUMySSxhQUFhLENBQUMzSCxLQUFLc0wsR0FBRyxFQUFFOUksU0FBUyxDQUFDLEdBQUcyRSxVQUFVO3dCQUN0RmpGLEtBQUtBO3dCQUNMMkYsV0FBVyxDQUFDLEdBQUduSSxLQUFLLENBQUMsVUFBVSxFQUFFLHNCQUFzQixPQUFPMEwsV0FBVyxZQUFZQSxPQUFPdkQsU0FBUyxHQUFHO29CQUMxRztnQkFDRjtnQkFDQSxPQUFPd0Q7WUFDVDtRQUNGO0tBQUU7QUFDSixFQUFFck0sT0FBT3VNLGFBQWE7QUFDdEJuSSxnQkFBZ0JyRSxPQUFPLGVBQWU7QUFDdENxRSxnQkFBZ0JyRSxPQUFPLGdCQUFnQjtJQUNyQ3lNLGFBQWE7SUFDYkMsY0FBYztJQUNkZCxNQUFNO0lBQ05lLFdBQVc7SUFDWC9FLEtBQUs7SUFDTGdGLFlBQVk7SUFDWjlDLG1CQUFtQixDQUFDakosUUFBUWdNLE1BQU0sQ0FBQ0MsS0FBSztJQUN4Qy9DLGdCQUFnQjtJQUNoQkMsbUJBQW1CO0lBQ25CQyxpQkFBaUI7QUFDbkI7QUFDQTVGLGdCQUFnQnJFLE9BQU8sbUJBQW1CLFNBQVUrTSxLQUFLO0lBQ3ZELElBQUlDLGFBQWFELE1BQU1DLFVBQVUsRUFDL0JDLFlBQVlGLE1BQU1FLFNBQVMsRUFDM0JDLGdCQUFnQkgsTUFBTUcsYUFBYSxFQUNuQ3JGLFVBQVVrRixNQUFNbEYsT0FBTyxFQUN2QnNGLFdBQVdKLE1BQU1JLFFBQVE7SUFDM0IsSUFBSTlFLEtBQUs0RSxVQUFVNUUsRUFBRSxFQUNuQkUsS0FBSzBFLFVBQVUxRSxFQUFFO0lBQ25CLElBQUlXLFVBQVU7SUFDZCxJQUFJeEIsU0FBUyxFQUFFO0lBQ2YsSUFBSTBGLGdCQUFnQkgsVUFBVUksSUFBSSxLQUFLLFdBQVdGLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUlBLFdBQVcsSUFBSTtJQUM1R0QsY0FBYzlJLE9BQU8sQ0FBQyxTQUFVK0QsS0FBSyxFQUFFNUYsQ0FBQztRQUN0QyxJQUFJK0ssT0FBTyxDQUFDLEdBQUd2TSxZQUFZd00saUJBQWlCLEVBQUVwRixPQUFPOEUsVUFBVXBGLE9BQU8sRUFBRXRGO1FBQ3hFLElBQUl4QyxRQUFRLENBQUMsR0FBR2dCLFlBQVl3TSxpQkFBaUIsRUFBRXBGLE9BQU9OO1FBQ3RELElBQUkyRixRQUFRUCxVQUFVUSxLQUFLLENBQUNILFFBQVFGO1FBQ3BDLElBQUlNLGFBQWExRyxNQUFNMkcsT0FBTyxDQUFDNU4sU0FBUyxDQUFDLEdBQUdRLEtBQUssQ0FBQyxVQUFVLEVBQUVSLFNBQVNBO1FBQ3ZFLElBQUk2TixTQUFTLENBQUMsR0FBR3ROLE1BQU0sQ0FBQyxVQUFVLEVBQUVvTixjQUFjRyxZQUFZYixXQUFXUyxLQUFLLENBQUNDO1FBQy9FLElBQUkxRyxNQUFNMkcsT0FBTyxDQUFDNU4sVUFBVUEsTUFBTXVELE1BQU0sSUFBSSxHQUFHO1lBQzdDNEYsVUFBVTtRQUNaO1FBQ0F4QixPQUFPeEQsSUFBSSxDQUFDQyxjQUFjQSxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUdyRCxZQUFZZ04sZ0JBQWdCLEVBQUV6RixJQUFJRSxJQUFJcUYsUUFBUUosU0FBUyxDQUFDLEdBQUc7WUFDekdGLE1BQU1BO1lBQ052TixPQUFPQTtZQUNQc0ksSUFBSUE7WUFDSkUsSUFBSUE7WUFDSnFGLFFBQVFBO1lBQ1JKLE9BQU9BO1lBQ1A5RSxTQUFTUDtRQUNYO0lBQ0Y7SUFDQSxJQUFJZ0IsaUJBQWlCLEVBQUU7SUFDdkIsSUFBSUQsU0FBUztRQUNYeEIsT0FBT3RELE9BQU8sQ0FBQyxTQUFVMkosS0FBSztZQUM1QixJQUFJL0csTUFBTTJHLE9BQU8sQ0FBQ0ksTUFBTWhPLEtBQUssR0FBRztnQkFDOUIsSUFBSWlPLFlBQVksQ0FBQyxHQUFHeE4sTUFBTSxDQUFDLFVBQVUsRUFBRXVOLE1BQU1oTyxLQUFLO2dCQUNsRCxJQUFJNk4sU0FBUyxDQUFDLEdBQUd0TixNQUFNLENBQUMsVUFBVSxFQUFFME4sYUFBYUgsWUFBWWIsV0FBV1MsS0FBSyxDQUFDTztnQkFDOUU3RSxlQUFlakYsSUFBSSxDQUFDQyxjQUFjQSxjQUFjLENBQUMsR0FBRzRKLFFBQVEsQ0FBQyxHQUFHO29CQUM5REgsUUFBUUE7Z0JBQ1YsR0FBRyxDQUFDLEdBQUc5TSxZQUFZZ04sZ0JBQWdCLEVBQUV6RixJQUFJRSxJQUFJcUYsUUFBUUcsTUFBTVAsS0FBSztZQUNsRSxPQUFPO2dCQUNMckUsZUFBZWpGLElBQUksQ0FBQzZKO1lBQ3RCO1FBQ0Y7SUFDRjtJQUNBLE9BQU87UUFDTHJHLFFBQVFBO1FBQ1J3QixTQUFTQTtRQUNUQyxnQkFBZ0JBO0lBQ2xCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3BvbGFyL1JhZGFyLmpzP2IzZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlJhZGFyID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3JlYWN0U21vb3RoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3Qtc21vb3RoXCIpKTtcbnZhciBfaXNOaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNOaWxcIikpO1xudmFyIF9sYXN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2xhc3RcIikpO1xudmFyIF9maXJzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9maXJzdFwiKSk7XG52YXIgX2lzRXF1YWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNFcXVhbFwiKSk7XG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvRGF0YVV0aWxzXCIpO1xudmFyIF9HbG9iYWwgPSByZXF1aXJlKFwiLi4vdXRpbC9HbG9iYWxcIik7XG52YXIgX1BvbGFyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Qb2xhclV0aWxzXCIpO1xudmFyIF9DaGFydFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvQ2hhcnRVdGlsc1wiKTtcbnZhciBfUG9seWdvbiA9IHJlcXVpcmUoXCIuLi9zaGFwZS9Qb2x5Z29uXCIpO1xudmFyIF9Eb3QgPSByZXF1aXJlKFwiLi4vc2hhcGUvRG90XCIpO1xudmFyIF9MYXllciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvTGF5ZXJcIik7XG52YXIgX0xhYmVsTGlzdCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQvTGFiZWxMaXN0XCIpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcbnZhciBfZXhjbHVkZWQgPSBbXCJrZXlcIl07XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxuICogQGZpbGVPdmVydmlldyBSYWRhclxuICovXG52YXIgUmFkYXIgPSBleHBvcnRzLlJhZGFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBmdW5jdGlvbiBSYWRhcigpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhZGFyKTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBSYWRhciwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwic3RhdGVcIiwge1xuICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogZmFsc2VcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQW5pbWF0aW9uRW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvbkFuaW1hdGlvbkVuZCA9IF90aGlzLnByb3BzLm9uQW5pbWF0aW9uRW5kO1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvbkFuaW1hdGlvbkVuZCkpIHtcbiAgICAgICAgb25BbmltYXRpb25FbmQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQW5pbWF0aW9uU3RhcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9uQW5pbWF0aW9uU3RhcnQgPSBfdGhpcy5wcm9wcy5vbkFuaW1hdGlvblN0YXJ0O1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob25BbmltYXRpb25TdGFydCkpIHtcbiAgICAgICAgb25BbmltYXRpb25TdGFydCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVNb3VzZUVudGVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgb25Nb3VzZUVudGVyID0gX3RoaXMucHJvcHMub25Nb3VzZUVudGVyO1xuICAgICAgaWYgKG9uTW91c2VFbnRlcikge1xuICAgICAgICBvbk1vdXNlRW50ZXIoX3RoaXMucHJvcHMsIGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVNb3VzZUxlYXZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgb25Nb3VzZUxlYXZlID0gX3RoaXMucHJvcHMub25Nb3VzZUxlYXZlO1xuICAgICAgaWYgKG9uTW91c2VMZWF2ZSkge1xuICAgICAgICBvbk1vdXNlTGVhdmUoX3RoaXMucHJvcHMsIGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoUmFkYXIsIF9QdXJlQ29tcG9uZW50KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhSYWRhciwgW3tcbiAgICBrZXk6IFwicmVuZGVyRG90c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJEb3RzKHBvaW50cykge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgZG90ID0gX3RoaXMkcHJvcHMuZG90LFxuICAgICAgICBkYXRhS2V5ID0gX3RoaXMkcHJvcHMuZGF0YUtleTtcbiAgICAgIHZhciBiYXNlUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRoaXMucHJvcHMsIGZhbHNlKTtcbiAgICAgIHZhciBjdXN0b21Eb3RQcm9wcyA9ICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykoZG90LCB0cnVlKTtcbiAgICAgIHZhciBkb3RzID0gcG9pbnRzLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgICAgICAgdmFyIGRvdFByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIGtleTogXCJkb3QtXCIuY29uY2F0KGkpLFxuICAgICAgICAgIHI6IDNcbiAgICAgICAgfSwgYmFzZVByb3BzKSwgY3VzdG9tRG90UHJvcHMpLCB7fSwge1xuICAgICAgICAgIGRhdGFLZXk6IGRhdGFLZXksXG4gICAgICAgICAgY3g6IGVudHJ5LngsXG4gICAgICAgICAgY3k6IGVudHJ5LnksXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgcGF5bG9hZDogZW50cnlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBSYWRhci5yZW5kZXJEb3RJdGVtKGRvdCwgZG90UHJvcHMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlY2hhcnRzLXJhZGFyLWRvdHNcIlxuICAgICAgfSwgZG90cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclBvbHlnb25TdGF0aWNhbGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclBvbHlnb25TdGF0aWNhbGx5KHBvaW50cykge1xuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIHNoYXBlID0gX3RoaXMkcHJvcHMyLnNoYXBlLFxuICAgICAgICBkb3QgPSBfdGhpcyRwcm9wczIuZG90LFxuICAgICAgICBpc1JhbmdlID0gX3RoaXMkcHJvcHMyLmlzUmFuZ2UsXG4gICAgICAgIGJhc2VMaW5lUG9pbnRzID0gX3RoaXMkcHJvcHMyLmJhc2VMaW5lUG9pbnRzLFxuICAgICAgICBjb25uZWN0TnVsbHMgPSBfdGhpcyRwcm9wczIuY29ubmVjdE51bGxzO1xuICAgICAgdmFyIHJhZGFyO1xuICAgICAgaWYgKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5pc1ZhbGlkRWxlbWVudChzaGFwZSkpIHtcbiAgICAgICAgcmFkYXIgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQoc2hhcGUsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5wcm9wcyksIHt9LCB7XG4gICAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShzaGFwZSkpIHtcbiAgICAgICAgcmFkYXIgPSBzaGFwZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMucHJvcHMpLCB7fSwge1xuICAgICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhZGFyID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfUG9seWdvbi5Qb2x5Z29uLCBfZXh0ZW5kcyh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aGlzLnByb3BzLCB0cnVlKSwge1xuICAgICAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5oYW5kbGVNb3VzZUVudGVyLFxuICAgICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5oYW5kbGVNb3VzZUxlYXZlLFxuICAgICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgICAgIGJhc2VMaW5lUG9pbnRzOiBpc1JhbmdlID8gYmFzZUxpbmVQb2ludHMgOiBudWxsLFxuICAgICAgICAgIGNvbm5lY3ROdWxsczogY29ubmVjdE51bGxzXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtcmFkYXItcG9seWdvblwiXG4gICAgICB9LCByYWRhciwgZG90ID8gdGhpcy5yZW5kZXJEb3RzKHBvaW50cykgOiBudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyUG9seWdvbldpdGhBbmltYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyUG9seWdvbldpdGhBbmltYXRpb24oKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICBwb2ludHMgPSBfdGhpcyRwcm9wczMucG9pbnRzLFxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzMy5pc0FuaW1hdGlvbkFjdGl2ZSxcbiAgICAgICAgYW5pbWF0aW9uQmVnaW4gPSBfdGhpcyRwcm9wczMuYW5pbWF0aW9uQmVnaW4sXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uID0gX3RoaXMkcHJvcHMzLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICBhbmltYXRpb25FYXNpbmcgPSBfdGhpcyRwcm9wczMuYW5pbWF0aW9uRWFzaW5nLFxuICAgICAgICBhbmltYXRpb25JZCA9IF90aGlzJHByb3BzMy5hbmltYXRpb25JZDtcbiAgICAgIHZhciBwcmV2UG9pbnRzID0gdGhpcy5zdGF0ZS5wcmV2UG9pbnRzO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JlYWN0U21vb3RoW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICBiZWdpbjogYW5pbWF0aW9uQmVnaW4sXG4gICAgICAgIGR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgaXNBY3RpdmU6IGlzQW5pbWF0aW9uQWN0aXZlLFxuICAgICAgICBlYXNpbmc6IGFuaW1hdGlvbkVhc2luZyxcbiAgICAgICAgZnJvbToge1xuICAgICAgICAgIHQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgdG86IHtcbiAgICAgICAgICB0OiAxXG4gICAgICAgIH0sXG4gICAgICAgIGtleTogXCJyYWRhci1cIi5jb25jYXQoYW5pbWF0aW9uSWQpLFxuICAgICAgICBvbkFuaW1hdGlvbkVuZDogdGhpcy5oYW5kbGVBbmltYXRpb25FbmQsXG4gICAgICAgIG9uQW5pbWF0aW9uU3RhcnQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uU3RhcnRcbiAgICAgIH0sIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciB0ID0gX3JlZi50O1xuICAgICAgICB2YXIgcHJldlBvaW50c0RpZmZGYWN0b3IgPSBwcmV2UG9pbnRzICYmIHByZXZQb2ludHMubGVuZ3RoIC8gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIHN0ZXBEYXRhID0gcG9pbnRzLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XG4gICAgICAgICAgdmFyIHByZXYgPSBwcmV2UG9pbnRzICYmIHByZXZQb2ludHNbTWF0aC5mbG9vcihpbmRleCAqIHByZXZQb2ludHNEaWZmRmFjdG9yKV07XG4gICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIHZhciBfaW50ZXJwb2xhdG9yWCA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2LngsIGVudHJ5LngpO1xuICAgICAgICAgICAgdmFyIF9pbnRlcnBvbGF0b3JZID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXYueSwgZW50cnkueSk7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XG4gICAgICAgICAgICAgIHg6IF9pbnRlcnBvbGF0b3JYKHQpLFxuICAgICAgICAgICAgICB5OiBfaW50ZXJwb2xhdG9yWSh0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3JYID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKGVudHJ5LmN4LCBlbnRyeS54KTtcbiAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yWSA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShlbnRyeS5jeSwgZW50cnkueSk7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCB7fSwge1xuICAgICAgICAgICAgeDogaW50ZXJwb2xhdG9yWCh0KSxcbiAgICAgICAgICAgIHk6IGludGVycG9sYXRvclkodClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpczIucmVuZGVyUG9seWdvblN0YXRpY2FsbHkoc3RlcERhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclBvbHlnb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyUG9seWdvbigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICBwb2ludHMgPSBfdGhpcyRwcm9wczQucG9pbnRzLFxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzNC5pc0FuaW1hdGlvbkFjdGl2ZSxcbiAgICAgICAgaXNSYW5nZSA9IF90aGlzJHByb3BzNC5pc1JhbmdlO1xuICAgICAgdmFyIHByZXZQb2ludHMgPSB0aGlzLnN0YXRlLnByZXZQb2ludHM7XG4gICAgICBpZiAoaXNBbmltYXRpb25BY3RpdmUgJiYgcG9pbnRzICYmIHBvaW50cy5sZW5ndGggJiYgIWlzUmFuZ2UgJiYgKCFwcmV2UG9pbnRzIHx8ICEoMCwgX2lzRXF1YWxbXCJkZWZhdWx0XCJdKShwcmV2UG9pbnRzLCBwb2ludHMpKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJQb2x5Z29uV2l0aEFuaW1hdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUG9seWdvblN0YXRpY2FsbHkocG9pbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczUgPSB0aGlzLnByb3BzLFxuICAgICAgICBoaWRlID0gX3RoaXMkcHJvcHM1LmhpZGUsXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzNS5jbGFzc05hbWUsXG4gICAgICAgIHBvaW50cyA9IF90aGlzJHByb3BzNS5wb2ludHMsXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHM1LmlzQW5pbWF0aW9uQWN0aXZlO1xuICAgICAgaWYgKGhpZGUgfHwgIXBvaW50cyB8fCAhcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FuaW1hdGlvbkZpbmlzaGVkID0gdGhpcy5zdGF0ZS5pc0FuaW1hdGlvbkZpbmlzaGVkO1xuICAgICAgdmFyIGxheWVyQ2xhc3MgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtcmFkYXInLCBjbGFzc05hbWUpO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XG4gICAgICAgIGNsYXNzTmFtZTogbGF5ZXJDbGFzc1xuICAgICAgfSwgdGhpcy5yZW5kZXJQb2x5Z29uKCksICghaXNBbmltYXRpb25BY3RpdmUgfHwgaXNBbmltYXRpb25GaW5pc2hlZCkgJiYgX0xhYmVsTGlzdC5MYWJlbExpc3QucmVuZGVyQ2FsbEJ5UGFyZW50KHRoaXMucHJvcHMsIHBvaW50cykpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuYW5pbWF0aW9uSWQgIT09IHByZXZTdGF0ZS5wcmV2QW5pbWF0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcmV2QW5pbWF0aW9uSWQ6IG5leHRQcm9wcy5hbmltYXRpb25JZCxcbiAgICAgICAgICBjdXJQb2ludHM6IG5leHRQcm9wcy5wb2ludHMsXG4gICAgICAgICAgcHJldlBvaW50czogcHJldlN0YXRlLmN1clBvaW50c1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKG5leHRQcm9wcy5wb2ludHMgIT09IHByZXZTdGF0ZS5jdXJQb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjdXJQb2ludHM6IG5leHRQcm9wcy5wb2ludHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJEb3RJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckRvdEl0ZW0ob3B0aW9uLCBwcm9wcykge1xuICAgICAgdmFyIGRvdEl0ZW07XG4gICAgICBpZiAoIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmlzVmFsaWRFbGVtZW50KG9wdGlvbikpIHtcbiAgICAgICAgZG90SXRlbSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChvcHRpb24sIHByb3BzKTtcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob3B0aW9uKSkge1xuICAgICAgICBkb3RJdGVtID0gb3B0aW9uKHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wcy5rZXksXG4gICAgICAgICAgZG90UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCk7XG4gICAgICAgIGRvdEl0ZW0gPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9Eb3QuRG90LCBfZXh0ZW5kcyh7fSwgZG90UHJvcHMsIHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1yYWRhci1kb3QnLCB0eXBlb2Ygb3B0aW9uICE9PSAnYm9vbGVhbicgPyBvcHRpb24uY2xhc3NOYW1lIDogJycpXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb3RJdGVtO1xuICAgIH1cbiAgfV0pO1xufShfcmVhY3QuUHVyZUNvbXBvbmVudCk7XG5fZGVmaW5lUHJvcGVydHkoUmFkYXIsIFwiZGlzcGxheU5hbWVcIiwgJ1JhZGFyJyk7XG5fZGVmaW5lUHJvcGVydHkoUmFkYXIsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgYW5nbGVBeGlzSWQ6IDAsXG4gIHJhZGl1c0F4aXNJZDogMCxcbiAgaGlkZTogZmFsc2UsXG4gIGFjdGl2ZURvdDogdHJ1ZSxcbiAgZG90OiBmYWxzZSxcbiAgbGVnZW5kVHlwZTogJ3JlY3QnLFxuICBpc0FuaW1hdGlvbkFjdGl2ZTogIV9HbG9iYWwuR2xvYmFsLmlzU3NyLFxuICBhbmltYXRpb25CZWdpbjogMCxcbiAgYW5pbWF0aW9uRHVyYXRpb246IDE1MDAsXG4gIGFuaW1hdGlvbkVhc2luZzogJ2Vhc2UnXG59KTtcbl9kZWZpbmVQcm9wZXJ0eShSYWRhciwgXCJnZXRDb21wb3NlZERhdGFcIiwgZnVuY3Rpb24gKF9yZWYyKSB7XG4gIHZhciByYWRpdXNBeGlzID0gX3JlZjIucmFkaXVzQXhpcyxcbiAgICBhbmdsZUF4aXMgPSBfcmVmMi5hbmdsZUF4aXMsXG4gICAgZGlzcGxheWVkRGF0YSA9IF9yZWYyLmRpc3BsYXllZERhdGEsXG4gICAgZGF0YUtleSA9IF9yZWYyLmRhdGFLZXksXG4gICAgYmFuZFNpemUgPSBfcmVmMi5iYW5kU2l6ZTtcbiAgdmFyIGN4ID0gYW5nbGVBeGlzLmN4LFxuICAgIGN5ID0gYW5nbGVBeGlzLmN5O1xuICB2YXIgaXNSYW5nZSA9IGZhbHNlO1xuICB2YXIgcG9pbnRzID0gW107XG4gIHZhciBhbmdsZUJhbmRTaXplID0gYW5nbGVBeGlzLnR5cGUgIT09ICdudW1iZXInID8gYmFuZFNpemUgIT09IG51bGwgJiYgYmFuZFNpemUgIT09IHZvaWQgMCA/IGJhbmRTaXplIDogMCA6IDA7XG4gIGRpc3BsYXllZERhdGEuZm9yRWFjaChmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgICB2YXIgbmFtZSA9ICgwLCBfQ2hhcnRVdGlscy5nZXRWYWx1ZUJ5RGF0YUtleSkoZW50cnksIGFuZ2xlQXhpcy5kYXRhS2V5LCBpKTtcbiAgICB2YXIgdmFsdWUgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0VmFsdWVCeURhdGFLZXkpKGVudHJ5LCBkYXRhS2V5KTtcbiAgICB2YXIgYW5nbGUgPSBhbmdsZUF4aXMuc2NhbGUobmFtZSkgKyBhbmdsZUJhbmRTaXplO1xuICAgIHZhciBwb2ludFZhbHVlID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyAoMCwgX2xhc3RbXCJkZWZhdWx0XCJdKSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB2YXIgcmFkaXVzID0gKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKHBvaW50VmFsdWUpID8gdW5kZWZpbmVkIDogcmFkaXVzQXhpcy5zY2FsZShwb2ludFZhbHVlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID49IDIpIHtcbiAgICAgIGlzUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICBwb2ludHMucHVzaChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIHJhZGl1cywgYW5nbGUpKSwge30sIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBjeDogY3gsXG4gICAgICBjeTogY3ksXG4gICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgIHBheWxvYWQ6IGVudHJ5XG4gICAgfSkpO1xuICB9KTtcbiAgdmFyIGJhc2VMaW5lUG9pbnRzID0gW107XG4gIGlmIChpc1JhbmdlKSB7XG4gICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2ludC52YWx1ZSkpIHtcbiAgICAgICAgdmFyIGJhc2VWYWx1ZSA9ICgwLCBfZmlyc3RbXCJkZWZhdWx0XCJdKShwb2ludC52YWx1ZSk7XG4gICAgICAgIHZhciByYWRpdXMgPSAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoYmFzZVZhbHVlKSA/IHVuZGVmaW5lZCA6IHJhZGl1c0F4aXMuc2NhbGUoYmFzZVZhbHVlKTtcbiAgICAgICAgYmFzZUxpbmVQb2ludHMucHVzaChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBvaW50KSwge30sIHtcbiAgICAgICAgICByYWRpdXM6IHJhZGl1c1xuICAgICAgICB9LCAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCByYWRpdXMsIHBvaW50LmFuZ2xlKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUxpbmVQb2ludHMucHVzaChwb2ludCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICBpc1JhbmdlOiBpc1JhbmdlLFxuICAgIGJhc2VMaW5lUG9pbnRzOiBiYXNlTGluZVBvaW50c1xuICB9O1xufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUmFkYXIiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfcmVhY3RTbW9vdGgiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2lzTmlsIiwiX2xhc3QiLCJfZmlyc3QiLCJfaXNFcXVhbCIsIl9pc0Z1bmN0aW9uIiwiX2Nsc3giLCJfRGF0YVV0aWxzIiwiX0dsb2JhbCIsIl9Qb2xhclV0aWxzIiwiX0NoYXJ0VXRpbHMiLCJfUG9seWdvbiIsIl9Eb3QiLCJfTGF5ZXIiLCJfTGFiZWxMaXN0IiwiX1JlYWN0VXRpbHMiLCJfZXhjbHVkZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2UiLCJleGNsdWRlZCIsInRhcmdldCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwia2V5IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImxlbmd0aCIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsImFyZ3VtZW50cyIsImFwcGx5Iiwib3duS2V5cyIsImtleXMiLCJmaWx0ZXIiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiX1B1cmVDb21wb25lbnQiLCJfdGhpcyIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiY29uY2F0IiwiaXNBbmltYXRpb25GaW5pc2hlZCIsIm9uQW5pbWF0aW9uRW5kIiwic2V0U3RhdGUiLCJvbkFuaW1hdGlvblN0YXJ0Iiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwicmVuZGVyRG90cyIsInBvaW50cyIsIl90aGlzJHByb3BzIiwiZG90IiwiZGF0YUtleSIsImJhc2VQcm9wcyIsImZpbHRlclByb3BzIiwiY3VzdG9tRG90UHJvcHMiLCJkb3RzIiwibWFwIiwiZW50cnkiLCJkb3RQcm9wcyIsImN4IiwieCIsImN5IiwieSIsImluZGV4IiwicGF5bG9hZCIsInJlbmRlckRvdEl0ZW0iLCJjcmVhdGVFbGVtZW50IiwiTGF5ZXIiLCJjbGFzc05hbWUiLCJyZW5kZXJQb2x5Z29uU3RhdGljYWxseSIsIl90aGlzJHByb3BzMiIsInNoYXBlIiwiaXNSYW5nZSIsImJhc2VMaW5lUG9pbnRzIiwiY29ubmVjdE51bGxzIiwicmFkYXIiLCJpc1ZhbGlkRWxlbWVudCIsImNsb25lRWxlbWVudCIsIlBvbHlnb24iLCJoYW5kbGVNb3VzZUVudGVyIiwiaGFuZGxlTW91c2VMZWF2ZSIsInJlbmRlclBvbHlnb25XaXRoQW5pbWF0aW9uIiwiX3RoaXMyIiwiX3RoaXMkcHJvcHMzIiwiaXNBbmltYXRpb25BY3RpdmUiLCJhbmltYXRpb25CZWdpbiIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRWFzaW5nIiwiYW5pbWF0aW9uSWQiLCJwcmV2UG9pbnRzIiwic3RhdGUiLCJiZWdpbiIsImR1cmF0aW9uIiwiaXNBY3RpdmUiLCJlYXNpbmciLCJmcm9tIiwidG8iLCJoYW5kbGVBbmltYXRpb25FbmQiLCJoYW5kbGVBbmltYXRpb25TdGFydCIsIl9yZWYiLCJwcmV2UG9pbnRzRGlmZkZhY3RvciIsInN0ZXBEYXRhIiwicHJldiIsIk1hdGgiLCJmbG9vciIsIl9pbnRlcnBvbGF0b3JYIiwiaW50ZXJwb2xhdGVOdW1iZXIiLCJfaW50ZXJwb2xhdG9yWSIsImludGVycG9sYXRvclgiLCJpbnRlcnBvbGF0b3JZIiwicmVuZGVyUG9seWdvbiIsIl90aGlzJHByb3BzNCIsInJlbmRlciIsIl90aGlzJHByb3BzNSIsImhpZGUiLCJsYXllckNsYXNzIiwiTGFiZWxMaXN0IiwicmVuZGVyQ2FsbEJ5UGFyZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibmV4dFByb3BzIiwicHJldlN0YXRlIiwicHJldkFuaW1hdGlvbklkIiwiY3VyUG9pbnRzIiwib3B0aW9uIiwiZG90SXRlbSIsIkRvdCIsIlB1cmVDb21wb25lbnQiLCJhbmdsZUF4aXNJZCIsInJhZGl1c0F4aXNJZCIsImFjdGl2ZURvdCIsImxlZ2VuZFR5cGUiLCJHbG9iYWwiLCJpc1NzciIsIl9yZWYyIiwicmFkaXVzQXhpcyIsImFuZ2xlQXhpcyIsImRpc3BsYXllZERhdGEiLCJiYW5kU2l6ZSIsImFuZ2xlQmFuZFNpemUiLCJ0eXBlIiwibmFtZSIsImdldFZhbHVlQnlEYXRhS2V5IiwiYW5nbGUiLCJzY2FsZSIsInBvaW50VmFsdWUiLCJpc0FycmF5IiwicmFkaXVzIiwidW5kZWZpbmVkIiwicG9sYXJUb0NhcnRlc2lhbiIsInBvaW50IiwiYmFzZVZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/polar/Radar.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/polar/RadialBar.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/polar/RadialBar.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RadialBar = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _RadialBarUtils = __webpack_require__(/*! ../util/RadialBarUtils */ \"./node_modules/recharts/lib/util/RadialBarUtils.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _Global = __webpack_require__(/*! ../util/Global */ \"./node_modules/recharts/lib/util/Global.js\");\nvar _LabelList = __webpack_require__(/*! ../component/LabelList */ \"./node_modules/recharts/lib/component/LabelList.js\");\nvar _Cell = __webpack_require__(/*! ../component/Cell */ \"./node_modules/recharts/lib/component/Cell.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ../util/ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _types = __webpack_require__(/*! ../util/types */ \"./node_modules/recharts/lib/util/types.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _excluded = [\n    \"shape\",\n    \"activeShape\",\n    \"activeIndex\",\n    \"cornerRadius\"\n], _excluded2 = [\n    \"value\",\n    \"background\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Render a group of radial bar\n */ \n// TODO: Cause of circular dependency. Needs refactoring of functions that need them.\n// import { AngleAxisProps, RadiusAxisProps } from './types';\nvar RadialBar = exports.RadialBar = /*#__PURE__*/ function(_PureComponent) {\n    function RadialBar() {\n        var _this;\n        _classCallCheck(this, RadialBar);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _callSuper(this, RadialBar, [].concat(args));\n        _defineProperty(_this, \"state\", {\n            isAnimationFinished: false\n        });\n        _defineProperty(_this, \"handleAnimationEnd\", function() {\n            var onAnimationEnd = _this.props.onAnimationEnd;\n            _this.setState({\n                isAnimationFinished: true\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationEnd)) {\n                onAnimationEnd();\n            }\n        });\n        _defineProperty(_this, \"handleAnimationStart\", function() {\n            var onAnimationStart = _this.props.onAnimationStart;\n            _this.setState({\n                isAnimationFinished: false\n            });\n            if ((0, _isFunction[\"default\"])(onAnimationStart)) {\n                onAnimationStart();\n            }\n        });\n        return _this;\n    }\n    _inherits(RadialBar, _PureComponent);\n    return _createClass(RadialBar, [\n        {\n            key: \"getDeltaAngle\",\n            value: function getDeltaAngle() {\n                var _this$props = this.props, startAngle = _this$props.startAngle, endAngle = _this$props.endAngle;\n                var sign = (0, _DataUtils.mathSign)(endAngle - startAngle);\n                var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);\n                return sign * deltaAngle;\n            }\n        },\n        {\n            key: \"renderSectorsStatically\",\n            value: function renderSectorsStatically(sectors) {\n                var _this2 = this;\n                var _this$props2 = this.props, shape = _this$props2.shape, activeShape = _this$props2.activeShape, activeIndex = _this$props2.activeIndex, cornerRadius = _this$props2.cornerRadius, others = _objectWithoutProperties(_this$props2, _excluded);\n                var baseProps = (0, _ReactUtils.filterProps)(others, false);\n                return sectors.map(function(entry, i) {\n                    var isActive = i === activeIndex;\n                    var props = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, baseProps), {}, {\n                        cornerRadius: (0, _RadialBarUtils.parseCornerRadius)(cornerRadius)\n                    }, entry), (0, _types.adaptEventsOfChild)(_this2.props, entry, i)), {}, {\n                        className: \"recharts-radial-bar-sector \".concat(entry.className),\n                        forceCornerRadius: others.forceCornerRadius,\n                        cornerIsExternal: others.cornerIsExternal,\n                        isActive: isActive,\n                        option: isActive ? activeShape : shape\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_RadialBarUtils.RadialBarSector, _extends({}, props, {\n                        key: \"sector-\".concat(i)\n                    }));\n                });\n            }\n        },\n        {\n            key: \"renderSectorsWithAnimation\",\n            value: function renderSectorsWithAnimation() {\n                var _this3 = this;\n                var _this$props3 = this.props, data = _this$props3.data, isAnimationActive = _this$props3.isAnimationActive, animationBegin = _this$props3.animationBegin, animationDuration = _this$props3.animationDuration, animationEasing = _this$props3.animationEasing, animationId = _this$props3.animationId;\n                var prevData = this.state.prevData;\n                return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n                    begin: animationBegin,\n                    duration: animationDuration,\n                    isActive: isAnimationActive,\n                    easing: animationEasing,\n                    from: {\n                        t: 0\n                    },\n                    to: {\n                        t: 1\n                    },\n                    key: \"radialBar-\".concat(animationId),\n                    onAnimationStart: this.handleAnimationStart,\n                    onAnimationEnd: this.handleAnimationEnd\n                }, function(_ref) {\n                    var t = _ref.t;\n                    var stepData = data.map(function(entry, index) {\n                        var prev = prevData && prevData[index];\n                        if (prev) {\n                            var interpolatorStartAngle = (0, _DataUtils.interpolateNumber)(prev.startAngle, entry.startAngle);\n                            var interpolatorEndAngle = (0, _DataUtils.interpolateNumber)(prev.endAngle, entry.endAngle);\n                            return _objectSpread(_objectSpread({}, entry), {}, {\n                                startAngle: interpolatorStartAngle(t),\n                                endAngle: interpolatorEndAngle(t)\n                            });\n                        }\n                        var endAngle = entry.endAngle, startAngle = entry.startAngle;\n                        var interpolator = (0, _DataUtils.interpolateNumber)(startAngle, endAngle);\n                        return _objectSpread(_objectSpread({}, entry), {}, {\n                            endAngle: interpolator(t)\n                        });\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, null, _this3.renderSectorsStatically(stepData));\n                });\n            }\n        },\n        {\n            key: \"renderSectors\",\n            value: function renderSectors() {\n                var _this$props4 = this.props, data = _this$props4.data, isAnimationActive = _this$props4.isAnimationActive;\n                var prevData = this.state.prevData;\n                if (isAnimationActive && data && data.length && (!prevData || !(0, _isEqual[\"default\"])(prevData, data))) {\n                    return this.renderSectorsWithAnimation();\n                }\n                return this.renderSectorsStatically(data);\n            }\n        },\n        {\n            key: \"renderBackground\",\n            value: function renderBackground(sectors) {\n                var _this4 = this;\n                var cornerRadius = this.props.cornerRadius;\n                var backgroundProps = (0, _ReactUtils.filterProps)(this.props.background, false);\n                return sectors.map(function(entry, i) {\n                    var value = entry.value, background = entry.background, rest = _objectWithoutProperties(entry, _excluded2);\n                    if (!background) {\n                        return null;\n                    }\n                    var props = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({\n                        cornerRadius: (0, _RadialBarUtils.parseCornerRadius)(cornerRadius)\n                    }, rest), {}, {\n                        fill: \"#eee\"\n                    }, background), backgroundProps), (0, _types.adaptEventsOfChild)(_this4.props, entry, i)), {}, {\n                        index: i,\n                        className: (0, _clsx[\"default\"])(\"recharts-radial-bar-background-sector\", backgroundProps === null || backgroundProps === void 0 ? void 0 : backgroundProps.className),\n                        option: background,\n                        isActive: false\n                    });\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_RadialBarUtils.RadialBarSector, _extends({}, props, {\n                        key: \"sector-\".concat(i)\n                    }));\n                });\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props5 = this.props, hide = _this$props5.hide, data = _this$props5.data, className = _this$props5.className, background = _this$props5.background, isAnimationActive = _this$props5.isAnimationActive;\n                if (hide || !data || !data.length) {\n                    return null;\n                }\n                var isAnimationFinished = this.state.isAnimationFinished;\n                var layerClass = (0, _clsx[\"default\"])(\"recharts-area\", className);\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: layerClass\n                }, background && /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-radial-bar-background\"\n                }, this.renderBackground(data)), /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n                    className: \"recharts-radial-bar-sectors\"\n                }, this.renderSectors()), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(_objectSpread({}, this.props), data));\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromProps\",\n            value: function getDerivedStateFromProps(nextProps, prevState) {\n                if (nextProps.animationId !== prevState.prevAnimationId) {\n                    return {\n                        prevAnimationId: nextProps.animationId,\n                        curData: nextProps.data,\n                        prevData: prevState.curData\n                    };\n                }\n                if (nextProps.data !== prevState.curData) {\n                    return {\n                        curData: nextProps.data\n                    };\n                }\n                return null;\n            }\n        }\n    ]);\n}(_react.PureComponent);\n_defineProperty(RadialBar, \"displayName\", \"RadialBar\");\n_defineProperty(RadialBar, \"defaultProps\", {\n    angleAxisId: 0,\n    radiusAxisId: 0,\n    minPointSize: 0,\n    hide: false,\n    legendType: \"rect\",\n    data: [],\n    isAnimationActive: !_Global.Global.isSsr,\n    animationBegin: 0,\n    animationDuration: 1500,\n    animationEasing: \"ease\",\n    forceCornerRadius: false,\n    cornerIsExternal: false\n});\n_defineProperty(RadialBar, \"getComposedData\", function(_ref2) {\n    var item = _ref2.item, props = _ref2.props, radiusAxis = _ref2.radiusAxis, radiusAxisTicks = _ref2.radiusAxisTicks, angleAxis = _ref2.angleAxis, angleAxisTicks = _ref2.angleAxisTicks, displayedData = _ref2.displayedData, dataKey = _ref2.dataKey, stackedData = _ref2.stackedData, barPosition = _ref2.barPosition, bandSize = _ref2.bandSize, dataStartIndex = _ref2.dataStartIndex;\n    var pos = (0, _ChartUtils.findPositionOfBar)(barPosition, item);\n    if (!pos) {\n        return null;\n    }\n    var cx = angleAxis.cx, cy = angleAxis.cy;\n    var layout = props.layout;\n    var _item$props = item.props, children = _item$props.children, minPointSize = _item$props.minPointSize;\n    var numericAxis = layout === \"radial\" ? angleAxis : radiusAxis;\n    var stackedDomain = stackedData ? numericAxis.scale.domain() : null;\n    var baseValue = (0, _ChartUtils.getBaseValueOfBar)({\n        numericAxis: numericAxis\n    });\n    var cells = (0, _ReactUtils.findAllByType)(children, _Cell.Cell);\n    var sectors = displayedData.map(function(entry, index) {\n        var value, innerRadius, outerRadius, startAngle, endAngle, backgroundSector;\n        if (stackedData) {\n            value = (0, _ChartUtils.truncateByDomain)(stackedData[dataStartIndex + index], stackedDomain);\n        } else {\n            value = (0, _ChartUtils.getValueByDataKey)(entry, dataKey);\n            if (!Array.isArray(value)) {\n                value = [\n                    baseValue,\n                    value\n                ];\n            }\n        }\n        if (layout === \"radial\") {\n            innerRadius = (0, _ChartUtils.getCateCoordinateOfBar)({\n                axis: radiusAxis,\n                ticks: radiusAxisTicks,\n                bandSize: bandSize,\n                offset: pos.offset,\n                entry: entry,\n                index: index\n            });\n            endAngle = angleAxis.scale(value[1]);\n            startAngle = angleAxis.scale(value[0]);\n            outerRadius = innerRadius + pos.size;\n            var deltaAngle = endAngle - startAngle;\n            if (Math.abs(minPointSize) > 0 && Math.abs(deltaAngle) < Math.abs(minPointSize)) {\n                var delta = (0, _DataUtils.mathSign)(deltaAngle || minPointSize) * (Math.abs(minPointSize) - Math.abs(deltaAngle));\n                endAngle += delta;\n            }\n            backgroundSector = {\n                background: {\n                    cx: cx,\n                    cy: cy,\n                    innerRadius: innerRadius,\n                    outerRadius: outerRadius,\n                    startAngle: props.startAngle,\n                    endAngle: props.endAngle\n                }\n            };\n        } else {\n            innerRadius = radiusAxis.scale(value[0]);\n            outerRadius = radiusAxis.scale(value[1]);\n            startAngle = (0, _ChartUtils.getCateCoordinateOfBar)({\n                axis: angleAxis,\n                ticks: angleAxisTicks,\n                bandSize: bandSize,\n                offset: pos.offset,\n                entry: entry,\n                index: index\n            });\n            endAngle = startAngle + pos.size;\n            var deltaRadius = outerRadius - innerRadius;\n            if (Math.abs(minPointSize) > 0 && Math.abs(deltaRadius) < Math.abs(minPointSize)) {\n                var _delta = (0, _DataUtils.mathSign)(deltaRadius || minPointSize) * (Math.abs(minPointSize) - Math.abs(deltaRadius));\n                outerRadius += _delta;\n            }\n        }\n        return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, entry), backgroundSector), {}, {\n            payload: entry,\n            value: stackedData ? value : value[1],\n            cx: cx,\n            cy: cy,\n            innerRadius: innerRadius,\n            outerRadius: outerRadius,\n            startAngle: startAngle,\n            endAngle: endAngle\n        }, cells && cells[index] && cells[index].props), {}, {\n            tooltipPayload: [\n                (0, _ChartUtils.getTooltipItem)(item, entry)\n            ],\n            tooltipPosition: (0, _PolarUtils.polarToCartesian)(cx, cy, (innerRadius + outerRadius) / 2, (startAngle + endAngle) / 2)\n        });\n    });\n    return {\n        data: sectors,\n        layout: layout\n    };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3BvbGFyL1JhZGlhbEJhci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLFFBQVFDLHVCQUF1QkYsbUJBQU9BLENBQUMsa0JBQU07QUFDakQsSUFBSUcsZUFBZUQsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUNoRSxJQUFJSSxXQUFXRix1QkFBdUJGLG1CQUFPQSxDQUFDLHNDQUFnQjtBQUM5RCxJQUFJSyxjQUFjSCx1QkFBdUJGLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJTSxrQkFBa0JOLG1CQUFPQSxDQUFDLGtGQUF3QjtBQUN0RCxJQUFJTyxTQUFTUCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDekMsSUFBSVEsY0FBY1IsbUJBQU9BLENBQUMsMEVBQW9CO0FBQzlDLElBQUlTLFVBQVVULG1CQUFPQSxDQUFDLGtFQUFnQjtBQUN0QyxJQUFJVSxhQUFhVixtQkFBT0EsQ0FBQyxrRkFBd0I7QUFDakQsSUFBSVcsUUFBUVgsbUJBQU9BLENBQUMsd0VBQW1CO0FBQ3ZDLElBQUlZLGFBQWFaLG1CQUFPQSxDQUFDLHdFQUFtQjtBQUM1QyxJQUFJYSxjQUFjYixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSWMsU0FBU2QsbUJBQU9BLENBQUMsZ0VBQWU7QUFDcEMsSUFBSWUsY0FBY2YsbUJBQU9BLENBQUMsMEVBQW9CO0FBQzlDLElBQUlnQixZQUFZO0lBQUM7SUFBUztJQUFlO0lBQWU7Q0FBZSxFQUNyRUMsYUFBYTtJQUFDO0lBQVM7Q0FBYTtBQUN0QyxTQUFTZix1QkFBdUJnQixHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FB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QUNKQyxJQUFJQTtZQUNKYSxhQUFhQTtZQUNiQyxhQUFhQTtZQUNiaEgsWUFBWUE7WUFDWkMsVUFBVUE7UUFDWixHQUFHMkcsU0FBU0EsS0FBSyxDQUFDMUQsTUFBTSxJQUFJMEQsS0FBSyxDQUFDMUQsTUFBTSxDQUFDOUYsS0FBSyxHQUFHLENBQUMsR0FBRztZQUNuRDBLLGdCQUFnQjtnQkFBRSxJQUFHdE8sWUFBWXVPLGNBQWMsRUFBRTNDLE1BQU1oRTthQUFPO1lBQzlENEcsaUJBQWlCLENBQUMsR0FBR3RPLFlBQVl1TyxnQkFBZ0IsRUFBRWhDLElBQUlDLElBQUksQ0FBQ2EsY0FBY0MsV0FBVSxJQUFLLEdBQUcsQ0FBQ2hILGFBQWFDLFFBQU8sSUFBSztRQUN4SDtJQUNGO0lBQ0EsT0FBTztRQUNMZ0MsTUFBTXhCO1FBQ04wRixRQUFRQTtJQUNWO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3BvbGFyL1JhZGlhbEJhci5qcz9jOGQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5SYWRpYWxCYXIgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xudmFyIF9yZWFjdFNtb290aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LXNtb290aFwiKSk7XG52YXIgX2lzRXF1YWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNFcXVhbFwiKSk7XG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XG52YXIgX1JhZGlhbEJhclV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmFkaWFsQmFyVXRpbHNcIik7XG52YXIgX0xheWVyID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9MYXllclwiKTtcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XG52YXIgX0dsb2JhbCA9IHJlcXVpcmUoXCIuLi91dGlsL0dsb2JhbFwiKTtcbnZhciBfTGFiZWxMaXN0ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MYWJlbExpc3RcIik7XG52YXIgX0NlbGwgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50L0NlbGxcIik7XG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcbnZhciBfQ2hhcnRVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0NoYXJ0VXRpbHNcIik7XG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4uL3V0aWwvdHlwZXNcIik7XG52YXIgX1BvbGFyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Qb2xhclV0aWxzXCIpO1xudmFyIF9leGNsdWRlZCA9IFtcInNoYXBlXCIsIFwiYWN0aXZlU2hhcGVcIiwgXCJhY3RpdmVJbmRleFwiLCBcImNvcm5lclJhZGl1c1wiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcInZhbHVlXCIsIFwiYmFja2dyb3VuZFwiXTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFJlbmRlciBhIGdyb3VwIG9mIHJhZGlhbCBiYXJcbiAqL1xuLy8gVE9ETzogQ2F1c2Ugb2YgY2lyY3VsYXIgZGVwZW5kZW5jeS4gTmVlZHMgcmVmYWN0b3Jpbmcgb2YgZnVuY3Rpb25zIHRoYXQgbmVlZCB0aGVtLlxuLy8gaW1wb3J0IHsgQW5nbGVBeGlzUHJvcHMsIFJhZGl1c0F4aXNQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xudmFyIFJhZGlhbEJhciA9IGV4cG9ydHMuUmFkaWFsQmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBmdW5jdGlvbiBSYWRpYWxCYXIoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYWRpYWxCYXIpO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIFJhZGlhbEJhciwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwic3RhdGVcIiwge1xuICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogZmFsc2VcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQW5pbWF0aW9uRW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvbkFuaW1hdGlvbkVuZCA9IF90aGlzLnByb3BzLm9uQW5pbWF0aW9uRW5kO1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShvbkFuaW1hdGlvbkVuZCkpIHtcbiAgICAgICAgb25BbmltYXRpb25FbmQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQW5pbWF0aW9uU3RhcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9uQW5pbWF0aW9uU3RhcnQgPSBfdGhpcy5wcm9wcy5vbkFuaW1hdGlvblN0YXJ0O1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob25BbmltYXRpb25TdGFydCkpIHtcbiAgICAgICAgb25BbmltYXRpb25TdGFydCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoUmFkaWFsQmFyLCBfUHVyZUNvbXBvbmVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUmFkaWFsQmFyLCBbe1xuICAgIGtleTogXCJnZXREZWx0YUFuZ2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlbHRhQW5nbGUoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBzdGFydEFuZ2xlID0gX3RoaXMkcHJvcHMuc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGUgPSBfdGhpcyRwcm9wcy5lbmRBbmdsZTtcbiAgICAgIHZhciBzaWduID0gKDAsIF9EYXRhVXRpbHMubWF0aFNpZ24pKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgICB2YXIgZGVsdGFBbmdsZSA9IE1hdGgubWluKE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSksIDM2MCk7XG4gICAgICByZXR1cm4gc2lnbiAqIGRlbHRhQW5nbGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclNlY3RvcnNTdGF0aWNhbGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclNlY3RvcnNTdGF0aWNhbGx5KHNlY3RvcnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIHNoYXBlID0gX3RoaXMkcHJvcHMyLnNoYXBlLFxuICAgICAgICBhY3RpdmVTaGFwZSA9IF90aGlzJHByb3BzMi5hY3RpdmVTaGFwZSxcbiAgICAgICAgYWN0aXZlSW5kZXggPSBfdGhpcyRwcm9wczIuYWN0aXZlSW5kZXgsXG4gICAgICAgIGNvcm5lclJhZGl1cyA9IF90aGlzJHByb3BzMi5jb3JuZXJSYWRpdXMsXG4gICAgICAgIG90aGVycyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRwcm9wczIsIF9leGNsdWRlZCk7XG4gICAgICB2YXIgYmFzZVByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShvdGhlcnMsIGZhbHNlKTtcbiAgICAgIHJldHVybiBzZWN0b3JzLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgICAgICAgdmFyIGlzQWN0aXZlID0gaSA9PT0gYWN0aXZlSW5kZXg7XG4gICAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGJhc2VQcm9wcyksIHt9LCB7XG4gICAgICAgICAgY29ybmVyUmFkaXVzOiAoMCwgX1JhZGlhbEJhclV0aWxzLnBhcnNlQ29ybmVyUmFkaXVzKShjb3JuZXJSYWRpdXMpXG4gICAgICAgIH0sIGVudHJ5KSwgKDAsIF90eXBlcy5hZGFwdEV2ZW50c09mQ2hpbGQpKF90aGlzMi5wcm9wcywgZW50cnksIGkpKSwge30sIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtcmFkaWFsLWJhci1zZWN0b3IgXCIuY29uY2F0KGVudHJ5LmNsYXNzTmFtZSksXG4gICAgICAgICAgZm9yY2VDb3JuZXJSYWRpdXM6IG90aGVycy5mb3JjZUNvcm5lclJhZGl1cyxcbiAgICAgICAgICBjb3JuZXJJc0V4dGVybmFsOiBvdGhlcnMuY29ybmVySXNFeHRlcm5hbCxcbiAgICAgICAgICBpc0FjdGl2ZTogaXNBY3RpdmUsXG4gICAgICAgICAgb3B0aW9uOiBpc0FjdGl2ZSA/IGFjdGl2ZVNoYXBlIDogc2hhcGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9SYWRpYWxCYXJVdGlscy5SYWRpYWxCYXJTZWN0b3IsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICAgIGtleTogXCJzZWN0b3ItXCIuY29uY2F0KGkpXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJTZWN0b3JzV2l0aEFuaW1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJTZWN0b3JzV2l0aEFuaW1hdGlvbigpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wczMuZGF0YSxcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczMuaXNBbmltYXRpb25BY3RpdmUsXG4gICAgICAgIGFuaW1hdGlvbkJlZ2luID0gX3RoaXMkcHJvcHMzLmFuaW1hdGlvbkJlZ2luLFxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbiA9IF90aGlzJHByb3BzMy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nID0gX3RoaXMkcHJvcHMzLmFuaW1hdGlvbkVhc2luZyxcbiAgICAgICAgYW5pbWF0aW9uSWQgPSBfdGhpcyRwcm9wczMuYW5pbWF0aW9uSWQ7XG4gICAgICB2YXIgcHJldkRhdGEgPSB0aGlzLnN0YXRlLnByZXZEYXRhO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JlYWN0U21vb3RoW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICBiZWdpbjogYW5pbWF0aW9uQmVnaW4sXG4gICAgICAgIGR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgaXNBY3RpdmU6IGlzQW5pbWF0aW9uQWN0aXZlLFxuICAgICAgICBlYXNpbmc6IGFuaW1hdGlvbkVhc2luZyxcbiAgICAgICAgZnJvbToge1xuICAgICAgICAgIHQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgdG86IHtcbiAgICAgICAgICB0OiAxXG4gICAgICAgIH0sXG4gICAgICAgIGtleTogXCJyYWRpYWxCYXItXCIuY29uY2F0KGFuaW1hdGlvbklkKSxcbiAgICAgICAgb25BbmltYXRpb25TdGFydDogdGhpcy5oYW5kbGVBbmltYXRpb25TdGFydCxcbiAgICAgICAgb25BbmltYXRpb25FbmQ6IHRoaXMuaGFuZGxlQW5pbWF0aW9uRW5kXG4gICAgICB9LCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgdCA9IF9yZWYudDtcbiAgICAgICAgdmFyIHN0ZXBEYXRhID0gZGF0YS5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xuICAgICAgICAgIHZhciBwcmV2ID0gcHJldkRhdGEgJiYgcHJldkRhdGFbaW5kZXhdO1xuICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yU3RhcnRBbmdsZSA9ICgwLCBfRGF0YVV0aWxzLmludGVycG9sYXRlTnVtYmVyKShwcmV2LnN0YXJ0QW5nbGUsIGVudHJ5LnN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgdmFyIGludGVycG9sYXRvckVuZEFuZ2xlID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHByZXYuZW5kQW5nbGUsIGVudHJ5LmVuZEFuZ2xlKTtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcbiAgICAgICAgICAgICAgc3RhcnRBbmdsZTogaW50ZXJwb2xhdG9yU3RhcnRBbmdsZSh0KSxcbiAgICAgICAgICAgICAgZW5kQW5nbGU6IGludGVycG9sYXRvckVuZEFuZ2xlKHQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZW50cnkuZW5kQW5nbGUsXG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gZW50cnkuc3RhcnRBbmdsZTtcbiAgICAgICAgICB2YXIgaW50ZXJwb2xhdG9yID0gKDAsIF9EYXRhVXRpbHMuaW50ZXJwb2xhdGVOdW1iZXIpKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XG4gICAgICAgICAgICBlbmRBbmdsZTogaW50ZXJwb2xhdG9yKHQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTGF5ZXIuTGF5ZXIsIG51bGwsIF90aGlzMy5yZW5kZXJTZWN0b3JzU3RhdGljYWxseShzdGVwRGF0YSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclNlY3RvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyU2VjdG9ycygpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHM0LmRhdGEsXG4gICAgICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gX3RoaXMkcHJvcHM0LmlzQW5pbWF0aW9uQWN0aXZlO1xuICAgICAgdmFyIHByZXZEYXRhID0gdGhpcy5zdGF0ZS5wcmV2RGF0YTtcbiAgICAgIGlmIChpc0FuaW1hdGlvbkFjdGl2ZSAmJiBkYXRhICYmIGRhdGEubGVuZ3RoICYmICghcHJldkRhdGEgfHwgISgwLCBfaXNFcXVhbFtcImRlZmF1bHRcIl0pKHByZXZEYXRhLCBkYXRhKSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyU2VjdG9yc1dpdGhBbmltYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclNlY3RvcnNTdGF0aWNhbGx5KGRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJCYWNrZ3JvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckJhY2tncm91bmQoc2VjdG9ycykge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICB2YXIgY29ybmVyUmFkaXVzID0gdGhpcy5wcm9wcy5jb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgYmFja2dyb3VuZFByb3BzID0gKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0aGlzLnByb3BzLmJhY2tncm91bmQsIGZhbHNlKTtcbiAgICAgIHJldHVybiBzZWN0b3JzLm1hcChmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZW50cnkudmFsdWUsXG4gICAgICAgICAgYmFja2dyb3VuZCA9IGVudHJ5LmJhY2tncm91bmQsXG4gICAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhlbnRyeSwgX2V4Y2x1ZGVkMik7XG4gICAgICAgIGlmICghYmFja2dyb3VuZCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgY29ybmVyUmFkaXVzOiAoMCwgX1JhZGlhbEJhclV0aWxzLnBhcnNlQ29ybmVyUmFkaXVzKShjb3JuZXJSYWRpdXMpXG4gICAgICAgIH0sIHJlc3QpLCB7fSwge1xuICAgICAgICAgIGZpbGw6ICcjZWVlJ1xuICAgICAgICB9LCBiYWNrZ3JvdW5kKSwgYmFja2dyb3VuZFByb3BzKSwgKDAsIF90eXBlcy5hZGFwdEV2ZW50c09mQ2hpbGQpKF90aGlzNC5wcm9wcywgZW50cnksIGkpKSwge30sIHtcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1yYWRpYWwtYmFyLWJhY2tncm91bmQtc2VjdG9yJywgYmFja2dyb3VuZFByb3BzID09PSBudWxsIHx8IGJhY2tncm91bmRQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmFja2dyb3VuZFByb3BzLmNsYXNzTmFtZSksXG4gICAgICAgICAgb3B0aW9uOiBiYWNrZ3JvdW5kLFxuICAgICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1JhZGlhbEJhclV0aWxzLlJhZGlhbEJhclNlY3RvciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgICAga2V5OiBcInNlY3Rvci1cIi5jb25jYXQoaSlcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgaGlkZSA9IF90aGlzJHByb3BzNS5oaWRlLFxuICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHM1LmRhdGEsXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzNS5jbGFzc05hbWUsXG4gICAgICAgIGJhY2tncm91bmQgPSBfdGhpcyRwcm9wczUuYmFja2dyb3VuZCxcbiAgICAgICAgaXNBbmltYXRpb25BY3RpdmUgPSBfdGhpcyRwcm9wczUuaXNBbmltYXRpb25BY3RpdmU7XG4gICAgICBpZiAoaGlkZSB8fCAhZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgaXNBbmltYXRpb25GaW5pc2hlZCA9IHRoaXMuc3RhdGUuaXNBbmltYXRpb25GaW5pc2hlZDtcbiAgICAgIHZhciBsYXllckNsYXNzID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLWFyZWEnLCBjbGFzc05hbWUpO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XG4gICAgICAgIGNsYXNzTmFtZTogbGF5ZXJDbGFzc1xuICAgICAgfSwgYmFja2dyb3VuZCAmJiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtcmFkaWFsLWJhci1iYWNrZ3JvdW5kXCJcbiAgICAgIH0sIHRoaXMucmVuZGVyQmFja2dyb3VuZChkYXRhKSksIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xheWVyLkxheWVyLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1yYWRpYWwtYmFyLXNlY3RvcnNcIlxuICAgICAgfSwgdGhpcy5yZW5kZXJTZWN0b3JzKCkpLCAoIWlzQW5pbWF0aW9uQWN0aXZlIHx8IGlzQW5pbWF0aW9uRmluaXNoZWQpICYmIF9MYWJlbExpc3QuTGFiZWxMaXN0LnJlbmRlckNhbGxCeVBhcmVudChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLnByb3BzKSwgZGF0YSkpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuYW5pbWF0aW9uSWQgIT09IHByZXZTdGF0ZS5wcmV2QW5pbWF0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcmV2QW5pbWF0aW9uSWQ6IG5leHRQcm9wcy5hbmltYXRpb25JZCxcbiAgICAgICAgICBjdXJEYXRhOiBuZXh0UHJvcHMuZGF0YSxcbiAgICAgICAgICBwcmV2RGF0YTogcHJldlN0YXRlLmN1ckRhdGFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0UHJvcHMuZGF0YSAhPT0gcHJldlN0YXRlLmN1ckRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjdXJEYXRhOiBuZXh0UHJvcHMuZGF0YVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XSk7XG59KF9yZWFjdC5QdXJlQ29tcG9uZW50KTtcbl9kZWZpbmVQcm9wZXJ0eShSYWRpYWxCYXIsIFwiZGlzcGxheU5hbWVcIiwgJ1JhZGlhbEJhcicpO1xuX2RlZmluZVByb3BlcnR5KFJhZGlhbEJhciwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBhbmdsZUF4aXNJZDogMCxcbiAgcmFkaXVzQXhpc0lkOiAwLFxuICBtaW5Qb2ludFNpemU6IDAsXG4gIGhpZGU6IGZhbHNlLFxuICBsZWdlbmRUeXBlOiAncmVjdCcsXG4gIGRhdGE6IFtdLFxuICBpc0FuaW1hdGlvbkFjdGl2ZTogIV9HbG9iYWwuR2xvYmFsLmlzU3NyLFxuICBhbmltYXRpb25CZWdpbjogMCxcbiAgYW5pbWF0aW9uRHVyYXRpb246IDE1MDAsXG4gIGFuaW1hdGlvbkVhc2luZzogJ2Vhc2UnLFxuICBmb3JjZUNvcm5lclJhZGl1czogZmFsc2UsXG4gIGNvcm5lcklzRXh0ZXJuYWw6IGZhbHNlXG59KTtcbl9kZWZpbmVQcm9wZXJ0eShSYWRpYWxCYXIsIFwiZ2V0Q29tcG9zZWREYXRhXCIsIGZ1bmN0aW9uIChfcmVmMikge1xuICB2YXIgaXRlbSA9IF9yZWYyLml0ZW0sXG4gICAgcHJvcHMgPSBfcmVmMi5wcm9wcyxcbiAgICByYWRpdXNBeGlzID0gX3JlZjIucmFkaXVzQXhpcyxcbiAgICByYWRpdXNBeGlzVGlja3MgPSBfcmVmMi5yYWRpdXNBeGlzVGlja3MsXG4gICAgYW5nbGVBeGlzID0gX3JlZjIuYW5nbGVBeGlzLFxuICAgIGFuZ2xlQXhpc1RpY2tzID0gX3JlZjIuYW5nbGVBeGlzVGlja3MsXG4gICAgZGlzcGxheWVkRGF0YSA9IF9yZWYyLmRpc3BsYXllZERhdGEsXG4gICAgZGF0YUtleSA9IF9yZWYyLmRhdGFLZXksXG4gICAgc3RhY2tlZERhdGEgPSBfcmVmMi5zdGFja2VkRGF0YSxcbiAgICBiYXJQb3NpdGlvbiA9IF9yZWYyLmJhclBvc2l0aW9uLFxuICAgIGJhbmRTaXplID0gX3JlZjIuYmFuZFNpemUsXG4gICAgZGF0YVN0YXJ0SW5kZXggPSBfcmVmMi5kYXRhU3RhcnRJbmRleDtcbiAgdmFyIHBvcyA9ICgwLCBfQ2hhcnRVdGlscy5maW5kUG9zaXRpb25PZkJhcikoYmFyUG9zaXRpb24sIGl0ZW0pO1xuICBpZiAoIXBvcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBjeCA9IGFuZ2xlQXhpcy5jeCxcbiAgICBjeSA9IGFuZ2xlQXhpcy5jeTtcbiAgdmFyIGxheW91dCA9IHByb3BzLmxheW91dDtcbiAgdmFyIF9pdGVtJHByb3BzID0gaXRlbS5wcm9wcyxcbiAgICBjaGlsZHJlbiA9IF9pdGVtJHByb3BzLmNoaWxkcmVuLFxuICAgIG1pblBvaW50U2l6ZSA9IF9pdGVtJHByb3BzLm1pblBvaW50U2l6ZTtcbiAgdmFyIG51bWVyaWNBeGlzID0gbGF5b3V0ID09PSAncmFkaWFsJyA/IGFuZ2xlQXhpcyA6IHJhZGl1c0F4aXM7XG4gIHZhciBzdGFja2VkRG9tYWluID0gc3RhY2tlZERhdGEgPyBudW1lcmljQXhpcy5zY2FsZS5kb21haW4oKSA6IG51bGw7XG4gIHZhciBiYXNlVmFsdWUgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0QmFzZVZhbHVlT2ZCYXIpKHtcbiAgICBudW1lcmljQXhpczogbnVtZXJpY0F4aXNcbiAgfSk7XG4gIHZhciBjZWxscyA9ICgwLCBfUmVhY3RVdGlscy5maW5kQWxsQnlUeXBlKShjaGlsZHJlbiwgX0NlbGwuQ2VsbCk7XG4gIHZhciBzZWN0b3JzID0gZGlzcGxheWVkRGF0YS5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xuICAgIHZhciB2YWx1ZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYmFja2dyb3VuZFNlY3RvcjtcbiAgICBpZiAoc3RhY2tlZERhdGEpIHtcbiAgICAgIHZhbHVlID0gKDAsIF9DaGFydFV0aWxzLnRydW5jYXRlQnlEb21haW4pKHN0YWNrZWREYXRhW2RhdGFTdGFydEluZGV4ICsgaW5kZXhdLCBzdGFja2VkRG9tYWluKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0VmFsdWVCeURhdGFLZXkpKGVudHJ5LCBkYXRhS2V5KTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBbYmFzZVZhbHVlLCB2YWx1ZV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXlvdXQgPT09ICdyYWRpYWwnKSB7XG4gICAgICBpbm5lclJhZGl1cyA9ICgwLCBfQ2hhcnRVdGlscy5nZXRDYXRlQ29vcmRpbmF0ZU9mQmFyKSh7XG4gICAgICAgIGF4aXM6IHJhZGl1c0F4aXMsXG4gICAgICAgIHRpY2tzOiByYWRpdXNBeGlzVGlja3MsXG4gICAgICAgIGJhbmRTaXplOiBiYW5kU2l6ZSxcbiAgICAgICAgb2Zmc2V0OiBwb3Mub2Zmc2V0LFxuICAgICAgICBlbnRyeTogZW50cnksXG4gICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgfSk7XG4gICAgICBlbmRBbmdsZSA9IGFuZ2xlQXhpcy5zY2FsZSh2YWx1ZVsxXSk7XG4gICAgICBzdGFydEFuZ2xlID0gYW5nbGVBeGlzLnNjYWxlKHZhbHVlWzBdKTtcbiAgICAgIG91dGVyUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBwb3Muc2l6ZTtcbiAgICAgIHZhciBkZWx0YUFuZ2xlID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgICAgaWYgKE1hdGguYWJzKG1pblBvaW50U2l6ZSkgPiAwICYmIE1hdGguYWJzKGRlbHRhQW5nbGUpIDwgTWF0aC5hYnMobWluUG9pbnRTaXplKSkge1xuICAgICAgICB2YXIgZGVsdGEgPSAoMCwgX0RhdGFVdGlscy5tYXRoU2lnbikoZGVsdGFBbmdsZSB8fCBtaW5Qb2ludFNpemUpICogKE1hdGguYWJzKG1pblBvaW50U2l6ZSkgLSBNYXRoLmFicyhkZWx0YUFuZ2xlKSk7XG4gICAgICAgIGVuZEFuZ2xlICs9IGRlbHRhO1xuICAgICAgfVxuICAgICAgYmFja2dyb3VuZFNlY3RvciA9IHtcbiAgICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgICAgICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcbiAgICAgICAgICBzdGFydEFuZ2xlOiBwcm9wcy5zdGFydEFuZ2xlLFxuICAgICAgICAgIGVuZEFuZ2xlOiBwcm9wcy5lbmRBbmdsZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbm5lclJhZGl1cyA9IHJhZGl1c0F4aXMuc2NhbGUodmFsdWVbMF0pO1xuICAgICAgb3V0ZXJSYWRpdXMgPSByYWRpdXNBeGlzLnNjYWxlKHZhbHVlWzFdKTtcbiAgICAgIHN0YXJ0QW5nbGUgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0Q2F0ZUNvb3JkaW5hdGVPZkJhcikoe1xuICAgICAgICBheGlzOiBhbmdsZUF4aXMsXG4gICAgICAgIHRpY2tzOiBhbmdsZUF4aXNUaWNrcyxcbiAgICAgICAgYmFuZFNpemU6IGJhbmRTaXplLFxuICAgICAgICBvZmZzZXQ6IHBvcy5vZmZzZXQsXG4gICAgICAgIGVudHJ5OiBlbnRyeSxcbiAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICB9KTtcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIHBvcy5zaXplO1xuICAgICAgdmFyIGRlbHRhUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cztcbiAgICAgIGlmIChNYXRoLmFicyhtaW5Qb2ludFNpemUpID4gMCAmJiBNYXRoLmFicyhkZWx0YVJhZGl1cykgPCBNYXRoLmFicyhtaW5Qb2ludFNpemUpKSB7XG4gICAgICAgIHZhciBfZGVsdGEgPSAoMCwgX0RhdGFVdGlscy5tYXRoU2lnbikoZGVsdGFSYWRpdXMgfHwgbWluUG9pbnRTaXplKSAqIChNYXRoLmFicyhtaW5Qb2ludFNpemUpIC0gTWF0aC5hYnMoZGVsdGFSYWRpdXMpKTtcbiAgICAgICAgb3V0ZXJSYWRpdXMgKz0gX2RlbHRhO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZW50cnkpLCBiYWNrZ3JvdW5kU2VjdG9yKSwge30sIHtcbiAgICAgIHBheWxvYWQ6IGVudHJ5LFxuICAgICAgdmFsdWU6IHN0YWNrZWREYXRhID8gdmFsdWUgOiB2YWx1ZVsxXSxcbiAgICAgIGN4OiBjeCxcbiAgICAgIGN5OiBjeSxcbiAgICAgIGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcbiAgICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcbiAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZTogZW5kQW5nbGVcbiAgICB9LCBjZWxscyAmJiBjZWxsc1tpbmRleF0gJiYgY2VsbHNbaW5kZXhdLnByb3BzKSwge30sIHtcbiAgICAgIHRvb2x0aXBQYXlsb2FkOiBbKDAsIF9DaGFydFV0aWxzLmdldFRvb2x0aXBJdGVtKShpdGVtLCBlbnRyeSldLFxuICAgICAgdG9vbHRpcFBvc2l0aW9uOiAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCAoaW5uZXJSYWRpdXMgKyBvdXRlclJhZGl1cykgLyAyLCAoc3RhcnRBbmdsZSArIGVuZEFuZ2xlKSAvIDIpXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGRhdGE6IHNlY3RvcnMsXG4gICAgbGF5b3V0OiBsYXlvdXRcbiAgfTtcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJhZGlhbEJhciIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9jbHN4IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9yZWFjdFNtb290aCIsIl9pc0VxdWFsIiwiX2lzRnVuY3Rpb24iLCJfUmFkaWFsQmFyVXRpbHMiLCJfTGF5ZXIiLCJfUmVhY3RVdGlscyIsIl9HbG9iYWwiLCJfTGFiZWxMaXN0IiwiX0NlbGwiLCJfRGF0YVV0aWxzIiwiX0NoYXJ0VXRpbHMiLCJfdHlwZXMiLCJfUG9sYXJVdGlscyIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJhcHBseSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiX1B1cmVDb21wb25lbnQiLCJfdGhpcyIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiY29uY2F0IiwiaXNBbmltYXRpb25GaW5pc2hlZCIsIm9uQW5pbWF0aW9uRW5kIiwic2V0U3RhdGUiLCJvbkFuaW1hdGlvblN0YXJ0IiwiZ2V0RGVsdGFBbmdsZSIsIl90aGlzJHByb3BzIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwic2lnbiIsIm1hdGhTaWduIiwiZGVsdGFBbmdsZSIsIk1hdGgiLCJtaW4iLCJhYnMiLCJyZW5kZXJTZWN0b3JzU3RhdGljYWxseSIsInNlY3RvcnMiLCJfdGhpczIiLCJfdGhpcyRwcm9wczIiLCJzaGFwZSIsImFjdGl2ZVNoYXBlIiwiYWN0aXZlSW5kZXgiLCJjb3JuZXJSYWRpdXMiLCJvdGhlcnMiLCJiYXNlUHJvcHMiLCJmaWx0ZXJQcm9wcyIsIm1hcCIsImVudHJ5IiwiaXNBY3RpdmUiLCJwYXJzZUNvcm5lclJhZGl1cyIsImFkYXB0RXZlbnRzT2ZDaGlsZCIsImNsYXNzTmFtZSIsImZvcmNlQ29ybmVyUmFkaXVzIiwiY29ybmVySXNFeHRlcm5hbCIsIm9wdGlvbiIsImNyZWF0ZUVsZW1lbnQiLCJSYWRpYWxCYXJTZWN0b3IiLCJyZW5kZXJTZWN0b3JzV2l0aEFuaW1hdGlvbiIsIl90aGlzMyIsIl90aGlzJHByb3BzMyIsImRhdGEiLCJpc0FuaW1hdGlvbkFjdGl2ZSIsImFuaW1hdGlvbkJlZ2luIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJhbmltYXRpb25FYXNpbmciLCJhbmltYXRpb25JZCIsInByZXZEYXRhIiwic3RhdGUiLCJiZWdpbiIsImR1cmF0aW9uIiwiZWFzaW5nIiwiZnJvbSIsInRvIiwiaGFuZGxlQW5pbWF0aW9uU3RhcnQiLCJoYW5kbGVBbmltYXRpb25FbmQiLCJfcmVmIiwic3RlcERhdGEiLCJpbmRleCIsInByZXYiLCJpbnRlcnBvbGF0b3JTdGFydEFuZ2xlIiwiaW50ZXJwb2xhdGVOdW1iZXIiLCJpbnRlcnBvbGF0b3JFbmRBbmdsZSIsImludGVycG9sYXRvciIsIkxheWVyIiwicmVuZGVyU2VjdG9ycyIsIl90aGlzJHByb3BzNCIsInJlbmRlckJhY2tncm91bmQiLCJfdGhpczQiLCJiYWNrZ3JvdW5kUHJvcHMiLCJiYWNrZ3JvdW5kIiwicmVzdCIsImZpbGwiLCJyZW5kZXIiLCJfdGhpcyRwcm9wczUiLCJoaWRlIiwibGF5ZXJDbGFzcyIsIkxhYmVsTGlzdCIsInJlbmRlckNhbGxCeVBhcmVudCIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIm5leHRQcm9wcyIsInByZXZTdGF0ZSIsInByZXZBbmltYXRpb25JZCIsImN1ckRhdGEiLCJQdXJlQ29tcG9uZW50IiwiYW5nbGVBeGlzSWQiLCJyYWRpdXNBeGlzSWQiLCJtaW5Qb2ludFNpemUiLCJsZWdlbmRUeXBlIiwiR2xvYmFsIiwiaXNTc3IiLCJfcmVmMiIsIml0ZW0iLCJyYWRpdXNBeGlzIiwicmFkaXVzQXhpc1RpY2tzIiwiYW5nbGVBeGlzIiwiYW5nbGVBeGlzVGlja3MiLCJkaXNwbGF5ZWREYXRhIiwiZGF0YUtleSIsInN0YWNrZWREYXRhIiwiYmFyUG9zaXRpb24iLCJiYW5kU2l6ZSIsImRhdGFTdGFydEluZGV4IiwicG9zIiwiZmluZFBvc2l0aW9uT2ZCYXIiLCJjeCIsImN5IiwibGF5b3V0IiwiX2l0ZW0kcHJvcHMiLCJjaGlsZHJlbiIsIm51bWVyaWNBeGlzIiwic3RhY2tlZERvbWFpbiIsInNjYWxlIiwiZG9tYWluIiwiYmFzZVZhbHVlIiwiZ2V0QmFzZVZhbHVlT2ZCYXIiLCJjZWxscyIsImZpbmRBbGxCeVR5cGUiLCJDZWxsIiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsImJhY2tncm91bmRTZWN0b3IiLCJ0cnVuY2F0ZUJ5RG9tYWluIiwiZ2V0VmFsdWVCeURhdGFLZXkiLCJpc0FycmF5IiwiZ2V0Q2F0ZUNvb3JkaW5hdGVPZkJhciIsImF4aXMiLCJ0aWNrcyIsIm9mZnNldCIsInNpemUiLCJkZWx0YSIsImRlbHRhUmFkaXVzIiwiX2RlbHRhIiwicGF5bG9hZCIsInRvb2x0aXBQYXlsb2FkIiwiZ2V0VG9vbHRpcEl0ZW0iLCJ0b29sdGlwUG9zaXRpb24iLCJwb2xhclRvQ2FydGVzaWFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/polar/RadialBar.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/shape/Cross.js":
/*!**************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Cross.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Cross = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"x\",\n    \"y\",\n    \"top\",\n    \"left\",\n    \"width\",\n    \"height\",\n    \"className\"\n];\n/**\n * @fileOverview Cross\n */ function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nvar getPath = function getPath(x, y, width, height, top, left) {\n    return \"M\".concat(x, \",\").concat(top, \"v\").concat(height, \"M\").concat(left, \",\").concat(y, \"h\").concat(width);\n};\nvar Cross = exports.Cross = function Cross(_ref) {\n    var _ref$x = _ref.x, x = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y = _ref$y === void 0 ? 0 : _ref$y, _ref$top = _ref.top, top = _ref$top === void 0 ? 0 : _ref$top, _ref$left = _ref.left, left = _ref$left === void 0 ? 0 : _ref$left, _ref$width = _ref.width, width = _ref$width === void 0 ? 0 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? 0 : _ref$height, className = _ref.className, rest = _objectWithoutProperties(_ref, _excluded);\n    var props = _objectSpread({\n        x: x,\n        y: y,\n        top: top,\n        left: left,\n        width: width,\n        height: height\n    }, rest);\n    if (!(0, _DataUtils.isNumber)(x) || !(0, _DataUtils.isNumber)(y) || !(0, _DataUtils.isNumber)(width) || !(0, _DataUtils.isNumber)(height) || !(0, _DataUtils.isNumber)(top) || !(0, _DataUtils.isNumber)(left)) {\n        return null;\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(props, true), {\n        className: (0, _clsx[\"default\"])(\"recharts-cross\", className),\n        d: getPath(x, y, width, height, top, left)\n    }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3NoYXBlL0Nyb3NzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdUSyw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsYUFBYSxHQUFHLEtBQUs7QUFDckIsSUFBSUcsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxRQUFRRix1QkFBdUJDLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlFLGFBQWFGLG1CQUFPQSxDQUFDLHdFQUFtQjtBQUM1QyxJQUFJRyxjQUFjSCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSUksWUFBWTtJQUFDO0lBQUs7SUFBSztJQUFPO0lBQVE7SUFBUztJQUFVO0NBQVk7QUFDekU7O0NBRUMsR0FDRCxTQUFTTCx1QkFBdUJNLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0U7SUFBYUEsV0FBV2QsT0FBT2UsTUFBTSxHQUFHZixPQUFPZSxNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUFFLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUFFLElBQUssSUFBSUksT0FBT0QsT0FBUTtn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RSxrQkFBa0I4RDtRQUNuRE0sR0FBR3JCLFFBQVFDLEdBQUdDLEdBQUdDLE9BQU9DLFFBQVFDLEtBQUtDO0lBQ3ZDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3NoYXBlL0Nyb3NzLmpzP2FlYzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNyb3NzID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xudmFyIF9leGNsdWRlZCA9IFtcInhcIiwgXCJ5XCIsIFwidG9wXCIsIFwibGVmdFwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwiY2xhc3NOYW1lXCJdO1xuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IENyb3NzXG4gKi9cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBnZXRQYXRoID0gZnVuY3Rpb24gZ2V0UGF0aCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0b3AsIGxlZnQpIHtcbiAgcmV0dXJuIFwiTVwiLmNvbmNhdCh4LCBcIixcIikuY29uY2F0KHRvcCwgXCJ2XCIpLmNvbmNhdChoZWlnaHQsIFwiTVwiKS5jb25jYXQobGVmdCwgXCIsXCIpLmNvbmNhdCh5LCBcImhcIikuY29uY2F0KHdpZHRoKTtcbn07XG52YXIgQ3Jvc3MgPSBleHBvcnRzLkNyb3NzID0gZnVuY3Rpb24gQ3Jvc3MoX3JlZikge1xuICB2YXIgX3JlZiR4ID0gX3JlZi54LFxuICAgIHggPSBfcmVmJHggPT09IHZvaWQgMCA/IDAgOiBfcmVmJHgsXG4gICAgX3JlZiR5ID0gX3JlZi55LFxuICAgIHkgPSBfcmVmJHkgPT09IHZvaWQgMCA/IDAgOiBfcmVmJHksXG4gICAgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkdG9wLFxuICAgIF9yZWYkbGVmdCA9IF9yZWYubGVmdCxcbiAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB2b2lkIDAgPyAwIDogX3JlZiRsZWZ0LFxuICAgIF9yZWYkd2lkdGggPSBfcmVmLndpZHRoLFxuICAgIHdpZHRoID0gX3JlZiR3aWR0aCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkd2lkdGgsXG4gICAgX3JlZiRoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICBoZWlnaHQgPSBfcmVmJGhlaWdodCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkaGVpZ2h0LFxuICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkKTtcbiAgdmFyIHByb3BzID0gX29iamVjdFNwcmVhZCh7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHRvcDogdG9wLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH0sIHJlc3QpO1xuICBpZiAoISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh4KSB8fCAhKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHkpIHx8ICEoMCwgX0RhdGFVdGlscy5pc051bWJlcikod2lkdGgpIHx8ICEoMCwgX0RhdGFVdGlscy5pc051bWJlcikoaGVpZ2h0KSB8fCAhKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHRvcCkgfHwgISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShsZWZ0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCBfZXh0ZW5kcyh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShwcm9wcywgdHJ1ZSksIHtcbiAgICBjbGFzc05hbWU6ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1jcm9zcycsIGNsYXNzTmFtZSksXG4gICAgZDogZ2V0UGF0aCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0b3AsIGxlZnQpXG4gIH0pKTtcbn07Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ3Jvc3MiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9jbHN4IiwiX0RhdGFVdGlscyIsIl9SZWFjdFV0aWxzIiwiX2V4Y2x1ZGVkIiwib2JqIiwiX19lc01vZHVsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIm93bktleXMiLCJlIiwiciIsInQiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJnZXRQYXRoIiwieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsInRvcCIsImxlZnQiLCJjb25jYXQiLCJfcmVmIiwiX3JlZiR4IiwiX3JlZiR5IiwiX3JlZiR0b3AiLCJfcmVmJGxlZnQiLCJfcmVmJHdpZHRoIiwiX3JlZiRoZWlnaHQiLCJjbGFzc05hbWUiLCJyZXN0IiwicHJvcHMiLCJpc051bWJlciIsImNyZWF0ZUVsZW1lbnQiLCJmaWx0ZXJQcm9wcyIsImQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/shape/Cross.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/shape/Curve.js":
/*!**************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Curve.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getPath = exports.Curve = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _d3Shape = __webpack_require__(/*! victory-vendor/d3-shape */ \"victory-vendor/d3-shape\");\nvar _upperFirst = _interopRequireDefault(__webpack_require__(/*! lodash/upperFirst */ \"lodash/upperFirst\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _types = __webpack_require__(/*! ../util/types */ \"./node_modules/recharts/lib/util/types.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Curve\n */ \nvar CURVE_FACTORIES = {\n    curveBasisClosed: _d3Shape.curveBasisClosed,\n    curveBasisOpen: _d3Shape.curveBasisOpen,\n    curveBasis: _d3Shape.curveBasis,\n    curveBumpX: _d3Shape.curveBumpX,\n    curveBumpY: _d3Shape.curveBumpY,\n    curveLinearClosed: _d3Shape.curveLinearClosed,\n    curveLinear: _d3Shape.curveLinear,\n    curveMonotoneX: _d3Shape.curveMonotoneX,\n    curveMonotoneY: _d3Shape.curveMonotoneY,\n    curveNatural: _d3Shape.curveNatural,\n    curveStep: _d3Shape.curveStep,\n    curveStepAfter: _d3Shape.curveStepAfter,\n    curveStepBefore: _d3Shape.curveStepBefore\n};\nvar defined = function defined(p) {\n    return p.x === +p.x && p.y === +p.y;\n};\nvar getX = function getX(p) {\n    return p.x;\n};\nvar getY = function getY(p) {\n    return p.y;\n};\nvar getCurveFactory = function getCurveFactory(type, layout) {\n    if ((0, _isFunction[\"default\"])(type)) {\n        return type;\n    }\n    var name = \"curve\".concat((0, _upperFirst[\"default\"])(type));\n    if ((name === \"curveMonotone\" || name === \"curveBump\") && layout) {\n        return CURVE_FACTORIES[\"\".concat(name).concat(layout === \"vertical\" ? \"Y\" : \"X\")];\n    }\n    return CURVE_FACTORIES[name] || _d3Shape.curveLinear;\n};\n/**\n * Calculate the path of curve. Returns null if points is an empty array.\n * @return path or null\n */ var getPath = exports.getPath = function getPath(_ref) {\n    var _ref$type = _ref.type, type = _ref$type === void 0 ? \"linear\" : _ref$type, _ref$points = _ref.points, points = _ref$points === void 0 ? [] : _ref$points, baseLine = _ref.baseLine, layout = _ref.layout, _ref$connectNulls = _ref.connectNulls, connectNulls = _ref$connectNulls === void 0 ? false : _ref$connectNulls;\n    var curveFactory = getCurveFactory(type, layout);\n    var formatPoints = connectNulls ? points.filter(function(entry) {\n        return defined(entry);\n    }) : points;\n    var lineFunction;\n    if (Array.isArray(baseLine)) {\n        var formatBaseLine = connectNulls ? baseLine.filter(function(base) {\n            return defined(base);\n        }) : baseLine;\n        var areaPoints = formatPoints.map(function(entry, index) {\n            return _objectSpread(_objectSpread({}, entry), {}, {\n                base: formatBaseLine[index]\n            });\n        });\n        if (layout === \"vertical\") {\n            lineFunction = (0, _d3Shape.area)().y(getY).x1(getX).x0(function(d) {\n                return d.base.x;\n            });\n        } else {\n            lineFunction = (0, _d3Shape.area)().x(getX).y1(getY).y0(function(d) {\n                return d.base.y;\n            });\n        }\n        lineFunction.defined(defined).curve(curveFactory);\n        return lineFunction(areaPoints);\n    }\n    if (layout === \"vertical\" && (0, _DataUtils.isNumber)(baseLine)) {\n        lineFunction = (0, _d3Shape.area)().y(getY).x1(getX).x0(baseLine);\n    } else if ((0, _DataUtils.isNumber)(baseLine)) {\n        lineFunction = (0, _d3Shape.area)().x(getX).y1(getY).y0(baseLine);\n    } else {\n        lineFunction = (0, _d3Shape.line)().x(getX).y(getY);\n    }\n    lineFunction.defined(defined).curve(curveFactory);\n    return lineFunction(formatPoints);\n};\nvar Curve = exports.Curve = function Curve(props) {\n    var className = props.className, points = props.points, path = props.path, pathRef = props.pathRef;\n    if ((!points || !points.length) && !path) {\n        return null;\n    }\n    var realPath = points && points.length ? getPath(props) : path;\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(props, false), (0, _types.adaptEventHandlers)(props), {\n        className: (0, _clsx[\"default\"])(\"recharts-curve\", className),\n        d: realPath,\n        ref: pathRef\n    }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3NoYXBlL0N1cnZlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxlQUFlLEdBQUdBLGFBQWEsR0FBRyxLQUFLO0FBQ3ZDLElBQUlJLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDbkQsSUFBSUMsV0FBV0QsbUJBQU9BLENBQUMsd0RBQXlCO0FBQ2hELElBQUlFLGNBQWNILHVCQUF1QkMsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlHLGNBQWNKLHVCQUF1QkMsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlJLFFBQVFMLHVCQUF1QkMsbUJBQU9BLENBQUMsa0JBQU07QUFDakQsSUFBSUssU0FBU0wsbUJBQU9BLENBQUMsZ0VBQWU7QUFDcEMsSUFBSU0sY0FBY04sbUJBQU9BLENBQUMsMEVBQW9CO0FBQzlDLElBQUlPLGFBQWFQLG1CQUFPQSxDQUFDLHdFQUFtQjtBQUM1QyxTQUFTRCx1QkFBdUJTLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLO0lBQWFBLFdBQVd4QixPQUFPeUIsTUFBTSxHQUFHekIsT0FBT3lCLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFBSSxJ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TztJQUNUO0lBQ0EsSUFBSUUsV0FBVzVCLFVBQVVBLE9BQU96RCxNQUFNLEdBQUcxQixRQUFRMkcsU0FBU0U7SUFDMUQsT0FBTyxXQUFXLEdBQUUzRyxNQUFNLENBQUMsVUFBVSxDQUFDOEcsYUFBYSxDQUFDLFFBQVE1RixTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUdWLFlBQVl1RyxXQUFXLEVBQUVOLE9BQU8sUUFBUSxDQUFDLEdBQUdsRyxPQUFPeUcsa0JBQWtCLEVBQUVQLFFBQVE7UUFDMUpDLFdBQVcsQ0FBQyxHQUFHcEcsS0FBSyxDQUFDLFVBQVUsRUFBRSxrQkFBa0JvRztRQUNuRFAsR0FBR1U7UUFDSEksS0FBS0w7SUFDUDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9zaGFwZS9DdXJ2ZS5qcz80M2EyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRQYXRoID0gZXhwb3J0cy5DdXJ2ZSA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2QzU2hhcGUgPSByZXF1aXJlKFwidmljdG9yeS12ZW5kb3IvZDMtc2hhcGVcIik7XG52YXIgX3VwcGVyRmlyc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvdXBwZXJGaXJzdFwiKSk7XG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi4vdXRpbC90eXBlc1wiKTtcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL0RhdGFVdGlsc1wiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfSAvKipcbiAqIEBmaWxlT3ZlcnZpZXcgQ3VydmVcbiAqL1xudmFyIENVUlZFX0ZBQ1RPUklFUyA9IHtcbiAgY3VydmVCYXNpc0Nsb3NlZDogX2QzU2hhcGUuY3VydmVCYXNpc0Nsb3NlZCxcbiAgY3VydmVCYXNpc09wZW46IF9kM1NoYXBlLmN1cnZlQmFzaXNPcGVuLFxuICBjdXJ2ZUJhc2lzOiBfZDNTaGFwZS5jdXJ2ZUJhc2lzLFxuICBjdXJ2ZUJ1bXBYOiBfZDNTaGFwZS5jdXJ2ZUJ1bXBYLFxuICBjdXJ2ZUJ1bXBZOiBfZDNTaGFwZS5jdXJ2ZUJ1bXBZLFxuICBjdXJ2ZUxpbmVhckNsb3NlZDogX2QzU2hhcGUuY3VydmVMaW5lYXJDbG9zZWQsXG4gIGN1cnZlTGluZWFyOiBfZDNTaGFwZS5jdXJ2ZUxpbmVhcixcbiAgY3VydmVNb25vdG9uZVg6IF9kM1NoYXBlLmN1cnZlTW9ub3RvbmVYLFxuICBjdXJ2ZU1vbm90b25lWTogX2QzU2hhcGUuY3VydmVNb25vdG9uZVksXG4gIGN1cnZlTmF0dXJhbDogX2QzU2hhcGUuY3VydmVOYXR1cmFsLFxuICBjdXJ2ZVN0ZXA6IF9kM1NoYXBlLmN1cnZlU3RlcCxcbiAgY3VydmVTdGVwQWZ0ZXI6IF9kM1NoYXBlLmN1cnZlU3RlcEFmdGVyLFxuICBjdXJ2ZVN0ZXBCZWZvcmU6IF9kM1NoYXBlLmN1cnZlU3RlcEJlZm9yZVxufTtcbnZhciBkZWZpbmVkID0gZnVuY3Rpb24gZGVmaW5lZChwKSB7XG4gIHJldHVybiBwLnggPT09ICtwLnggJiYgcC55ID09PSArcC55O1xufTtcbnZhciBnZXRYID0gZnVuY3Rpb24gZ2V0WChwKSB7XG4gIHJldHVybiBwLng7XG59O1xudmFyIGdldFkgPSBmdW5jdGlvbiBnZXRZKHApIHtcbiAgcmV0dXJuIHAueTtcbn07XG52YXIgZ2V0Q3VydmVGYWN0b3J5ID0gZnVuY3Rpb24gZ2V0Q3VydmVGYWN0b3J5KHR5cGUsIGxheW91dCkge1xuICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkodHlwZSkpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICB2YXIgbmFtZSA9IFwiY3VydmVcIi5jb25jYXQoKDAsIF91cHBlckZpcnN0W1wiZGVmYXVsdFwiXSkodHlwZSkpO1xuICBpZiAoKG5hbWUgPT09ICdjdXJ2ZU1vbm90b25lJyB8fCBuYW1lID09PSAnY3VydmVCdW1wJykgJiYgbGF5b3V0KSB7XG4gICAgcmV0dXJuIENVUlZFX0ZBQ1RPUklFU1tcIlwiLmNvbmNhdChuYW1lKS5jb25jYXQobGF5b3V0ID09PSAndmVydGljYWwnID8gJ1knIDogJ1gnKV07XG4gIH1cbiAgcmV0dXJuIENVUlZFX0ZBQ1RPUklFU1tuYW1lXSB8fCBfZDNTaGFwZS5jdXJ2ZUxpbmVhcjtcbn07XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgcGF0aCBvZiBjdXJ2ZS4gUmV0dXJucyBudWxsIGlmIHBvaW50cyBpcyBhbiBlbXB0eSBhcnJheS5cbiAqIEByZXR1cm4gcGF0aCBvciBudWxsXG4gKi9cbnZhciBnZXRQYXRoID0gZXhwb3J0cy5nZXRQYXRoID0gZnVuY3Rpb24gZ2V0UGF0aChfcmVmKSB7XG4gIHZhciBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgdHlwZSA9IF9yZWYkdHlwZSA9PT0gdm9pZCAwID8gJ2xpbmVhcicgOiBfcmVmJHR5cGUsXG4gICAgX3JlZiRwb2ludHMgPSBfcmVmLnBvaW50cyxcbiAgICBwb2ludHMgPSBfcmVmJHBvaW50cyA9PT0gdm9pZCAwID8gW10gOiBfcmVmJHBvaW50cyxcbiAgICBiYXNlTGluZSA9IF9yZWYuYmFzZUxpbmUsXG4gICAgbGF5b3V0ID0gX3JlZi5sYXlvdXQsXG4gICAgX3JlZiRjb25uZWN0TnVsbHMgPSBfcmVmLmNvbm5lY3ROdWxscyxcbiAgICBjb25uZWN0TnVsbHMgPSBfcmVmJGNvbm5lY3ROdWxscyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGNvbm5lY3ROdWxscztcbiAgdmFyIGN1cnZlRmFjdG9yeSA9IGdldEN1cnZlRmFjdG9yeSh0eXBlLCBsYXlvdXQpO1xuICB2YXIgZm9ybWF0UG9pbnRzID0gY29ubmVjdE51bGxzID8gcG9pbnRzLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gZGVmaW5lZChlbnRyeSk7XG4gIH0pIDogcG9pbnRzO1xuICB2YXIgbGluZUZ1bmN0aW9uO1xuICBpZiAoQXJyYXkuaXNBcnJheShiYXNlTGluZSkpIHtcbiAgICB2YXIgZm9ybWF0QmFzZUxpbmUgPSBjb25uZWN0TnVsbHMgPyBiYXNlTGluZS5maWx0ZXIoZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgIHJldHVybiBkZWZpbmVkKGJhc2UpO1xuICAgIH0pIDogYmFzZUxpbmU7XG4gICAgdmFyIGFyZWFQb2ludHMgPSBmb3JtYXRQb2ludHMubWFwKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KSwge30sIHtcbiAgICAgICAgYmFzZTogZm9ybWF0QmFzZUxpbmVbaW5kZXhdXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAobGF5b3V0ID09PSAndmVydGljYWwnKSB7XG4gICAgICBsaW5lRnVuY3Rpb24gPSAoMCwgX2QzU2hhcGUuYXJlYSkoKS55KGdldFkpLngxKGdldFgpLngwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmJhc2UueDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lRnVuY3Rpb24gPSAoMCwgX2QzU2hhcGUuYXJlYSkoKS54KGdldFgpLnkxKGdldFkpLnkwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmJhc2UueTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsaW5lRnVuY3Rpb24uZGVmaW5lZChkZWZpbmVkKS5jdXJ2ZShjdXJ2ZUZhY3RvcnkpO1xuICAgIHJldHVybiBsaW5lRnVuY3Rpb24oYXJlYVBvaW50cyk7XG4gIH1cbiAgaWYgKGxheW91dCA9PT0gJ3ZlcnRpY2FsJyAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoYmFzZUxpbmUpKSB7XG4gICAgbGluZUZ1bmN0aW9uID0gKDAsIF9kM1NoYXBlLmFyZWEpKCkueShnZXRZKS54MShnZXRYKS54MChiYXNlTGluZSk7XG4gIH0gZWxzZSBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGJhc2VMaW5lKSkge1xuICAgIGxpbmVGdW5jdGlvbiA9ICgwLCBfZDNTaGFwZS5hcmVhKSgpLngoZ2V0WCkueTEoZ2V0WSkueTAoYmFzZUxpbmUpO1xuICB9IGVsc2Uge1xuICAgIGxpbmVGdW5jdGlvbiA9ICgwLCBfZDNTaGFwZS5saW5lKSgpLngoZ2V0WCkueShnZXRZKTtcbiAgfVxuICBsaW5lRnVuY3Rpb24uZGVmaW5lZChkZWZpbmVkKS5jdXJ2ZShjdXJ2ZUZhY3RvcnkpO1xuICByZXR1cm4gbGluZUZ1bmN0aW9uKGZvcm1hdFBvaW50cyk7XG59O1xudmFyIEN1cnZlID0gZXhwb3J0cy5DdXJ2ZSA9IGZ1bmN0aW9uIEN1cnZlKHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgcG9pbnRzID0gcHJvcHMucG9pbnRzLFxuICAgIHBhdGggPSBwcm9wcy5wYXRoLFxuICAgIHBhdGhSZWYgPSBwcm9wcy5wYXRoUmVmO1xuICBpZiAoKCFwb2ludHMgfHwgIXBvaW50cy5sZW5ndGgpICYmICFwYXRoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlYWxQYXRoID0gcG9pbnRzICYmIHBvaW50cy5sZW5ndGggPyBnZXRQYXRoKHByb3BzKSA6IHBhdGg7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCBfZXh0ZW5kcyh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShwcm9wcywgZmFsc2UpLCAoMCwgX3R5cGVzLmFkYXB0RXZlbnRIYW5kbGVycykocHJvcHMpLCB7XG4gICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtY3VydmUnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHJlYWxQYXRoLFxuICAgIHJlZjogcGF0aFJlZlxuICB9KSk7XG59OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldFBhdGgiLCJDdXJ2ZSIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2QzU2hhcGUiLCJfdXBwZXJGaXJzdCIsIl9pc0Z1bmN0aW9uIiwiX2Nsc3giLCJfdHlwZXMiLCJfUmVhY3RVdGlscyIsIl9EYXRhVXRpbHMiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5Iiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJDVVJWRV9GQUNUT1JJRVMiLCJjdXJ2ZUJhc2lzQ2xvc2VkIiwiY3VydmVCYXNpc09wZW4iLCJjdXJ2ZUJhc2lzIiwiY3VydmVCdW1wWCIsImN1cnZlQnVtcFkiLCJjdXJ2ZUxpbmVhckNsb3NlZCIsImN1cnZlTGluZWFyIiwiY3VydmVNb25vdG9uZVgiLCJjdXJ2ZU1vbm90b25lWSIsImN1cnZlTmF0dXJhbCIsImN1cnZlU3RlcCIsImN1cnZlU3RlcEFmdGVyIiwiY3VydmVTdGVwQmVmb3JlIiwiZGVmaW5lZCIsInAiLCJ4IiwieSIsImdldFgiLCJnZXRZIiwiZ2V0Q3VydmVGYWN0b3J5IiwidHlwZSIsImxheW91dCIsIm5hbWUiLCJjb25jYXQiLCJfcmVmIiwiX3JlZiR0eXBlIiwiX3JlZiRwb2ludHMiLCJwb2ludHMiLCJiYXNlTGluZSIsIl9yZWYkY29ubmVjdE51bGxzIiwiY29ubmVjdE51bGxzIiwiY3VydmVGYWN0b3J5IiwiZm9ybWF0UG9pbnRzIiwiZW50cnkiLCJsaW5lRnVuY3Rpb24iLCJBcnJheSIsImlzQXJyYXkiLCJmb3JtYXRCYXNlTGluZSIsImJhc2UiLCJhcmVhUG9pbnRzIiwibWFwIiwiaW5kZXgiLCJhcmVhIiwieDEiLCJ4MCIsImQiLCJ5MSIsInkwIiwiY3VydmUiLCJpc051bWJlciIsImxpbmUiLCJwcm9wcyIsImNsYXNzTmFtZSIsInBhdGgiLCJwYXRoUmVmIiwicmVhbFBhdGgiLCJjcmVhdGVFbGVtZW50IiwiZmlsdGVyUHJvcHMiLCJhZGFwdEV2ZW50SGFuZGxlcnMiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/shape/Curve.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/shape/Dot.js":
/*!************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Dot.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Dot = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _types = __webpack_require__(/*! ../util/types */ \"./node_modules/recharts/lib/util/types.js\");\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n} /**\n * @fileOverview Dot\n */ \nvar Dot = exports.Dot = function Dot(props) {\n    var cx = props.cx, cy = props.cy, r = props.r, className = props.className;\n    var layerClass = (0, _clsx[\"default\"])(\"recharts-dot\", className);\n    if (cx === +cx && cy === +cy && r === +r) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"circle\", _extends({}, (0, _ReactUtils.filterProps)(props, false), (0, _types.adaptEventHandlers)(props), {\n            className: layerClass,\n            cx: cx,\n            cy: cy,\n            r: r\n        }));\n    }\n    return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3NoYXBlL0RvdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsV0FBVyxHQUFHLEtBQUs7QUFDbkIsSUFBSUcsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxRQUFRRix1QkFBdUJDLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlFLFNBQVNGLG1CQUFPQSxDQUFDLGdFQUFlO0FBQ3BDLElBQUlHLGNBQWNILG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxTQUFTRCx1QkFBdUJLLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0U7SUFBYUEsV0FBV2IsT0FBT2MsTUFBTSxHQUFHZCxPQUFPYyxNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUFFLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUFFLElBQUssSUFBSUksT0FBT0QsT0FBUTtnQkFBRSxJQUFJcEIsT0FBT3NCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFFBQVFDLE1BQU07b0JBQUVMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQUU7WUFBRTtRQUFFO1FBQUUsT0FBT0w7SUFBUTtJQUFHLE9BQU9ILFNBQVNZLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQVksRUFBRTs7Q0FFblY7QUFDRCxJQUFJZCxNQUFNRixXQUFXLEdBQUcsU0FBU0UsSUFBSXNCLEtBQUs7SUFDeEMsSUFBSUMsS0FBS0QsTUFBTUMsRUFBRSxFQUNmQyxLQUFLRixNQUFNRSxFQUFFLEVBQ2JDLElBQUlILE1BQU1HLENBQUMsRUFDWEMsWUFBWUosTUFBTUksU0FBUztJQUM3QixJQUFJQyxhQUFhLENBQUMsR0FBR3ZCLEtBQUssQ0FBQyxVQUFVLEVBQUUsZ0JBQWdCc0I7SUFDdkQsSUFBSUgsT0FBTyxDQUFDQSxNQUFNQyxPQUFPLENBQUNBLE1BQU1DLE1BQU0sQ0FBQ0EsR0FBRztRQUN4QyxPQUFPLFdBQVcsR0FBRXhCLE1BQU0sQ0FBQyxVQUFVLENBQUMyQixhQUFhLENBQUMsVUFBVW5CLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBR0gsWUFBWXVCLFdBQVcsRUFBRVAsT0FBTyxRQUFRLENBQUMsR0FBR2pCLE9BQU95QixrQkFBa0IsRUFBRVIsUUFBUTtZQUM1SkksV0FBV0M7WUFDWEosSUFBSUE7WUFDSkMsSUFBSUE7WUFDSkMsR0FBR0E7UUFDTDtJQUNGO0lBQ0EsT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9zaGFwZS9Eb3QuanM/OGRjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRG90ID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuLi91dGlsL3R5cGVzXCIpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IC8qKlxuICogQGZpbGVPdmVydmlldyBEb3RcbiAqL1xudmFyIERvdCA9IGV4cG9ydHMuRG90ID0gZnVuY3Rpb24gRG90KHByb3BzKSB7XG4gIHZhciBjeCA9IHByb3BzLmN4LFxuICAgIGN5ID0gcHJvcHMuY3ksXG4gICAgciA9IHByb3BzLnIsXG4gICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lO1xuICB2YXIgbGF5ZXJDbGFzcyA9ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1kb3QnLCBjbGFzc05hbWUpO1xuICBpZiAoY3ggPT09ICtjeCAmJiBjeSA9PT0gK2N5ICYmIHIgPT09ICtyKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwgX2V4dGVuZHMoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykocHJvcHMsIGZhbHNlKSwgKDAsIF90eXBlcy5hZGFwdEV2ZW50SGFuZGxlcnMpKHByb3BzKSwge1xuICAgICAgY2xhc3NOYW1lOiBsYXllckNsYXNzLFxuICAgICAgY3g6IGN4LFxuICAgICAgY3k6IGN5LFxuICAgICAgcjogclxuICAgIH0pKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRG90IiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfY2xzeCIsIl90eXBlcyIsIl9SZWFjdFV0aWxzIiwib2JqIiwiX19lc01vZHVsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsInByb3BzIiwiY3giLCJjeSIsInIiLCJjbGFzc05hbWUiLCJsYXllckNsYXNzIiwiY3JlYXRlRWxlbWVudCIsImZpbHRlclByb3BzIiwiYWRhcHRFdmVudEhhbmRsZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/shape/Dot.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/shape/Polygon.js":
/*!****************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Polygon.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Polygon = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"points\",\n    \"className\",\n    \"baseLinePoints\",\n    \"connectNulls\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n} /**\n * @fileOverview Polygon\n */ \nvar isValidatePoint = function isValidatePoint(point) {\n    return point && point.x === +point.x && point.y === +point.y;\n};\nvar getParsedPoints = function getParsedPoints() {\n    var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var segmentPoints = [\n        []\n    ];\n    points.forEach(function(entry) {\n        if (isValidatePoint(entry)) {\n            segmentPoints[segmentPoints.length - 1].push(entry);\n        } else if (segmentPoints[segmentPoints.length - 1].length > 0) {\n            // add another path\n            segmentPoints.push([]);\n        }\n    });\n    if (isValidatePoint(points[0])) {\n        segmentPoints[segmentPoints.length - 1].push(points[0]);\n    }\n    if (segmentPoints[segmentPoints.length - 1].length <= 0) {\n        segmentPoints = segmentPoints.slice(0, -1);\n    }\n    return segmentPoints;\n};\nvar getSinglePolygonPath = function getSinglePolygonPath(points, connectNulls) {\n    var segmentPoints = getParsedPoints(points);\n    if (connectNulls) {\n        segmentPoints = [\n            segmentPoints.reduce(function(res, segPoints) {\n                return [].concat(_toConsumableArray(res), _toConsumableArray(segPoints));\n            }, [])\n        ];\n    }\n    var polygonPath = segmentPoints.map(function(segPoints) {\n        return segPoints.reduce(function(path, point, index) {\n            return \"\".concat(path).concat(index === 0 ? \"M\" : \"L\").concat(point.x, \",\").concat(point.y);\n        }, \"\");\n    }).join(\"\");\n    return segmentPoints.length === 1 ? \"\".concat(polygonPath, \"Z\") : polygonPath;\n};\nvar getRanglePath = function getRanglePath(points, baseLinePoints, connectNulls) {\n    var outerPath = getSinglePolygonPath(points, connectNulls);\n    return \"\".concat(outerPath.slice(-1) === \"Z\" ? outerPath.slice(0, -1) : outerPath, \"L\").concat(getSinglePolygonPath(baseLinePoints.reverse(), connectNulls).slice(1));\n};\nvar Polygon = exports.Polygon = function Polygon(props) {\n    var points = props.points, className = props.className, baseLinePoints = props.baseLinePoints, connectNulls = props.connectNulls, others = _objectWithoutProperties(props, _excluded);\n    if (!points || !points.length) {\n        return null;\n    }\n    var layerClass = (0, _clsx[\"default\"])(\"recharts-polygon\", className);\n    if (baseLinePoints && baseLinePoints.length) {\n        var hasStroke = others.stroke && others.stroke !== \"none\";\n        var rangePath = getRanglePath(points, baseLinePoints, connectNulls);\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", {\n            className: layerClass\n        }, /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(others, true), {\n            fill: rangePath.slice(-1) === \"Z\" ? others.fill : \"none\",\n            stroke: \"none\",\n            d: rangePath\n        })), hasStroke ? /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(others, true), {\n            fill: \"none\",\n            d: getSinglePolygonPath(points, connectNulls)\n        })) : null, hasStroke ? /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(others, true), {\n            fill: \"none\",\n            d: getSinglePolygonPath(baseLinePoints, connectNulls)\n        })) : null);\n    }\n    var singlePath = getSinglePolygonPath(points, connectNulls);\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(others, true), {\n        fill: singlePath.slice(-1) === \"Z\" ? others.fill : \"none\",\n        className: layerClass,\n        d: singlePath\n    }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3NoYXBlL1BvbHlnb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCLElBQUlHLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDbkQsSUFBSUMsUUFBUUYsdUJBQXVCQyxtQkFBT0EsQ0FBQyxrQkFBTTtBQUNqRCxJQUFJRSxjQUFjRixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSUcsWUFBWTtJQUFDO0lBQVU7SUFBYTtJQUFrQjtDQUFlO0FBQ3pFLFNBQVNKLHVCQUF1QkssR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRTtJQUFhQSxXQUFXYixPQUFPYyxNQUFNLEdBQUdkLE9BQU9jLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQUUsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQUUsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUFFLElBQUlwQixPQUFPc0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osUUFBUUMsTUFBTTtvQkFBRUwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFBRTtZQUFFO1FBQUU7UUFBRSxPQUFPTDtJQUFRO0lBQUcsT0FBT0gsU0FBU1ksS0FBSyxDQUFDLElBQUksRUFBRVA7QUFBWTtBQUNsVixTQUFTUSx5QkFBeUJOLE1BQU0sRUFBRU8sUUFBUTtJQUFJLElBQUlQLFVBQVUsTUFBTSxPQUFPLENBQUM7SUFBRyxJQUFJSixTQUFTWSw4QkFBOEJSLFFBQVFPO0lBQVcsSUFBSU4sS0FBS0o7SUFBRyxJQUFJ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Y2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3NoYXBlL1BvbHlnb24uanM/OTNhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUG9seWdvbiA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XG52YXIgX2V4Y2x1ZGVkID0gW1wicG9pbnRzXCIsIFwiY2xhc3NOYW1lXCIsIFwiYmFzZUxpbmVQb2ludHNcIiwgXCJjb25uZWN0TnVsbHNcIl07XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9IC8qKlxuICogQGZpbGVPdmVydmlldyBQb2x5Z29uXG4gKi9cbnZhciBpc1ZhbGlkYXRlUG9pbnQgPSBmdW5jdGlvbiBpc1ZhbGlkYXRlUG9pbnQocG9pbnQpIHtcbiAgcmV0dXJuIHBvaW50ICYmIHBvaW50LnggPT09ICtwb2ludC54ICYmIHBvaW50LnkgPT09ICtwb2ludC55O1xufTtcbnZhciBnZXRQYXJzZWRQb2ludHMgPSBmdW5jdGlvbiBnZXRQYXJzZWRQb2ludHMoKSB7XG4gIHZhciBwb2ludHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICB2YXIgc2VnbWVudFBvaW50cyA9IFtbXV07XG4gIHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIGlmIChpc1ZhbGlkYXRlUG9pbnQoZW50cnkpKSB7XG4gICAgICBzZWdtZW50UG9pbnRzW3NlZ21lbnRQb2ludHMubGVuZ3RoIC0gMV0ucHVzaChlbnRyeSk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50UG9pbnRzW3NlZ21lbnRQb2ludHMubGVuZ3RoIC0gMV0ubGVuZ3RoID4gMCkge1xuICAgICAgLy8gYWRkIGFub3RoZXIgcGF0aFxuICAgICAgc2VnbWVudFBvaW50cy5wdXNoKFtdKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoaXNWYWxpZGF0ZVBvaW50KHBvaW50c1swXSkpIHtcbiAgICBzZWdtZW50UG9pbnRzW3NlZ21lbnRQb2ludHMubGVuZ3RoIC0gMV0ucHVzaChwb2ludHNbMF0pO1xuICB9XG4gIGlmIChzZWdtZW50UG9pbnRzW3NlZ21lbnRQb2ludHMubGVuZ3RoIC0gMV0ubGVuZ3RoIDw9IDApIHtcbiAgICBzZWdtZW50UG9pbnRzID0gc2VnbWVudFBvaW50cy5zbGljZSgwLCAtMSk7XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnRQb2ludHM7XG59O1xudmFyIGdldFNpbmdsZVBvbHlnb25QYXRoID0gZnVuY3Rpb24gZ2V0U2luZ2xlUG9seWdvblBhdGgocG9pbnRzLCBjb25uZWN0TnVsbHMpIHtcbiAgdmFyIHNlZ21lbnRQb2ludHMgPSBnZXRQYXJzZWRQb2ludHMocG9pbnRzKTtcbiAgaWYgKGNvbm5lY3ROdWxscykge1xuICAgIHNlZ21lbnRQb2ludHMgPSBbc2VnbWVudFBvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgc2VnUG9pbnRzKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXMpLCBfdG9Db25zdW1hYmxlQXJyYXkoc2VnUG9pbnRzKSk7XG4gICAgfSwgW10pXTtcbiAgfVxuICB2YXIgcG9seWdvblBhdGggPSBzZWdtZW50UG9pbnRzLm1hcChmdW5jdGlvbiAoc2VnUG9pbnRzKSB7XG4gICAgcmV0dXJuIHNlZ1BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHBhdGgsIHBvaW50LCBpbmRleCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHBhdGgpLmNvbmNhdChpbmRleCA9PT0gMCA/ICdNJyA6ICdMJykuY29uY2F0KHBvaW50LngsIFwiLFwiKS5jb25jYXQocG9pbnQueSk7XG4gICAgfSwgJycpO1xuICB9KS5qb2luKCcnKTtcbiAgcmV0dXJuIHNlZ21lbnRQb2ludHMubGVuZ3RoID09PSAxID8gXCJcIi5jb25jYXQocG9seWdvblBhdGgsIFwiWlwiKSA6IHBvbHlnb25QYXRoO1xufTtcbnZhciBnZXRSYW5nbGVQYXRoID0gZnVuY3Rpb24gZ2V0UmFuZ2xlUGF0aChwb2ludHMsIGJhc2VMaW5lUG9pbnRzLCBjb25uZWN0TnVsbHMpIHtcbiAgdmFyIG91dGVyUGF0aCA9IGdldFNpbmdsZVBvbHlnb25QYXRoKHBvaW50cywgY29ubmVjdE51bGxzKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KG91dGVyUGF0aC5zbGljZSgtMSkgPT09ICdaJyA/IG91dGVyUGF0aC5zbGljZSgwLCAtMSkgOiBvdXRlclBhdGgsIFwiTFwiKS5jb25jYXQoZ2V0U2luZ2xlUG9seWdvblBhdGgoYmFzZUxpbmVQb2ludHMucmV2ZXJzZSgpLCBjb25uZWN0TnVsbHMpLnNsaWNlKDEpKTtcbn07XG52YXIgUG9seWdvbiA9IGV4cG9ydHMuUG9seWdvbiA9IGZ1bmN0aW9uIFBvbHlnb24ocHJvcHMpIHtcbiAgdmFyIHBvaW50cyA9IHByb3BzLnBvaW50cyxcbiAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgYmFzZUxpbmVQb2ludHMgPSBwcm9wcy5iYXNlTGluZVBvaW50cyxcbiAgICBjb25uZWN0TnVsbHMgPSBwcm9wcy5jb25uZWN0TnVsbHMsXG4gICAgb3RoZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xuICBpZiAoIXBvaW50cyB8fCAhcG9pbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBsYXllckNsYXNzID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXBvbHlnb24nLCBjbGFzc05hbWUpO1xuICBpZiAoYmFzZUxpbmVQb2ludHMgJiYgYmFzZUxpbmVQb2ludHMubGVuZ3RoKSB7XG4gICAgdmFyIGhhc1N0cm9rZSA9IG90aGVycy5zdHJva2UgJiYgb3RoZXJzLnN0cm9rZSAhPT0gJ25vbmUnO1xuICAgIHZhciByYW5nZVBhdGggPSBnZXRSYW5nbGVQYXRoKHBvaW50cywgYmFzZUxpbmVQb2ludHMsIGNvbm5lY3ROdWxscyk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogbGF5ZXJDbGFzc1xuICAgIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIF9leHRlbmRzKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKG90aGVycywgdHJ1ZSksIHtcbiAgICAgIGZpbGw6IHJhbmdlUGF0aC5zbGljZSgtMSkgPT09ICdaJyA/IG90aGVycy5maWxsIDogJ25vbmUnLFxuICAgICAgc3Ryb2tlOiBcIm5vbmVcIixcbiAgICAgIGQ6IHJhbmdlUGF0aFxuICAgIH0pKSwgaGFzU3Ryb2tlID8gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBhdGhcIiwgX2V4dGVuZHMoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykob3RoZXJzLCB0cnVlKSwge1xuICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICBkOiBnZXRTaW5nbGVQb2x5Z29uUGF0aChwb2ludHMsIGNvbm5lY3ROdWxscylcbiAgICB9KSkgOiBudWxsLCBoYXNTdHJva2UgPyAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCBfZXh0ZW5kcyh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShvdGhlcnMsIHRydWUpLCB7XG4gICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgIGQ6IGdldFNpbmdsZVBvbHlnb25QYXRoKGJhc2VMaW5lUG9pbnRzLCBjb25uZWN0TnVsbHMpXG4gICAgfSkpIDogbnVsbCk7XG4gIH1cbiAgdmFyIHNpbmdsZVBhdGggPSBnZXRTaW5nbGVQb2x5Z29uUGF0aChwb2ludHMsIGNvbm5lY3ROdWxscyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCBfZXh0ZW5kcyh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShvdGhlcnMsIHRydWUpLCB7XG4gICAgZmlsbDogc2luZ2xlUGF0aC5zbGljZSgtMSkgPT09ICdaJyA/IG90aGVycy5maWxsIDogJ25vbmUnLFxuICAgIGNsYXNzTmFtZTogbGF5ZXJDbGFzcyxcbiAgICBkOiBzaW5nbGVQYXRoXG4gIH0pKTtcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUG9seWdvbiIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2Nsc3giLCJfUmVhY3RVdGlscyIsIl9leGNsdWRlZCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl90b0NvbnN1bWFibGVBcnJheSIsImFyciIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJUeXBlRXJyb3IiLCJvIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwidG9TdHJpbmciLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJpdGVyIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJpc0FycmF5IiwibGVuIiwiYXJyMiIsImlzVmFsaWRhdGVQb2ludCIsInBvaW50IiwieCIsInkiLCJnZXRQYXJzZWRQb2ludHMiLCJwb2ludHMiLCJ1bmRlZmluZWQiLCJzZWdtZW50UG9pbnRzIiwiZm9yRWFjaCIsImVudHJ5IiwicHVzaCIsImdldFNpbmdsZVBvbHlnb25QYXRoIiwiY29ubmVjdE51bGxzIiwicmVkdWNlIiwicmVzIiwic2VnUG9pbnRzIiwiY29uY2F0IiwicG9seWdvblBhdGgiLCJtYXAiLCJwYXRoIiwiaW5kZXgiLCJqb2luIiwiZ2V0UmFuZ2xlUGF0aCIsImJhc2VMaW5lUG9pbnRzIiwib3V0ZXJQYXRoIiwicmV2ZXJzZSIsInByb3BzIiwiY2xhc3NOYW1lIiwib3RoZXJzIiwibGF5ZXJDbGFzcyIsImhhc1N0cm9rZSIsInN0cm9rZSIsInJhbmdlUGF0aCIsImNyZWF0ZUVsZW1lbnQiLCJmaWx0ZXJQcm9wcyIsImZpbGwiLCJkIiwic2luZ2xlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/shape/Polygon.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/shape/Rectangle.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Rectangle.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isInRectangle = exports.Rectangle = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Rectangle\n */ \nvar getRectanglePath = function getRectanglePath(x, y, width, height, radius) {\n    var maxRadius = Math.min(Math.abs(width) / 2, Math.abs(height) / 2);\n    var ySign = height >= 0 ? 1 : -1;\n    var xSign = width >= 0 ? 1 : -1;\n    var clockWise = height >= 0 && width >= 0 || height < 0 && width < 0 ? 1 : 0;\n    var path;\n    if (maxRadius > 0 && radius instanceof Array) {\n        var newRadius = [\n            0,\n            0,\n            0,\n            0\n        ];\n        for(var i = 0, len = 4; i < len; i++){\n            newRadius[i] = radius[i] > maxRadius ? maxRadius : radius[i];\n        }\n        path = \"M\".concat(x, \",\").concat(y + ySign * newRadius[0]);\n        if (newRadius[0] > 0) {\n            path += \"A \".concat(newRadius[0], \",\").concat(newRadius[0], \",0,0,\").concat(clockWise, \",\").concat(x + xSign * newRadius[0], \",\").concat(y);\n        }\n        path += \"L \".concat(x + width - xSign * newRadius[1], \",\").concat(y);\n        if (newRadius[1] > 0) {\n            path += \"A \".concat(newRadius[1], \",\").concat(newRadius[1], \",0,0,\").concat(clockWise, \",\\n        \").concat(x + width, \",\").concat(y + ySign * newRadius[1]);\n        }\n        path += \"L \".concat(x + width, \",\").concat(y + height - ySign * newRadius[2]);\n        if (newRadius[2] > 0) {\n            path += \"A \".concat(newRadius[2], \",\").concat(newRadius[2], \",0,0,\").concat(clockWise, \",\\n        \").concat(x + width - xSign * newRadius[2], \",\").concat(y + height);\n        }\n        path += \"L \".concat(x + xSign * newRadius[3], \",\").concat(y + height);\n        if (newRadius[3] > 0) {\n            path += \"A \".concat(newRadius[3], \",\").concat(newRadius[3], \",0,0,\").concat(clockWise, \",\\n        \").concat(x, \",\").concat(y + height - ySign * newRadius[3]);\n        }\n        path += \"Z\";\n    } else if (maxRadius > 0 && radius === +radius && radius > 0) {\n        var _newRadius = Math.min(maxRadius, radius);\n        path = \"M \".concat(x, \",\").concat(y + ySign * _newRadius, \"\\n            A \").concat(_newRadius, \",\").concat(_newRadius, \",0,0,\").concat(clockWise, \",\").concat(x + xSign * _newRadius, \",\").concat(y, \"\\n            L \").concat(x + width - xSign * _newRadius, \",\").concat(y, \"\\n            A \").concat(_newRadius, \",\").concat(_newRadius, \",0,0,\").concat(clockWise, \",\").concat(x + width, \",\").concat(y + ySign * _newRadius, \"\\n            L \").concat(x + width, \",\").concat(y + height - ySign * _newRadius, \"\\n            A \").concat(_newRadius, \",\").concat(_newRadius, \",0,0,\").concat(clockWise, \",\").concat(x + width - xSign * _newRadius, \",\").concat(y + height, \"\\n            L \").concat(x + xSign * _newRadius, \",\").concat(y + height, \"\\n            A \").concat(_newRadius, \",\").concat(_newRadius, \",0,0,\").concat(clockWise, \",\").concat(x, \",\").concat(y + height - ySign * _newRadius, \" Z\");\n    } else {\n        path = \"M \".concat(x, \",\").concat(y, \" h \").concat(width, \" v \").concat(height, \" h \").concat(-width, \" Z\");\n    }\n    return path;\n};\nvar isInRectangle = exports.isInRectangle = function isInRectangle(point, rect) {\n    if (!point || !rect) {\n        return false;\n    }\n    var px = point.x, py = point.y;\n    var x = rect.x, y = rect.y, width = rect.width, height = rect.height;\n    if (Math.abs(width) > 0 && Math.abs(height) > 0) {\n        var minX = Math.min(x, x + width);\n        var maxX = Math.max(x, x + width);\n        var minY = Math.min(y, y + height);\n        var maxY = Math.max(y, y + height);\n        return px >= minX && px <= maxX && py >= minY && py <= maxY;\n    }\n    return false;\n};\nvar defaultProps = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    // The radius of border\n    // The radius of four corners when radius is a number\n    // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array\n    radius: 0,\n    isAnimationActive: false,\n    isUpdateAnimationActive: false,\n    animationBegin: 0,\n    animationDuration: 1500,\n    animationEasing: \"ease\"\n};\nvar Rectangle = exports.Rectangle = function Rectangle(rectangleProps) {\n    var props = _objectSpread(_objectSpread({}, defaultProps), rectangleProps);\n    var pathRef = (0, _react.useRef)();\n    var _useState = (0, _react.useState)(-1), _useState2 = _slicedToArray(_useState, 2), totalLength = _useState2[0], setTotalLength = _useState2[1];\n    (0, _react.useEffect)(function() {\n        if (pathRef.current && pathRef.current.getTotalLength) {\n            try {\n                var pathTotalLength = pathRef.current.getTotalLength();\n                if (pathTotalLength) {\n                    setTotalLength(pathTotalLength);\n                }\n            } catch (err) {\n            // calculate total length error\n            }\n        }\n    }, []);\n    var x = props.x, y = props.y, width = props.width, height = props.height, radius = props.radius, className = props.className;\n    var animationEasing = props.animationEasing, animationDuration = props.animationDuration, animationBegin = props.animationBegin, isAnimationActive = props.isAnimationActive, isUpdateAnimationActive = props.isUpdateAnimationActive;\n    if (x !== +x || y !== +y || width !== +width || height !== +height || width === 0 || height === 0) {\n        return null;\n    }\n    var layerClass = (0, _clsx[\"default\"])(\"recharts-rectangle\", className);\n    if (!isUpdateAnimationActive) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(props, true), {\n            className: layerClass,\n            d: getRectanglePath(x, y, width, height, radius)\n        }));\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n        canBegin: totalLength > 0,\n        from: {\n            width: width,\n            height: height,\n            x: x,\n            y: y\n        },\n        to: {\n            width: width,\n            height: height,\n            x: x,\n            y: y\n        },\n        duration: animationDuration,\n        animationEasing: animationEasing,\n        isActive: isUpdateAnimationActive\n    }, function(_ref) {\n        var currWidth = _ref.width, currHeight = _ref.height, currX = _ref.x, currY = _ref.y;\n        return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n            canBegin: totalLength > 0,\n            from: \"0px \".concat(totalLength === -1 ? 1 : totalLength, \"px\"),\n            to: \"\".concat(totalLength, \"px 0px\"),\n            attributeName: \"strokeDasharray\",\n            begin: animationBegin,\n            duration: animationDuration,\n            isActive: isAnimationActive,\n            easing: animationEasing\n        }, /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(props, true), {\n            className: layerClass,\n            d: getRectanglePath(currX, currY, currWidth, currHeight, radius),\n            ref: pathRef\n        })));\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3NoYXBlL1JlY3RhbmdsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQscUJBQXFCLEdBQUdBLGlCQUFpQixHQUFHLEtBQUs7QUFDakQsSUFBSUksU0FBU0Msd0JBQXdCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNwRCxJQUFJQyxRQUFRQyx1QkFBdUJGLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlHLGVBQWVELHVCQUF1QkYsbUJBQU9BLENBQUMsa0NBQWM7QUFDaEUsSUFBSUksY0FBY0osbUJBQU9BLENBQUMsMEVBQW9CO0FBQzlDLFNBQVNFLHVCQUF1QkcsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSx5QkFBeUJDLENBQUM7SUFBSSxJQUFJLGNBQWMsT0FBT0MsU0FBUyxPQUFPO0lBQU0sSUFBSUMsSUFBSSxJQUFJRCxXQUFXRSxJQUFJLElBQUlGO0lBQVcsT0FBTyxDQUFDRiwyQkFBMkIsU0FBU0EseUJBQXlCQyxDQUFDO1FBQUksT0FBT0EsSUFBSUcsSUFBSUQ7SUFBRyxHQUFHRjtBQUFJO0FBQ25PLFNBQVNULHdCQUF3QlMsQ0FBQyxFQUFFRSxDQUFDO0lBQUksSUFBSSxDQUFDQSxLQUFLRixLQUFLQSxFQUFFRixVQUFVLEVBQUUsT0FBT0U7SUFBRyxJQUFJLFNBQVNBLEtBQUssWUFBWUksUUFBUUosTUFBTSxjQUFjLE9BQU9BLEdBQUcsT0FBTztRQUFFLFdBQVdBO0lBQUU7SUFBRyxJQUFJRyxJQUFJSix5QkFBeUJHO0lBQUksSUFBSUMsS0FBS0EsRUFBRUUsR0FBRyxDQUFDTCxJQUFJLE9BQU9HLEVBQUVHLEdBQUcsQ0FBQ047SUFBSSxJQUFJTyxJQUFJO1FBQUVDLFdBQVc7SUFBSyxHQUFHQyxJQUFJekIsT0FBT0MsY0FBYyxJQUFJ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QyxVQUFVLEVBQUU7UUFDM0U4SCxVQUFVWixjQUFjO1FBQ3hCbEUsTUFBTTtZQUNKOEIsT0FBT0E7WUFDUEMsUUFBUUE7WUFDUkgsR0FBR0E7WUFDSEMsR0FBR0E7UUFDTDtRQUNBa0QsSUFBSTtZQUNGakQsT0FBT0E7WUFDUEMsUUFBUUE7WUFDUkgsR0FBR0E7WUFDSEMsR0FBR0E7UUFDTDtRQUNBbUQsVUFBVXZCO1FBQ1ZDLGlCQUFpQkE7UUFDakJ1QixVQUFVMUI7SUFDWixHQUFHLFNBQVUyQixJQUFJO1FBQ2YsSUFBSUMsWUFBWUQsS0FBS3BELEtBQUssRUFDeEJzRCxhQUFhRixLQUFLbkQsTUFBTSxFQUN4QnNELFFBQVFILEtBQUt0RCxDQUFDLEVBQ2QwRCxRQUFRSixLQUFLckQsQ0FBQztRQUNoQixPQUFPLFdBQVcsR0FBRWxGLE1BQU0sQ0FBQyxVQUFVLENBQUNnSSxhQUFhLENBQUMzSCxZQUFZLENBQUMsVUFBVSxFQUFFO1lBQzNFOEgsVUFBVVosY0FBYztZQUN4QmxFLE1BQU0sT0FBTzBDLE1BQU0sQ0FBQ3dCLGdCQUFnQixDQUFDLElBQUksSUFBSUEsYUFBYTtZQUMxRGEsSUFBSSxHQUFHckMsTUFBTSxDQUFDd0IsYUFBYTtZQUMzQnFCLGVBQWU7WUFDZkMsT0FBT2hDO1lBQ1B3QixVQUFVdkI7WUFDVndCLFVBQVUzQjtZQUNWbUMsUUFBUS9CO1FBQ1YsR0FBRyxXQUFXLEdBQUUvRyxNQUFNLENBQUMsVUFBVSxDQUFDZ0ksYUFBYSxDQUFDLFFBQVFqRyxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUd6QixZQUFZMkgsV0FBVyxFQUFFaEIsT0FBTyxPQUFPO1lBQzlHYSxXQUFXQztZQUNYRyxHQUFHbEQsaUJBQWlCMEQsT0FBT0MsT0FBT0gsV0FBV0MsWUFBWXBEO1lBQ3pEMEQsS0FBSzdCO1FBQ1A7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9zaGFwZS9SZWN0YW5nbGUuanM/ZGRjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNJblJlY3RhbmdsZSA9IGV4cG9ydHMuUmVjdGFuZ2xlID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfcmVhY3RTbW9vdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1zbW9vdGhcIikpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWwvUmVhY3RVdGlsc1wiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFJlY3RhbmdsZVxuICovXG52YXIgZ2V0UmVjdGFuZ2xlUGF0aCA9IGZ1bmN0aW9uIGdldFJlY3RhbmdsZVBhdGgoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gIHZhciBtYXhSYWRpdXMgPSBNYXRoLm1pbihNYXRoLmFicyh3aWR0aCkgLyAyLCBNYXRoLmFicyhoZWlnaHQpIC8gMik7XG4gIHZhciB5U2lnbiA9IGhlaWdodCA+PSAwID8gMSA6IC0xO1xuICB2YXIgeFNpZ24gPSB3aWR0aCA+PSAwID8gMSA6IC0xO1xuICB2YXIgY2xvY2tXaXNlID0gaGVpZ2h0ID49IDAgJiYgd2lkdGggPj0gMCB8fCBoZWlnaHQgPCAwICYmIHdpZHRoIDwgMCA/IDEgOiAwO1xuICB2YXIgcGF0aDtcbiAgaWYgKG1heFJhZGl1cyA+IDAgJiYgcmFkaXVzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICB2YXIgbmV3UmFkaXVzID0gWzAsIDAsIDAsIDBdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSA0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5ld1JhZGl1c1tpXSA9IHJhZGl1c1tpXSA+IG1heFJhZGl1cyA/IG1heFJhZGl1cyA6IHJhZGl1c1tpXTtcbiAgICB9XG4gICAgcGF0aCA9IFwiTVwiLmNvbmNhdCh4LCBcIixcIikuY29uY2F0KHkgKyB5U2lnbiAqIG5ld1JhZGl1c1swXSk7XG4gICAgaWYgKG5ld1JhZGl1c1swXSA+IDApIHtcbiAgICAgIHBhdGggKz0gXCJBIFwiLmNvbmNhdChuZXdSYWRpdXNbMF0sIFwiLFwiKS5jb25jYXQobmV3UmFkaXVzWzBdLCBcIiwwLDAsXCIpLmNvbmNhdChjbG9ja1dpc2UsIFwiLFwiKS5jb25jYXQoeCArIHhTaWduICogbmV3UmFkaXVzWzBdLCBcIixcIikuY29uY2F0KHkpO1xuICAgIH1cbiAgICBwYXRoICs9IFwiTCBcIi5jb25jYXQoeCArIHdpZHRoIC0geFNpZ24gKiBuZXdSYWRpdXNbMV0sIFwiLFwiKS5jb25jYXQoeSk7XG4gICAgaWYgKG5ld1JhZGl1c1sxXSA+IDApIHtcbiAgICAgIHBhdGggKz0gXCJBIFwiLmNvbmNhdChuZXdSYWRpdXNbMV0sIFwiLFwiKS5jb25jYXQobmV3UmFkaXVzWzFdLCBcIiwwLDAsXCIpLmNvbmNhdChjbG9ja1dpc2UsIFwiLFxcbiAgICAgICAgXCIpLmNvbmNhdCh4ICsgd2lkdGgsIFwiLFwiKS5jb25jYXQoeSArIHlTaWduICogbmV3UmFkaXVzWzFdKTtcbiAgICB9XG4gICAgcGF0aCArPSBcIkwgXCIuY29uY2F0KHggKyB3aWR0aCwgXCIsXCIpLmNvbmNhdCh5ICsgaGVpZ2h0IC0geVNpZ24gKiBuZXdSYWRpdXNbMl0pO1xuICAgIGlmIChuZXdSYWRpdXNbMl0gPiAwKSB7XG4gICAgICBwYXRoICs9IFwiQSBcIi5jb25jYXQobmV3UmFkaXVzWzJdLCBcIixcIikuY29uY2F0KG5ld1JhZGl1c1syXSwgXCIsMCwwLFwiKS5jb25jYXQoY2xvY2tXaXNlLCBcIixcXG4gICAgICAgIFwiKS5jb25jYXQoeCArIHdpZHRoIC0geFNpZ24gKiBuZXdSYWRpdXNbMl0sIFwiLFwiKS5jb25jYXQoeSArIGhlaWdodCk7XG4gICAgfVxuICAgIHBhdGggKz0gXCJMIFwiLmNvbmNhdCh4ICsgeFNpZ24gKiBuZXdSYWRpdXNbM10sIFwiLFwiKS5jb25jYXQoeSArIGhlaWdodCk7XG4gICAgaWYgKG5ld1JhZGl1c1szXSA+IDApIHtcbiAgICAgIHBhdGggKz0gXCJBIFwiLmNvbmNhdChuZXdSYWRpdXNbM10sIFwiLFwiKS5jb25jYXQobmV3UmFkaXVzWzNdLCBcIiwwLDAsXCIpLmNvbmNhdChjbG9ja1dpc2UsIFwiLFxcbiAgICAgICAgXCIpLmNvbmNhdCh4LCBcIixcIikuY29uY2F0KHkgKyBoZWlnaHQgLSB5U2lnbiAqIG5ld1JhZGl1c1szXSk7XG4gICAgfVxuICAgIHBhdGggKz0gJ1onO1xuICB9IGVsc2UgaWYgKG1heFJhZGl1cyA+IDAgJiYgcmFkaXVzID09PSArcmFkaXVzICYmIHJhZGl1cyA+IDApIHtcbiAgICB2YXIgX25ld1JhZGl1cyA9IE1hdGgubWluKG1heFJhZGl1cywgcmFkaXVzKTtcbiAgICBwYXRoID0gXCJNIFwiLmNvbmNhdCh4LCBcIixcIikuY29uY2F0KHkgKyB5U2lnbiAqIF9uZXdSYWRpdXMsIFwiXFxuICAgICAgICAgICAgQSBcIikuY29uY2F0KF9uZXdSYWRpdXMsIFwiLFwiKS5jb25jYXQoX25ld1JhZGl1cywgXCIsMCwwLFwiKS5jb25jYXQoY2xvY2tXaXNlLCBcIixcIikuY29uY2F0KHggKyB4U2lnbiAqIF9uZXdSYWRpdXMsIFwiLFwiKS5jb25jYXQoeSwgXCJcXG4gICAgICAgICAgICBMIFwiKS5jb25jYXQoeCArIHdpZHRoIC0geFNpZ24gKiBfbmV3UmFkaXVzLCBcIixcIikuY29uY2F0KHksIFwiXFxuICAgICAgICAgICAgQSBcIikuY29uY2F0KF9uZXdSYWRpdXMsIFwiLFwiKS5jb25jYXQoX25ld1JhZGl1cywgXCIsMCwwLFwiKS5jb25jYXQoY2xvY2tXaXNlLCBcIixcIikuY29uY2F0KHggKyB3aWR0aCwgXCIsXCIpLmNvbmNhdCh5ICsgeVNpZ24gKiBfbmV3UmFkaXVzLCBcIlxcbiAgICAgICAgICAgIEwgXCIpLmNvbmNhdCh4ICsgd2lkdGgsIFwiLFwiKS5jb25jYXQoeSArIGhlaWdodCAtIHlTaWduICogX25ld1JhZGl1cywgXCJcXG4gICAgICAgICAgICBBIFwiKS5jb25jYXQoX25ld1JhZGl1cywgXCIsXCIpLmNvbmNhdChfbmV3UmFkaXVzLCBcIiwwLDAsXCIpLmNvbmNhdChjbG9ja1dpc2UsIFwiLFwiKS5jb25jYXQoeCArIHdpZHRoIC0geFNpZ24gKiBfbmV3UmFkaXVzLCBcIixcIikuY29uY2F0KHkgKyBoZWlnaHQsIFwiXFxuICAgICAgICAgICAgTCBcIikuY29uY2F0KHggKyB4U2lnbiAqIF9uZXdSYWRpdXMsIFwiLFwiKS5jb25jYXQoeSArIGhlaWdodCwgXCJcXG4gICAgICAgICAgICBBIFwiKS5jb25jYXQoX25ld1JhZGl1cywgXCIsXCIpLmNvbmNhdChfbmV3UmFkaXVzLCBcIiwwLDAsXCIpLmNvbmNhdChjbG9ja1dpc2UsIFwiLFwiKS5jb25jYXQoeCwgXCIsXCIpLmNvbmNhdCh5ICsgaGVpZ2h0IC0geVNpZ24gKiBfbmV3UmFkaXVzLCBcIiBaXCIpO1xuICB9IGVsc2Uge1xuICAgIHBhdGggPSBcIk0gXCIuY29uY2F0KHgsIFwiLFwiKS5jb25jYXQoeSwgXCIgaCBcIikuY29uY2F0KHdpZHRoLCBcIiB2IFwiKS5jb25jYXQoaGVpZ2h0LCBcIiBoIFwiKS5jb25jYXQoLXdpZHRoLCBcIiBaXCIpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufTtcbnZhciBpc0luUmVjdGFuZ2xlID0gZXhwb3J0cy5pc0luUmVjdGFuZ2xlID0gZnVuY3Rpb24gaXNJblJlY3RhbmdsZShwb2ludCwgcmVjdCkge1xuICBpZiAoIXBvaW50IHx8ICFyZWN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBweCA9IHBvaW50LngsXG4gICAgcHkgPSBwb2ludC55O1xuICB2YXIgeCA9IHJlY3QueCxcbiAgICB5ID0gcmVjdC55LFxuICAgIHdpZHRoID0gcmVjdC53aWR0aCxcbiAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgaWYgKE1hdGguYWJzKHdpZHRoKSA+IDAgJiYgTWF0aC5hYnMoaGVpZ2h0KSA+IDApIHtcbiAgICB2YXIgbWluWCA9IE1hdGgubWluKHgsIHggKyB3aWR0aCk7XG4gICAgdmFyIG1heFggPSBNYXRoLm1heCh4LCB4ICsgd2lkdGgpO1xuICAgIHZhciBtaW5ZID0gTWF0aC5taW4oeSwgeSArIGhlaWdodCk7XG4gICAgdmFyIG1heFkgPSBNYXRoLm1heCh5LCB5ICsgaGVpZ2h0KTtcbiAgICByZXR1cm4gcHggPj0gbWluWCAmJiBweCA8PSBtYXhYICYmIHB5ID49IG1pblkgJiYgcHkgPD0gbWF4WTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgeDogMCxcbiAgeTogMCxcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgLy8gVGhlIHJhZGl1cyBvZiBib3JkZXJcbiAgLy8gVGhlIHJhZGl1cyBvZiBmb3VyIGNvcm5lcnMgd2hlbiByYWRpdXMgaXMgYSBudW1iZXJcbiAgLy8gVGhlIHJhZGl1cyBvZiBsZWZ0LXRvcCwgcmlnaHQtdG9wLCByaWdodC1ib3R0b20sIGxlZnQtYm90dG9tIHdoZW4gcmFkaXVzIGlzIGFuIGFycmF5XG4gIHJhZGl1czogMCxcbiAgaXNBbmltYXRpb25BY3RpdmU6IGZhbHNlLFxuICBpc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZTogZmFsc2UsXG4gIGFuaW1hdGlvbkJlZ2luOiAwLFxuICBhbmltYXRpb25EdXJhdGlvbjogMTUwMCxcbiAgYW5pbWF0aW9uRWFzaW5nOiAnZWFzZSdcbn07XG52YXIgUmVjdGFuZ2xlID0gZXhwb3J0cy5SZWN0YW5nbGUgPSBmdW5jdGlvbiBSZWN0YW5nbGUocmVjdGFuZ2xlUHJvcHMpIHtcbiAgdmFyIHByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0UHJvcHMpLCByZWN0YW5nbGVQcm9wcyk7XG4gIHZhciBwYXRoUmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKCk7XG4gIHZhciBfdXNlU3RhdGUgPSAoMCwgX3JlYWN0LnVzZVN0YXRlKSgtMSksXG4gICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgdG90YWxMZW5ndGggPSBfdXNlU3RhdGUyWzBdLFxuICAgIHNldFRvdGFsTGVuZ3RoID0gX3VzZVN0YXRlMlsxXTtcbiAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocGF0aFJlZi5jdXJyZW50ICYmIHBhdGhSZWYuY3VycmVudC5nZXRUb3RhbExlbmd0aCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHBhdGhUb3RhbExlbmd0aCA9IHBhdGhSZWYuY3VycmVudC5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICBpZiAocGF0aFRvdGFsTGVuZ3RoKSB7XG4gICAgICAgICAgc2V0VG90YWxMZW5ndGgocGF0aFRvdGFsTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0b3RhbCBsZW5ndGggZXJyb3JcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcbiAgdmFyIHggPSBwcm9wcy54LFxuICAgIHkgPSBwcm9wcy55LFxuICAgIHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxuICAgIHJhZGl1cyA9IHByb3BzLnJhZGl1cyxcbiAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWU7XG4gIHZhciBhbmltYXRpb25FYXNpbmcgPSBwcm9wcy5hbmltYXRpb25FYXNpbmcsXG4gICAgYW5pbWF0aW9uRHVyYXRpb24gPSBwcm9wcy5hbmltYXRpb25EdXJhdGlvbixcbiAgICBhbmltYXRpb25CZWdpbiA9IHByb3BzLmFuaW1hdGlvbkJlZ2luLFxuICAgIGlzQW5pbWF0aW9uQWN0aXZlID0gcHJvcHMuaXNBbmltYXRpb25BY3RpdmUsXG4gICAgaXNVcGRhdGVBbmltYXRpb25BY3RpdmUgPSBwcm9wcy5pc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZTtcbiAgaWYgKHggIT09ICt4IHx8IHkgIT09ICt5IHx8IHdpZHRoICE9PSArd2lkdGggfHwgaGVpZ2h0ICE9PSAraGVpZ2h0IHx8IHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBsYXllckNsYXNzID0gKDAsIF9jbHN4W1wiZGVmYXVsdFwiXSkoJ3JlY2hhcnRzLXJlY3RhbmdsZScsIGNsYXNzTmFtZSk7XG4gIGlmICghaXNVcGRhdGVBbmltYXRpb25BY3RpdmUpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBhdGhcIiwgX2V4dGVuZHMoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykocHJvcHMsIHRydWUpLCB7XG4gICAgICBjbGFzc05hbWU6IGxheWVyQ2xhc3MsXG4gICAgICBkOiBnZXRSZWN0YW5nbGVQYXRoKHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cylcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JlYWN0U21vb3RoW1wiZGVmYXVsdFwiXSwge1xuICAgIGNhbkJlZ2luOiB0b3RhbExlbmd0aCA+IDAsXG4gICAgZnJvbToge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH0sXG4gICAgdG86IHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9LFxuICAgIGR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvbixcbiAgICBhbmltYXRpb25FYXNpbmc6IGFuaW1hdGlvbkVhc2luZyxcbiAgICBpc0FjdGl2ZTogaXNVcGRhdGVBbmltYXRpb25BY3RpdmVcbiAgfSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgY3VycldpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGN1cnJIZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICAgIGN1cnJYID0gX3JlZi54LFxuICAgICAgY3VyclkgPSBfcmVmLnk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JlYWN0U21vb3RoW1wiZGVmYXVsdFwiXSwge1xuICAgICAgY2FuQmVnaW46IHRvdGFsTGVuZ3RoID4gMCxcbiAgICAgIGZyb206IFwiMHB4IFwiLmNvbmNhdCh0b3RhbExlbmd0aCA9PT0gLTEgPyAxIDogdG90YWxMZW5ndGgsIFwicHhcIiksXG4gICAgICB0bzogXCJcIi5jb25jYXQodG90YWxMZW5ndGgsIFwicHggMHB4XCIpLFxuICAgICAgYXR0cmlidXRlTmFtZTogXCJzdHJva2VEYXNoYXJyYXlcIixcbiAgICAgIGJlZ2luOiBhbmltYXRpb25CZWdpbixcbiAgICAgIGR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvbixcbiAgICAgIGlzQWN0aXZlOiBpc0FuaW1hdGlvbkFjdGl2ZSxcbiAgICAgIGVhc2luZzogYW5pbWF0aW9uRWFzaW5nXG4gICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInBhdGhcIiwgX2V4dGVuZHMoe30sICgwLCBfUmVhY3RVdGlscy5maWx0ZXJQcm9wcykocHJvcHMsIHRydWUpLCB7XG4gICAgICBjbGFzc05hbWU6IGxheWVyQ2xhc3MsXG4gICAgICBkOiBnZXRSZWN0YW5nbGVQYXRoKGN1cnJYLCBjdXJyWSwgY3VycldpZHRoLCBjdXJySGVpZ2h0LCByYWRpdXMpLFxuICAgICAgcmVmOiBwYXRoUmVmXG4gICAgfSkpKTtcbiAgfSk7XG59OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlzSW5SZWN0YW5nbGUiLCJSZWN0YW5nbGUiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfY2xzeCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfcmVhY3RTbW9vdGgiLCJfUmVhY3RVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImFwcGx5IiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJsZW4iLCJhcnIyIiwibCIsImYiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJpc0FycmF5Iiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJlbnVtZXJhYmxlIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsImdldFJlY3RhbmdsZVBhdGgiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0IiwicmFkaXVzIiwibWF4UmFkaXVzIiwiTWF0aCIsIm1pbiIsImFicyIsInlTaWduIiwieFNpZ24iLCJjbG9ja1dpc2UiLCJwYXRoIiwibmV3UmFkaXVzIiwiY29uY2F0IiwiX25ld1JhZGl1cyIsInBvaW50IiwicmVjdCIsInB4IiwicHkiLCJtaW5YIiwibWF4WCIsIm1heCIsIm1pblkiLCJtYXhZIiwiZGVmYXVsdFByb3BzIiwiaXNBbmltYXRpb25BY3RpdmUiLCJpc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZSIsImFuaW1hdGlvbkJlZ2luIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJhbmltYXRpb25FYXNpbmciLCJyZWN0YW5nbGVQcm9wcyIsInByb3BzIiwicGF0aFJlZiIsInVzZVJlZiIsIl91c2VTdGF0ZSIsInVzZVN0YXRlIiwiX3VzZVN0YXRlMiIsInRvdGFsTGVuZ3RoIiwic2V0VG90YWxMZW5ndGgiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiZ2V0VG90YWxMZW5ndGgiLCJwYXRoVG90YWxMZW5ndGgiLCJlcnIiLCJjbGFzc05hbWUiLCJsYXllckNsYXNzIiwiY3JlYXRlRWxlbWVudCIsImZpbHRlclByb3BzIiwiZCIsImNhbkJlZ2luIiwidG8iLCJkdXJhdGlvbiIsImlzQWN0aXZlIiwiX3JlZiIsImN1cnJXaWR0aCIsImN1cnJIZWlnaHQiLCJjdXJyWCIsImN1cnJZIiwiYXR0cmlidXRlTmFtZSIsImJlZ2luIiwiZWFzaW5nIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/shape/Rectangle.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/shape/Sector.js":
/*!***************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Sector.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Sector = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _PolarUtils = __webpack_require__(/*! ../util/PolarUtils */ \"./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ../util/DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Sector\n */ \nvar getDeltaAngle = function getDeltaAngle(startAngle, endAngle) {\n    var sign = (0, _DataUtils.mathSign)(endAngle - startAngle);\n    var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 359.999);\n    return sign * deltaAngle;\n};\nvar getTangentCircle = function getTangentCircle(_ref) {\n    var cx = _ref.cx, cy = _ref.cy, radius = _ref.radius, angle = _ref.angle, sign = _ref.sign, isExternal = _ref.isExternal, cornerRadius = _ref.cornerRadius, cornerIsExternal = _ref.cornerIsExternal;\n    var centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;\n    var theta = Math.asin(cornerRadius / centerRadius) / _PolarUtils.RADIAN;\n    var centerAngle = cornerIsExternal ? angle : angle + sign * theta;\n    var center = (0, _PolarUtils.polarToCartesian)(cx, cy, centerRadius, centerAngle);\n    // The coordinate of point which is tangent to the circle\n    var circleTangency = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, centerAngle);\n    // The coordinate of point which is tangent to the radius line\n    var lineTangencyAngle = cornerIsExternal ? angle - sign * theta : angle;\n    var lineTangency = (0, _PolarUtils.polarToCartesian)(cx, cy, centerRadius * Math.cos(theta * _PolarUtils.RADIAN), lineTangencyAngle);\n    return {\n        center: center,\n        circleTangency: circleTangency,\n        lineTangency: lineTangency,\n        theta: theta\n    };\n};\nvar getSectorPath = function getSectorPath(_ref2) {\n    var cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius, startAngle = _ref2.startAngle, endAngle = _ref2.endAngle;\n    var angle = getDeltaAngle(startAngle, endAngle);\n    // When the angle of sector equals to 360, star point and end point coincide\n    var tempEndAngle = startAngle + angle;\n    var outerStartPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, outerRadius, startAngle);\n    var outerEndPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, outerRadius, tempEndAngle);\n    var path = \"M \".concat(outerStartPoint.x, \",\").concat(outerStartPoint.y, \"\\n    A \").concat(outerRadius, \",\").concat(outerRadius, \",0,\\n    \").concat(+(Math.abs(angle) > 180), \",\").concat(+(startAngle > tempEndAngle), \",\\n    \").concat(outerEndPoint.x, \",\").concat(outerEndPoint.y, \"\\n  \");\n    if (innerRadius > 0) {\n        var innerStartPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, innerRadius, startAngle);\n        var innerEndPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, innerRadius, tempEndAngle);\n        path += \"L \".concat(innerEndPoint.x, \",\").concat(innerEndPoint.y, \"\\n            A \").concat(innerRadius, \",\").concat(innerRadius, \",0,\\n            \").concat(+(Math.abs(angle) > 180), \",\").concat(+(startAngle <= tempEndAngle), \",\\n            \").concat(innerStartPoint.x, \",\").concat(innerStartPoint.y, \" Z\");\n    } else {\n        path += \"L \".concat(cx, \",\").concat(cy, \" Z\");\n    }\n    return path;\n};\nvar getSectorWithCorner = function getSectorWithCorner(_ref3) {\n    var cx = _ref3.cx, cy = _ref3.cy, innerRadius = _ref3.innerRadius, outerRadius = _ref3.outerRadius, cornerRadius = _ref3.cornerRadius, forceCornerRadius = _ref3.forceCornerRadius, cornerIsExternal = _ref3.cornerIsExternal, startAngle = _ref3.startAngle, endAngle = _ref3.endAngle;\n    var sign = (0, _DataUtils.mathSign)(endAngle - startAngle);\n    var _getTangentCircle = getTangentCircle({\n        cx: cx,\n        cy: cy,\n        radius: outerRadius,\n        angle: startAngle,\n        sign: sign,\n        cornerRadius: cornerRadius,\n        cornerIsExternal: cornerIsExternal\n    }), soct = _getTangentCircle.circleTangency, solt = _getTangentCircle.lineTangency, sot = _getTangentCircle.theta;\n    var _getTangentCircle2 = getTangentCircle({\n        cx: cx,\n        cy: cy,\n        radius: outerRadius,\n        angle: endAngle,\n        sign: -sign,\n        cornerRadius: cornerRadius,\n        cornerIsExternal: cornerIsExternal\n    }), eoct = _getTangentCircle2.circleTangency, eolt = _getTangentCircle2.lineTangency, eot = _getTangentCircle2.theta;\n    var outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;\n    if (outerArcAngle < 0) {\n        if (forceCornerRadius) {\n            return \"M \".concat(solt.x, \",\").concat(solt.y, \"\\n        a\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,1,\").concat(cornerRadius * 2, \",0\\n        a\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,1,\").concat(-cornerRadius * 2, \",0\\n      \");\n        }\n        return getSectorPath({\n            cx: cx,\n            cy: cy,\n            innerRadius: innerRadius,\n            outerRadius: outerRadius,\n            startAngle: startAngle,\n            endAngle: endAngle\n        });\n    }\n    var path = \"M \".concat(solt.x, \",\").concat(solt.y, \"\\n    A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(soct.x, \",\").concat(soct.y, \"\\n    A\").concat(outerRadius, \",\").concat(outerRadius, \",0,\").concat(+(outerArcAngle > 180), \",\").concat(+(sign < 0), \",\").concat(eoct.x, \",\").concat(eoct.y, \"\\n    A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(eolt.x, \",\").concat(eolt.y, \"\\n  \");\n    if (innerRadius > 0) {\n        var _getTangentCircle3 = getTangentCircle({\n            cx: cx,\n            cy: cy,\n            radius: innerRadius,\n            angle: startAngle,\n            sign: sign,\n            isExternal: true,\n            cornerRadius: cornerRadius,\n            cornerIsExternal: cornerIsExternal\n        }), sict = _getTangentCircle3.circleTangency, silt = _getTangentCircle3.lineTangency, sit = _getTangentCircle3.theta;\n        var _getTangentCircle4 = getTangentCircle({\n            cx: cx,\n            cy: cy,\n            radius: innerRadius,\n            angle: endAngle,\n            sign: -sign,\n            isExternal: true,\n            cornerRadius: cornerRadius,\n            cornerIsExternal: cornerIsExternal\n        }), eict = _getTangentCircle4.circleTangency, eilt = _getTangentCircle4.lineTangency, eit = _getTangentCircle4.theta;\n        var innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;\n        if (innerArcAngle < 0 && cornerRadius === 0) {\n            return \"\".concat(path, \"L\").concat(cx, \",\").concat(cy, \"Z\");\n        }\n        path += \"L\".concat(eilt.x, \",\").concat(eilt.y, \"\\n      A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(eict.x, \",\").concat(eict.y, \"\\n      A\").concat(innerRadius, \",\").concat(innerRadius, \",0,\").concat(+(innerArcAngle > 180), \",\").concat(+(sign > 0), \",\").concat(sict.x, \",\").concat(sict.y, \"\\n      A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(silt.x, \",\").concat(silt.y, \"Z\");\n    } else {\n        path += \"L\".concat(cx, \",\").concat(cy, \"Z\");\n    }\n    return path;\n};\nvar defaultProps = {\n    cx: 0,\n    cy: 0,\n    innerRadius: 0,\n    outerRadius: 0,\n    startAngle: 0,\n    endAngle: 0,\n    cornerRadius: 0,\n    forceCornerRadius: false,\n    cornerIsExternal: false\n};\nvar Sector = exports.Sector = function Sector(sectorProps) {\n    var props = _objectSpread(_objectSpread({}, defaultProps), sectorProps);\n    var cx = props.cx, cy = props.cy, innerRadius = props.innerRadius, outerRadius = props.outerRadius, cornerRadius = props.cornerRadius, forceCornerRadius = props.forceCornerRadius, cornerIsExternal = props.cornerIsExternal, startAngle = props.startAngle, endAngle = props.endAngle, className = props.className;\n    if (outerRadius < innerRadius || startAngle === endAngle) {\n        return null;\n    }\n    var layerClass = (0, _clsx[\"default\"])(\"recharts-sector\", className);\n    var deltaRadius = outerRadius - innerRadius;\n    var cr = (0, _DataUtils.getPercentValue)(cornerRadius, deltaRadius, 0, true);\n    var path;\n    if (cr > 0 && Math.abs(startAngle - endAngle) < 360) {\n        path = getSectorWithCorner({\n            cx: cx,\n            cy: cy,\n            innerRadius: innerRadius,\n            outerRadius: outerRadius,\n            cornerRadius: Math.min(cr, deltaRadius / 2),\n            forceCornerRadius: forceCornerRadius,\n            cornerIsExternal: cornerIsExternal,\n            startAngle: startAngle,\n            endAngle: endAngle\n        });\n    } else {\n        path = getSectorPath({\n            cx: cx,\n            cy: cy,\n            innerRadius: innerRadius,\n            outerRadius: outerRadius,\n            startAngle: startAngle,\n            endAngle: endAngle\n        });\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(props, true), {\n        className: layerClass,\n        d: path,\n        role: \"img\"\n    }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3NoYXBlL1NlY3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsSUFBSUcsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxRQUFRRix1QkFBdUJDLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlFLGNBQWNGLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJRyxjQUFjSCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsSUFBSUksYUFBYUosbUJBQU9BLENBQUMsd0VBQW1CO0FBQzVDLFNBQVNELHVCQUF1Qk0sR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0s7SUFBYUEsV0FBV3BCLE9BQU9xQixNQUFNLEdBQUdyQixPQUFPcUIsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFBRSxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFBRSxJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQUUsSUFBSTNCLE9BQU9tQixTQUFTLENB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WUFDWkMsVUFBVUE7UUFDWjtJQUNGO0lBQ0EsT0FBTyxXQUFXLEdBQUVwRCxNQUFNLENBQUMsVUFBVSxDQUFDeUgsYUFBYSxDQUFDLFFBQVExRyxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUdYLFlBQVlzSCxXQUFXLEVBQUVQLE9BQU8sT0FBTztRQUNsSEMsV0FBV0M7UUFDWE0sR0FBR3JDO1FBQ0hzQyxNQUFNO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvc2hhcGUvU2VjdG9yLmpzPzMxN2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlNlY3RvciA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XG52YXIgX1BvbGFyVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9Qb2xhclV0aWxzXCIpO1xudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9EYXRhVXRpbHNcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFNlY3RvclxuICovXG52YXIgZ2V0RGVsdGFBbmdsZSA9IGZ1bmN0aW9uIGdldERlbHRhQW5nbGUoc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcbiAgdmFyIHNpZ24gPSAoMCwgX0RhdGFVdGlscy5tYXRoU2lnbikoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgdmFyIGRlbHRhQW5nbGUgPSBNYXRoLm1pbihNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpLCAzNTkuOTk5KTtcbiAgcmV0dXJuIHNpZ24gKiBkZWx0YUFuZ2xlO1xufTtcbnZhciBnZXRUYW5nZW50Q2lyY2xlID0gZnVuY3Rpb24gZ2V0VGFuZ2VudENpcmNsZShfcmVmKSB7XG4gIHZhciBjeCA9IF9yZWYuY3gsXG4gICAgY3kgPSBfcmVmLmN5LFxuICAgIHJhZGl1cyA9IF9yZWYucmFkaXVzLFxuICAgIGFuZ2xlID0gX3JlZi5hbmdsZSxcbiAgICBzaWduID0gX3JlZi5zaWduLFxuICAgIGlzRXh0ZXJuYWwgPSBfcmVmLmlzRXh0ZXJuYWwsXG4gICAgY29ybmVyUmFkaXVzID0gX3JlZi5jb3JuZXJSYWRpdXMsXG4gICAgY29ybmVySXNFeHRlcm5hbCA9IF9yZWYuY29ybmVySXNFeHRlcm5hbDtcbiAgdmFyIGNlbnRlclJhZGl1cyA9IGNvcm5lclJhZGl1cyAqIChpc0V4dGVybmFsID8gMSA6IC0xKSArIHJhZGl1cztcbiAgdmFyIHRoZXRhID0gTWF0aC5hc2luKGNvcm5lclJhZGl1cyAvIGNlbnRlclJhZGl1cykgLyBfUG9sYXJVdGlscy5SQURJQU47XG4gIHZhciBjZW50ZXJBbmdsZSA9IGNvcm5lcklzRXh0ZXJuYWwgPyBhbmdsZSA6IGFuZ2xlICsgc2lnbiAqIHRoZXRhO1xuICB2YXIgY2VudGVyID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgY2VudGVyUmFkaXVzLCBjZW50ZXJBbmdsZSk7XG4gIC8vIFRoZSBjb29yZGluYXRlIG9mIHBvaW50IHdoaWNoIGlzIHRhbmdlbnQgdG8gdGhlIGNpcmNsZVxuICB2YXIgY2lyY2xlVGFuZ2VuY3kgPSAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCByYWRpdXMsIGNlbnRlckFuZ2xlKTtcbiAgLy8gVGhlIGNvb3JkaW5hdGUgb2YgcG9pbnQgd2hpY2ggaXMgdGFuZ2VudCB0byB0aGUgcmFkaXVzIGxpbmVcbiAgdmFyIGxpbmVUYW5nZW5jeUFuZ2xlID0gY29ybmVySXNFeHRlcm5hbCA/IGFuZ2xlIC0gc2lnbiAqIHRoZXRhIDogYW5nbGU7XG4gIHZhciBsaW5lVGFuZ2VuY3kgPSAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCBjZW50ZXJSYWRpdXMgKiBNYXRoLmNvcyh0aGV0YSAqIF9Qb2xhclV0aWxzLlJBRElBTiksIGxpbmVUYW5nZW5jeUFuZ2xlKTtcbiAgcmV0dXJuIHtcbiAgICBjZW50ZXI6IGNlbnRlcixcbiAgICBjaXJjbGVUYW5nZW5jeTogY2lyY2xlVGFuZ2VuY3ksXG4gICAgbGluZVRhbmdlbmN5OiBsaW5lVGFuZ2VuY3ksXG4gICAgdGhldGE6IHRoZXRhXG4gIH07XG59O1xudmFyIGdldFNlY3RvclBhdGggPSBmdW5jdGlvbiBnZXRTZWN0b3JQYXRoKF9yZWYyKSB7XG4gIHZhciBjeCA9IF9yZWYyLmN4LFxuICAgIGN5ID0gX3JlZjIuY3ksXG4gICAgaW5uZXJSYWRpdXMgPSBfcmVmMi5pbm5lclJhZGl1cyxcbiAgICBvdXRlclJhZGl1cyA9IF9yZWYyLm91dGVyUmFkaXVzLFxuICAgIHN0YXJ0QW5nbGUgPSBfcmVmMi5zdGFydEFuZ2xlLFxuICAgIGVuZEFuZ2xlID0gX3JlZjIuZW5kQW5nbGU7XG4gIHZhciBhbmdsZSA9IGdldERlbHRhQW5nbGUoc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuXG4gIC8vIFdoZW4gdGhlIGFuZ2xlIG9mIHNlY3RvciBlcXVhbHMgdG8gMzYwLCBzdGFyIHBvaW50IGFuZCBlbmQgcG9pbnQgY29pbmNpZGVcbiAgdmFyIHRlbXBFbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBhbmdsZTtcbiAgdmFyIG91dGVyU3RhcnRQb2ludCA9ICgwLCBfUG9sYXJVdGlscy5wb2xhclRvQ2FydGVzaWFuKShjeCwgY3ksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlKTtcbiAgdmFyIG91dGVyRW5kUG9pbnQgPSAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCBvdXRlclJhZGl1cywgdGVtcEVuZEFuZ2xlKTtcbiAgdmFyIHBhdGggPSBcIk0gXCIuY29uY2F0KG91dGVyU3RhcnRQb2ludC54LCBcIixcIikuY29uY2F0KG91dGVyU3RhcnRQb2ludC55LCBcIlxcbiAgICBBIFwiKS5jb25jYXQob3V0ZXJSYWRpdXMsIFwiLFwiKS5jb25jYXQob3V0ZXJSYWRpdXMsIFwiLDAsXFxuICAgIFwiKS5jb25jYXQoKyhNYXRoLmFicyhhbmdsZSkgPiAxODApLCBcIixcIikuY29uY2F0KCsoc3RhcnRBbmdsZSA+IHRlbXBFbmRBbmdsZSksIFwiLFxcbiAgICBcIikuY29uY2F0KG91dGVyRW5kUG9pbnQueCwgXCIsXCIpLmNvbmNhdChvdXRlckVuZFBvaW50LnksIFwiXFxuICBcIik7XG4gIGlmIChpbm5lclJhZGl1cyA+IDApIHtcbiAgICB2YXIgaW5uZXJTdGFydFBvaW50ID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgaW5uZXJSYWRpdXMsIHN0YXJ0QW5nbGUpO1xuICAgIHZhciBpbm5lckVuZFBvaW50ID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgaW5uZXJSYWRpdXMsIHRlbXBFbmRBbmdsZSk7XG4gICAgcGF0aCArPSBcIkwgXCIuY29uY2F0KGlubmVyRW5kUG9pbnQueCwgXCIsXCIpLmNvbmNhdChpbm5lckVuZFBvaW50LnksIFwiXFxuICAgICAgICAgICAgQSBcIikuY29uY2F0KGlubmVyUmFkaXVzLCBcIixcIikuY29uY2F0KGlubmVyUmFkaXVzLCBcIiwwLFxcbiAgICAgICAgICAgIFwiKS5jb25jYXQoKyhNYXRoLmFicyhhbmdsZSkgPiAxODApLCBcIixcIikuY29uY2F0KCsoc3RhcnRBbmdsZSA8PSB0ZW1wRW5kQW5nbGUpLCBcIixcXG4gICAgICAgICAgICBcIikuY29uY2F0KGlubmVyU3RhcnRQb2ludC54LCBcIixcIikuY29uY2F0KGlubmVyU3RhcnRQb2ludC55LCBcIiBaXCIpO1xuICB9IGVsc2Uge1xuICAgIHBhdGggKz0gXCJMIFwiLmNvbmNhdChjeCwgXCIsXCIpLmNvbmNhdChjeSwgXCIgWlwiKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG52YXIgZ2V0U2VjdG9yV2l0aENvcm5lciA9IGZ1bmN0aW9uIGdldFNlY3RvcldpdGhDb3JuZXIoX3JlZjMpIHtcbiAgdmFyIGN4ID0gX3JlZjMuY3gsXG4gICAgY3kgPSBfcmVmMy5jeSxcbiAgICBpbm5lclJhZGl1cyA9IF9yZWYzLmlubmVyUmFkaXVzLFxuICAgIG91dGVyUmFkaXVzID0gX3JlZjMub3V0ZXJSYWRpdXMsXG4gICAgY29ybmVyUmFkaXVzID0gX3JlZjMuY29ybmVyUmFkaXVzLFxuICAgIGZvcmNlQ29ybmVyUmFkaXVzID0gX3JlZjMuZm9yY2VDb3JuZXJSYWRpdXMsXG4gICAgY29ybmVySXNFeHRlcm5hbCA9IF9yZWYzLmNvcm5lcklzRXh0ZXJuYWwsXG4gICAgc3RhcnRBbmdsZSA9IF9yZWYzLnN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGUgPSBfcmVmMy5lbmRBbmdsZTtcbiAgdmFyIHNpZ24gPSAoMCwgX0RhdGFVdGlscy5tYXRoU2lnbikoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgdmFyIF9nZXRUYW5nZW50Q2lyY2xlID0gZ2V0VGFuZ2VudENpcmNsZSh7XG4gICAgICBjeDogY3gsXG4gICAgICBjeTogY3ksXG4gICAgICByYWRpdXM6IG91dGVyUmFkaXVzLFxuICAgICAgYW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICBzaWduOiBzaWduLFxuICAgICAgY29ybmVyUmFkaXVzOiBjb3JuZXJSYWRpdXMsXG4gICAgICBjb3JuZXJJc0V4dGVybmFsOiBjb3JuZXJJc0V4dGVybmFsXG4gICAgfSksXG4gICAgc29jdCA9IF9nZXRUYW5nZW50Q2lyY2xlLmNpcmNsZVRhbmdlbmN5LFxuICAgIHNvbHQgPSBfZ2V0VGFuZ2VudENpcmNsZS5saW5lVGFuZ2VuY3ksXG4gICAgc290ID0gX2dldFRhbmdlbnRDaXJjbGUudGhldGE7XG4gIHZhciBfZ2V0VGFuZ2VudENpcmNsZTIgPSBnZXRUYW5nZW50Q2lyY2xlKHtcbiAgICAgIGN4OiBjeCxcbiAgICAgIGN5OiBjeSxcbiAgICAgIHJhZGl1czogb3V0ZXJSYWRpdXMsXG4gICAgICBhbmdsZTogZW5kQW5nbGUsXG4gICAgICBzaWduOiAtc2lnbixcbiAgICAgIGNvcm5lclJhZGl1czogY29ybmVyUmFkaXVzLFxuICAgICAgY29ybmVySXNFeHRlcm5hbDogY29ybmVySXNFeHRlcm5hbFxuICAgIH0pLFxuICAgIGVvY3QgPSBfZ2V0VGFuZ2VudENpcmNsZTIuY2lyY2xlVGFuZ2VuY3ksXG4gICAgZW9sdCA9IF9nZXRUYW5nZW50Q2lyY2xlMi5saW5lVGFuZ2VuY3ksXG4gICAgZW90ID0gX2dldFRhbmdlbnRDaXJjbGUyLnRoZXRhO1xuICB2YXIgb3V0ZXJBcmNBbmdsZSA9IGNvcm5lcklzRXh0ZXJuYWwgPyBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpIDogTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAtIHNvdCAtIGVvdDtcbiAgaWYgKG91dGVyQXJjQW5nbGUgPCAwKSB7XG4gICAgaWYgKGZvcmNlQ29ybmVyUmFkaXVzKSB7XG4gICAgICByZXR1cm4gXCJNIFwiLmNvbmNhdChzb2x0LngsIFwiLFwiKS5jb25jYXQoc29sdC55LCBcIlxcbiAgICAgICAgYVwiKS5jb25jYXQoY29ybmVyUmFkaXVzLCBcIixcIikuY29uY2F0KGNvcm5lclJhZGl1cywgXCIsMCwwLDEsXCIpLmNvbmNhdChjb3JuZXJSYWRpdXMgKiAyLCBcIiwwXFxuICAgICAgICBhXCIpLmNvbmNhdChjb3JuZXJSYWRpdXMsIFwiLFwiKS5jb25jYXQoY29ybmVyUmFkaXVzLCBcIiwwLDAsMSxcIikuY29uY2F0KC1jb3JuZXJSYWRpdXMgKiAyLCBcIiwwXFxuICAgICAgXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0U2VjdG9yUGF0aCh7XG4gICAgICBjeDogY3gsXG4gICAgICBjeTogY3ksXG4gICAgICBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG4gICAgICBvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG4gICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGU6IGVuZEFuZ2xlXG4gICAgfSk7XG4gIH1cbiAgdmFyIHBhdGggPSBcIk0gXCIuY29uY2F0KHNvbHQueCwgXCIsXCIpLmNvbmNhdChzb2x0LnksIFwiXFxuICAgIEFcIikuY29uY2F0KGNvcm5lclJhZGl1cywgXCIsXCIpLmNvbmNhdChjb3JuZXJSYWRpdXMsIFwiLDAsMCxcIikuY29uY2F0KCsoc2lnbiA8IDApLCBcIixcIikuY29uY2F0KHNvY3QueCwgXCIsXCIpLmNvbmNhdChzb2N0LnksIFwiXFxuICAgIEFcIikuY29uY2F0KG91dGVyUmFkaXVzLCBcIixcIikuY29uY2F0KG91dGVyUmFkaXVzLCBcIiwwLFwiKS5jb25jYXQoKyhvdXRlckFyY0FuZ2xlID4gMTgwKSwgXCIsXCIpLmNvbmNhdCgrKHNpZ24gPCAwKSwgXCIsXCIpLmNvbmNhdChlb2N0LngsIFwiLFwiKS5jb25jYXQoZW9jdC55LCBcIlxcbiAgICBBXCIpLmNvbmNhdChjb3JuZXJSYWRpdXMsIFwiLFwiKS5jb25jYXQoY29ybmVyUmFkaXVzLCBcIiwwLDAsXCIpLmNvbmNhdCgrKHNpZ24gPCAwKSwgXCIsXCIpLmNvbmNhdChlb2x0LngsIFwiLFwiKS5jb25jYXQoZW9sdC55LCBcIlxcbiAgXCIpO1xuICBpZiAoaW5uZXJSYWRpdXMgPiAwKSB7XG4gICAgdmFyIF9nZXRUYW5nZW50Q2lyY2xlMyA9IGdldFRhbmdlbnRDaXJjbGUoe1xuICAgICAgICBjeDogY3gsXG4gICAgICAgIGN5OiBjeSxcbiAgICAgICAgcmFkaXVzOiBpbm5lclJhZGl1cyxcbiAgICAgICAgYW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgIHNpZ246IHNpZ24sXG4gICAgICAgIGlzRXh0ZXJuYWw6IHRydWUsXG4gICAgICAgIGNvcm5lclJhZGl1czogY29ybmVyUmFkaXVzLFxuICAgICAgICBjb3JuZXJJc0V4dGVybmFsOiBjb3JuZXJJc0V4dGVybmFsXG4gICAgICB9KSxcbiAgICAgIHNpY3QgPSBfZ2V0VGFuZ2VudENpcmNsZTMuY2lyY2xlVGFuZ2VuY3ksXG4gICAgICBzaWx0ID0gX2dldFRhbmdlbnRDaXJjbGUzLmxpbmVUYW5nZW5jeSxcbiAgICAgIHNpdCA9IF9nZXRUYW5nZW50Q2lyY2xlMy50aGV0YTtcbiAgICB2YXIgX2dldFRhbmdlbnRDaXJjbGU0ID0gZ2V0VGFuZ2VudENpcmNsZSh7XG4gICAgICAgIGN4OiBjeCxcbiAgICAgICAgY3k6IGN5LFxuICAgICAgICByYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgICAgICBhbmdsZTogZW5kQW5nbGUsXG4gICAgICAgIHNpZ246IC1zaWduLFxuICAgICAgICBpc0V4dGVybmFsOiB0cnVlLFxuICAgICAgICBjb3JuZXJSYWRpdXM6IGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVySXNFeHRlcm5hbDogY29ybmVySXNFeHRlcm5hbFxuICAgICAgfSksXG4gICAgICBlaWN0ID0gX2dldFRhbmdlbnRDaXJjbGU0LmNpcmNsZVRhbmdlbmN5LFxuICAgICAgZWlsdCA9IF9nZXRUYW5nZW50Q2lyY2xlNC5saW5lVGFuZ2VuY3ksXG4gICAgICBlaXQgPSBfZ2V0VGFuZ2VudENpcmNsZTQudGhldGE7XG4gICAgdmFyIGlubmVyQXJjQW5nbGUgPSBjb3JuZXJJc0V4dGVybmFsID8gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSA6IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSkgLSBzaXQgLSBlaXQ7XG4gICAgaWYgKGlubmVyQXJjQW5nbGUgPCAwICYmIGNvcm5lclJhZGl1cyA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHBhdGgsIFwiTFwiKS5jb25jYXQoY3gsIFwiLFwiKS5jb25jYXQoY3ksIFwiWlwiKTtcbiAgICB9XG4gICAgcGF0aCArPSBcIkxcIi5jb25jYXQoZWlsdC54LCBcIixcIikuY29uY2F0KGVpbHQueSwgXCJcXG4gICAgICBBXCIpLmNvbmNhdChjb3JuZXJSYWRpdXMsIFwiLFwiKS5jb25jYXQoY29ybmVyUmFkaXVzLCBcIiwwLDAsXCIpLmNvbmNhdCgrKHNpZ24gPCAwKSwgXCIsXCIpLmNvbmNhdChlaWN0LngsIFwiLFwiKS5jb25jYXQoZWljdC55LCBcIlxcbiAgICAgIEFcIikuY29uY2F0KGlubmVyUmFkaXVzLCBcIixcIikuY29uY2F0KGlubmVyUmFkaXVzLCBcIiwwLFwiKS5jb25jYXQoKyhpbm5lckFyY0FuZ2xlID4gMTgwKSwgXCIsXCIpLmNvbmNhdCgrKHNpZ24gPiAwKSwgXCIsXCIpLmNvbmNhdChzaWN0LngsIFwiLFwiKS5jb25jYXQoc2ljdC55LCBcIlxcbiAgICAgIEFcIikuY29uY2F0KGNvcm5lclJhZGl1cywgXCIsXCIpLmNvbmNhdChjb3JuZXJSYWRpdXMsIFwiLDAsMCxcIikuY29uY2F0KCsoc2lnbiA8IDApLCBcIixcIikuY29uY2F0KHNpbHQueCwgXCIsXCIpLmNvbmNhdChzaWx0LnksIFwiWlwiKTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoICs9IFwiTFwiLmNvbmNhdChjeCwgXCIsXCIpLmNvbmNhdChjeSwgXCJaXCIpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufTtcbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGN4OiAwLFxuICBjeTogMCxcbiAgaW5uZXJSYWRpdXM6IDAsXG4gIG91dGVyUmFkaXVzOiAwLFxuICBzdGFydEFuZ2xlOiAwLFxuICBlbmRBbmdsZTogMCxcbiAgY29ybmVyUmFkaXVzOiAwLFxuICBmb3JjZUNvcm5lclJhZGl1czogZmFsc2UsXG4gIGNvcm5lcklzRXh0ZXJuYWw6IGZhbHNlXG59O1xudmFyIFNlY3RvciA9IGV4cG9ydHMuU2VjdG9yID0gZnVuY3Rpb24gU2VjdG9yKHNlY3RvclByb3BzKSB7XG4gIHZhciBwcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFByb3BzKSwgc2VjdG9yUHJvcHMpO1xuICB2YXIgY3ggPSBwcm9wcy5jeCxcbiAgICBjeSA9IHByb3BzLmN5LFxuICAgIGlubmVyUmFkaXVzID0gcHJvcHMuaW5uZXJSYWRpdXMsXG4gICAgb3V0ZXJSYWRpdXMgPSBwcm9wcy5vdXRlclJhZGl1cyxcbiAgICBjb3JuZXJSYWRpdXMgPSBwcm9wcy5jb3JuZXJSYWRpdXMsXG4gICAgZm9yY2VDb3JuZXJSYWRpdXMgPSBwcm9wcy5mb3JjZUNvcm5lclJhZGl1cyxcbiAgICBjb3JuZXJJc0V4dGVybmFsID0gcHJvcHMuY29ybmVySXNFeHRlcm5hbCxcbiAgICBzdGFydEFuZ2xlID0gcHJvcHMuc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZSA9IHByb3BzLmVuZEFuZ2xlLFxuICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZTtcbiAgaWYgKG91dGVyUmFkaXVzIDwgaW5uZXJSYWRpdXMgfHwgc3RhcnRBbmdsZSA9PT0gZW5kQW5nbGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbGF5ZXJDbGFzcyA9ICgwLCBfY2xzeFtcImRlZmF1bHRcIl0pKCdyZWNoYXJ0cy1zZWN0b3InLCBjbGFzc05hbWUpO1xuICB2YXIgZGVsdGFSYWRpdXMgPSBvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzO1xuICB2YXIgY3IgPSAoMCwgX0RhdGFVdGlscy5nZXRQZXJjZW50VmFsdWUpKGNvcm5lclJhZGl1cywgZGVsdGFSYWRpdXMsIDAsIHRydWUpO1xuICB2YXIgcGF0aDtcbiAgaWYgKGNyID4gMCAmJiBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpIDwgMzYwKSB7XG4gICAgcGF0aCA9IGdldFNlY3RvcldpdGhDb3JuZXIoe1xuICAgICAgY3g6IGN4LFxuICAgICAgY3k6IGN5LFxuICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuICAgICAgY29ybmVyUmFkaXVzOiBNYXRoLm1pbihjciwgZGVsdGFSYWRpdXMgLyAyKSxcbiAgICAgIGZvcmNlQ29ybmVyUmFkaXVzOiBmb3JjZUNvcm5lclJhZGl1cyxcbiAgICAgIGNvcm5lcklzRXh0ZXJuYWw6IGNvcm5lcklzRXh0ZXJuYWwsXG4gICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGU6IGVuZEFuZ2xlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcGF0aCA9IGdldFNlY3RvclBhdGgoe1xuICAgICAgY3g6IGN4LFxuICAgICAgY3k6IGN5LFxuICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCBfZXh0ZW5kcyh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShwcm9wcywgdHJ1ZSksIHtcbiAgICBjbGFzc05hbWU6IGxheWVyQ2xhc3MsXG4gICAgZDogcGF0aCxcbiAgICByb2xlOiBcImltZ1wiXG4gIH0pKTtcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU2VjdG9yIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfY2xzeCIsIl9SZWFjdFV0aWxzIiwiX1BvbGFyVXRpbHMiLCJfRGF0YVV0aWxzIiwib2JqIiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIm93bktleXMiLCJlIiwiciIsInQiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiZ2V0RGVsdGFBbmdsZSIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsInNpZ24iLCJtYXRoU2lnbiIsImRlbHRhQW5nbGUiLCJNYXRoIiwibWluIiwiYWJzIiwiZ2V0VGFuZ2VudENpcmNsZSIsIl9yZWYiLCJjeCIsImN5IiwicmFkaXVzIiwiYW5nbGUiLCJpc0V4dGVybmFsIiwiY29ybmVyUmFkaXVzIiwiY29ybmVySXNFeHRlcm5hbCIsImNlbnRlclJhZGl1cyIsInRoZXRhIiwiYXNpbiIsIlJBRElBTiIsImNlbnRlckFuZ2xlIiwiY2VudGVyIiwicG9sYXJUb0NhcnRlc2lhbiIsImNpcmNsZVRhbmdlbmN5IiwibGluZVRhbmdlbmN5QW5nbGUiLCJsaW5lVGFuZ2VuY3kiLCJjb3MiLCJnZXRTZWN0b3JQYXRoIiwiX3JlZjIiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwidGVtcEVuZEFuZ2xlIiwib3V0ZXJTdGFydFBvaW50Iiwib3V0ZXJFbmRQb2ludCIsInBhdGgiLCJjb25jYXQiLCJ4IiwieSIsImlubmVyU3RhcnRQb2ludCIsImlubmVyRW5kUG9pbnQiLCJnZXRTZWN0b3JXaXRoQ29ybmVyIiwiX3JlZjMiLCJmb3JjZUNvcm5lclJhZGl1cyIsIl9nZXRUYW5nZW50Q2lyY2xlIiwic29jdCIsInNvbHQiLCJzb3QiLCJfZ2V0VGFuZ2VudENpcmNsZTIiLCJlb2N0IiwiZW9sdCIsImVvdCIsIm91dGVyQXJjQW5nbGUiLCJfZ2V0VGFuZ2VudENpcmNsZTMiLCJzaWN0Iiwic2lsdCIsInNpdCIsIl9nZXRUYW5nZW50Q2lyY2xlNCIsImVpY3QiLCJlaWx0IiwiZWl0IiwiaW5uZXJBcmNBbmdsZSIsImRlZmF1bHRQcm9wcyIsInNlY3RvclByb3BzIiwicHJvcHMiLCJjbGFzc05hbWUiLCJsYXllckNsYXNzIiwiZGVsdGFSYWRpdXMiLCJjciIsImdldFBlcmNlbnRWYWx1ZSIsImNyZWF0ZUVsZW1lbnQiLCJmaWx0ZXJQcm9wcyIsImQiLCJyb2xlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/shape/Sector.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/shape/Symbols.js":
/*!****************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Symbols.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Symbols = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _upperFirst = _interopRequireDefault(__webpack_require__(/*! lodash/upperFirst */ \"lodash/upperFirst\"));\nvar _d3Shape = __webpack_require__(/*! victory-vendor/d3-shape */ \"victory-vendor/d3-shape\");\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _excluded = [\n    \"type\",\n    \"size\",\n    \"sizeType\"\n];\n/**\n * @fileOverview Curve\n */ function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nvar symbolFactories = {\n    symbolCircle: _d3Shape.symbolCircle,\n    symbolCross: _d3Shape.symbolCross,\n    symbolDiamond: _d3Shape.symbolDiamond,\n    symbolSquare: _d3Shape.symbolSquare,\n    symbolStar: _d3Shape.symbolStar,\n    symbolTriangle: _d3Shape.symbolTriangle,\n    symbolWye: _d3Shape.symbolWye\n};\nvar RADIAN = Math.PI / 180;\nvar getSymbolFactory = function getSymbolFactory(type) {\n    var name = \"symbol\".concat((0, _upperFirst[\"default\"])(type));\n    return symbolFactories[name] || _d3Shape.symbolCircle;\n};\nvar calculateAreaSize = function calculateAreaSize(size, sizeType, type) {\n    if (sizeType === \"area\") {\n        return size;\n    }\n    switch(type){\n        case \"cross\":\n            return 5 * size * size / 9;\n        case \"diamond\":\n            return 0.5 * size * size / Math.sqrt(3);\n        case \"square\":\n            return size * size;\n        case \"star\":\n            {\n                var angle = 18 * RADIAN;\n                return 1.25 * size * size * (Math.tan(angle) - Math.tan(angle * 2) * Math.pow(Math.tan(angle), 2));\n            }\n        case \"triangle\":\n            return Math.sqrt(3) * size * size / 4;\n        case \"wye\":\n            return (21 - 10 * Math.sqrt(3)) * size * size / 8;\n        default:\n            return Math.PI * size * size / 4;\n    }\n};\nvar registerSymbol = function registerSymbol(key, factory) {\n    symbolFactories[\"symbol\".concat((0, _upperFirst[\"default\"])(key))] = factory;\n};\nvar Symbols = exports.Symbols = function Symbols(_ref) {\n    var _ref$type = _ref.type, type = _ref$type === void 0 ? \"circle\" : _ref$type, _ref$size = _ref.size, size = _ref$size === void 0 ? 64 : _ref$size, _ref$sizeType = _ref.sizeType, sizeType = _ref$sizeType === void 0 ? \"area\" : _ref$sizeType, rest = _objectWithoutProperties(_ref, _excluded);\n    var props = _objectSpread(_objectSpread({}, rest), {}, {\n        type: type,\n        size: size,\n        sizeType: sizeType\n    });\n    /**\n   * Calculate the path of curve\n   * @return {String} path\n   */ var getPath = function getPath() {\n        var symbolFactory = getSymbolFactory(type);\n        var symbol = (0, _d3Shape.symbol)().type(symbolFactory).size(calculateAreaSize(size, sizeType, type));\n        return symbol();\n    };\n    var className = props.className, cx = props.cx, cy = props.cy;\n    var filteredProps = (0, _ReactUtils.filterProps)(props, true);\n    if (cx === +cx && cy === +cy && size === +size) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, filteredProps, {\n            className: (0, _clsx[\"default\"])(\"recharts-symbols\", className),\n            transform: \"translate(\".concat(cx, \", \").concat(cy, \")\"),\n            d: getPath()\n        }));\n    }\n    return null;\n};\nSymbols.registerSymbol = registerSymbol;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3NoYXBlL1N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1RLLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxlQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJRyxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ25ELElBQUlDLGNBQWNGLHVCQUF1QkMsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlFLFdBQVdGLG1CQUFPQSxDQUFDLHdEQUF5QjtBQUNoRCxJQUFJRyxRQUFRSix1QkFBdUJDLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2pELElBQUlJLGNBQWNKLG1CQUFPQSxDQUFDLDBFQUFvQjtBQUM5QyxJQUFJSyxZQUFZO0lBQUM7SUFBUTtJQUFRO0NBQVc7QUFDNUM7O0NBRUMsR0FDRCxTQUFTTix1QkFBdUJPLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0U7SUFBYUEsV0FBV2YsT0FBT2dCLE1BQU0sR0FBR2hCLE9BQU9nQixNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUFFLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFB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QWxGLFFBQVEwRSxjQUFjLEdBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi9zaGFwZS9TeW1ib2xzLmpzP2FlMTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlN5bWJvbHMgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF91cHBlckZpcnN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3VwcGVyRmlyc3RcIikpO1xudmFyIF9kM1NoYXBlID0gcmVxdWlyZShcInZpY3RvcnktdmVuZG9yL2QzLXNoYXBlXCIpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX1JlYWN0VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbC9SZWFjdFV0aWxzXCIpO1xudmFyIF9leGNsdWRlZCA9IFtcInR5cGVcIiwgXCJzaXplXCIsIFwic2l6ZVR5cGVcIl07XG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgQ3VydmVcbiAqL1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIHN5bWJvbEZhY3RvcmllcyA9IHtcbiAgc3ltYm9sQ2lyY2xlOiBfZDNTaGFwZS5zeW1ib2xDaXJjbGUsXG4gIHN5bWJvbENyb3NzOiBfZDNTaGFwZS5zeW1ib2xDcm9zcyxcbiAgc3ltYm9sRGlhbW9uZDogX2QzU2hhcGUuc3ltYm9sRGlhbW9uZCxcbiAgc3ltYm9sU3F1YXJlOiBfZDNTaGFwZS5zeW1ib2xTcXVhcmUsXG4gIHN5bWJvbFN0YXI6IF9kM1NoYXBlLnN5bWJvbFN0YXIsXG4gIHN5bWJvbFRyaWFuZ2xlOiBfZDNTaGFwZS5zeW1ib2xUcmlhbmdsZSxcbiAgc3ltYm9sV3llOiBfZDNTaGFwZS5zeW1ib2xXeWVcbn07XG52YXIgUkFESUFOID0gTWF0aC5QSSAvIDE4MDtcbnZhciBnZXRTeW1ib2xGYWN0b3J5ID0gZnVuY3Rpb24gZ2V0U3ltYm9sRmFjdG9yeSh0eXBlKSB7XG4gIHZhciBuYW1lID0gXCJzeW1ib2xcIi5jb25jYXQoKDAsIF91cHBlckZpcnN0W1wiZGVmYXVsdFwiXSkodHlwZSkpO1xuICByZXR1cm4gc3ltYm9sRmFjdG9yaWVzW25hbWVdIHx8IF9kM1NoYXBlLnN5bWJvbENpcmNsZTtcbn07XG52YXIgY2FsY3VsYXRlQXJlYVNpemUgPSBmdW5jdGlvbiBjYWxjdWxhdGVBcmVhU2l6ZShzaXplLCBzaXplVHlwZSwgdHlwZSkge1xuICBpZiAoc2l6ZVR5cGUgPT09ICdhcmVhJykge1xuICAgIHJldHVybiBzaXplO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Nyb3NzJzpcbiAgICAgIHJldHVybiA1ICogc2l6ZSAqIHNpemUgLyA5O1xuICAgIGNhc2UgJ2RpYW1vbmQnOlxuICAgICAgcmV0dXJuIDAuNSAqIHNpemUgKiBzaXplIC8gTWF0aC5zcXJ0KDMpO1xuICAgIGNhc2UgJ3NxdWFyZSc6XG4gICAgICByZXR1cm4gc2l6ZSAqIHNpemU7XG4gICAgY2FzZSAnc3Rhcic6XG4gICAgICB7XG4gICAgICAgIHZhciBhbmdsZSA9IDE4ICogUkFESUFOO1xuICAgICAgICByZXR1cm4gMS4yNSAqIHNpemUgKiBzaXplICogKE1hdGgudGFuKGFuZ2xlKSAtIE1hdGgudGFuKGFuZ2xlICogMikgKiBNYXRoLnBvdyhNYXRoLnRhbihhbmdsZSksIDIpKTtcbiAgICAgIH1cbiAgICBjYXNlICd0cmlhbmdsZSc6XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KDMpICogc2l6ZSAqIHNpemUgLyA0O1xuICAgIGNhc2UgJ3d5ZSc6XG4gICAgICByZXR1cm4gKDIxIC0gMTAgKiBNYXRoLnNxcnQoMykpICogc2l6ZSAqIHNpemUgLyA4O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gTWF0aC5QSSAqIHNpemUgKiBzaXplIC8gNDtcbiAgfVxufTtcbnZhciByZWdpc3RlclN5bWJvbCA9IGZ1bmN0aW9uIHJlZ2lzdGVyU3ltYm9sKGtleSwgZmFjdG9yeSkge1xuICBzeW1ib2xGYWN0b3JpZXNbXCJzeW1ib2xcIi5jb25jYXQoKDAsIF91cHBlckZpcnN0W1wiZGVmYXVsdFwiXSkoa2V5KSldID0gZmFjdG9yeTtcbn07XG52YXIgU3ltYm9scyA9IGV4cG9ydHMuU3ltYm9scyA9IGZ1bmN0aW9uIFN5bWJvbHMoX3JlZikge1xuICB2YXIgX3JlZiR0eXBlID0gX3JlZi50eXBlLFxuICAgIHR5cGUgPSBfcmVmJHR5cGUgPT09IHZvaWQgMCA/ICdjaXJjbGUnIDogX3JlZiR0eXBlLFxuICAgIF9yZWYkc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICBzaXplID0gX3JlZiRzaXplID09PSB2b2lkIDAgPyA2NCA6IF9yZWYkc2l6ZSxcbiAgICBfcmVmJHNpemVUeXBlID0gX3JlZi5zaXplVHlwZSxcbiAgICBzaXplVHlwZSA9IF9yZWYkc2l6ZVR5cGUgPT09IHZvaWQgMCA/ICdhcmVhJyA6IF9yZWYkc2l6ZVR5cGUsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuICB2YXIgcHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3QpLCB7fSwge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgc2l6ZTogc2l6ZSxcbiAgICBzaXplVHlwZTogc2l6ZVR5cGVcbiAgfSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgcGF0aCBvZiBjdXJ2ZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHBhdGhcbiAgICovXG4gIHZhciBnZXRQYXRoID0gZnVuY3Rpb24gZ2V0UGF0aCgpIHtcbiAgICB2YXIgc3ltYm9sRmFjdG9yeSA9IGdldFN5bWJvbEZhY3RvcnkodHlwZSk7XG4gICAgdmFyIHN5bWJvbCA9ICgwLCBfZDNTaGFwZS5zeW1ib2wpKCkudHlwZShzeW1ib2xGYWN0b3J5KS5zaXplKGNhbGN1bGF0ZUFyZWFTaXplKHNpemUsIHNpemVUeXBlLCB0eXBlKSk7XG4gICAgcmV0dXJuIHN5bWJvbCgpO1xuICB9O1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgIGN4ID0gcHJvcHMuY3gsXG4gICAgY3kgPSBwcm9wcy5jeTtcbiAgdmFyIGZpbHRlcmVkUHJvcHMgPSAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHByb3BzLCB0cnVlKTtcbiAgaWYgKGN4ID09PSArY3ggJiYgY3kgPT09ICtjeSAmJiBzaXplID09PSArc2l6ZSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCBfZXh0ZW5kcyh7fSwgZmlsdGVyZWRQcm9wcywge1xuICAgICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtc3ltYm9scycsIGNsYXNzTmFtZSksXG4gICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdChjeCwgXCIsIFwiKS5jb25jYXQoY3ksIFwiKVwiKSxcbiAgICAgIGQ6IGdldFBhdGgoKVxuICAgIH0pKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5TeW1ib2xzLnJlZ2lzdGVyU3ltYm9sID0gcmVnaXN0ZXJTeW1ib2w7Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU3ltYm9scyIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3VwcGVyRmlyc3QiLCJfZDNTaGFwZSIsIl9jbHN4IiwiX1JlYWN0VXRpbHMiLCJfZXhjbHVkZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5Iiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInN5bWJvbEZhY3RvcmllcyIsInN5bWJvbENpcmNsZSIsInN5bWJvbENyb3NzIiwic3ltYm9sRGlhbW9uZCIsInN5bWJvbFNxdWFyZSIsInN5bWJvbFN0YXIiLCJzeW1ib2xUcmlhbmdsZSIsInN5bWJvbFd5ZSIsIlJBRElBTiIsIk1hdGgiLCJQSSIsImdldFN5bWJvbEZhY3RvcnkiLCJ0eXBlIiwibmFtZSIsImNvbmNhdCIsImNhbGN1bGF0ZUFyZWFTaXplIiwic2l6ZSIsInNpemVUeXBlIiwic3FydCIsImFuZ2xlIiwidGFuIiwicG93IiwicmVnaXN0ZXJTeW1ib2wiLCJmYWN0b3J5IiwiX3JlZiIsIl9yZWYkdHlwZSIsIl9yZWYkc2l6ZSIsIl9yZWYkc2l6ZVR5cGUiLCJyZXN0IiwicHJvcHMiLCJnZXRQYXRoIiwic3ltYm9sRmFjdG9yeSIsInN5bWJvbCIsImNsYXNzTmFtZSIsImN4IiwiY3kiLCJmaWx0ZXJlZFByb3BzIiwiZmlsdGVyUHJvcHMiLCJjcmVhdGVFbGVtZW50IiwidHJhbnNmb3JtIiwiZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/shape/Symbols.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/shape/Trapezoid.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/shape/Trapezoid.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Trapezoid = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _reactSmooth = _interopRequireDefault(__webpack_require__(/*! react-smooth */ \"react-smooth\"));\nvar _ReactUtils = __webpack_require__(/*! ../util/ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /**\n * @fileOverview Rectangle\n */ \nvar getTrapezoidPath = function getTrapezoidPath(x, y, upperWidth, lowerWidth, height) {\n    var widthGap = upperWidth - lowerWidth;\n    var path;\n    path = \"M \".concat(x, \",\").concat(y);\n    path += \"L \".concat(x + upperWidth, \",\").concat(y);\n    path += \"L \".concat(x + upperWidth - widthGap / 2, \",\").concat(y + height);\n    path += \"L \".concat(x + upperWidth - widthGap / 2 - lowerWidth, \",\").concat(y + height);\n    path += \"L \".concat(x, \",\").concat(y, \" Z\");\n    return path;\n};\nvar defaultProps = {\n    x: 0,\n    y: 0,\n    upperWidth: 0,\n    lowerWidth: 0,\n    height: 0,\n    isUpdateAnimationActive: false,\n    animationBegin: 0,\n    animationDuration: 1500,\n    animationEasing: \"ease\"\n};\nvar Trapezoid = exports.Trapezoid = function Trapezoid(props) {\n    var trapezoidProps = _objectSpread(_objectSpread({}, defaultProps), props);\n    var pathRef = (0, _react.useRef)();\n    var _useState = (0, _react.useState)(-1), _useState2 = _slicedToArray(_useState, 2), totalLength = _useState2[0], setTotalLength = _useState2[1];\n    (0, _react.useEffect)(function() {\n        if (pathRef.current && pathRef.current.getTotalLength) {\n            try {\n                var pathTotalLength = pathRef.current.getTotalLength();\n                if (pathTotalLength) {\n                    setTotalLength(pathTotalLength);\n                }\n            } catch (err) {\n            // calculate total length error\n            }\n        }\n    }, []);\n    var x = trapezoidProps.x, y = trapezoidProps.y, upperWidth = trapezoidProps.upperWidth, lowerWidth = trapezoidProps.lowerWidth, height = trapezoidProps.height, className = trapezoidProps.className;\n    var animationEasing = trapezoidProps.animationEasing, animationDuration = trapezoidProps.animationDuration, animationBegin = trapezoidProps.animationBegin, isUpdateAnimationActive = trapezoidProps.isUpdateAnimationActive;\n    if (x !== +x || y !== +y || upperWidth !== +upperWidth || lowerWidth !== +lowerWidth || height !== +height || upperWidth === 0 && lowerWidth === 0 || height === 0) {\n        return null;\n    }\n    var layerClass = (0, _clsx[\"default\"])(\"recharts-trapezoid\", className);\n    if (!isUpdateAnimationActive) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"g\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(trapezoidProps, true), {\n            className: layerClass,\n            d: getTrapezoidPath(x, y, upperWidth, lowerWidth, height)\n        })));\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n        canBegin: totalLength > 0,\n        from: {\n            upperWidth: 0,\n            lowerWidth: 0,\n            height: height,\n            x: x,\n            y: y\n        },\n        to: {\n            upperWidth: upperWidth,\n            lowerWidth: lowerWidth,\n            height: height,\n            x: x,\n            y: y\n        },\n        duration: animationDuration,\n        animationEasing: animationEasing,\n        isActive: isUpdateAnimationActive\n    }, function(_ref) {\n        var currUpperWidth = _ref.upperWidth, currLowerWidth = _ref.lowerWidth, currHeight = _ref.height, currX = _ref.x, currY = _ref.y;\n        return /*#__PURE__*/ _react[\"default\"].createElement(_reactSmooth[\"default\"], {\n            canBegin: totalLength > 0,\n            from: \"0px \".concat(totalLength === -1 ? 1 : totalLength, \"px\"),\n            to: \"\".concat(totalLength, \"px 0px\"),\n            attributeName: \"strokeDasharray\",\n            begin: animationBegin,\n            duration: animationDuration,\n            easing: animationEasing\n        }, /*#__PURE__*/ _react[\"default\"].createElement(\"path\", _extends({}, (0, _ReactUtils.filterProps)(trapezoidProps, true), {\n            className: layerClass,\n            d: getTrapezoidPath(currX, currY, currUpperWidth, currLowerWidth, currHeight),\n            ref: pathRef\n        })));\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3NoYXBlL1RyYXBlem9pZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixJQUFJRyxTQUFTQyx3QkFBd0JDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3BELElBQUlDLFFBQVFDLHVCQUF1QkYsbUJBQU9BLENBQUMsa0JBQU07QUFDakQsSUFBSUcsZUFBZUQsdUJBQXVCRixtQkFBT0EsQ0FBQyxrQ0FBYztBQUNoRSxJQUFJSSxjQUFjSixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDOUMsU0FBU0UsdUJBQXVCRyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLHlCQUF5QkMsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLE9BQU87SUFBTSxJQUFJQyxJQUFJLElBQUlELFdBQVdFLElBQUksSUFBSUY7SUFBVyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx5QkFBeUJDLENBQUM7UUFBSSxPQUFPQSxJQUFJRyxJQUFJRDtJQUFHLEdBQUdGO0FBQUk7QUFDbk8sU0FBU1Qsd0JBQXdCUyxDQUFDLEVBQUVFLENBQUM7SUFBSSxJQUFJLENBQUNBLEtBQUtGLEtBQUtBLEVBQUVGLFVBQVUsRUFBRSxPQUFPRTtJQUFHLElBQUksU0FBU0EsS0FBSyxZQUFZSSxRQUFRSixNQUFNLGNBQWMsT0FBT0EsR0FBRyxPQUFPO1FBQUUsV0FBV0E7SUFBRTtJQUFHLElBQUlHLElBQUlKLHlCQUF5Qkc7SUFBSSxJQUFJQyxLQUFLQSxFQUFFRSxHQUFHLENBQUNMLElBQUksT0FBT0csRUFBRUcsR0FBRyxDQUFDTjtJQUFJLElBQUlPLElBQUk7UUFBRUMsV0FBVztJQUFLLEdBQUdDLElBQUl4QixPQUFPQyxjQUFjLElBQUlELE9BQU95Qix3QkFB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QyxVQUFVLEVBQ2hDb0MsYUFBYUgsS0FBS2hDLE1BQU0sRUFDeEJvQyxRQUFRSixLQUFLcEMsQ0FBQyxFQUNkeUMsUUFBUUwsS0FBS25DLENBQUM7UUFDaEIsT0FBTyxXQUFXLEdBQUVsRixNQUFNLENBQUMsVUFBVSxDQUFDOEcsYUFBYSxDQUFDekcsWUFBWSxDQUFDLFVBQVUsRUFBRTtZQUMzRTRHLFVBQVVaLGNBQWM7WUFDeEJoRCxNQUFNLE9BQU9tQyxNQUFNLENBQUNhLGdCQUFnQixDQUFDLElBQUksSUFBSUEsYUFBYTtZQUMxRGEsSUFBSSxHQUFHMUIsTUFBTSxDQUFDYSxhQUFhO1lBQzNCc0IsZUFBZTtZQUNmQyxPQUFPakM7WUFDUHdCLFVBQVV2QjtZQUNWaUMsUUFBUWhDO1FBQ1YsR0FBRyxXQUFXLEdBQUU3RixNQUFNLENBQUMsVUFBVSxDQUFDOEcsYUFBYSxDQUFDLFFBQVEvRSxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUd6QixZQUFZeUcsV0FBVyxFQUFFaEIsZ0JBQWdCLE9BQU87WUFDdkhhLFdBQVdDO1lBQ1hHLEdBQUdoQyxpQkFBaUJ5QyxPQUFPQyxPQUFPSixnQkFBZ0JDLGdCQUFnQkM7WUFDbEVNLEtBQUs5QjtRQUNQO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvc2hhcGUvVHJhcGV6b2lkLmpzPzRjOWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlRyYXBlem9pZCA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX3JlYWN0U21vb3RoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3Qtc21vb3RoXCIpKTtcbnZhciBfUmVhY3RVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsL1JlYWN0VXRpbHNcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qKlxuICogQGZpbGVPdmVydmlldyBSZWN0YW5nbGVcbiAqL1xudmFyIGdldFRyYXBlem9pZFBhdGggPSBmdW5jdGlvbiBnZXRUcmFwZXpvaWRQYXRoKHgsIHksIHVwcGVyV2lkdGgsIGxvd2VyV2lkdGgsIGhlaWdodCkge1xuICB2YXIgd2lkdGhHYXAgPSB1cHBlcldpZHRoIC0gbG93ZXJXaWR0aDtcbiAgdmFyIHBhdGg7XG4gIHBhdGggPSBcIk0gXCIuY29uY2F0KHgsIFwiLFwiKS5jb25jYXQoeSk7XG4gIHBhdGggKz0gXCJMIFwiLmNvbmNhdCh4ICsgdXBwZXJXaWR0aCwgXCIsXCIpLmNvbmNhdCh5KTtcbiAgcGF0aCArPSBcIkwgXCIuY29uY2F0KHggKyB1cHBlcldpZHRoIC0gd2lkdGhHYXAgLyAyLCBcIixcIikuY29uY2F0KHkgKyBoZWlnaHQpO1xuICBwYXRoICs9IFwiTCBcIi5jb25jYXQoeCArIHVwcGVyV2lkdGggLSB3aWR0aEdhcCAvIDIgLSBsb3dlcldpZHRoLCBcIixcIikuY29uY2F0KHkgKyBoZWlnaHQpO1xuICBwYXRoICs9IFwiTCBcIi5jb25jYXQoeCwgXCIsXCIpLmNvbmNhdCh5LCBcIiBaXCIpO1xuICByZXR1cm4gcGF0aDtcbn07XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICB1cHBlcldpZHRoOiAwLFxuICBsb3dlcldpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIGlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlOiBmYWxzZSxcbiAgYW5pbWF0aW9uQmVnaW46IDAsXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiAxNTAwLFxuICBhbmltYXRpb25FYXNpbmc6ICdlYXNlJ1xufTtcbnZhciBUcmFwZXpvaWQgPSBleHBvcnRzLlRyYXBlem9pZCA9IGZ1bmN0aW9uIFRyYXBlem9pZChwcm9wcykge1xuICB2YXIgdHJhcGV6b2lkUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRQcm9wcyksIHByb3BzKTtcbiAgdmFyIHBhdGhSZWYgPSAoMCwgX3JlYWN0LnVzZVJlZikoKTtcbiAgdmFyIF91c2VTdGF0ZSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKC0xKSxcbiAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICB0b3RhbExlbmd0aCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgc2V0VG90YWxMZW5ndGggPSBfdXNlU3RhdGUyWzFdO1xuICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgIGlmIChwYXRoUmVmLmN1cnJlbnQgJiYgcGF0aFJlZi5jdXJyZW50LmdldFRvdGFsTGVuZ3RoKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcGF0aFRvdGFsTGVuZ3RoID0gcGF0aFJlZi5jdXJyZW50LmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICAgIGlmIChwYXRoVG90YWxMZW5ndGgpIHtcbiAgICAgICAgICBzZXRUb3RhbExlbmd0aChwYXRoVG90YWxMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRvdGFsIGxlbmd0aCBlcnJvclxuICAgICAgfVxuICAgIH1cbiAgfSwgW10pO1xuICB2YXIgeCA9IHRyYXBlem9pZFByb3BzLngsXG4gICAgeSA9IHRyYXBlem9pZFByb3BzLnksXG4gICAgdXBwZXJXaWR0aCA9IHRyYXBlem9pZFByb3BzLnVwcGVyV2lkdGgsXG4gICAgbG93ZXJXaWR0aCA9IHRyYXBlem9pZFByb3BzLmxvd2VyV2lkdGgsXG4gICAgaGVpZ2h0ID0gdHJhcGV6b2lkUHJvcHMuaGVpZ2h0LFxuICAgIGNsYXNzTmFtZSA9IHRyYXBlem9pZFByb3BzLmNsYXNzTmFtZTtcbiAgdmFyIGFuaW1hdGlvbkVhc2luZyA9IHRyYXBlem9pZFByb3BzLmFuaW1hdGlvbkVhc2luZyxcbiAgICBhbmltYXRpb25EdXJhdGlvbiA9IHRyYXBlem9pZFByb3BzLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgIGFuaW1hdGlvbkJlZ2luID0gdHJhcGV6b2lkUHJvcHMuYW5pbWF0aW9uQmVnaW4sXG4gICAgaXNVcGRhdGVBbmltYXRpb25BY3RpdmUgPSB0cmFwZXpvaWRQcm9wcy5pc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZTtcbiAgaWYgKHggIT09ICt4IHx8IHkgIT09ICt5IHx8IHVwcGVyV2lkdGggIT09ICt1cHBlcldpZHRoIHx8IGxvd2VyV2lkdGggIT09ICtsb3dlcldpZHRoIHx8IGhlaWdodCAhPT0gK2hlaWdodCB8fCB1cHBlcldpZHRoID09PSAwICYmIGxvd2VyV2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGxheWVyQ2xhc3MgPSAoMCwgX2Nsc3hbXCJkZWZhdWx0XCJdKSgncmVjaGFydHMtdHJhcGV6b2lkJywgY2xhc3NOYW1lKTtcbiAgaWYgKCFpc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZ1wiLCBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCBfZXh0ZW5kcyh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKSh0cmFwZXpvaWRQcm9wcywgdHJ1ZSksIHtcbiAgICAgIGNsYXNzTmFtZTogbGF5ZXJDbGFzcyxcbiAgICAgIGQ6IGdldFRyYXBlem9pZFBhdGgoeCwgeSwgdXBwZXJXaWR0aCwgbG93ZXJXaWR0aCwgaGVpZ2h0KVxuICAgIH0pKSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JlYWN0U21vb3RoW1wiZGVmYXVsdFwiXSwge1xuICAgIGNhbkJlZ2luOiB0b3RhbExlbmd0aCA+IDAsXG4gICAgZnJvbToge1xuICAgICAgdXBwZXJXaWR0aDogMCxcbiAgICAgIGxvd2VyV2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfSxcbiAgICB0bzoge1xuICAgICAgdXBwZXJXaWR0aDogdXBwZXJXaWR0aCxcbiAgICAgIGxvd2VyV2lkdGg6IGxvd2VyV2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfSxcbiAgICBkdXJhdGlvbjogYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgYW5pbWF0aW9uRWFzaW5nOiBhbmltYXRpb25FYXNpbmcsXG4gICAgaXNBY3RpdmU6IGlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlXG4gIH0sIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGN1cnJVcHBlcldpZHRoID0gX3JlZi51cHBlcldpZHRoLFxuICAgICAgY3Vyckxvd2VyV2lkdGggPSBfcmVmLmxvd2VyV2lkdGgsXG4gICAgICBjdXJySGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICBjdXJyWCA9IF9yZWYueCxcbiAgICAgIGN1cnJZID0gX3JlZi55O1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9yZWFjdFNtb290aFtcImRlZmF1bHRcIl0sIHtcbiAgICAgIGNhbkJlZ2luOiB0b3RhbExlbmd0aCA+IDAsXG4gICAgICBmcm9tOiBcIjBweCBcIi5jb25jYXQodG90YWxMZW5ndGggPT09IC0xID8gMSA6IHRvdGFsTGVuZ3RoLCBcInB4XCIpLFxuICAgICAgdG86IFwiXCIuY29uY2F0KHRvdGFsTGVuZ3RoLCBcInB4IDBweFwiKSxcbiAgICAgIGF0dHJpYnV0ZU5hbWU6IFwic3Ryb2tlRGFzaGFycmF5XCIsXG4gICAgICBiZWdpbjogYW5pbWF0aW9uQmVnaW4sXG4gICAgICBkdXJhdGlvbjogYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICBlYXNpbmc6IGFuaW1hdGlvbkVhc2luZ1xuICAgIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIF9leHRlbmRzKHt9LCAoMCwgX1JlYWN0VXRpbHMuZmlsdGVyUHJvcHMpKHRyYXBlem9pZFByb3BzLCB0cnVlKSwge1xuICAgICAgY2xhc3NOYW1lOiBsYXllckNsYXNzLFxuICAgICAgZDogZ2V0VHJhcGV6b2lkUGF0aChjdXJyWCwgY3VyclksIGN1cnJVcHBlcldpZHRoLCBjdXJyTG93ZXJXaWR0aCwgY3VyckhlaWdodCksXG4gICAgICByZWY6IHBhdGhSZWZcbiAgICB9KSkpO1xuICB9KTtcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVHJhcGV6b2lkIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX2Nsc3giLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX3JlYWN0U21vb3RoIiwiX1JlYWN0VXRpbHMiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJhcHBseSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIlR5cGVFcnJvciIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibGVuIiwiYXJyMiIsImwiLCJmIiwibmV4dCIsImRvbmUiLCJwdXNoIiwiaXNBcnJheSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJnZXRUcmFwZXpvaWRQYXRoIiwieCIsInkiLCJ1cHBlcldpZHRoIiwibG93ZXJXaWR0aCIsImhlaWdodCIsIndpZHRoR2FwIiwicGF0aCIsImNvbmNhdCIsImRlZmF1bHRQcm9wcyIsImlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlIiwiYW5pbWF0aW9uQmVnaW4iLCJhbmltYXRpb25EdXJhdGlvbiIsImFuaW1hdGlvbkVhc2luZyIsInByb3BzIiwidHJhcGV6b2lkUHJvcHMiLCJwYXRoUmVmIiwidXNlUmVmIiwiX3VzZVN0YXRlIiwidXNlU3RhdGUiLCJfdXNlU3RhdGUyIiwidG90YWxMZW5ndGgiLCJzZXRUb3RhbExlbmd0aCIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJnZXRUb3RhbExlbmd0aCIsInBhdGhUb3RhbExlbmd0aCIsImVyciIsImNsYXNzTmFtZSIsImxheWVyQ2xhc3MiLCJjcmVhdGVFbGVtZW50IiwiZmlsdGVyUHJvcHMiLCJkIiwiY2FuQmVnaW4iLCJ0byIsImR1cmF0aW9uIiwiaXNBY3RpdmUiLCJfcmVmIiwiY3VyclVwcGVyV2lkdGgiLCJjdXJyTG93ZXJXaWR0aCIsImN1cnJIZWlnaHQiLCJjdXJyWCIsImN1cnJZIiwiYXR0cmlidXRlTmFtZSIsImJlZ2luIiwiZWFzaW5nIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/shape/Trapezoid.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/ActiveShapeUtils.js":
/*!************************************************************!*\
  !*** ./node_modules/recharts/lib/util/ActiveShapeUtils.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Shape = Shape;\nexports.compareFunnel = compareFunnel;\nexports.comparePie = comparePie;\nexports.compareScatter = compareScatter;\nexports.getActiveShapeIndexForTooltip = getActiveShapeIndexForTooltip;\nexports.getPropsFromShapeOption = getPropsFromShapeOption;\nexports.isFunnel = isFunnel;\nexports.isPie = isPie;\nexports.isScatter = isScatter;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _isPlainObject = _interopRequireDefault(__webpack_require__(/*! lodash/isPlainObject */ \"lodash/isPlainObject\"));\nvar _isBoolean = _interopRequireDefault(__webpack_require__(/*! lodash/isBoolean */ \"lodash/isBoolean\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _Rectangle = __webpack_require__(/*! ../shape/Rectangle */ \"./node_modules/recharts/lib/shape/Rectangle.js\");\nvar _Trapezoid = __webpack_require__(/*! ../shape/Trapezoid */ \"./node_modules/recharts/lib/shape/Trapezoid.js\");\nvar _Sector = __webpack_require__(/*! ../shape/Sector */ \"./node_modules/recharts/lib/shape/Sector.js\");\nvar _Layer = __webpack_require__(/*! ../container/Layer */ \"./node_modules/recharts/lib/container/Layer.js\");\nvar _Symbols = __webpack_require__(/*! ../shape/Symbols */ \"./node_modules/recharts/lib/shape/Symbols.js\");\nvar _excluded = [\n    \"option\",\n    \"shapeType\",\n    \"propTransformer\",\n    \"activeClassName\",\n    \"isActive\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n/**\n * This is an abstraction for rendering a user defined prop for a customized shape in several forms.\n *\n * <Shape /> is the root and will handle taking in:\n *  - an object of svg properties\n *  - a boolean\n *  - a render prop(inline function that returns jsx)\n *  - a react element\n *\n * <ShapeSelector /> is a subcomponent of <Shape /> and used to match a component\n * to the value of props.shapeType that is passed to the root.\n *\n */ function defaultPropTransformer(option, props) {\n    return _objectSpread(_objectSpread({}, props), option);\n}\nfunction isSymbolsProps(shapeType, _elementProps) {\n    return shapeType === \"symbols\";\n}\nfunction ShapeSelector(_ref) {\n    var shapeType = _ref.shapeType, elementProps = _ref.elementProps;\n    switch(shapeType){\n        case \"rectangle\":\n            return /*#__PURE__*/ _react[\"default\"].createElement(_Rectangle.Rectangle, elementProps);\n        case \"trapezoid\":\n            return /*#__PURE__*/ _react[\"default\"].createElement(_Trapezoid.Trapezoid, elementProps);\n        case \"sector\":\n            return /*#__PURE__*/ _react[\"default\"].createElement(_Sector.Sector, elementProps);\n        case \"symbols\":\n            if (isSymbolsProps(shapeType, elementProps)) {\n                return /*#__PURE__*/ _react[\"default\"].createElement(_Symbols.Symbols, elementProps);\n            }\n            break;\n        default:\n            return null;\n    }\n}\nfunction getPropsFromShapeOption(option) {\n    if (/*#__PURE__*/ (0, _react.isValidElement)(option)) {\n        return option.props;\n    }\n    return option;\n}\nfunction Shape(_ref2) {\n    var option = _ref2.option, shapeType = _ref2.shapeType, _ref2$propTransformer = _ref2.propTransformer, propTransformer = _ref2$propTransformer === void 0 ? defaultPropTransformer : _ref2$propTransformer, _ref2$activeClassName = _ref2.activeClassName, activeClassName = _ref2$activeClassName === void 0 ? \"recharts-active-shape\" : _ref2$activeClassName, isActive = _ref2.isActive, props = _objectWithoutProperties(_ref2, _excluded);\n    var shape;\n    if (/*#__PURE__*/ (0, _react.isValidElement)(option)) {\n        shape = /*#__PURE__*/ (0, _react.cloneElement)(option, _objectSpread(_objectSpread({}, props), getPropsFromShapeOption(option)));\n    } else if ((0, _isFunction[\"default\"])(option)) {\n        shape = option(props);\n    } else if ((0, _isPlainObject[\"default\"])(option) && !(0, _isBoolean[\"default\"])(option)) {\n        var nextProps = propTransformer(option, props);\n        shape = /*#__PURE__*/ _react[\"default\"].createElement(ShapeSelector, {\n            shapeType: shapeType,\n            elementProps: nextProps\n        });\n    } else {\n        var elementProps = props;\n        shape = /*#__PURE__*/ _react[\"default\"].createElement(ShapeSelector, {\n            shapeType: shapeType,\n            elementProps: elementProps\n        });\n    }\n    if (isActive) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(_Layer.Layer, {\n            className: activeClassName\n        }, shape);\n    }\n    return shape;\n}\n/**\n * This is an abstraction to handle identifying the active index from a tooltip mouse interaction\n */ function isFunnel(graphicalItem, _item) {\n    return _item != null && \"trapezoids\" in graphicalItem.props;\n}\nfunction isPie(graphicalItem, _item) {\n    return _item != null && \"sectors\" in graphicalItem.props;\n}\nfunction isScatter(graphicalItem, _item) {\n    return _item != null && \"points\" in graphicalItem.props;\n}\nfunction compareFunnel(shapeData, activeTooltipItem) {\n    var _activeTooltipItem$la, _activeTooltipItem$la2;\n    var xMatches = shapeData.x === (activeTooltipItem === null || activeTooltipItem === void 0 || (_activeTooltipItem$la = activeTooltipItem.labelViewBox) === null || _activeTooltipItem$la === void 0 ? void 0 : _activeTooltipItem$la.x) || shapeData.x === activeTooltipItem.x;\n    var yMatches = shapeData.y === (activeTooltipItem === null || activeTooltipItem === void 0 || (_activeTooltipItem$la2 = activeTooltipItem.labelViewBox) === null || _activeTooltipItem$la2 === void 0 ? void 0 : _activeTooltipItem$la2.y) || shapeData.y === activeTooltipItem.y;\n    return xMatches && yMatches;\n}\nfunction comparePie(shapeData, activeTooltipItem) {\n    var startAngleMatches = shapeData.endAngle === activeTooltipItem.endAngle;\n    var endAngleMatches = shapeData.startAngle === activeTooltipItem.startAngle;\n    return startAngleMatches && endAngleMatches;\n}\nfunction compareScatter(shapeData, activeTooltipItem) {\n    var xMatches = shapeData.x === activeTooltipItem.x;\n    var yMatches = shapeData.y === activeTooltipItem.y;\n    var zMatches = shapeData.z === activeTooltipItem.z;\n    return xMatches && yMatches && zMatches;\n}\nfunction getComparisonFn(graphicalItem, activeItem) {\n    var comparison;\n    if (isFunnel(graphicalItem, activeItem)) {\n        comparison = compareFunnel;\n    } else if (isPie(graphicalItem, activeItem)) {\n        comparison = comparePie;\n    } else if (isScatter(graphicalItem, activeItem)) {\n        comparison = compareScatter;\n    }\n    return comparison;\n}\nfunction getShapeDataKey(graphicalItem, activeItem) {\n    var shapeKey;\n    if (isFunnel(graphicalItem, activeItem)) {\n        shapeKey = \"trapezoids\";\n    } else if (isPie(graphicalItem, activeItem)) {\n        shapeKey = \"sectors\";\n    } else if (isScatter(graphicalItem, activeItem)) {\n        shapeKey = \"points\";\n    }\n    return shapeKey;\n}\nfunction getActiveShapeTooltipPayload(graphicalItem, activeItem) {\n    if (isFunnel(graphicalItem, activeItem)) {\n        var _activeItem$tooltipPa;\n        return (_activeItem$tooltipPa = activeItem.tooltipPayload) === null || _activeItem$tooltipPa === void 0 || (_activeItem$tooltipPa = _activeItem$tooltipPa[0]) === null || _activeItem$tooltipPa === void 0 || (_activeItem$tooltipPa = _activeItem$tooltipPa.payload) === null || _activeItem$tooltipPa === void 0 ? void 0 : _activeItem$tooltipPa.payload;\n    }\n    if (isPie(graphicalItem, activeItem)) {\n        var _activeItem$tooltipPa2;\n        return (_activeItem$tooltipPa2 = activeItem.tooltipPayload) === null || _activeItem$tooltipPa2 === void 0 || (_activeItem$tooltipPa2 = _activeItem$tooltipPa2[0]) === null || _activeItem$tooltipPa2 === void 0 || (_activeItem$tooltipPa2 = _activeItem$tooltipPa2.payload) === null || _activeItem$tooltipPa2 === void 0 ? void 0 : _activeItem$tooltipPa2.payload;\n    }\n    if (isScatter(graphicalItem, activeItem)) {\n        return activeItem.payload;\n    }\n    return {};\n}\n/**\n *\n * @param {GetActiveShapeIndexForTooltip} arg an object of incoming attributes from Tooltip\n * @returns {number}\n *\n * To handle possible duplicates in the data set,\n * match both the data value of the active item to a data value on a graph item,\n * and match the mouse coordinates of the active item to the coordinates of in a particular components shape data.\n * This assumes equal lengths of shape objects to data items.\n */ function getActiveShapeIndexForTooltip(_ref3) {\n    var activeTooltipItem = _ref3.activeTooltipItem, graphicalItem = _ref3.graphicalItem, itemData = _ref3.itemData;\n    var shapeKey = getShapeDataKey(graphicalItem, activeTooltipItem);\n    var tooltipPayload = getActiveShapeTooltipPayload(graphicalItem, activeTooltipItem);\n    var activeItemMatches = itemData.filter(function(datum, dataIndex) {\n        var valuesMatch = (0, _isEqual[\"default\"])(tooltipPayload, datum);\n        var mouseCoordinateMatches = graphicalItem.props[shapeKey].filter(function(shapeData) {\n            var comparison = getComparisonFn(graphicalItem, activeTooltipItem);\n            return comparison(shapeData, activeTooltipItem);\n        });\n        // get the last index in case of multiple matches\n        var indexOfMouseCoordinates = graphicalItem.props[shapeKey].indexOf(mouseCoordinateMatches[mouseCoordinateMatches.length - 1]);\n        var coordinatesMatch = dataIndex === indexOfMouseCoordinates;\n        return valuesMatch && coordinatesMatch;\n    });\n    // get the last index in case of multiple matches\n    var activeIndex = itemData.indexOf(activeItemMatches[activeItemMatches.length - 1]);\n    return activeIndex;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvQWN0aXZlU2hhcGVVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsYUFBYSxHQUFHRTtBQUNoQkYscUJBQXFCLEdBQUdHO0FBQ3hCSCxrQkFBa0IsR0FBR0k7QUFDckJKLHNCQUFzQixHQUFHSztBQUN6QkwscUNBQXFDLEdBQUdNO0FBQ3hDTiwrQkFBK0IsR0FBR087QUFDbENQLGdCQUFnQixHQUFHUTtBQUNuQlIsYUFBYSxHQUFHUztBQUNoQlQsaUJBQWlCLEdBQUdVO0FBQ3BCLElBQUlDLFNBQVNDLHdCQUF3QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDcEQsSUFBSUMsY0FBY0MsdUJBQXVCRixtQkFBT0EsQ0FBQyw0Q0FBbUI7QUFDcEUsSUFBSUcsaUJBQWlCRCx1QkFBdUJGLG1CQUFPQSxDQUFDLGtEQUFzQjtBQUMxRSxJQUFJSSxhQUFhRix1QkFBdUJGLG1CQUFPQSxDQUFDLDBDQUFrQjtBQUNsRSxJQUFJSyxXQUFXSCx1QkFBdUJGLG1CQUFPQSxDQUFDLHNDQUFnQjtBQUM5RCxJQUFJTSxhQUFhTixtQkFBT0EsQ0FBQywwRUFBb0I7QUFDN0MsSUFBSU8sYUFBYVAsbUJBQU9BLENBQUMsMEVBQW9CO0FBQzdDLElBQUlRLFVBQVVSLG1CQUFPQSxDQUFDLG9FQUFpQjtBQUN2QyxJQUFJUyxTQUFTVCxtQkFBT0EsQ0FBQywwRUFBb0I7QUFDekMsSUFBSVUsV0FBV1YsbUJBQU9BLENBQUMsc0VBQWtCO0FBQ3pDLElBQUlXLFlBQVk7SUFBQztJQUFVO0lBQWE7SUFBbUI7SUFBbUI7Q0FBVztBQUN6RixTQUFTVCx1QkFBdUJVLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UseUJBQXlCQyxDQUFDO0lBQUksSUFBSSxjQUFjLE9BQU9DLFNB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SXhCLG9CQUFvQndCLE1BQU14QixpQkFBaUIsRUFDN0NILGdCQUFnQjJCLE1BQU0zQixhQUFhLEVBQ25DNEIsV0FBV0QsTUFBTUMsUUFBUTtJQUMzQixJQUFJUCxXQUFXRCxnQkFBZ0JwQixlQUFlRztJQUM5QyxJQUFJcUIsaUJBQWlCRiw2QkFBNkJ0QixlQUFlRztJQUNqRSxJQUFJMEIsb0JBQW9CRCxTQUFTeEUsTUFBTSxDQUFDLFNBQVUwRSxLQUFLLEVBQUVDLFNBQVM7UUFDaEUsSUFBSUMsY0FBYyxDQUFDLEdBQUd4SCxRQUFRLENBQUMsVUFBVSxFQUFFZ0gsZ0JBQWdCTTtRQUMzRCxJQUFJRyx5QkFBeUJqQyxjQUFjeEIsS0FBSyxDQUFDNkMsU0FBUyxDQUFDakUsTUFBTSxDQUFDLFNBQVU4QyxTQUFTO1lBQ25GLElBQUlpQixhQUFhRixnQkFBZ0JqQixlQUFlRztZQUNoRCxPQUFPZ0IsV0FBV2pCLFdBQVdDO1FBQy9CO1FBRUEsaURBQWlEO1FBQ2pELElBQUkrQiwwQkFBMEJsQyxjQUFjeEIsS0FBSyxDQUFDNkMsU0FBUyxDQUFDckUsT0FBTyxDQUFDaUYsc0JBQXNCLENBQUNBLHVCQUF1QmxGLE1BQU0sR0FBRyxFQUFFO1FBQzdILElBQUlvRixtQkFBbUJKLGNBQWNHO1FBQ3JDLE9BQU9GLGVBQWVHO0lBQ3hCO0lBRUEsaURBQWlEO0lBQ2pELElBQUlDLGNBQWNSLFNBQVM1RSxPQUFPLENBQUM2RSxpQkFBaUIsQ0FBQ0Esa0JBQWtCOUUsTUFBTSxHQUFHLEVBQUU7SUFDbEYsT0FBT3FGO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvQWN0aXZlU2hhcGVVdGlscy5qcz9lZTBkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5TaGFwZSA9IFNoYXBlO1xuZXhwb3J0cy5jb21wYXJlRnVubmVsID0gY29tcGFyZUZ1bm5lbDtcbmV4cG9ydHMuY29tcGFyZVBpZSA9IGNvbXBhcmVQaWU7XG5leHBvcnRzLmNvbXBhcmVTY2F0dGVyID0gY29tcGFyZVNjYXR0ZXI7XG5leHBvcnRzLmdldEFjdGl2ZVNoYXBlSW5kZXhGb3JUb29sdGlwID0gZ2V0QWN0aXZlU2hhcGVJbmRleEZvclRvb2x0aXA7XG5leHBvcnRzLmdldFByb3BzRnJvbVNoYXBlT3B0aW9uID0gZ2V0UHJvcHNGcm9tU2hhcGVPcHRpb247XG5leHBvcnRzLmlzRnVubmVsID0gaXNGdW5uZWw7XG5leHBvcnRzLmlzUGllID0gaXNQaWU7XG5leHBvcnRzLmlzU2NhdHRlciA9IGlzU2NhdHRlcjtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xudmFyIF9pc1BsYWluT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIikpO1xudmFyIF9pc0Jvb2xlYW4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNCb29sZWFuXCIpKTtcbnZhciBfaXNFcXVhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0VxdWFsXCIpKTtcbnZhciBfUmVjdGFuZ2xlID0gcmVxdWlyZShcIi4uL3NoYXBlL1JlY3RhbmdsZVwiKTtcbnZhciBfVHJhcGV6b2lkID0gcmVxdWlyZShcIi4uL3NoYXBlL1RyYXBlem9pZFwiKTtcbnZhciBfU2VjdG9yID0gcmVxdWlyZShcIi4uL3NoYXBlL1NlY3RvclwiKTtcbnZhciBfTGF5ZXIgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0xheWVyXCIpO1xudmFyIF9TeW1ib2xzID0gcmVxdWlyZShcIi4uL3NoYXBlL1N5bWJvbHNcIik7XG52YXIgX2V4Y2x1ZGVkID0gW1wib3B0aW9uXCIsIFwic2hhcGVUeXBlXCIsIFwicHJvcFRyYW5zZm9ybWVyXCIsIFwiYWN0aXZlQ2xhc3NOYW1lXCIsIFwiaXNBY3RpdmVcIl07XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IFwiZGVmYXVsdFwiOiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB1KSkgeyB2YXIgaSA9IGEgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHUpIDogbnVsbDsgaSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHUsIGkpIDogblt1XSA9IGVbdV07IH0gcmV0dXJuIG5bXCJkZWZhdWx0XCJdID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG4vKipcbiAqIFRoaXMgaXMgYW4gYWJzdHJhY3Rpb24gZm9yIHJlbmRlcmluZyBhIHVzZXIgZGVmaW5lZCBwcm9wIGZvciBhIGN1c3RvbWl6ZWQgc2hhcGUgaW4gc2V2ZXJhbCBmb3Jtcy5cbiAqXG4gKiA8U2hhcGUgLz4gaXMgdGhlIHJvb3QgYW5kIHdpbGwgaGFuZGxlIHRha2luZyBpbjpcbiAqICAtIGFuIG9iamVjdCBvZiBzdmcgcHJvcGVydGllc1xuICogIC0gYSBib29sZWFuXG4gKiAgLSBhIHJlbmRlciBwcm9wKGlubGluZSBmdW5jdGlvbiB0aGF0IHJldHVybnMganN4KVxuICogIC0gYSByZWFjdCBlbGVtZW50XG4gKlxuICogPFNoYXBlU2VsZWN0b3IgLz4gaXMgYSBzdWJjb21wb25lbnQgb2YgPFNoYXBlIC8+IGFuZCB1c2VkIHRvIG1hdGNoIGEgY29tcG9uZW50XG4gKiB0byB0aGUgdmFsdWUgb2YgcHJvcHMuc2hhcGVUeXBlIHRoYXQgaXMgcGFzc2VkIHRvIHRoZSByb290LlxuICpcbiAqL1xuXG5mdW5jdGlvbiBkZWZhdWx0UHJvcFRyYW5zZm9ybWVyKG9wdGlvbiwgcHJvcHMpIHtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCBvcHRpb24pO1xufVxuZnVuY3Rpb24gaXNTeW1ib2xzUHJvcHMoc2hhcGVUeXBlLCBfZWxlbWVudFByb3BzKSB7XG4gIHJldHVybiBzaGFwZVR5cGUgPT09ICdzeW1ib2xzJztcbn1cbmZ1bmN0aW9uIFNoYXBlU2VsZWN0b3IoX3JlZikge1xuICB2YXIgc2hhcGVUeXBlID0gX3JlZi5zaGFwZVR5cGUsXG4gICAgZWxlbWVudFByb3BzID0gX3JlZi5lbGVtZW50UHJvcHM7XG4gIHN3aXRjaCAoc2hhcGVUeXBlKSB7XG4gICAgY2FzZSAncmVjdGFuZ2xlJzpcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9SZWN0YW5nbGUuUmVjdGFuZ2xlLCBlbGVtZW50UHJvcHMpO1xuICAgIGNhc2UgJ3RyYXBlem9pZCc6XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfVHJhcGV6b2lkLlRyYXBlem9pZCwgZWxlbWVudFByb3BzKTtcbiAgICBjYXNlICdzZWN0b3InOlxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1NlY3Rvci5TZWN0b3IsIGVsZW1lbnRQcm9wcyk7XG4gICAgY2FzZSAnc3ltYm9scyc6XG4gICAgICBpZiAoaXNTeW1ib2xzUHJvcHMoc2hhcGVUeXBlLCBlbGVtZW50UHJvcHMpKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9TeW1ib2xzLlN5bWJvbHMsIGVsZW1lbnRQcm9wcyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFByb3BzRnJvbVNoYXBlT3B0aW9uKG9wdGlvbikge1xuICBpZiAoIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmlzVmFsaWRFbGVtZW50KShvcHRpb24pKSB7XG4gICAgcmV0dXJuIG9wdGlvbi5wcm9wcztcbiAgfVxuICByZXR1cm4gb3B0aW9uO1xufVxuZnVuY3Rpb24gU2hhcGUoX3JlZjIpIHtcbiAgdmFyIG9wdGlvbiA9IF9yZWYyLm9wdGlvbixcbiAgICBzaGFwZVR5cGUgPSBfcmVmMi5zaGFwZVR5cGUsXG4gICAgX3JlZjIkcHJvcFRyYW5zZm9ybWVyID0gX3JlZjIucHJvcFRyYW5zZm9ybWVyLFxuICAgIHByb3BUcmFuc2Zvcm1lciA9IF9yZWYyJHByb3BUcmFuc2Zvcm1lciA9PT0gdm9pZCAwID8gZGVmYXVsdFByb3BUcmFuc2Zvcm1lciA6IF9yZWYyJHByb3BUcmFuc2Zvcm1lcixcbiAgICBfcmVmMiRhY3RpdmVDbGFzc05hbWUgPSBfcmVmMi5hY3RpdmVDbGFzc05hbWUsXG4gICAgYWN0aXZlQ2xhc3NOYW1lID0gX3JlZjIkYWN0aXZlQ2xhc3NOYW1lID09PSB2b2lkIDAgPyAncmVjaGFydHMtYWN0aXZlLXNoYXBlJyA6IF9yZWYyJGFjdGl2ZUNsYXNzTmFtZSxcbiAgICBpc0FjdGl2ZSA9IF9yZWYyLmlzQWN0aXZlLFxuICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBfZXhjbHVkZWQpO1xuICB2YXIgc2hhcGU7XG4gIGlmICggLyojX19QVVJFX18qLygwLCBfcmVhY3QuaXNWYWxpZEVsZW1lbnQpKG9wdGlvbikpIHtcbiAgICBzaGFwZSA9IC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNsb25lRWxlbWVudCkob3B0aW9uLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwgZ2V0UHJvcHNGcm9tU2hhcGVPcHRpb24ob3B0aW9uKSkpO1xuICB9IGVsc2UgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKG9wdGlvbikpIHtcbiAgICBzaGFwZSA9IG9wdGlvbihwcm9wcyk7XG4gIH0gZWxzZSBpZiAoKDAsIF9pc1BsYWluT2JqZWN0W1wiZGVmYXVsdFwiXSkob3B0aW9uKSAmJiAhKDAsIF9pc0Jvb2xlYW5bXCJkZWZhdWx0XCJdKShvcHRpb24pKSB7XG4gICAgdmFyIG5leHRQcm9wcyA9IHByb3BUcmFuc2Zvcm1lcihvcHRpb24sIHByb3BzKTtcbiAgICBzaGFwZSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoU2hhcGVTZWxlY3Rvciwge1xuICAgICAgc2hhcGVUeXBlOiBzaGFwZVR5cGUsXG4gICAgICBlbGVtZW50UHJvcHM6IG5leHRQcm9wc1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBlbGVtZW50UHJvcHMgPSBwcm9wcztcbiAgICBzaGFwZSA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoU2hhcGVTZWxlY3Rvciwge1xuICAgICAgc2hhcGVUeXBlOiBzaGFwZVR5cGUsXG4gICAgICBlbGVtZW50UHJvcHM6IGVsZW1lbnRQcm9wc1xuICAgIH0pO1xuICB9XG4gIGlmIChpc0FjdGl2ZSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9MYXllci5MYXllciwge1xuICAgICAgY2xhc3NOYW1lOiBhY3RpdmVDbGFzc05hbWVcbiAgICB9LCBzaGFwZSk7XG4gIH1cbiAgcmV0dXJuIHNoYXBlO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYW4gYWJzdHJhY3Rpb24gdG8gaGFuZGxlIGlkZW50aWZ5aW5nIHRoZSBhY3RpdmUgaW5kZXggZnJvbSBhIHRvb2x0aXAgbW91c2UgaW50ZXJhY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBpc0Z1bm5lbChncmFwaGljYWxJdGVtLCBfaXRlbSkge1xuICByZXR1cm4gX2l0ZW0gIT0gbnVsbCAmJiAndHJhcGV6b2lkcycgaW4gZ3JhcGhpY2FsSXRlbS5wcm9wcztcbn1cbmZ1bmN0aW9uIGlzUGllKGdyYXBoaWNhbEl0ZW0sIF9pdGVtKSB7XG4gIHJldHVybiBfaXRlbSAhPSBudWxsICYmICdzZWN0b3JzJyBpbiBncmFwaGljYWxJdGVtLnByb3BzO1xufVxuZnVuY3Rpb24gaXNTY2F0dGVyKGdyYXBoaWNhbEl0ZW0sIF9pdGVtKSB7XG4gIHJldHVybiBfaXRlbSAhPSBudWxsICYmICdwb2ludHMnIGluIGdyYXBoaWNhbEl0ZW0ucHJvcHM7XG59XG5mdW5jdGlvbiBjb21wYXJlRnVubmVsKHNoYXBlRGF0YSwgYWN0aXZlVG9vbHRpcEl0ZW0pIHtcbiAgdmFyIF9hY3RpdmVUb29sdGlwSXRlbSRsYSwgX2FjdGl2ZVRvb2x0aXBJdGVtJGxhMjtcbiAgdmFyIHhNYXRjaGVzID0gc2hhcGVEYXRhLnggPT09IChhY3RpdmVUb29sdGlwSXRlbSA9PT0gbnVsbCB8fCBhY3RpdmVUb29sdGlwSXRlbSA9PT0gdm9pZCAwIHx8IChfYWN0aXZlVG9vbHRpcEl0ZW0kbGEgPSBhY3RpdmVUb29sdGlwSXRlbS5sYWJlbFZpZXdCb3gpID09PSBudWxsIHx8IF9hY3RpdmVUb29sdGlwSXRlbSRsYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FjdGl2ZVRvb2x0aXBJdGVtJGxhLngpIHx8IHNoYXBlRGF0YS54ID09PSBhY3RpdmVUb29sdGlwSXRlbS54O1xuICB2YXIgeU1hdGNoZXMgPSBzaGFwZURhdGEueSA9PT0gKGFjdGl2ZVRvb2x0aXBJdGVtID09PSBudWxsIHx8IGFjdGl2ZVRvb2x0aXBJdGVtID09PSB2b2lkIDAgfHwgKF9hY3RpdmVUb29sdGlwSXRlbSRsYTIgPSBhY3RpdmVUb29sdGlwSXRlbS5sYWJlbFZpZXdCb3gpID09PSBudWxsIHx8IF9hY3RpdmVUb29sdGlwSXRlbSRsYTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hY3RpdmVUb29sdGlwSXRlbSRsYTIueSkgfHwgc2hhcGVEYXRhLnkgPT09IGFjdGl2ZVRvb2x0aXBJdGVtLnk7XG4gIHJldHVybiB4TWF0Y2hlcyAmJiB5TWF0Y2hlcztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVQaWUoc2hhcGVEYXRhLCBhY3RpdmVUb29sdGlwSXRlbSkge1xuICB2YXIgc3RhcnRBbmdsZU1hdGNoZXMgPSBzaGFwZURhdGEuZW5kQW5nbGUgPT09IGFjdGl2ZVRvb2x0aXBJdGVtLmVuZEFuZ2xlO1xuICB2YXIgZW5kQW5nbGVNYXRjaGVzID0gc2hhcGVEYXRhLnN0YXJ0QW5nbGUgPT09IGFjdGl2ZVRvb2x0aXBJdGVtLnN0YXJ0QW5nbGU7XG4gIHJldHVybiBzdGFydEFuZ2xlTWF0Y2hlcyAmJiBlbmRBbmdsZU1hdGNoZXM7XG59XG5mdW5jdGlvbiBjb21wYXJlU2NhdHRlcihzaGFwZURhdGEsIGFjdGl2ZVRvb2x0aXBJdGVtKSB7XG4gIHZhciB4TWF0Y2hlcyA9IHNoYXBlRGF0YS54ID09PSBhY3RpdmVUb29sdGlwSXRlbS54O1xuICB2YXIgeU1hdGNoZXMgPSBzaGFwZURhdGEueSA9PT0gYWN0aXZlVG9vbHRpcEl0ZW0ueTtcbiAgdmFyIHpNYXRjaGVzID0gc2hhcGVEYXRhLnogPT09IGFjdGl2ZVRvb2x0aXBJdGVtLno7XG4gIHJldHVybiB4TWF0Y2hlcyAmJiB5TWF0Y2hlcyAmJiB6TWF0Y2hlcztcbn1cbmZ1bmN0aW9uIGdldENvbXBhcmlzb25GbihncmFwaGljYWxJdGVtLCBhY3RpdmVJdGVtKSB7XG4gIHZhciBjb21wYXJpc29uO1xuICBpZiAoaXNGdW5uZWwoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkpIHtcbiAgICBjb21wYXJpc29uID0gY29tcGFyZUZ1bm5lbDtcbiAgfSBlbHNlIGlmIChpc1BpZShncmFwaGljYWxJdGVtLCBhY3RpdmVJdGVtKSkge1xuICAgIGNvbXBhcmlzb24gPSBjb21wYXJlUGllO1xuICB9IGVsc2UgaWYgKGlzU2NhdHRlcihncmFwaGljYWxJdGVtLCBhY3RpdmVJdGVtKSkge1xuICAgIGNvbXBhcmlzb24gPSBjb21wYXJlU2NhdHRlcjtcbiAgfVxuICByZXR1cm4gY29tcGFyaXNvbjtcbn1cbmZ1bmN0aW9uIGdldFNoYXBlRGF0YUtleShncmFwaGljYWxJdGVtLCBhY3RpdmVJdGVtKSB7XG4gIHZhciBzaGFwZUtleTtcbiAgaWYgKGlzRnVubmVsKGdyYXBoaWNhbEl0ZW0sIGFjdGl2ZUl0ZW0pKSB7XG4gICAgc2hhcGVLZXkgPSAndHJhcGV6b2lkcyc7XG4gIH0gZWxzZSBpZiAoaXNQaWUoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkpIHtcbiAgICBzaGFwZUtleSA9ICdzZWN0b3JzJztcbiAgfSBlbHNlIGlmIChpc1NjYXR0ZXIoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkpIHtcbiAgICBzaGFwZUtleSA9ICdwb2ludHMnO1xuICB9XG4gIHJldHVybiBzaGFwZUtleTtcbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZVNoYXBlVG9vbHRpcFBheWxvYWQoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkge1xuICBpZiAoaXNGdW5uZWwoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkpIHtcbiAgICB2YXIgX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhO1xuICAgIHJldHVybiAoX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhID0gYWN0aXZlSXRlbS50b29sdGlwUGF5bG9hZCkgPT09IG51bGwgfHwgX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhID09PSB2b2lkIDAgfHwgKF9hY3RpdmVJdGVtJHRvb2x0aXBQYSA9IF9hY3RpdmVJdGVtJHRvb2x0aXBQYVswXSkgPT09IG51bGwgfHwgX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhID09PSB2b2lkIDAgfHwgKF9hY3RpdmVJdGVtJHRvb2x0aXBQYSA9IF9hY3RpdmVJdGVtJHRvb2x0aXBQYS5wYXlsb2FkKSA9PT0gbnVsbCB8fCBfYWN0aXZlSXRlbSR0b29sdGlwUGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hY3RpdmVJdGVtJHRvb2x0aXBQYS5wYXlsb2FkO1xuICB9XG4gIGlmIChpc1BpZShncmFwaGljYWxJdGVtLCBhY3RpdmVJdGVtKSkge1xuICAgIHZhciBfYWN0aXZlSXRlbSR0b29sdGlwUGEyO1xuICAgIHJldHVybiAoX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhMiA9IGFjdGl2ZUl0ZW0udG9vbHRpcFBheWxvYWQpID09PSBudWxsIHx8IF9hY3RpdmVJdGVtJHRvb2x0aXBQYTIgPT09IHZvaWQgMCB8fCAoX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhMiA9IF9hY3RpdmVJdGVtJHRvb2x0aXBQYTJbMF0pID09PSBudWxsIHx8IF9hY3RpdmVJdGVtJHRvb2x0aXBQYTIgPT09IHZvaWQgMCB8fCAoX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhMiA9IF9hY3RpdmVJdGVtJHRvb2x0aXBQYTIucGF5bG9hZCkgPT09IG51bGwgfHwgX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhMi5wYXlsb2FkO1xuICB9XG4gIGlmIChpc1NjYXR0ZXIoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkpIHtcbiAgICByZXR1cm4gYWN0aXZlSXRlbS5wYXlsb2FkO1xuICB9XG4gIHJldHVybiB7fTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB7R2V0QWN0aXZlU2hhcGVJbmRleEZvclRvb2x0aXB9IGFyZyBhbiBvYmplY3Qgb2YgaW5jb21pbmcgYXR0cmlidXRlcyBmcm9tIFRvb2x0aXBcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKlxuICogVG8gaGFuZGxlIHBvc3NpYmxlIGR1cGxpY2F0ZXMgaW4gdGhlIGRhdGEgc2V0LFxuICogbWF0Y2ggYm90aCB0aGUgZGF0YSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGl0ZW0gdG8gYSBkYXRhIHZhbHVlIG9uIGEgZ3JhcGggaXRlbSxcbiAqIGFuZCBtYXRjaCB0aGUgbW91c2UgY29vcmRpbmF0ZXMgb2YgdGhlIGFjdGl2ZSBpdGVtIHRvIHRoZSBjb29yZGluYXRlcyBvZiBpbiBhIHBhcnRpY3VsYXIgY29tcG9uZW50cyBzaGFwZSBkYXRhLlxuICogVGhpcyBhc3N1bWVzIGVxdWFsIGxlbmd0aHMgb2Ygc2hhcGUgb2JqZWN0cyB0byBkYXRhIGl0ZW1zLlxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVTaGFwZUluZGV4Rm9yVG9vbHRpcChfcmVmMykge1xuICB2YXIgYWN0aXZlVG9vbHRpcEl0ZW0gPSBfcmVmMy5hY3RpdmVUb29sdGlwSXRlbSxcbiAgICBncmFwaGljYWxJdGVtID0gX3JlZjMuZ3JhcGhpY2FsSXRlbSxcbiAgICBpdGVtRGF0YSA9IF9yZWYzLml0ZW1EYXRhO1xuICB2YXIgc2hhcGVLZXkgPSBnZXRTaGFwZURhdGFLZXkoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlVG9vbHRpcEl0ZW0pO1xuICB2YXIgdG9vbHRpcFBheWxvYWQgPSBnZXRBY3RpdmVTaGFwZVRvb2x0aXBQYXlsb2FkKGdyYXBoaWNhbEl0ZW0sIGFjdGl2ZVRvb2x0aXBJdGVtKTtcbiAgdmFyIGFjdGl2ZUl0ZW1NYXRjaGVzID0gaXRlbURhdGEuZmlsdGVyKGZ1bmN0aW9uIChkYXR1bSwgZGF0YUluZGV4KSB7XG4gICAgdmFyIHZhbHVlc01hdGNoID0gKDAsIF9pc0VxdWFsW1wiZGVmYXVsdFwiXSkodG9vbHRpcFBheWxvYWQsIGRhdHVtKTtcbiAgICB2YXIgbW91c2VDb29yZGluYXRlTWF0Y2hlcyA9IGdyYXBoaWNhbEl0ZW0ucHJvcHNbc2hhcGVLZXldLmZpbHRlcihmdW5jdGlvbiAoc2hhcGVEYXRhKSB7XG4gICAgICB2YXIgY29tcGFyaXNvbiA9IGdldENvbXBhcmlzb25GbihncmFwaGljYWxJdGVtLCBhY3RpdmVUb29sdGlwSXRlbSk7XG4gICAgICByZXR1cm4gY29tcGFyaXNvbihzaGFwZURhdGEsIGFjdGl2ZVRvb2x0aXBJdGVtKTtcbiAgICB9KTtcblxuICAgIC8vIGdldCB0aGUgbGFzdCBpbmRleCBpbiBjYXNlIG9mIG11bHRpcGxlIG1hdGNoZXNcbiAgICB2YXIgaW5kZXhPZk1vdXNlQ29vcmRpbmF0ZXMgPSBncmFwaGljYWxJdGVtLnByb3BzW3NoYXBlS2V5XS5pbmRleE9mKG1vdXNlQ29vcmRpbmF0ZU1hdGNoZXNbbW91c2VDb29yZGluYXRlTWF0Y2hlcy5sZW5ndGggLSAxXSk7XG4gICAgdmFyIGNvb3JkaW5hdGVzTWF0Y2ggPSBkYXRhSW5kZXggPT09IGluZGV4T2ZNb3VzZUNvb3JkaW5hdGVzO1xuICAgIHJldHVybiB2YWx1ZXNNYXRjaCAmJiBjb29yZGluYXRlc01hdGNoO1xuICB9KTtcblxuICAvLyBnZXQgdGhlIGxhc3QgaW5kZXggaW4gY2FzZSBvZiBtdWx0aXBsZSBtYXRjaGVzXG4gIHZhciBhY3RpdmVJbmRleCA9IGl0ZW1EYXRhLmluZGV4T2YoYWN0aXZlSXRlbU1hdGNoZXNbYWN0aXZlSXRlbU1hdGNoZXMubGVuZ3RoIC0gMV0pO1xuICByZXR1cm4gYWN0aXZlSW5kZXg7XG59Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU2hhcGUiLCJjb21wYXJlRnVubmVsIiwiY29tcGFyZVBpZSIsImNvbXBhcmVTY2F0dGVyIiwiZ2V0QWN0aXZlU2hhcGVJbmRleEZvclRvb2x0aXAiLCJnZXRQcm9wc0Zyb21TaGFwZU9wdGlvbiIsImlzRnVubmVsIiwiaXNQaWUiLCJpc1NjYXR0ZXIiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfaXNGdW5jdGlvbiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfaXNQbGFpbk9iamVjdCIsIl9pc0Jvb2xlYW4iLCJfaXNFcXVhbCIsIl9SZWN0YW5nbGUiLCJfVHJhcGV6b2lkIiwiX1NlY3RvciIsIl9MYXllciIsIl9TeW1ib2xzIiwiX2V4Y2x1ZGVkIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfdHlwZW9mIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaSIsInNldCIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwic291cmNlIiwiZXhjbHVkZWQiLCJ0YXJnZXQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImtleSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJsZW5ndGgiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJvd25LZXlzIiwia2V5cyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiZGVmYXVsdFByb3BUcmFuc2Zvcm1lciIsIm9wdGlvbiIsInByb3BzIiwiaXNTeW1ib2xzUHJvcHMiLCJzaGFwZVR5cGUiLCJfZWxlbWVudFByb3BzIiwiU2hhcGVTZWxlY3RvciIsIl9yZWYiLCJlbGVtZW50UHJvcHMiLCJjcmVhdGVFbGVtZW50IiwiUmVjdGFuZ2xlIiwiVHJhcGV6b2lkIiwiU2VjdG9yIiwiU3ltYm9scyIsImlzVmFsaWRFbGVtZW50IiwiX3JlZjIiLCJfcmVmMiRwcm9wVHJhbnNmb3JtZXIiLCJwcm9wVHJhbnNmb3JtZXIiLCJfcmVmMiRhY3RpdmVDbGFzc05hbWUiLCJhY3RpdmVDbGFzc05hbWUiLCJpc0FjdGl2ZSIsInNoYXBlIiwiY2xvbmVFbGVtZW50IiwibmV4dFByb3BzIiwiTGF5ZXIiLCJjbGFzc05hbWUiLCJncmFwaGljYWxJdGVtIiwiX2l0ZW0iLCJzaGFwZURhdGEiLCJhY3RpdmVUb29sdGlwSXRlbSIsIl9hY3RpdmVUb29sdGlwSXRlbSRsYSIsIl9hY3RpdmVUb29sdGlwSXRlbSRsYTIiLCJ4TWF0Y2hlcyIsIngiLCJsYWJlbFZpZXdCb3giLCJ5TWF0Y2hlcyIsInkiLCJzdGFydEFuZ2xlTWF0Y2hlcyIsImVuZEFuZ2xlIiwiZW5kQW5nbGVNYXRjaGVzIiwic3RhcnRBbmdsZSIsInpNYXRjaGVzIiwieiIsImdldENvbXBhcmlzb25GbiIsImFjdGl2ZUl0ZW0iLCJjb21wYXJpc29uIiwiZ2V0U2hhcGVEYXRhS2V5Iiwic2hhcGVLZXkiLCJnZXRBY3RpdmVTaGFwZVRvb2x0aXBQYXlsb2FkIiwiX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhIiwidG9vbHRpcFBheWxvYWQiLCJwYXlsb2FkIiwiX2FjdGl2ZUl0ZW0kdG9vbHRpcFBhMiIsIl9yZWYzIiwiaXRlbURhdGEiLCJhY3RpdmVJdGVtTWF0Y2hlcyIsImRhdHVtIiwiZGF0YUluZGV4IiwidmFsdWVzTWF0Y2giLCJtb3VzZUNvb3JkaW5hdGVNYXRjaGVzIiwiaW5kZXhPZk1vdXNlQ29vcmRpbmF0ZXMiLCJjb29yZGluYXRlc01hdGNoIiwiYWN0aXZlSW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/ActiveShapeUtils.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/BarUtils.js":
/*!****************************************************!*\
  !*** ./node_modules/recharts/lib/util/BarUtils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BarRectangle = BarRectangle;\nexports.minPointSizeCallback = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _tinyInvariant = _interopRequireDefault(__webpack_require__(/*! tiny-invariant */ \"tiny-invariant\"));\nvar _ActiveShapeUtils = __webpack_require__(/*! ./ActiveShapeUtils */ \"./node_modules/recharts/lib/util/ActiveShapeUtils.js\");\nvar _excluded = [\n    \"x\",\n    \"y\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n// Rectangle props is expecting x, y, height, width as numbers, name as a string, and radius as a custom type\n// When props are being spread in from a user defined component in Bar,\n// the prop types of an SVGElement have these typed as something else.\n// This function will return the passed in props\n// along with x, y, height as numbers, name as a string, and radius as number | [number, number, number, number]\nfunction typeguardBarRectangleProps(_ref, props) {\n    var xProp = _ref.x, yProp = _ref.y, option = _objectWithoutProperties(_ref, _excluded);\n    var xValue = \"\".concat(xProp);\n    var x = parseInt(xValue, 10);\n    var yValue = \"\".concat(yProp);\n    var y = parseInt(yValue, 10);\n    var heightValue = \"\".concat(props.height || option.height);\n    var height = parseInt(heightValue, 10);\n    var widthValue = \"\".concat(props.width || option.width);\n    var width = parseInt(widthValue, 10);\n    return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, props), option), x ? {\n        x: x\n    } : {}), y ? {\n        y: y\n    } : {}), {}, {\n        height: height,\n        width: width,\n        name: props.name,\n        radius: props.radius\n    });\n}\nfunction BarRectangle(props) {\n    return /*#__PURE__*/ _react[\"default\"].createElement(_ActiveShapeUtils.Shape, _extends({\n        shapeType: \"rectangle\",\n        propTransformer: typeguardBarRectangleProps,\n        activeClassName: \"recharts-active-bar\"\n    }, props));\n}\n/**\n * Safely gets minPointSize from from the minPointSize prop if it is a function\n * @param minPointSize minPointSize as passed to the Bar component\n * @param defaultValue default minPointSize\n * @returns minPointSize\n */ var minPointSizeCallback = exports.minPointSizeCallback = function minPointSizeCallback(minPointSize) {\n    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return function(value, index) {\n        if (typeof minPointSize === \"number\") return minPointSize;\n        var isValueNumber = typeof value === \"number\";\n        if (isValueNumber) {\n            return minPointSize(value, index);\n        }\n        !isValueNumber ?  true ? (0, _tinyInvariant[\"default\"])(false, \"minPointSize callback function received a value with type of \".concat(_typeof(value), \". Currently only numbers are supported.\")) : 0 : void 0;\n        return defaultValue;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvQmFyVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELG9CQUFvQixHQUFHRTtBQUN2QkYsNEJBQTRCLEdBQUcsS0FBSztBQUNwQyxJQUFJSSxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ25ELElBQUlDLGlCQUFpQkYsdUJBQXVCQyxtQkFBT0EsQ0FBQyxzQ0FBZ0I7QUFDcEUsSUFBSUUsb0JBQW9CRixtQkFBT0EsQ0FBQyxnRkFBb0I7QUFDcEQsSUFBSUcsWUFBWTtJQUFDO0lBQUs7Q0FBSTtBQUMxQixTQUFTSix1QkFBdUJLLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLO0lBQWFBLFdBQVdwQixPQUFPcUIsTUFBTSxHQUFHckIsT0FBT3FCLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQUUsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQUUsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUFFLElBQUkzQixPQUFPbUIsU0FBUyxDQUFDVSxjQUFjLENBQUND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QUUsT0FBTyxnRUFBZ0U2RCxNQUFNLENBQUN4RCxRQUFRWCxRQUFRLDhDQUE4QyxDQUFxQyxHQUFHLEtBQUs7UUFDalIsT0FBT2tGO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9CYXJVdGlscy5qcz9mYjVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5CYXJSZWN0YW5nbGUgPSBCYXJSZWN0YW5nbGU7XG5leHBvcnRzLm1pblBvaW50U2l6ZUNhbGxiYWNrID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfdGlueUludmFyaWFudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInRpbnktaW52YXJpYW50XCIpKTtcbnZhciBfQWN0aXZlU2hhcGVVdGlscyA9IHJlcXVpcmUoXCIuL0FjdGl2ZVNoYXBlVXRpbHNcIik7XG52YXIgX2V4Y2x1ZGVkID0gW1wieFwiLCBcInlcIl07XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vLyBSZWN0YW5nbGUgcHJvcHMgaXMgZXhwZWN0aW5nIHgsIHksIGhlaWdodCwgd2lkdGggYXMgbnVtYmVycywgbmFtZSBhcyBhIHN0cmluZywgYW5kIHJhZGl1cyBhcyBhIGN1c3RvbSB0eXBlXG4vLyBXaGVuIHByb3BzIGFyZSBiZWluZyBzcHJlYWQgaW4gZnJvbSBhIHVzZXIgZGVmaW5lZCBjb21wb25lbnQgaW4gQmFyLFxuLy8gdGhlIHByb3AgdHlwZXMgb2YgYW4gU1ZHRWxlbWVudCBoYXZlIHRoZXNlIHR5cGVkIGFzIHNvbWV0aGluZyBlbHNlLlxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcGFzc2VkIGluIHByb3BzXG4vLyBhbG9uZyB3aXRoIHgsIHksIGhlaWdodCBhcyBudW1iZXJzLCBuYW1lIGFzIGEgc3RyaW5nLCBhbmQgcmFkaXVzIGFzIG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdXG5mdW5jdGlvbiB0eXBlZ3VhcmRCYXJSZWN0YW5nbGVQcm9wcyhfcmVmLCBwcm9wcykge1xuICB2YXIgeFByb3AgPSBfcmVmLngsXG4gICAgeVByb3AgPSBfcmVmLnksXG4gICAgb3B0aW9uID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG4gIHZhciB4VmFsdWUgPSBcIlwiLmNvbmNhdCh4UHJvcCk7XG4gIHZhciB4ID0gcGFyc2VJbnQoeFZhbHVlLCAxMCk7XG4gIHZhciB5VmFsdWUgPSBcIlwiLmNvbmNhdCh5UHJvcCk7XG4gIHZhciB5ID0gcGFyc2VJbnQoeVZhbHVlLCAxMCk7XG4gIHZhciBoZWlnaHRWYWx1ZSA9IFwiXCIuY29uY2F0KHByb3BzLmhlaWdodCB8fCBvcHRpb24uaGVpZ2h0KTtcbiAgdmFyIGhlaWdodCA9IHBhcnNlSW50KGhlaWdodFZhbHVlLCAxMCk7XG4gIHZhciB3aWR0aFZhbHVlID0gXCJcIi5jb25jYXQocHJvcHMud2lkdGggfHwgb3B0aW9uLndpZHRoKTtcbiAgdmFyIHdpZHRoID0gcGFyc2VJbnQod2lkdGhWYWx1ZSwgMTApO1xuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIG9wdGlvbiksIHggPyB7XG4gICAgeDogeFxuICB9IDoge30pLCB5ID8ge1xuICAgIHk6IHlcbiAgfSA6IHt9KSwge30sIHtcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgbmFtZTogcHJvcHMubmFtZSxcbiAgICByYWRpdXM6IHByb3BzLnJhZGl1c1xuICB9KTtcbn1cbmZ1bmN0aW9uIEJhclJlY3RhbmdsZShwcm9wcykge1xuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfQWN0aXZlU2hhcGVVdGlscy5TaGFwZSwgX2V4dGVuZHMoe1xuICAgIHNoYXBlVHlwZTogXCJyZWN0YW5nbGVcIixcbiAgICBwcm9wVHJhbnNmb3JtZXI6IHR5cGVndWFyZEJhclJlY3RhbmdsZVByb3BzLFxuICAgIGFjdGl2ZUNsYXNzTmFtZTogXCJyZWNoYXJ0cy1hY3RpdmUtYmFyXCJcbiAgfSwgcHJvcHMpKTtcbn1cbi8qKlxuICogU2FmZWx5IGdldHMgbWluUG9pbnRTaXplIGZyb20gZnJvbSB0aGUgbWluUG9pbnRTaXplIHByb3AgaWYgaXQgaXMgYSBmdW5jdGlvblxuICogQHBhcmFtIG1pblBvaW50U2l6ZSBtaW5Qb2ludFNpemUgYXMgcGFzc2VkIHRvIHRoZSBCYXIgY29tcG9uZW50XG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIGRlZmF1bHQgbWluUG9pbnRTaXplXG4gKiBAcmV0dXJucyBtaW5Qb2ludFNpemVcbiAqL1xudmFyIG1pblBvaW50U2l6ZUNhbGxiYWNrID0gZXhwb3J0cy5taW5Qb2ludFNpemVDYWxsYmFjayA9IGZ1bmN0aW9uIG1pblBvaW50U2l6ZUNhbGxiYWNrKG1pblBvaW50U2l6ZSkge1xuICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgbWluUG9pbnRTaXplID09PSAnbnVtYmVyJykgcmV0dXJuIG1pblBvaW50U2l6ZTtcbiAgICB2YXIgaXNWYWx1ZU51bWJlciA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgaWYgKGlzVmFsdWVOdW1iZXIpIHtcbiAgICAgIHJldHVybiBtaW5Qb2ludFNpemUodmFsdWUsIGluZGV4KTtcbiAgICB9XG4gICAgIWlzVmFsdWVOdW1iZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAoMCwgX3RpbnlJbnZhcmlhbnRbXCJkZWZhdWx0XCJdKShmYWxzZSwgXCJtaW5Qb2ludFNpemUgY2FsbGJhY2sgZnVuY3Rpb24gcmVjZWl2ZWQgYSB2YWx1ZSB3aXRoIHR5cGUgb2YgXCIuY29uY2F0KF90eXBlb2YodmFsdWUpLCBcIi4gQ3VycmVudGx5IG9ubHkgbnVtYmVycyBhcmUgc3VwcG9ydGVkLlwiKSkgOiAoMCwgX3RpbnlJbnZhcmlhbnRbXCJkZWZhdWx0XCJdKShmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfTtcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQmFyUmVjdGFuZ2xlIiwibWluUG9pbnRTaXplQ2FsbGJhY2siLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl90aW55SW52YXJpYW50IiwiX0FjdGl2ZVNoYXBlVXRpbHMiLCJfZXhjbHVkZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5Iiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInR5cGVndWFyZEJhclJlY3RhbmdsZVByb3BzIiwiX3JlZiIsInByb3BzIiwieFByb3AiLCJ4IiwieVByb3AiLCJ5Iiwib3B0aW9uIiwieFZhbHVlIiwiY29uY2F0IiwicGFyc2VJbnQiLCJ5VmFsdWUiLCJoZWlnaHRWYWx1ZSIsImhlaWdodCIsIndpZHRoVmFsdWUiLCJ3aWR0aCIsIm5hbWUiLCJyYWRpdXMiLCJjcmVhdGVFbGVtZW50IiwiU2hhcGUiLCJzaGFwZVR5cGUiLCJwcm9wVHJhbnNmb3JtZXIiLCJhY3RpdmVDbGFzc05hbWUiLCJtaW5Qb2ludFNpemUiLCJkZWZhdWx0VmFsdWUiLCJ1bmRlZmluZWQiLCJpbmRleCIsImlzVmFsdWVOdW1iZXIiLCJwcm9jZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/BarUtils.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/CartesianUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/recharts/lib/util/CartesianUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getAngledRectangleWidth = exports.formatAxisMap = exports.createLabeledScales = exports.ScaleHelper = void 0;\nexports.normalizeAngle = normalizeAngle;\nexports.rectWithPoints = exports.rectWithCoords = void 0;\nvar _mapValues = _interopRequireDefault(__webpack_require__(/*! lodash/mapValues */ \"lodash/mapValues\"));\nvar _every = _interopRequireDefault(__webpack_require__(/*! lodash/every */ \"lodash/every\"));\nvar _ChartUtils = __webpack_require__(/*! ./ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ./ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ./DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _Bar = __webpack_require__(/*! ../cartesian/Bar */ \"./node_modules/recharts/lib/cartesian/Bar.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n/**\n * Calculate the scale function, position, width, height of axes\n * @param  {Object} props     Latest props\n * @param  {Object} axisMap   The configuration of axes\n * @param  {Object} offset    The offset of main part in the svg element\n * @param  {String} axisType  The type of axes, x-axis or y-axis\n * @param  {String} chartName The name of chart\n * @return {Object} Configuration\n */ var formatAxisMap = exports.formatAxisMap = function formatAxisMap(props, axisMap, offset, axisType, chartName) {\n    var width = props.width, height = props.height, layout = props.layout, children = props.children;\n    var ids = Object.keys(axisMap);\n    var steps = {\n        left: offset.left,\n        leftMirror: offset.left,\n        right: width - offset.right,\n        rightMirror: width - offset.right,\n        top: offset.top,\n        topMirror: offset.top,\n        bottom: height - offset.bottom,\n        bottomMirror: height - offset.bottom\n    };\n    var hasBar = !!(0, _ReactUtils.findChildByType)(children, _Bar.Bar);\n    return ids.reduce(function(result, id) {\n        var axis = axisMap[id];\n        var orientation = axis.orientation, domain = axis.domain, _axis$padding = axis.padding, padding = _axis$padding === void 0 ? {} : _axis$padding, mirror = axis.mirror, reversed = axis.reversed;\n        var offsetKey = \"\".concat(orientation).concat(mirror ? \"Mirror\" : \"\");\n        var calculatedPadding, range, x, y, needSpace;\n        if (axis.type === \"number\" && (axis.padding === \"gap\" || axis.padding === \"no-gap\")) {\n            var diff = domain[1] - domain[0];\n            var smallestDistanceBetweenValues = Infinity;\n            var sortedValues = axis.categoricalDomain.sort();\n            sortedValues.forEach(function(value, index) {\n                if (index > 0) {\n                    smallestDistanceBetweenValues = Math.min((value || 0) - (sortedValues[index - 1] || 0), smallestDistanceBetweenValues);\n                }\n            });\n            if (Number.isFinite(smallestDistanceBetweenValues)) {\n                var smallestDistanceInPercent = smallestDistanceBetweenValues / diff;\n                var rangeWidth = axis.layout === \"vertical\" ? offset.height : offset.width;\n                if (axis.padding === \"gap\") {\n                    calculatedPadding = smallestDistanceInPercent * rangeWidth / 2;\n                }\n                if (axis.padding === \"no-gap\") {\n                    var gap = (0, _DataUtils.getPercentValue)(props.barCategoryGap, smallestDistanceInPercent * rangeWidth);\n                    var halfBand = smallestDistanceInPercent * rangeWidth / 2;\n                    calculatedPadding = halfBand - gap - (halfBand - gap) / rangeWidth * gap;\n                }\n            }\n        }\n        if (axisType === \"xAxis\") {\n            range = [\n                offset.left + (padding.left || 0) + (calculatedPadding || 0),\n                offset.left + offset.width - (padding.right || 0) - (calculatedPadding || 0)\n            ];\n        } else if (axisType === \"yAxis\") {\n            range = layout === \"horizontal\" ? [\n                offset.top + offset.height - (padding.bottom || 0),\n                offset.top + (padding.top || 0)\n            ] : [\n                offset.top + (padding.top || 0) + (calculatedPadding || 0),\n                offset.top + offset.height - (padding.bottom || 0) - (calculatedPadding || 0)\n            ];\n        } else {\n            range = axis.range;\n        }\n        if (reversed) {\n            range = [\n                range[1],\n                range[0]\n            ];\n        }\n        var _parseScale = (0, _ChartUtils.parseScale)(axis, chartName, hasBar), scale = _parseScale.scale, realScaleType = _parseScale.realScaleType;\n        scale.domain(domain).range(range);\n        (0, _ChartUtils.checkDomainOfScale)(scale);\n        var ticks = (0, _ChartUtils.getTicksOfScale)(scale, _objectSpread(_objectSpread({}, axis), {}, {\n            realScaleType: realScaleType\n        }));\n        if (axisType === \"xAxis\") {\n            needSpace = orientation === \"top\" && !mirror || orientation === \"bottom\" && mirror;\n            x = offset.left;\n            y = steps[offsetKey] - needSpace * axis.height;\n        } else if (axisType === \"yAxis\") {\n            needSpace = orientation === \"left\" && !mirror || orientation === \"right\" && mirror;\n            x = steps[offsetKey] - needSpace * axis.width;\n            y = offset.top;\n        }\n        var finalAxis = _objectSpread(_objectSpread(_objectSpread({}, axis), ticks), {}, {\n            realScaleType: realScaleType,\n            x: x,\n            y: y,\n            scale: scale,\n            width: axisType === \"xAxis\" ? offset.width : axis.width,\n            height: axisType === \"yAxis\" ? offset.height : axis.height\n        });\n        finalAxis.bandSize = (0, _ChartUtils.getBandSizeOfAxis)(finalAxis, ticks);\n        if (!axis.hide && axisType === \"xAxis\") {\n            steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.height;\n        } else if (!axis.hide) {\n            steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.width;\n        }\n        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, id, finalAxis));\n    }, {});\n};\nvar rectWithPoints = exports.rectWithPoints = function rectWithPoints(_ref, _ref2) {\n    var x1 = _ref.x, y1 = _ref.y;\n    var x2 = _ref2.x, y2 = _ref2.y;\n    return {\n        x: Math.min(x1, x2),\n        y: Math.min(y1, y2),\n        width: Math.abs(x2 - x1),\n        height: Math.abs(y2 - y1)\n    };\n};\n/**\n * Compute the x, y, width, and height of a box from two reference points.\n * @param  {Object} coords     x1, x2, y1, and y2\n * @return {Object} object\n */ var rectWithCoords = exports.rectWithCoords = function rectWithCoords(_ref3) {\n    var x1 = _ref3.x1, y1 = _ref3.y1, x2 = _ref3.x2, y2 = _ref3.y2;\n    return rectWithPoints({\n        x: x1,\n        y: y1\n    }, {\n        x: x2,\n        y: y2\n    });\n};\nvar ScaleHelper = exports.ScaleHelper = /*#__PURE__*/ function() {\n    function ScaleHelper(scale) {\n        _classCallCheck(this, ScaleHelper);\n        this.scale = scale;\n    }\n    return _createClass(ScaleHelper, [\n        {\n            key: \"domain\",\n            get: function get() {\n                return this.scale.domain;\n            }\n        },\n        {\n            key: \"range\",\n            get: function get() {\n                return this.scale.range;\n            }\n        },\n        {\n            key: \"rangeMin\",\n            get: function get() {\n                return this.range()[0];\n            }\n        },\n        {\n            key: \"rangeMax\",\n            get: function get() {\n                return this.range()[1];\n            }\n        },\n        {\n            key: \"bandwidth\",\n            get: function get() {\n                return this.scale.bandwidth;\n            }\n        },\n        {\n            key: \"apply\",\n            value: function apply(value) {\n                var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, bandAware = _ref4.bandAware, position = _ref4.position;\n                if (value === undefined) {\n                    return undefined;\n                }\n                if (position) {\n                    switch(position){\n                        case \"start\":\n                            {\n                                return this.scale(value);\n                            }\n                        case \"middle\":\n                            {\n                                var offset = this.bandwidth ? this.bandwidth() / 2 : 0;\n                                return this.scale(value) + offset;\n                            }\n                        case \"end\":\n                            {\n                                var _offset = this.bandwidth ? this.bandwidth() : 0;\n                                return this.scale(value) + _offset;\n                            }\n                        default:\n                            {\n                                return this.scale(value);\n                            }\n                    }\n                }\n                if (bandAware) {\n                    var _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;\n                    return this.scale(value) + _offset2;\n                }\n                return this.scale(value);\n            }\n        },\n        {\n            key: \"isInRange\",\n            value: function isInRange(value) {\n                var range = this.range();\n                var first = range[0];\n                var last = range[range.length - 1];\n                return first <= last ? value >= first && value <= last : value >= last && value <= first;\n            }\n        }\n    ], [\n        {\n            key: \"create\",\n            value: function create(obj) {\n                return new ScaleHelper(obj);\n            }\n        }\n    ]);\n}();\n_defineProperty(ScaleHelper, \"EPS\", 1e-4);\nvar createLabeledScales = exports.createLabeledScales = function createLabeledScales(options) {\n    var scales = Object.keys(options).reduce(function(res, key) {\n        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, key, ScaleHelper.create(options[key])));\n    }, {});\n    return _objectSpread(_objectSpread({}, scales), {}, {\n        apply: function apply(coord) {\n            var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, bandAware = _ref5.bandAware, position = _ref5.position;\n            return (0, _mapValues[\"default\"])(coord, function(value, label) {\n                return scales[label].apply(value, {\n                    bandAware: bandAware,\n                    position: position\n                });\n            });\n        },\n        isInRange: function isInRange(coord) {\n            return (0, _every[\"default\"])(coord, function(value, label) {\n                return scales[label].isInRange(value);\n            });\n        }\n    });\n};\n/** Normalizes the angle so that 0 <= angle < 180.\n * @param {number} angle Angle in degrees.\n * @return {number} the normalized angle with a value of at least 0 and never greater or equal to 180. */ function normalizeAngle(angle) {\n    return (angle % 180 + 180) % 180;\n}\n/** Calculates the width of the largest horizontal line that fits inside a rectangle that is displayed at an angle.\n * @param {Object} size Width and height of the text in a horizontal position.\n * @param {number} angle Angle in degrees in which the text is displayed.\n * @return {number} The width of the largest horizontal line that fits inside a rectangle that is displayed at an angle.\n */ var getAngledRectangleWidth = exports.getAngledRectangleWidth = function getAngledRectangleWidth(_ref6) {\n    var width = _ref6.width, height = _ref6.height;\n    var angle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    // Ensure angle is >= 0 && < 180\n    var normalizedAngle = normalizeAngle(angle);\n    var angleRadians = normalizedAngle * Math.PI / 180;\n    /* Depending on the height and width of the rectangle, we may need to use different formulas to calculate the angled\n   * width. This threshold defines when each formula should kick in. */ var angleThreshold = Math.atan(height / width);\n    var angledWidth = angleRadians > angleThreshold && angleRadians < Math.PI - angleThreshold ? height / Math.sin(angleRadians) : width / Math.cos(angleRadians);\n    return Math.abs(angledWidth);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvQ2FydGVzaWFuVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELCtCQUErQixHQUFHQSxxQkFBcUIsR0FBR0EsMkJBQTJCLEdBQUdBLG1CQUFtQixHQUFHLEtBQUs7QUFDbkhBLHNCQUFzQixHQUFHTTtBQUN6Qk4sc0JBQXNCLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDdkQsSUFBSVMsYUFBYUMsdUJBQXVCQyxtQkFBT0EsQ0FBQywwQ0FBa0I7QUFDbEUsSUFBSUMsU0FBU0YsdUJBQXVCQyxtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJRSxjQUFjRixtQkFBT0EsQ0FBQyxvRUFBYztBQUN4QyxJQUFJRyxjQUFjSCxtQkFBT0EsQ0FBQyxvRUFBYztBQUN4QyxJQUFJSSxhQUFhSixtQkFBT0EsQ0FBQyxrRUFBYTtBQUN0QyxJQUFJSyxPQUFPTCxtQkFBT0EsQ0FBQyxzRUFBa0I7QUFDckMsU0FBU0QsdUJBQXVCTyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSyxnQkFBZ0JDLFFBQVEsRUFBRUMsV0FBVztJQUFJLElBQUksQ0FBRUQsQ0FBQUEsb0JBQW9CQyxXQUFVLEdBQUk7UUFBRSxNQUFN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dkIsSUFBSXVGLFFBQVF0RyxVQUFVckIsTUFBTSxHQUFHLEtBQUtxQixTQUFTLENBQUMsRUFBRSxLQUFLdUYsWUFBWXZGLFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDaEYsZ0NBQWdDO0lBQ2hDLElBQUl3RyxrQkFBa0J4SixlQUFlc0o7SUFDckMsSUFBSUcsZUFBZUQsa0JBQWtCaEQsS0FBS2tELEVBQUUsR0FBRztJQUUvQztxRUFDbUUsR0FDbkUsSUFBSUMsaUJBQWlCbkQsS0FBS29ELElBQUksQ0FBQzdGLFNBQVNEO0lBQ3hDLElBQUkrRixjQUFjSixlQUFlRSxrQkFBa0JGLGVBQWVqRCxLQUFLa0QsRUFBRSxHQUFHQyxpQkFBaUI1RixTQUFTeUMsS0FBS3NELEdBQUcsQ0FBQ0wsZ0JBQWdCM0YsUUFBUTBDLEtBQUt1RCxHQUFHLENBQUNOO0lBQ2hKLE9BQU9qRCxLQUFLMEIsR0FBRyxDQUFDMkI7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvQ2FydGVzaWFuVXRpbHMuanM/ZmYzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0QW5nbGVkUmVjdGFuZ2xlV2lkdGggPSBleHBvcnRzLmZvcm1hdEF4aXNNYXAgPSBleHBvcnRzLmNyZWF0ZUxhYmVsZWRTY2FsZXMgPSBleHBvcnRzLlNjYWxlSGVscGVyID0gdm9pZCAwO1xuZXhwb3J0cy5ub3JtYWxpemVBbmdsZSA9IG5vcm1hbGl6ZUFuZ2xlO1xuZXhwb3J0cy5yZWN0V2l0aFBvaW50cyA9IGV4cG9ydHMucmVjdFdpdGhDb29yZHMgPSB2b2lkIDA7XG52YXIgX21hcFZhbHVlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9tYXBWYWx1ZXNcIikpO1xudmFyIF9ldmVyeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9ldmVyeVwiKSk7XG52YXIgX0NoYXJ0VXRpbHMgPSByZXF1aXJlKFwiLi9DaGFydFV0aWxzXCIpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4vUmVhY3RVdGlsc1wiKTtcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4vRGF0YVV0aWxzXCIpO1xudmFyIF9CYXIgPSByZXF1aXJlKFwiLi4vY2FydGVzaWFuL0JhclwiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzY2FsZSBmdW5jdGlvbiwgcG9zaXRpb24sIHdpZHRoLCBoZWlnaHQgb2YgYXhlc1xuICogQHBhcmFtICB7T2JqZWN0fSBwcm9wcyAgICAgTGF0ZXN0IHByb3BzXG4gKiBAcGFyYW0gIHtPYmplY3R9IGF4aXNNYXAgICBUaGUgY29uZmlndXJhdGlvbiBvZiBheGVzXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9mZnNldCAgICBUaGUgb2Zmc2V0IG9mIG1haW4gcGFydCBpbiB0aGUgc3ZnIGVsZW1lbnRcbiAqIEBwYXJhbSAge1N0cmluZ30gYXhpc1R5cGUgIFRoZSB0eXBlIG9mIGF4ZXMsIHgtYXhpcyBvciB5LWF4aXNcbiAqIEBwYXJhbSAge1N0cmluZ30gY2hhcnROYW1lIFRoZSBuYW1lIG9mIGNoYXJ0XG4gKiBAcmV0dXJuIHtPYmplY3R9IENvbmZpZ3VyYXRpb25cbiAqL1xudmFyIGZvcm1hdEF4aXNNYXAgPSBleHBvcnRzLmZvcm1hdEF4aXNNYXAgPSBmdW5jdGlvbiBmb3JtYXRBeGlzTWFwKHByb3BzLCBheGlzTWFwLCBvZmZzZXQsIGF4aXNUeXBlLCBjaGFydE5hbWUpIHtcbiAgdmFyIHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxuICAgIGxheW91dCA9IHByb3BzLmxheW91dCxcbiAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICB2YXIgaWRzID0gT2JqZWN0LmtleXMoYXhpc01hcCk7XG4gIHZhciBzdGVwcyA9IHtcbiAgICBsZWZ0OiBvZmZzZXQubGVmdCxcbiAgICBsZWZ0TWlycm9yOiBvZmZzZXQubGVmdCxcbiAgICByaWdodDogd2lkdGggLSBvZmZzZXQucmlnaHQsXG4gICAgcmlnaHRNaXJyb3I6IHdpZHRoIC0gb2Zmc2V0LnJpZ2h0LFxuICAgIHRvcDogb2Zmc2V0LnRvcCxcbiAgICB0b3BNaXJyb3I6IG9mZnNldC50b3AsXG4gICAgYm90dG9tOiBoZWlnaHQgLSBvZmZzZXQuYm90dG9tLFxuICAgIGJvdHRvbU1pcnJvcjogaGVpZ2h0IC0gb2Zmc2V0LmJvdHRvbVxuICB9O1xuICB2YXIgaGFzQmFyID0gISEoMCwgX1JlYWN0VXRpbHMuZmluZENoaWxkQnlUeXBlKShjaGlsZHJlbiwgX0Jhci5CYXIpO1xuICByZXR1cm4gaWRzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBpZCkge1xuICAgIHZhciBheGlzID0gYXhpc01hcFtpZF07XG4gICAgdmFyIG9yaWVudGF0aW9uID0gYXhpcy5vcmllbnRhdGlvbixcbiAgICAgIGRvbWFpbiA9IGF4aXMuZG9tYWluLFxuICAgICAgX2F4aXMkcGFkZGluZyA9IGF4aXMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfYXhpcyRwYWRkaW5nID09PSB2b2lkIDAgPyB7fSA6IF9heGlzJHBhZGRpbmcsXG4gICAgICBtaXJyb3IgPSBheGlzLm1pcnJvcixcbiAgICAgIHJldmVyc2VkID0gYXhpcy5yZXZlcnNlZDtcbiAgICB2YXIgb2Zmc2V0S2V5ID0gXCJcIi5jb25jYXQob3JpZW50YXRpb24pLmNvbmNhdChtaXJyb3IgPyAnTWlycm9yJyA6ICcnKTtcbiAgICB2YXIgY2FsY3VsYXRlZFBhZGRpbmcsIHJhbmdlLCB4LCB5LCBuZWVkU3BhY2U7XG4gICAgaWYgKGF4aXMudHlwZSA9PT0gJ251bWJlcicgJiYgKGF4aXMucGFkZGluZyA9PT0gJ2dhcCcgfHwgYXhpcy5wYWRkaW5nID09PSAnbm8tZ2FwJykpIHtcbiAgICAgIHZhciBkaWZmID0gZG9tYWluWzFdIC0gZG9tYWluWzBdO1xuICAgICAgdmFyIHNtYWxsZXN0RGlzdGFuY2VCZXR3ZWVuVmFsdWVzID0gSW5maW5pdHk7XG4gICAgICB2YXIgc29ydGVkVmFsdWVzID0gYXhpcy5jYXRlZ29yaWNhbERvbWFpbi5zb3J0KCk7XG4gICAgICBzb3J0ZWRWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICBzbWFsbGVzdERpc3RhbmNlQmV0d2VlblZhbHVlcyA9IE1hdGgubWluKCh2YWx1ZSB8fCAwKSAtIChzb3J0ZWRWYWx1ZXNbaW5kZXggLSAxXSB8fCAwKSwgc21hbGxlc3REaXN0YW5jZUJldHdlZW5WYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc21hbGxlc3REaXN0YW5jZUJldHdlZW5WYWx1ZXMpKSB7XG4gICAgICAgIHZhciBzbWFsbGVzdERpc3RhbmNlSW5QZXJjZW50ID0gc21hbGxlc3REaXN0YW5jZUJldHdlZW5WYWx1ZXMgLyBkaWZmO1xuICAgICAgICB2YXIgcmFuZ2VXaWR0aCA9IGF4aXMubGF5b3V0ID09PSAndmVydGljYWwnID8gb2Zmc2V0LmhlaWdodCA6IG9mZnNldC53aWR0aDtcbiAgICAgICAgaWYgKGF4aXMucGFkZGluZyA9PT0gJ2dhcCcpIHtcbiAgICAgICAgICBjYWxjdWxhdGVkUGFkZGluZyA9IHNtYWxsZXN0RGlzdGFuY2VJblBlcmNlbnQgKiByYW5nZVdpZHRoIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXhpcy5wYWRkaW5nID09PSAnbm8tZ2FwJykge1xuICAgICAgICAgIHZhciBnYXAgPSAoMCwgX0RhdGFVdGlscy5nZXRQZXJjZW50VmFsdWUpKHByb3BzLmJhckNhdGVnb3J5R2FwLCBzbWFsbGVzdERpc3RhbmNlSW5QZXJjZW50ICogcmFuZ2VXaWR0aCk7XG4gICAgICAgICAgdmFyIGhhbGZCYW5kID0gc21hbGxlc3REaXN0YW5jZUluUGVyY2VudCAqIHJhbmdlV2lkdGggLyAyO1xuICAgICAgICAgIGNhbGN1bGF0ZWRQYWRkaW5nID0gaGFsZkJhbmQgLSBnYXAgLSAoaGFsZkJhbmQgLSBnYXApIC8gcmFuZ2VXaWR0aCAqIGdhcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXhpc1R5cGUgPT09ICd4QXhpcycpIHtcbiAgICAgIHJhbmdlID0gW29mZnNldC5sZWZ0ICsgKHBhZGRpbmcubGVmdCB8fCAwKSArIChjYWxjdWxhdGVkUGFkZGluZyB8fCAwKSwgb2Zmc2V0LmxlZnQgKyBvZmZzZXQud2lkdGggLSAocGFkZGluZy5yaWdodCB8fCAwKSAtIChjYWxjdWxhdGVkUGFkZGluZyB8fCAwKV07XG4gICAgfSBlbHNlIGlmIChheGlzVHlwZSA9PT0gJ3lBeGlzJykge1xuICAgICAgcmFuZ2UgPSBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IFtvZmZzZXQudG9wICsgb2Zmc2V0LmhlaWdodCAtIChwYWRkaW5nLmJvdHRvbSB8fCAwKSwgb2Zmc2V0LnRvcCArIChwYWRkaW5nLnRvcCB8fCAwKV0gOiBbb2Zmc2V0LnRvcCArIChwYWRkaW5nLnRvcCB8fCAwKSArIChjYWxjdWxhdGVkUGFkZGluZyB8fCAwKSwgb2Zmc2V0LnRvcCArIG9mZnNldC5oZWlnaHQgLSAocGFkZGluZy5ib3R0b20gfHwgMCkgLSAoY2FsY3VsYXRlZFBhZGRpbmcgfHwgMCldO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IGF4aXMucmFuZ2U7XG4gICAgfVxuICAgIGlmIChyZXZlcnNlZCkge1xuICAgICAgcmFuZ2UgPSBbcmFuZ2VbMV0sIHJhbmdlWzBdXTtcbiAgICB9XG4gICAgdmFyIF9wYXJzZVNjYWxlID0gKDAsIF9DaGFydFV0aWxzLnBhcnNlU2NhbGUpKGF4aXMsIGNoYXJ0TmFtZSwgaGFzQmFyKSxcbiAgICAgIHNjYWxlID0gX3BhcnNlU2NhbGUuc2NhbGUsXG4gICAgICByZWFsU2NhbGVUeXBlID0gX3BhcnNlU2NhbGUucmVhbFNjYWxlVHlwZTtcbiAgICBzY2FsZS5kb21haW4oZG9tYWluKS5yYW5nZShyYW5nZSk7XG4gICAgKDAsIF9DaGFydFV0aWxzLmNoZWNrRG9tYWluT2ZTY2FsZSkoc2NhbGUpO1xuICAgIHZhciB0aWNrcyA9ICgwLCBfQ2hhcnRVdGlscy5nZXRUaWNrc09mU2NhbGUpKHNjYWxlLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGF4aXMpLCB7fSwge1xuICAgICAgcmVhbFNjYWxlVHlwZTogcmVhbFNjYWxlVHlwZVxuICAgIH0pKTtcbiAgICBpZiAoYXhpc1R5cGUgPT09ICd4QXhpcycpIHtcbiAgICAgIG5lZWRTcGFjZSA9IG9yaWVudGF0aW9uID09PSAndG9wJyAmJiAhbWlycm9yIHx8IG9yaWVudGF0aW9uID09PSAnYm90dG9tJyAmJiBtaXJyb3I7XG4gICAgICB4ID0gb2Zmc2V0LmxlZnQ7XG4gICAgICB5ID0gc3RlcHNbb2Zmc2V0S2V5XSAtIG5lZWRTcGFjZSAqIGF4aXMuaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoYXhpc1R5cGUgPT09ICd5QXhpcycpIHtcbiAgICAgIG5lZWRTcGFjZSA9IG9yaWVudGF0aW9uID09PSAnbGVmdCcgJiYgIW1pcnJvciB8fCBvcmllbnRhdGlvbiA9PT0gJ3JpZ2h0JyAmJiBtaXJyb3I7XG4gICAgICB4ID0gc3RlcHNbb2Zmc2V0S2V5XSAtIG5lZWRTcGFjZSAqIGF4aXMud2lkdGg7XG4gICAgICB5ID0gb2Zmc2V0LnRvcDtcbiAgICB9XG4gICAgdmFyIGZpbmFsQXhpcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBheGlzKSwgdGlja3MpLCB7fSwge1xuICAgICAgcmVhbFNjYWxlVHlwZTogcmVhbFNjYWxlVHlwZSxcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgd2lkdGg6IGF4aXNUeXBlID09PSAneEF4aXMnID8gb2Zmc2V0LndpZHRoIDogYXhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogYXhpc1R5cGUgPT09ICd5QXhpcycgPyBvZmZzZXQuaGVpZ2h0IDogYXhpcy5oZWlnaHRcbiAgICB9KTtcbiAgICBmaW5hbEF4aXMuYmFuZFNpemUgPSAoMCwgX0NoYXJ0VXRpbHMuZ2V0QmFuZFNpemVPZkF4aXMpKGZpbmFsQXhpcywgdGlja3MpO1xuICAgIGlmICghYXhpcy5oaWRlICYmIGF4aXNUeXBlID09PSAneEF4aXMnKSB7XG4gICAgICBzdGVwc1tvZmZzZXRLZXldICs9IChuZWVkU3BhY2UgPyAtMSA6IDEpICogZmluYWxBeGlzLmhlaWdodDtcbiAgICB9IGVsc2UgaWYgKCFheGlzLmhpZGUpIHtcbiAgICAgIHN0ZXBzW29mZnNldEtleV0gKz0gKG5lZWRTcGFjZSA/IC0xIDogMSkgKiBmaW5hbEF4aXMud2lkdGg7XG4gICAgfVxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGlkLCBmaW5hbEF4aXMpKTtcbiAgfSwge30pO1xufTtcbnZhciByZWN0V2l0aFBvaW50cyA9IGV4cG9ydHMucmVjdFdpdGhQb2ludHMgPSBmdW5jdGlvbiByZWN0V2l0aFBvaW50cyhfcmVmLCBfcmVmMikge1xuICB2YXIgeDEgPSBfcmVmLngsXG4gICAgeTEgPSBfcmVmLnk7XG4gIHZhciB4MiA9IF9yZWYyLngsXG4gICAgeTIgPSBfcmVmMi55O1xuICByZXR1cm4ge1xuICAgIHg6IE1hdGgubWluKHgxLCB4MiksXG4gICAgeTogTWF0aC5taW4oeTEsIHkyKSxcbiAgICB3aWR0aDogTWF0aC5hYnMoeDIgLSB4MSksXG4gICAgaGVpZ2h0OiBNYXRoLmFicyh5MiAtIHkxKVxuICB9O1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSB4LCB5LCB3aWR0aCwgYW5kIGhlaWdodCBvZiBhIGJveCBmcm9tIHR3byByZWZlcmVuY2UgcG9pbnRzLlxuICogQHBhcmFtICB7T2JqZWN0fSBjb29yZHMgICAgIHgxLCB4MiwgeTEsIGFuZCB5MlxuICogQHJldHVybiB7T2JqZWN0fSBvYmplY3RcbiAqL1xudmFyIHJlY3RXaXRoQ29vcmRzID0gZXhwb3J0cy5yZWN0V2l0aENvb3JkcyA9IGZ1bmN0aW9uIHJlY3RXaXRoQ29vcmRzKF9yZWYzKSB7XG4gIHZhciB4MSA9IF9yZWYzLngxLFxuICAgIHkxID0gX3JlZjMueTEsXG4gICAgeDIgPSBfcmVmMy54MixcbiAgICB5MiA9IF9yZWYzLnkyO1xuICByZXR1cm4gcmVjdFdpdGhQb2ludHMoe1xuICAgIHg6IHgxLFxuICAgIHk6IHkxXG4gIH0sIHtcbiAgICB4OiB4MixcbiAgICB5OiB5MlxuICB9KTtcbn07XG52YXIgU2NhbGVIZWxwZXIgPSBleHBvcnRzLlNjYWxlSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2NhbGVIZWxwZXIoc2NhbGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2NhbGVIZWxwZXIpO1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFNjYWxlSGVscGVyLCBbe1xuICAgIGtleTogXCJkb21haW5cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlLmRvbWFpbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZ2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlLnJhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYW5nZU1pblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2UoKVswXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZ2VNYXhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlKClbMV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJhbmR3aWR0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGUuYmFuZHdpZHRoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseSh2YWx1ZSkge1xuICAgICAgdmFyIF9yZWY0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgYmFuZEF3YXJlID0gX3JlZjQuYmFuZEF3YXJlLFxuICAgICAgICBwb3NpdGlvbiA9IF9yZWY0LnBvc2l0aW9uO1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuYmFuZHdpZHRoID8gdGhpcy5iYW5kd2lkdGgoKSAvIDIgOiAwO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSkgKyBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIF9vZmZzZXQgPSB0aGlzLmJhbmR3aWR0aCA/IHRoaXMuYmFuZHdpZHRoKCkgOiAwO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSkgKyBfb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJhbmRBd2FyZSkge1xuICAgICAgICB2YXIgX29mZnNldDIgPSB0aGlzLmJhbmR3aWR0aCA/IHRoaXMuYmFuZHdpZHRoKCkgLyAyIDogMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUodmFsdWUpICsgX29mZnNldDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSW5SYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0luUmFuZ2UodmFsdWUpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucmFuZ2UoKTtcbiAgICAgIHZhciBmaXJzdCA9IHJhbmdlWzBdO1xuICAgICAgdmFyIGxhc3QgPSByYW5nZVtyYW5nZS5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiBmaXJzdCA8PSBsYXN0ID8gdmFsdWUgPj0gZmlyc3QgJiYgdmFsdWUgPD0gbGFzdCA6IHZhbHVlID49IGxhc3QgJiYgdmFsdWUgPD0gZmlyc3Q7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShvYmopIHtcbiAgICAgIHJldHVybiBuZXcgU2NhbGVIZWxwZXIob2JqKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbl9kZWZpbmVQcm9wZXJ0eShTY2FsZUhlbHBlciwgXCJFUFNcIiwgMWUtNCk7XG52YXIgY3JlYXRlTGFiZWxlZFNjYWxlcyA9IGV4cG9ydHMuY3JlYXRlTGFiZWxlZFNjYWxlcyA9IGZ1bmN0aW9uIGNyZWF0ZUxhYmVsZWRTY2FsZXMob3B0aW9ucykge1xuICB2YXIgc2NhbGVzID0gT2JqZWN0LmtleXMob3B0aW9ucykucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGtleSkge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlcyksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgU2NhbGVIZWxwZXIuY3JlYXRlKG9wdGlvbnNba2V5XSkpKTtcbiAgfSwge30pO1xuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzY2FsZXMpLCB7fSwge1xuICAgIGFwcGx5OiBmdW5jdGlvbiBhcHBseShjb29yZCkge1xuICAgICAgdmFyIF9yZWY1ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgYmFuZEF3YXJlID0gX3JlZjUuYmFuZEF3YXJlLFxuICAgICAgICBwb3NpdGlvbiA9IF9yZWY1LnBvc2l0aW9uO1xuICAgICAgcmV0dXJuICgwLCBfbWFwVmFsdWVzW1wiZGVmYXVsdFwiXSkoY29vcmQsIGZ1bmN0aW9uICh2YWx1ZSwgbGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlc1tsYWJlbF0uYXBwbHkodmFsdWUsIHtcbiAgICAgICAgICBiYW5kQXdhcmU6IGJhbmRBd2FyZSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGlzSW5SYW5nZTogZnVuY3Rpb24gaXNJblJhbmdlKGNvb3JkKSB7XG4gICAgICByZXR1cm4gKDAsIF9ldmVyeVtcImRlZmF1bHRcIl0pKGNvb3JkLCBmdW5jdGlvbiAodmFsdWUsIGxhYmVsKSB7XG4gICAgICAgIHJldHVybiBzY2FsZXNbbGFiZWxdLmlzSW5SYW5nZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqIE5vcm1hbGl6ZXMgdGhlIGFuZ2xlIHNvIHRoYXQgMCA8PSBhbmdsZSA8IDE4MC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBBbmdsZSBpbiBkZWdyZWVzLlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgbm9ybWFsaXplZCBhbmdsZSB3aXRoIGEgdmFsdWUgb2YgYXQgbGVhc3QgMCBhbmQgbmV2ZXIgZ3JlYXRlciBvciBlcXVhbCB0byAxODAuICovXG5mdW5jdGlvbiBub3JtYWxpemVBbmdsZShhbmdsZSkge1xuICByZXR1cm4gKGFuZ2xlICUgMTgwICsgMTgwKSAlIDE4MDtcbn1cblxuLyoqIENhbGN1bGF0ZXMgdGhlIHdpZHRoIG9mIHRoZSBsYXJnZXN0IGhvcml6b250YWwgbGluZSB0aGF0IGZpdHMgaW5zaWRlIGEgcmVjdGFuZ2xlIHRoYXQgaXMgZGlzcGxheWVkIGF0IGFuIGFuZ2xlLlxuICogQHBhcmFtIHtPYmplY3R9IHNpemUgV2lkdGggYW5kIGhlaWdodCBvZiB0aGUgdGV4dCBpbiBhIGhvcml6b250YWwgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgQW5nbGUgaW4gZGVncmVlcyBpbiB3aGljaCB0aGUgdGV4dCBpcyBkaXNwbGF5ZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgbGFyZ2VzdCBob3Jpem9udGFsIGxpbmUgdGhhdCBmaXRzIGluc2lkZSBhIHJlY3RhbmdsZSB0aGF0IGlzIGRpc3BsYXllZCBhdCBhbiBhbmdsZS5cbiAqL1xudmFyIGdldEFuZ2xlZFJlY3RhbmdsZVdpZHRoID0gZXhwb3J0cy5nZXRBbmdsZWRSZWN0YW5nbGVXaWR0aCA9IGZ1bmN0aW9uIGdldEFuZ2xlZFJlY3RhbmdsZVdpZHRoKF9yZWY2KSB7XG4gIHZhciB3aWR0aCA9IF9yZWY2LndpZHRoLFxuICAgIGhlaWdodCA9IF9yZWY2LmhlaWdodDtcbiAgdmFyIGFuZ2xlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAvLyBFbnN1cmUgYW5nbGUgaXMgPj0gMCAmJiA8IDE4MFxuICB2YXIgbm9ybWFsaXplZEFuZ2xlID0gbm9ybWFsaXplQW5nbGUoYW5nbGUpO1xuICB2YXIgYW5nbGVSYWRpYW5zID0gbm9ybWFsaXplZEFuZ2xlICogTWF0aC5QSSAvIDE4MDtcblxuICAvKiBEZXBlbmRpbmcgb24gdGhlIGhlaWdodCBhbmQgd2lkdGggb2YgdGhlIHJlY3RhbmdsZSwgd2UgbWF5IG5lZWQgdG8gdXNlIGRpZmZlcmVudCBmb3JtdWxhcyB0byBjYWxjdWxhdGUgdGhlIGFuZ2xlZFxuICAgKiB3aWR0aC4gVGhpcyB0aHJlc2hvbGQgZGVmaW5lcyB3aGVuIGVhY2ggZm9ybXVsYSBzaG91bGQga2ljayBpbi4gKi9cbiAgdmFyIGFuZ2xlVGhyZXNob2xkID0gTWF0aC5hdGFuKGhlaWdodCAvIHdpZHRoKTtcbiAgdmFyIGFuZ2xlZFdpZHRoID0gYW5nbGVSYWRpYW5zID4gYW5nbGVUaHJlc2hvbGQgJiYgYW5nbGVSYWRpYW5zIDwgTWF0aC5QSSAtIGFuZ2xlVGhyZXNob2xkID8gaGVpZ2h0IC8gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKSA6IHdpZHRoIC8gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcbiAgcmV0dXJuIE1hdGguYWJzKGFuZ2xlZFdpZHRoKTtcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0QW5nbGVkUmVjdGFuZ2xlV2lkdGgiLCJmb3JtYXRBeGlzTWFwIiwiY3JlYXRlTGFiZWxlZFNjYWxlcyIsIlNjYWxlSGVscGVyIiwibm9ybWFsaXplQW5nbGUiLCJyZWN0V2l0aFBvaW50cyIsInJlY3RXaXRoQ29vcmRzIiwiX21hcFZhbHVlcyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2V2ZXJ5IiwiX0NoYXJ0VXRpbHMiLCJfUmVhY3RVdGlscyIsIl9EYXRhVXRpbHMiLCJfQmFyIiwib2JqIiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIm93bktleXMiLCJlIiwiciIsInQiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiY2FsbCIsIlN0cmluZyIsIk51bWJlciIsImF4aXNNYXAiLCJvZmZzZXQiLCJheGlzVHlwZSIsImNoYXJ0TmFtZSIsIndpZHRoIiwiaGVpZ2h0IiwibGF5b3V0IiwiY2hpbGRyZW4iLCJpZHMiLCJzdGVwcyIsImxlZnQiLCJsZWZ0TWlycm9yIiwicmlnaHQiLCJyaWdodE1pcnJvciIsInRvcCIsInRvcE1pcnJvciIsImJvdHRvbSIsImJvdHRvbU1pcnJvciIsImhhc0JhciIsImZpbmRDaGlsZEJ5VHlwZSIsIkJhciIsInJlZHVjZSIsInJlc3VsdCIsImlkIiwiYXhpcyIsIm9yaWVudGF0aW9uIiwiZG9tYWluIiwiX2F4aXMkcGFkZGluZyIsInBhZGRpbmciLCJtaXJyb3IiLCJyZXZlcnNlZCIsIm9mZnNldEtleSIsImNvbmNhdCIsImNhbGN1bGF0ZWRQYWRkaW5nIiwicmFuZ2UiLCJ4IiwieSIsIm5lZWRTcGFjZSIsInR5cGUiLCJkaWZmIiwic21hbGxlc3REaXN0YW5jZUJldHdlZW5WYWx1ZXMiLCJJbmZpbml0eSIsInNvcnRlZFZhbHVlcyIsImNhdGVnb3JpY2FsRG9tYWluIiwic29ydCIsImluZGV4IiwiTWF0aCIsIm1pbiIsImlzRmluaXRlIiwic21hbGxlc3REaXN0YW5jZUluUGVyY2VudCIsInJhbmdlV2lkdGgiLCJnYXAiLCJnZXRQZXJjZW50VmFsdWUiLCJiYXJDYXRlZ29yeUdhcCIsImhhbGZCYW5kIiwiX3BhcnNlU2NhbGUiLCJwYXJzZVNjYWxlIiwic2NhbGUiLCJyZWFsU2NhbGVUeXBlIiwiY2hlY2tEb21haW5PZlNjYWxlIiwidGlja3MiLCJnZXRUaWNrc09mU2NhbGUiLCJmaW5hbEF4aXMiLCJiYW5kU2l6ZSIsImdldEJhbmRTaXplT2ZBeGlzIiwiaGlkZSIsIl9yZWYiLCJfcmVmMiIsIngxIiwieTEiLCJ4MiIsInkyIiwiYWJzIiwiX3JlZjMiLCJnZXQiLCJiYW5kd2lkdGgiLCJfcmVmNCIsInVuZGVmaW5lZCIsImJhbmRBd2FyZSIsInBvc2l0aW9uIiwiX29mZnNldCIsIl9vZmZzZXQyIiwiaXNJblJhbmdlIiwiZmlyc3QiLCJsYXN0IiwiY3JlYXRlIiwib3B0aW9ucyIsInNjYWxlcyIsInJlcyIsImNvb3JkIiwiX3JlZjUiLCJsYWJlbCIsImFuZ2xlIiwiX3JlZjYiLCJub3JtYWxpemVkQW5nbGUiLCJhbmdsZVJhZGlhbnMiLCJQSSIsImFuZ2xlVGhyZXNob2xkIiwiYXRhbiIsImFuZ2xlZFdpZHRoIiwic2luIiwiY29zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/CartesianUtils.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/ChartUtils.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/util/ChartUtils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getCateCoordinateOfBar = exports.getBaseValueOfBar = exports.getBarSizeList = exports.getBarPosition = exports.getBandSizeOfAxis = exports.findPositionOfBar = exports.combineEventHandlers = exports.checkDomainOfScale = exports.calculateActiveTickIndex = exports.appendOffsetOfLegend = exports.MIN_VALUE_REG = exports.MAX_VALUE_REG = void 0;\nexports.getCateCoordinateOfLine = getCateCoordinateOfLine;\nexports.getCoordinatesOfGrid = void 0;\nexports.getDomainOfDataByKey = getDomainOfDataByKey;\nexports.getDomainOfStackGroups = exports.getDomainOfItemsWithSameAxis = exports.getDomainOfErrorBars = void 0;\nObject.defineProperty(exports, \"getLegendProps\", ({\n    enumerable: true,\n    get: function get() {\n        return _getLegendProps.getLegendProps;\n    }\n}));\nexports.getTooltipItem = exports.getTicksOfScale = exports.getTicksOfAxis = exports.getStackedDataOfItem = exports.getStackedData = exports.getStackGroupsByAxisId = exports.getMainColorOfGraphicItem = void 0;\nexports.getValueByDataKey = getValueByDataKey;\nexports.truncateByDomain = exports.parseSpecifiedDomain = exports.parseScale = exports.parseErrorBarsOfAxis = exports.parseDomainOfCategoryAxis = exports.offsetSign = exports.offsetPositive = exports.isCategoricalAxis = void 0;\nvar d3Scales = _interopRequireWildcard(__webpack_require__(/*! victory-vendor/d3-scale */ \"victory-vendor/d3-scale\"));\nvar _d3Shape = __webpack_require__(/*! victory-vendor/d3-shape */ \"victory-vendor/d3-shape\");\nvar _max = _interopRequireDefault(__webpack_require__(/*! lodash/max */ \"lodash/max\"));\nvar _min = _interopRequireDefault(__webpack_require__(/*! lodash/min */ \"lodash/min\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _isString = _interopRequireDefault(__webpack_require__(/*! lodash/isString */ \"lodash/isString\"));\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _flatMap = _interopRequireDefault(__webpack_require__(/*! lodash/flatMap */ \"lodash/flatMap\"));\nvar _isNaN = _interopRequireDefault(__webpack_require__(/*! lodash/isNaN */ \"lodash/isNaN\"));\nvar _upperFirst = _interopRequireDefault(__webpack_require__(/*! lodash/upperFirst */ \"lodash/upperFirst\"));\nvar _isEqual = _interopRequireDefault(__webpack_require__(/*! lodash/isEqual */ \"lodash/isEqual\"));\nvar _sortBy = _interopRequireDefault(__webpack_require__(/*! lodash/sortBy */ \"lodash/sortBy\"));\nvar _rechartsScale = __webpack_require__(/*! recharts-scale */ \"recharts-scale\");\nvar _ErrorBar = __webpack_require__(/*! ../cartesian/ErrorBar */ \"./node_modules/recharts/lib/cartesian/ErrorBar.js\");\nvar _DataUtils = __webpack_require__(/*! ./DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ./ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _getLegendProps = __webpack_require__(/*! ./getLegendProps */ \"./node_modules/recharts/lib/util/getLegendProps.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _getRequireWildcardCache(e) {\n    if (\"function\" != typeof WeakMap) return null;\n    var r = new WeakMap(), t = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n        return e ? t : r;\n    })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n    if (!r && e && e.__esModule) return e;\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return {\n        \"default\": e\n    };\n    var t = _getRequireWildcardCache(r);\n    if (t && t.has(e)) return t.get(e);\n    var n = {\n        __proto__: null\n    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var u in e)if (\"default\" !== u && ({}).hasOwnProperty.call(e, u)) {\n        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n    }\n    return n[\"default\"] = e, t && t.set(e, n), n;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} // TODO: Cause of circular dependency. Needs refactor.\n// import { RadiusAxisProps, AngleAxisProps } from '../polar/types';\n// Exported for backwards compatibility\nfunction getValueByDataKey(obj, dataKey, defaultValue) {\n    if ((0, _isNil[\"default\"])(obj) || (0, _isNil[\"default\"])(dataKey)) {\n        return defaultValue;\n    }\n    if ((0, _DataUtils.isNumOrStr)(dataKey)) {\n        return (0, _get[\"default\"])(obj, dataKey, defaultValue);\n    }\n    if ((0, _isFunction[\"default\"])(dataKey)) {\n        return dataKey(obj);\n    }\n    return defaultValue;\n}\n/**\n * Get domain of data by key.\n * @param  {Array}   data      The data displayed in the chart\n * @param  {String}  key       The unique key of a group of data\n * @param  {String}  type      The type of axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array} Domain of data\n */ function getDomainOfDataByKey(data, key, type, filterNil) {\n    var flattenData = (0, _flatMap[\"default\"])(data, function(entry) {\n        return getValueByDataKey(entry, key);\n    });\n    if (type === \"number\") {\n        // @ts-expect-error parseFloat type only accepts strings\n        var domain = flattenData.filter(function(entry) {\n            return (0, _DataUtils.isNumber)(entry) || parseFloat(entry);\n        });\n        return domain.length ? [\n            (0, _min[\"default\"])(domain),\n            (0, _max[\"default\"])(domain)\n        ] : [\n            Infinity,\n            -Infinity\n        ];\n    }\n    var validateData = filterNil ? flattenData.filter(function(entry) {\n        return !(0, _isNil[\"default\"])(entry);\n    }) : flattenData;\n    // Supports x-axis of Date type\n    return validateData.map(function(entry) {\n        return (0, _DataUtils.isNumOrStr)(entry) || entry instanceof Date ? entry : \"\";\n    });\n}\nvar calculateActiveTickIndex = exports.calculateActiveTickIndex = function calculateActiveTickIndex(coordinate) {\n    var _ticks$length;\n    var ticks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var unsortedTicks = arguments.length > 2 ? arguments[2] : undefined;\n    var axis = arguments.length > 3 ? arguments[3] : undefined;\n    var index = -1;\n    var len = (_ticks$length = ticks === null || ticks === void 0 ? void 0 : ticks.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;\n    // if there are 1 or less ticks ticks then the active tick is at index 0\n    if (len <= 1) {\n        return 0;\n    }\n    if (axis && axis.axisType === \"angleAxis\" && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {\n        var range = axis.range;\n        // ticks are distributed in a circle\n        for(var i = 0; i < len; i++){\n            var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n            var cur = unsortedTicks[i].coordinate;\n            var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n            var sameDirectionCoord = void 0;\n            if ((0, _DataUtils.mathSign)(cur - before) !== (0, _DataUtils.mathSign)(after - cur)) {\n                var diffInterval = [];\n                if ((0, _DataUtils.mathSign)(after - cur) === (0, _DataUtils.mathSign)(range[1] - range[0])) {\n                    sameDirectionCoord = after;\n                    var curInRange = cur + range[1] - range[0];\n                    diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n                    diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n                } else {\n                    sameDirectionCoord = before;\n                    var afterInRange = after + range[1] - range[0];\n                    diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n                    diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n                }\n                var sameInterval = [\n                    Math.min(cur, (sameDirectionCoord + cur) / 2),\n                    Math.max(cur, (sameDirectionCoord + cur) / 2)\n                ];\n                if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n                    index = unsortedTicks[i].index;\n                    break;\n                }\n            } else {\n                var minValue = Math.min(before, after);\n                var maxValue = Math.max(before, after);\n                if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2) {\n                    index = unsortedTicks[i].index;\n                    break;\n                }\n            }\n        }\n    } else {\n        // ticks are distributed in a single direction\n        for(var _i = 0; _i < len; _i++){\n            if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n                index = ticks[_i].index;\n                break;\n            }\n        }\n    }\n    return index;\n};\n/**\n * Get the main color of each graphic item\n * @param  {ReactElement} item A graphic item\n * @return {String}            Color\n */ var getMainColorOfGraphicItem = exports.getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n    var _item$type;\n    var _ref = item, displayName = _ref.type.displayName; // TODO: check if displayName is valid.\n    var defaultedProps = (_item$type = item.type) !== null && _item$type !== void 0 && _item$type.defaultProps ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n    var stroke = defaultedProps.stroke, fill = defaultedProps.fill;\n    var result;\n    switch(displayName){\n        case \"Line\":\n            result = stroke;\n            break;\n        case \"Area\":\n        case \"Radar\":\n            result = stroke && stroke !== \"none\" ? stroke : fill;\n            break;\n        default:\n            result = fill;\n            break;\n    }\n    return result;\n};\n/**\n * Calculate the size of all groups for stacked bar graph\n * @param  {Object} stackGroups The items grouped by axisId and stackId\n * @return {Object} The size of all groups\n */ var getBarSizeList = exports.getBarSizeList = function getBarSizeList(_ref2) {\n    var globalSize = _ref2.barSize, totalSize = _ref2.totalSize, _ref2$stackGroups = _ref2.stackGroups, stackGroups = _ref2$stackGroups === void 0 ? {} : _ref2$stackGroups;\n    if (!stackGroups) {\n        return {};\n    }\n    var result = {};\n    var numericAxisIds = Object.keys(stackGroups);\n    for(var i = 0, len = numericAxisIds.length; i < len; i++){\n        var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n        var stackIds = Object.keys(sgs);\n        for(var j = 0, sLen = stackIds.length; j < sLen; j++){\n            var _sgs$stackIds$j = sgs[stackIds[j]], items = _sgs$stackIds$j.items, cateAxisId = _sgs$stackIds$j.cateAxisId;\n            var barItems = items.filter(function(item) {\n                return (0, _ReactUtils.getDisplayName)(item.type).indexOf(\"Bar\") >= 0;\n            });\n            if (barItems && barItems.length) {\n                var barItemDefaultProps = barItems[0].type.defaultProps;\n                var barItemProps = barItemDefaultProps !== undefined ? _objectSpread(_objectSpread({}, barItemDefaultProps), barItems[0].props) : barItems[0].props;\n                var selfSize = barItemProps.barSize;\n                var cateId = barItemProps[cateAxisId];\n                if (!result[cateId]) {\n                    result[cateId] = [];\n                }\n                var barSize = (0, _isNil[\"default\"])(selfSize) ? globalSize : selfSize;\n                result[cateId].push({\n                    item: barItems[0],\n                    stackList: barItems.slice(1),\n                    barSize: (0, _isNil[\"default\"])(barSize) ? undefined : (0, _DataUtils.getPercentValue)(barSize, totalSize, 0)\n                });\n            }\n        }\n    }\n    return result;\n};\n/**\n * Calculate the size of each bar and offset between start of band and the bar\n *\n * @param  {number} bandSize is the size of area where bars can render\n * @param  {number | string} barGap is the gap size, as a percentage of `bandSize`.\n *                                  Can be defined as number or percent string\n * @param  {number | string} barCategoryGap is the gap size, as a percentage of `bandSize`.\n *                                  Can be defined as number or percent string\n * @param  {Array<object>} sizeList Sizes of all groups\n * @param  {number} maxBarSize The maximum size of each bar\n * @return {Array<object>} The size and offset of each bar\n */ var getBarPosition = exports.getBarPosition = function getBarPosition(_ref3) {\n    var barGap = _ref3.barGap, barCategoryGap = _ref3.barCategoryGap, bandSize = _ref3.bandSize, _ref3$sizeList = _ref3.sizeList, sizeList = _ref3$sizeList === void 0 ? [] : _ref3$sizeList, maxBarSize = _ref3.maxBarSize;\n    var len = sizeList.length;\n    if (len < 1) return null;\n    var realBarGap = (0, _DataUtils.getPercentValue)(barGap, bandSize, 0, true);\n    var result;\n    var initialValue = [];\n    // whether or not is barSize setted by user\n    if (sizeList[0].barSize === +sizeList[0].barSize) {\n        var useFull = false;\n        var fullBarSize = bandSize / len;\n        // @ts-expect-error the type check above does not check for type number explicitly\n        var sum = sizeList.reduce(function(res, entry) {\n            return res + entry.barSize || 0;\n        }, 0);\n        sum += (len - 1) * realBarGap;\n        if (sum >= bandSize) {\n            sum -= (len - 1) * realBarGap;\n            realBarGap = 0;\n        }\n        if (sum >= bandSize && fullBarSize > 0) {\n            useFull = true;\n            fullBarSize *= 0.9;\n            sum = len * fullBarSize;\n        }\n        var offset = (bandSize - sum) / 2 >> 0;\n        var prev = {\n            offset: offset - realBarGap,\n            size: 0\n        };\n        result = sizeList.reduce(function(res, entry) {\n            var newPosition = {\n                item: entry.item,\n                position: {\n                    offset: prev.offset + prev.size + realBarGap,\n                    // @ts-expect-error the type check above does not check for type number explicitly\n                    size: useFull ? fullBarSize : entry.barSize\n                }\n            };\n            var newRes = [].concat(_toConsumableArray(res), [\n                newPosition\n            ]);\n            prev = newRes[newRes.length - 1].position;\n            if (entry.stackList && entry.stackList.length) {\n                entry.stackList.forEach(function(item) {\n                    newRes.push({\n                        item: item,\n                        position: prev\n                    });\n                });\n            }\n            return newRes;\n        }, initialValue);\n    } else {\n        var _offset = (0, _DataUtils.getPercentValue)(barCategoryGap, bandSize, 0, true);\n        if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {\n            realBarGap = 0;\n        }\n        var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;\n        if (originalSize > 1) {\n            originalSize >>= 0;\n        }\n        var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n        result = sizeList.reduce(function(res, entry, i) {\n            var newRes = [].concat(_toConsumableArray(res), [\n                {\n                    item: entry.item,\n                    position: {\n                        offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n                        size: size\n                    }\n                }\n            ]);\n            if (entry.stackList && entry.stackList.length) {\n                entry.stackList.forEach(function(item) {\n                    newRes.push({\n                        item: item,\n                        position: newRes[newRes.length - 1].position\n                    });\n                });\n            }\n            return newRes;\n        }, initialValue);\n    }\n    return result;\n};\nvar appendOffsetOfLegend = exports.appendOffsetOfLegend = function appendOffsetOfLegend(offset, _unused, props, legendBox) {\n    var children = props.children, width = props.width, margin = props.margin;\n    var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n    var legendProps = (0, _getLegendProps.getLegendProps)({\n        children: children,\n        legendWidth: legendWidth\n    });\n    if (legendProps) {\n        var _ref4 = legendBox || {}, boxWidth = _ref4.width, boxHeight = _ref4.height;\n        var align = legendProps.align, verticalAlign = legendProps.verticalAlign, layout = legendProps.layout;\n        if ((layout === \"vertical\" || layout === \"horizontal\" && verticalAlign === \"middle\") && align !== \"center\" && (0, _DataUtils.isNumber)(offset[align])) {\n            return _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, align, offset[align] + (boxWidth || 0)));\n        }\n        if ((layout === \"horizontal\" || layout === \"vertical\" && align === \"center\") && verticalAlign !== \"middle\" && (0, _DataUtils.isNumber)(offset[verticalAlign])) {\n            return _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, verticalAlign, offset[verticalAlign] + (boxHeight || 0)));\n        }\n    }\n    return offset;\n};\nvar isErrorBarRelevantForAxis = function isErrorBarRelevantForAxis(layout, axisType, direction) {\n    if ((0, _isNil[\"default\"])(axisType)) {\n        return true;\n    }\n    if (layout === \"horizontal\") {\n        return axisType === \"yAxis\";\n    }\n    if (layout === \"vertical\") {\n        return axisType === \"xAxis\";\n    }\n    if (direction === \"x\") {\n        return axisType === \"xAxis\";\n    }\n    if (direction === \"y\") {\n        return axisType === \"yAxis\";\n    }\n    return true;\n};\nvar getDomainOfErrorBars = exports.getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, layout, axisType) {\n    var children = item.props.children;\n    var errorBars = (0, _ReactUtils.findAllByType)(children, _ErrorBar.ErrorBar).filter(function(errorBarChild) {\n        return isErrorBarRelevantForAxis(layout, axisType, errorBarChild.props.direction);\n    });\n    if (errorBars && errorBars.length) {\n        var keys = errorBars.map(function(errorBarChild) {\n            return errorBarChild.props.dataKey;\n        });\n        return data.reduce(function(result, entry) {\n            var entryValue = getValueByDataKey(entry, dataKey);\n            if ((0, _isNil[\"default\"])(entryValue)) return result;\n            var mainValue = Array.isArray(entryValue) ? [\n                (0, _min[\"default\"])(entryValue),\n                (0, _max[\"default\"])(entryValue)\n            ] : [\n                entryValue,\n                entryValue\n            ];\n            var errorDomain = keys.reduce(function(prevErrorArr, k) {\n                var errorValue = getValueByDataKey(entry, k, 0);\n                var lowerValue = mainValue[0] - Math.abs(Array.isArray(errorValue) ? errorValue[0] : errorValue);\n                var upperValue = mainValue[1] + Math.abs(Array.isArray(errorValue) ? errorValue[1] : errorValue);\n                return [\n                    Math.min(lowerValue, prevErrorArr[0]),\n                    Math.max(upperValue, prevErrorArr[1])\n                ];\n            }, [\n                Infinity,\n                -Infinity\n            ]);\n            return [\n                Math.min(errorDomain[0], result[0]),\n                Math.max(errorDomain[1], result[1])\n            ];\n        }, [\n            Infinity,\n            -Infinity\n        ]);\n    }\n    return null;\n};\nvar parseErrorBarsOfAxis = exports.parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType, layout) {\n    var domains = items.map(function(item) {\n        return getDomainOfErrorBars(data, item, dataKey, layout, axisType);\n    }).filter(function(entry) {\n        return !(0, _isNil[\"default\"])(entry);\n    });\n    if (domains && domains.length) {\n        return domains.reduce(function(result, entry) {\n            return [\n                Math.min(result[0], entry[0]),\n                Math.max(result[1], entry[1])\n            ];\n        }, [\n            Infinity,\n            -Infinity\n        ]);\n    }\n    return null;\n};\n/**\n * Get domain of data by the configuration of item element\n * @param  {Array}   data      The data displayed in the chart\n * @param  {Array}   items     The instances of item\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\n * @param  {LayoutType} layout The type of layout\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array}        Domain\n */ var getDomainOfItemsWithSameAxis = exports.getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, layout, filterNil) {\n    var domains = items.map(function(item) {\n        var dataKey = item.props.dataKey;\n        if (type === \"number\" && dataKey) {\n            return getDomainOfErrorBars(data, item, dataKey, layout) || getDomainOfDataByKey(data, dataKey, type, filterNil);\n        }\n        return getDomainOfDataByKey(data, dataKey, type, filterNil);\n    });\n    if (type === \"number\") {\n        // Calculate the domain of number axis\n        return domains.reduce(// @ts-expect-error if (type === number) means that the domain is numerical type\n        // - but this link is missing in the type definition\n        function(result, entry) {\n            return [\n                Math.min(result[0], entry[0]),\n                Math.max(result[1], entry[1])\n            ];\n        }, [\n            Infinity,\n            -Infinity\n        ]);\n    }\n    var tag = {};\n    // Get the union set of category axis\n    return domains.reduce(function(result, entry) {\n        for(var i = 0, len = entry.length; i < len; i++){\n            // @ts-expect-error Date cannot index an object\n            if (!tag[entry[i]]) {\n                // @ts-expect-error Date cannot index an object\n                tag[entry[i]] = true;\n                // @ts-expect-error Date cannot index an object\n                result.push(entry[i]);\n            }\n        }\n        return result;\n    }, []);\n};\nvar isCategoricalAxis = exports.isCategoricalAxis = function isCategoricalAxis(layout, axisType) {\n    return layout === \"horizontal\" && axisType === \"xAxis\" || layout === \"vertical\" && axisType === \"yAxis\" || layout === \"centric\" && axisType === \"angleAxis\" || layout === \"radial\" && axisType === \"radiusAxis\";\n};\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks           The ticks in axis\n * @param {Number} minValue        The minimun value of axis\n * @param {Number} maxValue        The maximun value of axis\n * @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not\n * @return {Array}                 Coordinates\n */ var getCoordinatesOfGrid = exports.getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, minValue, maxValue, syncWithTicks) {\n    if (syncWithTicks) {\n        return ticks.map(function(entry) {\n            return entry.coordinate;\n        });\n    }\n    var hasMin, hasMax;\n    var values = ticks.map(function(entry) {\n        if (entry.coordinate === minValue) {\n            hasMin = true;\n        }\n        if (entry.coordinate === maxValue) {\n            hasMax = true;\n        }\n        return entry.coordinate;\n    });\n    if (!hasMin) {\n        values.push(minValue);\n    }\n    if (!hasMax) {\n        values.push(maxValue);\n    }\n    return values;\n};\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */ var getTicksOfAxis = exports.getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n    if (!axis) return null;\n    var scale = axis.scale;\n    var duplicateDomain = axis.duplicateDomain, type = axis.type, range = axis.range;\n    var offsetForBand = axis.realScaleType === \"scaleBand\" ? scale.bandwidth() / 2 : 2;\n    var offset = (isGrid || isAll) && type === \"category\" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n    offset = axis.axisType === \"angleAxis\" && (range === null || range === void 0 ? void 0 : range.length) >= 2 ? (0, _DataUtils.mathSign)(range[0] - range[1]) * 2 * offset : offset;\n    // The ticks set by user should only affect the ticks adjacent to axis line\n    if (isGrid && (axis.ticks || axis.niceTicks)) {\n        var result = (axis.ticks || axis.niceTicks).map(function(entry) {\n            var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n            return {\n                // If the scaleContent is not a number, the coordinate will be NaN.\n                // That could be the case for example with a PointScale and a string as domain.\n                coordinate: scale(scaleContent) + offset,\n                value: entry,\n                offset: offset\n            };\n        });\n        return result.filter(function(row) {\n            return !(0, _isNaN[\"default\"])(row.coordinate);\n        });\n    }\n    // When axis is a categorial axis, but the type of axis is number or the scale of axis is not \"auto\"\n    if (axis.isCategorical && axis.categoricalDomain) {\n        return axis.categoricalDomain.map(function(entry, index) {\n            return {\n                coordinate: scale(entry) + offset,\n                value: entry,\n                index: index,\n                offset: offset\n            };\n        });\n    }\n    if (scale.ticks && !isAll) {\n        return scale.ticks(axis.tickCount).map(function(entry) {\n            return {\n                coordinate: scale(entry) + offset,\n                value: entry,\n                offset: offset\n            };\n        });\n    }\n    // When axis has duplicated text, serial numbers are used to generate scale\n    return scale.domain().map(function(entry, index) {\n        return {\n            coordinate: scale(entry) + offset,\n            value: duplicateDomain ? duplicateDomain[entry] : entry,\n            index: index,\n            offset: offset\n        };\n    });\n};\n/**\n * combine the handlers\n * @param  {Function} defaultHandler Internal private handler\n * @param  {Function} childHandler Handler function specified in child component\n * @return {Function}                The combined handler\n */ var handlerWeakMap = new WeakMap();\nvar combineEventHandlers = exports.combineEventHandlers = function combineEventHandlers(defaultHandler, childHandler) {\n    if (typeof childHandler !== \"function\") {\n        return defaultHandler;\n    }\n    if (!handlerWeakMap.has(defaultHandler)) {\n        handlerWeakMap.set(defaultHandler, new WeakMap());\n    }\n    var childWeakMap = handlerWeakMap.get(defaultHandler);\n    if (childWeakMap.has(childHandler)) {\n        return childWeakMap.get(childHandler);\n    }\n    var combineHandler = function combineHandler() {\n        defaultHandler.apply(void 0, arguments);\n        childHandler.apply(void 0, arguments);\n    };\n    childWeakMap.set(childHandler, combineHandler);\n    return combineHandler;\n};\n/**\n * Parse the scale function of axis\n * @param  {Object}   axis          The option of axis\n * @param  {String}   chartType     The displayName of chart\n * @param  {Boolean}  hasBar        if it has a bar\n * @return {object}               The scale function and resolved name\n */ var parseScale = exports.parseScale = function parseScale(axis, chartType, hasBar) {\n    var scale = axis.scale, type = axis.type, layout = axis.layout, axisType = axis.axisType;\n    if (scale === \"auto\") {\n        if (layout === \"radial\" && axisType === \"radiusAxis\") {\n            return {\n                scale: d3Scales.scaleBand(),\n                realScaleType: \"band\"\n            };\n        }\n        if (layout === \"radial\" && axisType === \"angleAxis\") {\n            return {\n                scale: d3Scales.scaleLinear(),\n                realScaleType: \"linear\"\n            };\n        }\n        if (type === \"category\" && chartType && (chartType.indexOf(\"LineChart\") >= 0 || chartType.indexOf(\"AreaChart\") >= 0 || chartType.indexOf(\"ComposedChart\") >= 0 && !hasBar)) {\n            return {\n                scale: d3Scales.scalePoint(),\n                realScaleType: \"point\"\n            };\n        }\n        if (type === \"category\") {\n            return {\n                scale: d3Scales.scaleBand(),\n                realScaleType: \"band\"\n            };\n        }\n        return {\n            scale: d3Scales.scaleLinear(),\n            realScaleType: \"linear\"\n        };\n    }\n    if ((0, _isString[\"default\"])(scale)) {\n        var name = \"scale\".concat((0, _upperFirst[\"default\"])(scale));\n        return {\n            scale: (d3Scales[name] || d3Scales.scalePoint)(),\n            realScaleType: d3Scales[name] ? name : \"point\"\n        };\n    }\n    return (0, _isFunction[\"default\"])(scale) ? {\n        scale: scale\n    } : {\n        scale: d3Scales.scalePoint(),\n        realScaleType: \"point\"\n    };\n};\nvar EPS = 1e-4;\nvar checkDomainOfScale = exports.checkDomainOfScale = function checkDomainOfScale(scale) {\n    var domain = scale.domain();\n    if (!domain || domain.length <= 2) {\n        return;\n    }\n    var len = domain.length;\n    var range = scale.range();\n    var minValue = Math.min(range[0], range[1]) - EPS;\n    var maxValue = Math.max(range[0], range[1]) + EPS;\n    var first = scale(domain[0]);\n    var last = scale(domain[len - 1]);\n    if (first < minValue || first > maxValue || last < minValue || last > maxValue) {\n        scale.domain([\n            domain[0],\n            domain[len - 1]\n        ]);\n    }\n};\nvar findPositionOfBar = exports.findPositionOfBar = function findPositionOfBar(barPosition, child) {\n    if (!barPosition) {\n        return null;\n    }\n    for(var i = 0, len = barPosition.length; i < len; i++){\n        if (barPosition[i].item === child) {\n            return barPosition[i].position;\n        }\n    }\n    return null;\n};\n/**\n * Both value and domain are tuples of two numbers\n * - but the type stays as array of numbers until we have better support in rest of the app\n * @param {Array} value input that will be truncated\n * @param {Array} domain boundaries\n * @returns {Array} tuple of two numbers\n */ var truncateByDomain = exports.truncateByDomain = function truncateByDomain(value, domain) {\n    if (!domain || domain.length !== 2 || !(0, _DataUtils.isNumber)(domain[0]) || !(0, _DataUtils.isNumber)(domain[1])) {\n        return value;\n    }\n    var minValue = Math.min(domain[0], domain[1]);\n    var maxValue = Math.max(domain[0], domain[1]);\n    var result = [\n        value[0],\n        value[1]\n    ];\n    if (!(0, _DataUtils.isNumber)(value[0]) || value[0] < minValue) {\n        result[0] = minValue;\n    }\n    if (!(0, _DataUtils.isNumber)(value[1]) || value[1] > maxValue) {\n        result[1] = maxValue;\n    }\n    if (result[0] > maxValue) {\n        result[0] = maxValue;\n    }\n    if (result[1] < minValue) {\n        result[1] = minValue;\n    }\n    return result;\n};\n/**\n * Stacks all positive numbers above zero and all negative numbers below zero.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */ var offsetSign = exports.offsetSign = function offsetSign(series) {\n    var n = series.length;\n    if (n <= 0) {\n        return;\n    }\n    for(var j = 0, m = series[0].length; j < m; ++j){\n        var positive = 0;\n        var negative = 0;\n        for(var i = 0; i < n; ++i){\n            var value = (0, _isNaN[\"default\"])(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n            /* eslint-disable prefer-destructuring, no-param-reassign */ if (value >= 0) {\n                series[i][j][0] = positive;\n                series[i][j][1] = positive + value;\n                positive = series[i][j][1];\n            } else {\n                series[i][j][0] = negative;\n                series[i][j][1] = negative + value;\n                negative = series[i][j][1];\n            }\n        /* eslint-enable prefer-destructuring, no-param-reassign */ }\n    }\n};\n/**\n * Replaces all negative values with zero when stacking data.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */ var offsetPositive = exports.offsetPositive = function offsetPositive(series) {\n    var n = series.length;\n    if (n <= 0) {\n        return;\n    }\n    for(var j = 0, m = series[0].length; j < m; ++j){\n        var positive = 0;\n        for(var i = 0; i < n; ++i){\n            var value = (0, _isNaN[\"default\"])(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n            /* eslint-disable prefer-destructuring, no-param-reassign */ if (value >= 0) {\n                series[i][j][0] = positive;\n                series[i][j][1] = positive + value;\n                positive = series[i][j][1];\n            } else {\n                series[i][j][0] = 0;\n                series[i][j][1] = 0;\n            }\n        /* eslint-enable prefer-destructuring, no-param-reassign */ }\n    }\n};\n/**\n * Function type to compute offset for stacked data.\n *\n * d3-shape has something fishy going on with its types.\n * In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.\n * However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.\n * The same I can see in the source code itself:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n * That one unfortunately has no types but we can tell it passes three-dimensional array.\n *\n * Which leads me to believe that definitelytyped is wrong on this one.\n * There's open discussion on this topic without much attention:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n */ var STACK_OFFSET_MAP = {\n    sign: offsetSign,\n    // @ts-expect-error definitelytyped types are incorrect\n    expand: _d3Shape.stackOffsetExpand,\n    // @ts-expect-error definitelytyped types are incorrect\n    none: _d3Shape.stackOffsetNone,\n    // @ts-expect-error definitelytyped types are incorrect\n    silhouette: _d3Shape.stackOffsetSilhouette,\n    // @ts-expect-error definitelytyped types are incorrect\n    wiggle: _d3Shape.stackOffsetWiggle,\n    positive: offsetPositive\n};\nvar getStackedData = exports.getStackedData = function getStackedData(data, stackItems, offsetType) {\n    var dataKeys = stackItems.map(function(item) {\n        return item.props.dataKey;\n    });\n    var offsetAccessor = STACK_OFFSET_MAP[offsetType];\n    var stack = (0, _d3Shape.stack)()// @ts-expect-error stack.keys type wants an array of strings, but we provide array of DataKeys\n    .keys(dataKeys).value(function(d, key) {\n        return +getValueByDataKey(d, key, 0);\n    }).order(_d3Shape.stackOrderNone)// @ts-expect-error definitelytyped types are incorrect\n    .offset(offsetAccessor);\n    return stack(data);\n};\nvar getStackGroupsByAxisId = exports.getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {\n    if (!data) {\n        return null;\n    }\n    // reversing items to affect render order (for layering)\n    var items = reverseStackOrder ? _items.reverse() : _items;\n    var parentStackGroupsInitialValue = {};\n    var stackGroups = items.reduce(function(result, item) {\n        var _item$type2;\n        var defaultedProps = (_item$type2 = item.type) !== null && _item$type2 !== void 0 && _item$type2.defaultProps ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n        var stackId = defaultedProps.stackId, hide = defaultedProps.hide;\n        if (hide) {\n            return result;\n        }\n        var axisId = defaultedProps[numericAxisId];\n        var parentGroup = result[axisId] || {\n            hasStack: false,\n            stackGroups: {}\n        };\n        if ((0, _DataUtils.isNumOrStr)(stackId)) {\n            var childGroup = parentGroup.stackGroups[stackId] || {\n                numericAxisId: numericAxisId,\n                cateAxisId: cateAxisId,\n                items: []\n            };\n            childGroup.items.push(item);\n            parentGroup.hasStack = true;\n            parentGroup.stackGroups[stackId] = childGroup;\n        } else {\n            parentGroup.stackGroups[(0, _DataUtils.uniqueId)(\"_stackId_\")] = {\n                numericAxisId: numericAxisId,\n                cateAxisId: cateAxisId,\n                items: [\n                    item\n                ]\n            };\n        }\n        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, parentGroup));\n    }, parentStackGroupsInitialValue);\n    var axisStackGroupsInitialValue = {};\n    return Object.keys(stackGroups).reduce(function(result, axisId) {\n        var group = stackGroups[axisId];\n        if (group.hasStack) {\n            var stackGroupsInitialValue = {};\n            group.stackGroups = Object.keys(group.stackGroups).reduce(function(res, stackId) {\n                var g = group.stackGroups[stackId];\n                return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, stackId, {\n                    numericAxisId: numericAxisId,\n                    cateAxisId: cateAxisId,\n                    items: g.items,\n                    stackedData: getStackedData(data, g.items, offsetType)\n                }));\n            }, stackGroupsInitialValue);\n        }\n        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, group));\n    }, axisStackGroupsInitialValue);\n};\n/**\n * Configure the scale function of axis\n * @param {Object} scale The scale function\n * @param {Object} opts  The configuration of axis\n * @return {Object}      null\n */ var getTicksOfScale = exports.getTicksOfScale = function getTicksOfScale(scale, opts) {\n    var realScaleType = opts.realScaleType, type = opts.type, tickCount = opts.tickCount, originalDomain = opts.originalDomain, allowDecimals = opts.allowDecimals;\n    var scaleType = realScaleType || opts.scale;\n    if (scaleType !== \"auto\" && scaleType !== \"linear\") {\n        return null;\n    }\n    if (tickCount && type === \"number\" && originalDomain && (originalDomain[0] === \"auto\" || originalDomain[1] === \"auto\")) {\n        // Calculate the ticks by the number of grid when the axis is a number axis\n        var domain = scale.domain();\n        if (!domain.length) {\n            return null;\n        }\n        var tickValues = (0, _rechartsScale.getNiceTickValues)(domain, tickCount, allowDecimals);\n        scale.domain([\n            (0, _min[\"default\"])(tickValues),\n            (0, _max[\"default\"])(tickValues)\n        ]);\n        return {\n            niceTicks: tickValues\n        };\n    }\n    if (tickCount && type === \"number\") {\n        var _domain = scale.domain();\n        var _tickValues = (0, _rechartsScale.getTickValuesFixedDomain)(_domain, tickCount, allowDecimals);\n        return {\n            niceTicks: _tickValues\n        };\n    }\n    return null;\n};\nfunction getCateCoordinateOfLine(_ref5) {\n    var axis = _ref5.axis, ticks = _ref5.ticks, bandSize = _ref5.bandSize, entry = _ref5.entry, index = _ref5.index, dataKey = _ref5.dataKey;\n    if (axis.type === \"category\") {\n        // find coordinate of category axis by the value of category\n        // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n        if (!axis.allowDuplicatedCategory && axis.dataKey && !(0, _isNil[\"default\"])(entry[axis.dataKey])) {\n            // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n            var matchedTick = (0, _DataUtils.findEntryInArray)(ticks, \"value\", entry[axis.dataKey]);\n            if (matchedTick) {\n                return matchedTick.coordinate + bandSize / 2;\n            }\n        }\n        return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n    }\n    var value = getValueByDataKey(entry, !(0, _isNil[\"default\"])(dataKey) ? dataKey : axis.dataKey);\n    return !(0, _isNil[\"default\"])(value) ? axis.scale(value) : null;\n}\nvar getCateCoordinateOfBar = exports.getCateCoordinateOfBar = function getCateCoordinateOfBar(_ref6) {\n    var axis = _ref6.axis, ticks = _ref6.ticks, offset = _ref6.offset, bandSize = _ref6.bandSize, entry = _ref6.entry, index = _ref6.index;\n    if (axis.type === \"category\") {\n        return ticks[index] ? ticks[index].coordinate + offset : null;\n    }\n    var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);\n    return !(0, _isNil[\"default\"])(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nvar getBaseValueOfBar = exports.getBaseValueOfBar = function getBaseValueOfBar(_ref7) {\n    var numericAxis = _ref7.numericAxis;\n    var domain = numericAxis.scale.domain();\n    if (numericAxis.type === \"number\") {\n        var minValue = Math.min(domain[0], domain[1]);\n        var maxValue = Math.max(domain[0], domain[1]);\n        if (minValue <= 0 && maxValue >= 0) {\n            return 0;\n        }\n        if (maxValue < 0) {\n            return maxValue;\n        }\n        return minValue;\n    }\n    return domain[0];\n};\nvar getStackedDataOfItem = exports.getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n    var _item$type3;\n    var defaultedProps = (_item$type3 = item.type) !== null && _item$type3 !== void 0 && _item$type3.defaultProps ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n    var stackId = defaultedProps.stackId;\n    if ((0, _DataUtils.isNumOrStr)(stackId)) {\n        var group = stackGroups[stackId];\n        if (group) {\n            var itemIndex = group.items.indexOf(item);\n            return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n        }\n    }\n    return null;\n};\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n    return data.reduce(function(result, entry) {\n        return [\n            (0, _min[\"default\"])(entry.concat([\n                result[0]\n            ]).filter(_DataUtils.isNumber)),\n            (0, _max[\"default\"])(entry.concat([\n                result[1]\n            ]).filter(_DataUtils.isNumber))\n        ];\n    }, [\n        Infinity,\n        -Infinity\n    ]);\n};\nvar getDomainOfStackGroups = exports.getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n    return Object.keys(stackGroups).reduce(function(result, stackId) {\n        var group = stackGroups[stackId];\n        var stackedData = group.stackedData;\n        var domain = stackedData.reduce(function(res, entry) {\n            var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n            return [\n                Math.min(res[0], s[0]),\n                Math.max(res[1], s[1])\n            ];\n        }, [\n            Infinity,\n            -Infinity\n        ]);\n        return [\n            Math.min(domain[0], result[0]),\n            Math.max(domain[1], result[1])\n        ];\n    }, [\n        Infinity,\n        -Infinity\n    ]).map(function(result) {\n        return result === Infinity || result === -Infinity ? 0 : result;\n    });\n};\nvar MIN_VALUE_REG = exports.MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nvar MAX_VALUE_REG = exports.MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nvar parseSpecifiedDomain = exports.parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {\n    if ((0, _isFunction[\"default\"])(specifiedDomain)) {\n        return specifiedDomain(dataDomain, allowDataOverflow);\n    }\n    if (!Array.isArray(specifiedDomain)) {\n        return dataDomain;\n    }\n    var domain = [];\n    /* eslint-disable prefer-destructuring */ if ((0, _DataUtils.isNumber)(specifiedDomain[0])) {\n        domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);\n    } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {\n        var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];\n        domain[0] = dataDomain[0] - value;\n    } else if ((0, _isFunction[\"default\"])(specifiedDomain[0])) {\n        domain[0] = specifiedDomain[0](dataDomain[0]);\n    } else {\n        domain[0] = dataDomain[0];\n    }\n    if ((0, _DataUtils.isNumber)(specifiedDomain[1])) {\n        domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);\n    } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {\n        var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];\n        domain[1] = dataDomain[1] + _value;\n    } else if ((0, _isFunction[\"default\"])(specifiedDomain[1])) {\n        domain[1] = specifiedDomain[1](dataDomain[1]);\n    } else {\n        domain[1] = dataDomain[1];\n    }\n    /* eslint-enable prefer-destructuring */ return domain;\n};\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */ var getBandSizeOfAxis = exports.getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks, isBar) {\n    // @ts-expect-error we need to rethink scale type\n    if (axis && axis.scale && axis.scale.bandwidth) {\n        // @ts-expect-error we need to rethink scale type\n        var bandWidth = axis.scale.bandwidth();\n        if (!isBar || bandWidth > 0) {\n            return bandWidth;\n        }\n    }\n    if (axis && ticks && ticks.length >= 2) {\n        var orderedTicks = (0, _sortBy[\"default\"])(ticks, function(o) {\n            return o.coordinate;\n        });\n        var bandSize = Infinity;\n        for(var i = 1, len = orderedTicks.length; i < len; i++){\n            var cur = orderedTicks[i];\n            var prev = orderedTicks[i - 1];\n            bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n        }\n        return bandSize === Infinity ? 0 : bandSize;\n    }\n    return isBar ? undefined : 0;\n};\n/**\n * parse the domain of a category axis when a domain is specified\n * @param   {Array}        specifiedDomain  The domain specified by users\n * @param   {Array}        calculatedDomain The domain calculated by dateKey\n * @param   {ReactElement} axisChild        The axis ReactElement\n * @returns {Array}        domains\n */ var parseDomainOfCategoryAxis = exports.parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {\n    if (!specifiedDomain || !specifiedDomain.length) {\n        return calculatedDomain;\n    }\n    if ((0, _isEqual[\"default\"])(specifiedDomain, (0, _get[\"default\"])(axisChild, \"type.defaultProps.domain\"))) {\n        return calculatedDomain;\n    }\n    return specifiedDomain;\n};\nvar getTooltipItem = exports.getTooltipItem = function getTooltipItem(graphicalItem, payload) {\n    var defaultedProps = graphicalItem.type.defaultProps ? _objectSpread(_objectSpread({}, graphicalItem.type.defaultProps), graphicalItem.props) : graphicalItem.props;\n    var dataKey = defaultedProps.dataKey, name = defaultedProps.name, unit = defaultedProps.unit, formatter = defaultedProps.formatter, tooltipType = defaultedProps.tooltipType, chartType = defaultedProps.chartType, hide = defaultedProps.hide;\n    return _objectSpread(_objectSpread({}, (0, _ReactUtils.filterProps)(graphicalItem, false)), {}, {\n        dataKey: dataKey,\n        unit: unit,\n        formatter: formatter,\n        name: name || dataKey,\n        color: getMainColorOfGraphicItem(graphicalItem),\n        value: getValueByDataKey(payload, dataKey),\n        type: tooltipType,\n        payload: payload,\n        chartType: chartType,\n        hide: hide\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvQ2hhcnRVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsOEJBQThCLEdBQUdBLHlCQUF5QixHQUFHQSxzQkFBc0IsR0FBR0Esc0JBQXNCLEdBQUdBLHlCQUF5QixHQUFHQSx5QkFBeUIsR0FBR0EsNEJBQTRCLEdBQUdBLDBCQUEwQixHQUFHQSxnQ0FBZ0MsR0FBR0EsNEJBQTRCLEdBQUdBLHFCQUFxQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQzFWQSwrQkFBK0IsR0FBR2M7QUFDbENkLDRCQUE0QixHQUFHLEtBQUs7QUFDcENBLDRCQUE0QixHQUFHZ0I7QUFDL0JoQiw4QkFBOEIsR0FBR0Esb0NBQW9DLEdBQUdBLDRCQUE0QixHQUFHLEtBQUs7QUFDNUdGLGtEQUFpRDtJQUMvQ3NCLFlBQVk7SUFDWkMsS0FBSyxTQUFTQTtRQUNaLE9BQU9DLGdCQUFnQkMsY0FBYztJQUN2QztBQUNGLENBQUMsRUFBQztBQUNGdkIsc0JBQXNCLEdBQUdBLHVCQUF1QixHQUFHQSxzQkFBc0IsR0FBR0EsNEJBQTRCLEdBQUdBLHNCQUFzQixHQUFHQSw4QkFBOEIsR0FBR0EsaUNBQWlDLEdBQUcsS0FBSztBQUM5TUEseUJBQXlCLEdBQUcrQjtBQUM1Qi9CLHdCQUF3QixHQUFHQSw0QkFBNEIsR0FBR0Esa0JBQWtCLEdBQUdBLDRCQUE0QixHQUFHQSxpQ0FBaUMsR0FBR0Esa0JBQWtCLEdBQUdBLHNCQUFzQixHQUFHQSx5QkFBeUIsR0FBRyxLQUFLO0FBQ2pPLElBQUl3QyxXQUFXQyx3QkFBd0JDLG1CQUFPQSxDQUFDLHdEQUF5QjtBQUN4RSxJQUFJQyxXQUFXRCxtQkFBT0EsQ0FBQyx3REFBeUI7QUFDaEQsSUFBSUUsT0FBT0MsdUJBQXVCSCxtQkFBT0EsQ0FBQyw4QkFBWTtBQUN0RCxJQUFJSSxPQUFPRCx1QkFBdUJILG1CQUFPQSxDQUFD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IndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvQ2hhcnRVdGlscy5qcz85ZTFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRDYXRlQ29vcmRpbmF0ZU9mQmFyID0gZXhwb3J0cy5nZXRCYXNlVmFsdWVPZkJhciA9IGV4cG9ydHMuZ2V0QmFyU2l6ZUxpc3QgPSBleHBvcnRzLmdldEJhclBvc2l0aW9uID0gZXhwb3J0cy5nZXRCYW5kU2l6ZU9mQXhpcyA9IGV4cG9ydHMuZmluZFBvc2l0aW9uT2ZCYXIgPSBleHBvcnRzLmNvbWJpbmVFdmVudEhhbmRsZXJzID0gZXhwb3J0cy5jaGVja0RvbWFpbk9mU2NhbGUgPSBleHBvcnRzLmNhbGN1bGF0ZUFjdGl2ZVRpY2tJbmRleCA9IGV4cG9ydHMuYXBwZW5kT2Zmc2V0T2ZMZWdlbmQgPSBleHBvcnRzLk1JTl9WQUxVRV9SRUcgPSBleHBvcnRzLk1BWF9WQUxVRV9SRUcgPSB2b2lkIDA7XG5leHBvcnRzLmdldENhdGVDb29yZGluYXRlT2ZMaW5lID0gZ2V0Q2F0ZUNvb3JkaW5hdGVPZkxpbmU7XG5leHBvcnRzLmdldENvb3JkaW5hdGVzT2ZHcmlkID0gdm9pZCAwO1xuZXhwb3J0cy5nZXREb21haW5PZkRhdGFCeUtleSA9IGdldERvbWFpbk9mRGF0YUJ5S2V5O1xuZXhwb3J0cy5nZXREb21haW5PZlN0YWNrR3JvdXBzID0gZXhwb3J0cy5nZXREb21haW5PZkl0ZW1zV2l0aFNhbWVBeGlzID0gZXhwb3J0cy5nZXREb21haW5PZkVycm9yQmFycyA9IHZvaWQgMDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldExlZ2VuZFByb3BzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXRMZWdlbmRQcm9wcy5nZXRMZWdlbmRQcm9wcztcbiAgfVxufSk7XG5leHBvcnRzLmdldFRvb2x0aXBJdGVtID0gZXhwb3J0cy5nZXRUaWNrc09mU2NhbGUgPSBleHBvcnRzLmdldFRpY2tzT2ZBeGlzID0gZXhwb3J0cy5nZXRTdGFja2VkRGF0YU9mSXRlbSA9IGV4cG9ydHMuZ2V0U3RhY2tlZERhdGEgPSBleHBvcnRzLmdldFN0YWNrR3JvdXBzQnlBeGlzSWQgPSBleHBvcnRzLmdldE1haW5Db2xvck9mR3JhcGhpY0l0ZW0gPSB2b2lkIDA7XG5leHBvcnRzLmdldFZhbHVlQnlEYXRhS2V5ID0gZ2V0VmFsdWVCeURhdGFLZXk7XG5leHBvcnRzLnRydW5jYXRlQnlEb21haW4gPSBleHBvcnRzLnBhcnNlU3BlY2lmaWVkRG9tYWluID0gZXhwb3J0cy5wYXJzZVNjYWxlID0gZXhwb3J0cy5wYXJzZUVycm9yQmFyc09mQXhpcyA9IGV4cG9ydHMucGFyc2VEb21haW5PZkNhdGVnb3J5QXhpcyA9IGV4cG9ydHMub2Zmc2V0U2lnbiA9IGV4cG9ydHMub2Zmc2V0UG9zaXRpdmUgPSBleHBvcnRzLmlzQ2F0ZWdvcmljYWxBeGlzID0gdm9pZCAwO1xudmFyIGQzU2NhbGVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInZpY3RvcnktdmVuZG9yL2QzLXNjYWxlXCIpKTtcbnZhciBfZDNTaGFwZSA9IHJlcXVpcmUoXCJ2aWN0b3J5LXZlbmRvci9kMy1zaGFwZVwiKTtcbnZhciBfbWF4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL21heFwiKSk7XG52YXIgX21pbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9taW5cIikpO1xudmFyIF9pc05pbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc05pbFwiKSk7XG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XG52YXIgX2lzU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzU3RyaW5nXCIpKTtcbnZhciBfZ2V0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2dldFwiKSk7XG52YXIgX2ZsYXRNYXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZmxhdE1hcFwiKSk7XG52YXIgX2lzTmFOID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzTmFOXCIpKTtcbnZhciBfdXBwZXJGaXJzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC91cHBlckZpcnN0XCIpKTtcbnZhciBfaXNFcXVhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0VxdWFsXCIpKTtcbnZhciBfc29ydEJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3NvcnRCeVwiKSk7XG52YXIgX3JlY2hhcnRzU2NhbGUgPSByZXF1aXJlKFwicmVjaGFydHMtc2NhbGVcIik7XG52YXIgX0Vycm9yQmFyID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9FcnJvckJhclwiKTtcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4vRGF0YVV0aWxzXCIpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4vUmVhY3RVdGlsc1wiKTtcbnZhciBfZ2V0TGVnZW5kUHJvcHMgPSByZXF1aXJlKFwiLi9nZXRMZWdlbmRQcm9wc1wiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLy8gVE9ETzogQ2F1c2Ugb2YgY2lyY3VsYXIgZGVwZW5kZW5jeS4gTmVlZHMgcmVmYWN0b3IuXG4vLyBpbXBvcnQgeyBSYWRpdXNBeGlzUHJvcHMsIEFuZ2xlQXhpc1Byb3BzIH0gZnJvbSAnLi4vcG9sYXIvdHlwZXMnO1xuLy8gRXhwb3J0ZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5mdW5jdGlvbiBnZXRWYWx1ZUJ5RGF0YUtleShvYmosIGRhdGFLZXksIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAoKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKG9iaikgfHwgKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGRhdGFLZXkpKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxuICBpZiAoKDAsIF9EYXRhVXRpbHMuaXNOdW1PclN0cikoZGF0YUtleSkpIHtcbiAgICByZXR1cm4gKDAsIF9nZXRbXCJkZWZhdWx0XCJdKShvYmosIGRhdGFLZXksIGRlZmF1bHRWYWx1ZSk7XG4gIH1cbiAgaWYgKCgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKGRhdGFLZXkpKSB7XG4gICAgcmV0dXJuIGRhdGFLZXkob2JqKTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufVxuLyoqXG4gKiBHZXQgZG9tYWluIG9mIGRhdGEgYnkga2V5LlxuICogQHBhcmFtICB7QXJyYXl9ICAgZGF0YSAgICAgIFRoZSBkYXRhIGRpc3BsYXllZCBpbiB0aGUgY2hhcnRcbiAqIEBwYXJhbSAge1N0cmluZ30gIGtleSAgICAgICBUaGUgdW5pcXVlIGtleSBvZiBhIGdyb3VwIG9mIGRhdGFcbiAqIEBwYXJhbSAge1N0cmluZ30gIHR5cGUgICAgICBUaGUgdHlwZSBvZiBheGlzXG4gKiBAcGFyYW0gIHtCb29sZWFufSBmaWx0ZXJOaWwgV2hldGhlciBvciBub3QgZmlsdGVyIG5pbCB2YWx1ZXNcbiAqIEByZXR1cm4ge0FycmF5fSBEb21haW4gb2YgZGF0YVxuICovXG5mdW5jdGlvbiBnZXREb21haW5PZkRhdGFCeUtleShkYXRhLCBrZXksIHR5cGUsIGZpbHRlck5pbCkge1xuICB2YXIgZmxhdHRlbkRhdGEgPSAoMCwgX2ZsYXRNYXBbXCJkZWZhdWx0XCJdKShkYXRhLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gZ2V0VmFsdWVCeURhdGFLZXkoZW50cnksIGtleSk7XG4gIH0pO1xuICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHBhcnNlRmxvYXQgdHlwZSBvbmx5IGFjY2VwdHMgc3RyaW5nc1xuICAgIHZhciBkb21haW4gPSBmbGF0dGVuRGF0YS5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICByZXR1cm4gKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGVudHJ5KSB8fCBwYXJzZUZsb2F0KGVudHJ5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9tYWluLmxlbmd0aCA/IFsoMCwgX21pbltcImRlZmF1bHRcIl0pKGRvbWFpbiksICgwLCBfbWF4W1wiZGVmYXVsdFwiXSkoZG9tYWluKV0gOiBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gIH1cbiAgdmFyIHZhbGlkYXRlRGF0YSA9IGZpbHRlck5pbCA/IGZsYXR0ZW5EYXRhLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gISgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShlbnRyeSk7XG4gIH0pIDogZmxhdHRlbkRhdGE7XG5cbiAgLy8gU3VwcG9ydHMgeC1heGlzIG9mIERhdGUgdHlwZVxuICByZXR1cm4gdmFsaWRhdGVEYXRhLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gKDAsIF9EYXRhVXRpbHMuaXNOdW1PclN0cikoZW50cnkpIHx8IGVudHJ5IGluc3RhbmNlb2YgRGF0ZSA/IGVudHJ5IDogJyc7XG4gIH0pO1xufVxudmFyIGNhbGN1bGF0ZUFjdGl2ZVRpY2tJbmRleCA9IGV4cG9ydHMuY2FsY3VsYXRlQWN0aXZlVGlja0luZGV4ID0gZnVuY3Rpb24gY2FsY3VsYXRlQWN0aXZlVGlja0luZGV4KGNvb3JkaW5hdGUpIHtcbiAgdmFyIF90aWNrcyRsZW5ndGg7XG4gIHZhciB0aWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gIHZhciB1bnNvcnRlZFRpY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBheGlzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gIHZhciBpbmRleCA9IC0xO1xuICB2YXIgbGVuID0gKF90aWNrcyRsZW5ndGggPSB0aWNrcyA9PT0gbnVsbCB8fCB0aWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGlja3MubGVuZ3RoKSAhPT0gbnVsbCAmJiBfdGlja3MkbGVuZ3RoICE9PSB2b2lkIDAgPyBfdGlja3MkbGVuZ3RoIDogMDtcblxuICAvLyBpZiB0aGVyZSBhcmUgMSBvciBsZXNzIHRpY2tzIHRpY2tzIHRoZW4gdGhlIGFjdGl2ZSB0aWNrIGlzIGF0IGluZGV4IDBcbiAgaWYgKGxlbiA8PSAxKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGF4aXMgJiYgYXhpcy5heGlzVHlwZSA9PT0gJ2FuZ2xlQXhpcycgJiYgTWF0aC5hYnMoTWF0aC5hYnMoYXhpcy5yYW5nZVsxXSAtIGF4aXMucmFuZ2VbMF0pIC0gMzYwKSA8PSAxZS02KSB7XG4gICAgdmFyIHJhbmdlID0gYXhpcy5yYW5nZTtcbiAgICAvLyB0aWNrcyBhcmUgZGlzdHJpYnV0ZWQgaW4gYSBjaXJjbGVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYmVmb3JlID0gaSA+IDAgPyB1bnNvcnRlZFRpY2tzW2kgLSAxXS5jb29yZGluYXRlIDogdW5zb3J0ZWRUaWNrc1tsZW4gLSAxXS5jb29yZGluYXRlO1xuICAgICAgdmFyIGN1ciA9IHVuc29ydGVkVGlja3NbaV0uY29vcmRpbmF0ZTtcbiAgICAgIHZhciBhZnRlciA9IGkgPj0gbGVuIC0gMSA/IHVuc29ydGVkVGlja3NbMF0uY29vcmRpbmF0ZSA6IHVuc29ydGVkVGlja3NbaSArIDFdLmNvb3JkaW5hdGU7XG4gICAgICB2YXIgc2FtZURpcmVjdGlvbkNvb3JkID0gdm9pZCAwO1xuICAgICAgaWYgKCgwLCBfRGF0YVV0aWxzLm1hdGhTaWduKShjdXIgLSBiZWZvcmUpICE9PSAoMCwgX0RhdGFVdGlscy5tYXRoU2lnbikoYWZ0ZXIgLSBjdXIpKSB7XG4gICAgICAgIHZhciBkaWZmSW50ZXJ2YWwgPSBbXTtcbiAgICAgICAgaWYgKCgwLCBfRGF0YVV0aWxzLm1hdGhTaWduKShhZnRlciAtIGN1cikgPT09ICgwLCBfRGF0YVV0aWxzLm1hdGhTaWduKShyYW5nZVsxXSAtIHJhbmdlWzBdKSkge1xuICAgICAgICAgIHNhbWVEaXJlY3Rpb25Db29yZCA9IGFmdGVyO1xuICAgICAgICAgIHZhciBjdXJJblJhbmdlID0gY3VyICsgcmFuZ2VbMV0gLSByYW5nZVswXTtcbiAgICAgICAgICBkaWZmSW50ZXJ2YWxbMF0gPSBNYXRoLm1pbihjdXJJblJhbmdlLCAoY3VySW5SYW5nZSArIGJlZm9yZSkgLyAyKTtcbiAgICAgICAgICBkaWZmSW50ZXJ2YWxbMV0gPSBNYXRoLm1heChjdXJJblJhbmdlLCAoY3VySW5SYW5nZSArIGJlZm9yZSkgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzYW1lRGlyZWN0aW9uQ29vcmQgPSBiZWZvcmU7XG4gICAgICAgICAgdmFyIGFmdGVySW5SYW5nZSA9IGFmdGVyICsgcmFuZ2VbMV0gLSByYW5nZVswXTtcbiAgICAgICAgICBkaWZmSW50ZXJ2YWxbMF0gPSBNYXRoLm1pbihjdXIsIChhZnRlckluUmFuZ2UgKyBjdXIpIC8gMik7XG4gICAgICAgICAgZGlmZkludGVydmFsWzFdID0gTWF0aC5tYXgoY3VyLCAoYWZ0ZXJJblJhbmdlICsgY3VyKSAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzYW1lSW50ZXJ2YWwgPSBbTWF0aC5taW4oY3VyLCAoc2FtZURpcmVjdGlvbkNvb3JkICsgY3VyKSAvIDIpLCBNYXRoLm1heChjdXIsIChzYW1lRGlyZWN0aW9uQ29vcmQgKyBjdXIpIC8gMildO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZSA+IHNhbWVJbnRlcnZhbFswXSAmJiBjb29yZGluYXRlIDw9IHNhbWVJbnRlcnZhbFsxXSB8fCBjb29yZGluYXRlID49IGRpZmZJbnRlcnZhbFswXSAmJiBjb29yZGluYXRlIDw9IGRpZmZJbnRlcnZhbFsxXSkge1xuICAgICAgICAgIGluZGV4ID0gdW5zb3J0ZWRUaWNrc1tpXS5pbmRleDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1pblZhbHVlID0gTWF0aC5taW4oYmVmb3JlLCBhZnRlcik7XG4gICAgICAgIHZhciBtYXhWYWx1ZSA9IE1hdGgubWF4KGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZSA+IChtaW5WYWx1ZSArIGN1cikgLyAyICYmIGNvb3JkaW5hdGUgPD0gKG1heFZhbHVlICsgY3VyKSAvIDIpIHtcbiAgICAgICAgICBpbmRleCA9IHVuc29ydGVkVGlja3NbaV0uaW5kZXg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gdGlja3MgYXJlIGRpc3RyaWJ1dGVkIGluIGEgc2luZ2xlIGRpcmVjdGlvblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW47IF9pKyspIHtcbiAgICAgIGlmIChfaSA9PT0gMCAmJiBjb29yZGluYXRlIDw9ICh0aWNrc1tfaV0uY29vcmRpbmF0ZSArIHRpY2tzW19pICsgMV0uY29vcmRpbmF0ZSkgLyAyIHx8IF9pID4gMCAmJiBfaSA8IGxlbiAtIDEgJiYgY29vcmRpbmF0ZSA+ICh0aWNrc1tfaV0uY29vcmRpbmF0ZSArIHRpY2tzW19pIC0gMV0uY29vcmRpbmF0ZSkgLyAyICYmIGNvb3JkaW5hdGUgPD0gKHRpY2tzW19pXS5jb29yZGluYXRlICsgdGlja3NbX2kgKyAxXS5jb29yZGluYXRlKSAvIDIgfHwgX2kgPT09IGxlbiAtIDEgJiYgY29vcmRpbmF0ZSA+ICh0aWNrc1tfaV0uY29vcmRpbmF0ZSArIHRpY2tzW19pIC0gMV0uY29vcmRpbmF0ZSkgLyAyKSB7XG4gICAgICAgIGluZGV4ID0gdGlja3NbX2ldLmluZGV4O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1haW4gY29sb3Igb2YgZWFjaCBncmFwaGljIGl0ZW1cbiAqIEBwYXJhbSAge1JlYWN0RWxlbWVudH0gaXRlbSBBIGdyYXBoaWMgaXRlbVxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgIENvbG9yXG4gKi9cbnZhciBnZXRNYWluQ29sb3JPZkdyYXBoaWNJdGVtID0gZXhwb3J0cy5nZXRNYWluQ29sb3JPZkdyYXBoaWNJdGVtID0gZnVuY3Rpb24gZ2V0TWFpbkNvbG9yT2ZHcmFwaGljSXRlbShpdGVtKSB7XG4gIHZhciBfaXRlbSR0eXBlO1xuICB2YXIgX3JlZiA9IGl0ZW0sXG4gICAgZGlzcGxheU5hbWUgPSBfcmVmLnR5cGUuZGlzcGxheU5hbWU7IC8vIFRPRE86IGNoZWNrIGlmIGRpc3BsYXlOYW1lIGlzIHZhbGlkLlxuICB2YXIgZGVmYXVsdGVkUHJvcHMgPSAoX2l0ZW0kdHlwZSA9IGl0ZW0udHlwZSkgIT09IG51bGwgJiYgX2l0ZW0kdHlwZSAhPT0gdm9pZCAwICYmIF9pdGVtJHR5cGUuZGVmYXVsdFByb3BzID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBpdGVtLnR5cGUuZGVmYXVsdFByb3BzKSwgaXRlbS5wcm9wcykgOiBpdGVtLnByb3BzO1xuICB2YXIgc3Ryb2tlID0gZGVmYXVsdGVkUHJvcHMuc3Ryb2tlLFxuICAgIGZpbGwgPSBkZWZhdWx0ZWRQcm9wcy5maWxsO1xuICB2YXIgcmVzdWx0O1xuICBzd2l0Y2ggKGRpc3BsYXlOYW1lKSB7XG4gICAgY2FzZSAnTGluZSc6XG4gICAgICByZXN1bHQgPSBzdHJva2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdBcmVhJzpcbiAgICBjYXNlICdSYWRhcic6XG4gICAgICByZXN1bHQgPSBzdHJva2UgJiYgc3Ryb2tlICE9PSAnbm9uZScgPyBzdHJva2UgOiBmaWxsO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlc3VsdCA9IGZpbGw7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzaXplIG9mIGFsbCBncm91cHMgZm9yIHN0YWNrZWQgYmFyIGdyYXBoXG4gKiBAcGFyYW0gIHtPYmplY3R9IHN0YWNrR3JvdXBzIFRoZSBpdGVtcyBncm91cGVkIGJ5IGF4aXNJZCBhbmQgc3RhY2tJZFxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgc2l6ZSBvZiBhbGwgZ3JvdXBzXG4gKi9cbnZhciBnZXRCYXJTaXplTGlzdCA9IGV4cG9ydHMuZ2V0QmFyU2l6ZUxpc3QgPSBmdW5jdGlvbiBnZXRCYXJTaXplTGlzdChfcmVmMikge1xuICB2YXIgZ2xvYmFsU2l6ZSA9IF9yZWYyLmJhclNpemUsXG4gICAgdG90YWxTaXplID0gX3JlZjIudG90YWxTaXplLFxuICAgIF9yZWYyJHN0YWNrR3JvdXBzID0gX3JlZjIuc3RhY2tHcm91cHMsXG4gICAgc3RhY2tHcm91cHMgPSBfcmVmMiRzdGFja0dyb3VwcyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMiRzdGFja0dyb3VwcztcbiAgaWYgKCFzdGFja0dyb3Vwcykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBudW1lcmljQXhpc0lkcyA9IE9iamVjdC5rZXlzKHN0YWNrR3JvdXBzKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG51bWVyaWNBeGlzSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHNncyA9IHN0YWNrR3JvdXBzW251bWVyaWNBeGlzSWRzW2ldXS5zdGFja0dyb3VwcztcbiAgICB2YXIgc3RhY2tJZHMgPSBPYmplY3Qua2V5cyhzZ3MpO1xuICAgIGZvciAodmFyIGogPSAwLCBzTGVuID0gc3RhY2tJZHMubGVuZ3RoOyBqIDwgc0xlbjsgaisrKSB7XG4gICAgICB2YXIgX3NncyRzdGFja0lkcyRqID0gc2dzW3N0YWNrSWRzW2pdXSxcbiAgICAgICAgaXRlbXMgPSBfc2dzJHN0YWNrSWRzJGouaXRlbXMsXG4gICAgICAgIGNhdGVBeGlzSWQgPSBfc2dzJHN0YWNrSWRzJGouY2F0ZUF4aXNJZDtcbiAgICAgIHZhciBiYXJJdGVtcyA9IGl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gKDAsIF9SZWFjdFV0aWxzLmdldERpc3BsYXlOYW1lKShpdGVtLnR5cGUpLmluZGV4T2YoJ0JhcicpID49IDA7XG4gICAgICB9KTtcbiAgICAgIGlmIChiYXJJdGVtcyAmJiBiYXJJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGJhckl0ZW1EZWZhdWx0UHJvcHMgPSBiYXJJdGVtc1swXS50eXBlLmRlZmF1bHRQcm9wcztcbiAgICAgICAgdmFyIGJhckl0ZW1Qcm9wcyA9IGJhckl0ZW1EZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYmFySXRlbURlZmF1bHRQcm9wcyksIGJhckl0ZW1zWzBdLnByb3BzKSA6IGJhckl0ZW1zWzBdLnByb3BzO1xuICAgICAgICB2YXIgc2VsZlNpemUgPSBiYXJJdGVtUHJvcHMuYmFyU2l6ZTtcbiAgICAgICAgdmFyIGNhdGVJZCA9IGJhckl0ZW1Qcm9wc1tjYXRlQXhpc0lkXTtcbiAgICAgICAgaWYgKCFyZXN1bHRbY2F0ZUlkXSkge1xuICAgICAgICAgIHJlc3VsdFtjYXRlSWRdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhclNpemUgPSAoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoc2VsZlNpemUpID8gZ2xvYmFsU2l6ZSA6IHNlbGZTaXplO1xuICAgICAgICByZXN1bHRbY2F0ZUlkXS5wdXNoKHtcbiAgICAgICAgICBpdGVtOiBiYXJJdGVtc1swXSxcbiAgICAgICAgICBzdGFja0xpc3Q6IGJhckl0ZW1zLnNsaWNlKDEpLFxuICAgICAgICAgIGJhclNpemU6ICgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShiYXJTaXplKSA/IHVuZGVmaW5lZCA6ICgwLCBfRGF0YVV0aWxzLmdldFBlcmNlbnRWYWx1ZSkoYmFyU2l6ZSwgdG90YWxTaXplLCAwKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgc2l6ZSBvZiBlYWNoIGJhciBhbmQgb2Zmc2V0IGJldHdlZW4gc3RhcnQgb2YgYmFuZCBhbmQgdGhlIGJhclxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gYmFuZFNpemUgaXMgdGhlIHNpemUgb2YgYXJlYSB3aGVyZSBiYXJzIGNhbiByZW5kZXJcbiAqIEBwYXJhbSAge251bWJlciB8IHN0cmluZ30gYmFyR2FwIGlzIHRoZSBnYXAgc2l6ZSwgYXMgYSBwZXJjZW50YWdlIG9mIGBiYW5kU2l6ZWAuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgZGVmaW5lZCBhcyBudW1iZXIgb3IgcGVyY2VudCBzdHJpbmdcbiAqIEBwYXJhbSAge251bWJlciB8IHN0cmluZ30gYmFyQ2F0ZWdvcnlHYXAgaXMgdGhlIGdhcCBzaXplLCBhcyBhIHBlcmNlbnRhZ2Ugb2YgYGJhbmRTaXplYC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSBkZWZpbmVkIGFzIG51bWJlciBvciBwZXJjZW50IHN0cmluZ1xuICogQHBhcmFtICB7QXJyYXk8b2JqZWN0Pn0gc2l6ZUxpc3QgU2l6ZXMgb2YgYWxsIGdyb3Vwc1xuICogQHBhcmFtICB7bnVtYmVyfSBtYXhCYXJTaXplIFRoZSBtYXhpbXVtIHNpemUgb2YgZWFjaCBiYXJcbiAqIEByZXR1cm4ge0FycmF5PG9iamVjdD59IFRoZSBzaXplIGFuZCBvZmZzZXQgb2YgZWFjaCBiYXJcbiAqL1xudmFyIGdldEJhclBvc2l0aW9uID0gZXhwb3J0cy5nZXRCYXJQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldEJhclBvc2l0aW9uKF9yZWYzKSB7XG4gIHZhciBiYXJHYXAgPSBfcmVmMy5iYXJHYXAsXG4gICAgYmFyQ2F0ZWdvcnlHYXAgPSBfcmVmMy5iYXJDYXRlZ29yeUdhcCxcbiAgICBiYW5kU2l6ZSA9IF9yZWYzLmJhbmRTaXplLFxuICAgIF9yZWYzJHNpemVMaXN0ID0gX3JlZjMuc2l6ZUxpc3QsXG4gICAgc2l6ZUxpc3QgPSBfcmVmMyRzaXplTGlzdCA9PT0gdm9pZCAwID8gW10gOiBfcmVmMyRzaXplTGlzdCxcbiAgICBtYXhCYXJTaXplID0gX3JlZjMubWF4QmFyU2l6ZTtcbiAgdmFyIGxlbiA9IHNpemVMaXN0Lmxlbmd0aDtcbiAgaWYgKGxlbiA8IDEpIHJldHVybiBudWxsO1xuICB2YXIgcmVhbEJhckdhcCA9ICgwLCBfRGF0YVV0aWxzLmdldFBlcmNlbnRWYWx1ZSkoYmFyR2FwLCBiYW5kU2l6ZSwgMCwgdHJ1ZSk7XG4gIHZhciByZXN1bHQ7XG4gIHZhciBpbml0aWFsVmFsdWUgPSBbXTtcblxuICAvLyB3aGV0aGVyIG9yIG5vdCBpcyBiYXJTaXplIHNldHRlZCBieSB1c2VyXG4gIGlmIChzaXplTGlzdFswXS5iYXJTaXplID09PSArc2l6ZUxpc3RbMF0uYmFyU2l6ZSkge1xuICAgIHZhciB1c2VGdWxsID0gZmFsc2U7XG4gICAgdmFyIGZ1bGxCYXJTaXplID0gYmFuZFNpemUgLyBsZW47XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGUgdHlwZSBjaGVjayBhYm92ZSBkb2VzIG5vdCBjaGVjayBmb3IgdHlwZSBudW1iZXIgZXhwbGljaXRseVxuICAgIHZhciBzdW0gPSBzaXplTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgZW50cnkpIHtcbiAgICAgIHJldHVybiByZXMgKyBlbnRyeS5iYXJTaXplIHx8IDA7XG4gICAgfSwgMCk7XG4gICAgc3VtICs9IChsZW4gLSAxKSAqIHJlYWxCYXJHYXA7XG4gICAgaWYgKHN1bSA+PSBiYW5kU2l6ZSkge1xuICAgICAgc3VtIC09IChsZW4gLSAxKSAqIHJlYWxCYXJHYXA7XG4gICAgICByZWFsQmFyR2FwID0gMDtcbiAgICB9XG4gICAgaWYgKHN1bSA+PSBiYW5kU2l6ZSAmJiBmdWxsQmFyU2l6ZSA+IDApIHtcbiAgICAgIHVzZUZ1bGwgPSB0cnVlO1xuICAgICAgZnVsbEJhclNpemUgKj0gMC45O1xuICAgICAgc3VtID0gbGVuICogZnVsbEJhclNpemU7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSAoYmFuZFNpemUgLSBzdW0pIC8gMiA+PiAwO1xuICAgIHZhciBwcmV2ID0ge1xuICAgICAgb2Zmc2V0OiBvZmZzZXQgLSByZWFsQmFyR2FwLFxuICAgICAgc2l6ZTogMFxuICAgIH07XG4gICAgcmVzdWx0ID0gc2l6ZUxpc3QucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGVudHJ5KSB7XG4gICAgICB2YXIgbmV3UG9zaXRpb24gPSB7XG4gICAgICAgIGl0ZW06IGVudHJ5Lml0ZW0sXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgb2Zmc2V0OiBwcmV2Lm9mZnNldCArIHByZXYuc2l6ZSArIHJlYWxCYXJHYXAsXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGUgdHlwZSBjaGVjayBhYm92ZSBkb2VzIG5vdCBjaGVjayBmb3IgdHlwZSBudW1iZXIgZXhwbGljaXRseVxuICAgICAgICAgIHNpemU6IHVzZUZ1bGwgPyBmdWxsQmFyU2l6ZSA6IGVudHJ5LmJhclNpemVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBuZXdSZXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlcyksIFtuZXdQb3NpdGlvbl0pO1xuICAgICAgcHJldiA9IG5ld1Jlc1tuZXdSZXMubGVuZ3RoIC0gMV0ucG9zaXRpb247XG4gICAgICBpZiAoZW50cnkuc3RhY2tMaXN0ICYmIGVudHJ5LnN0YWNrTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgZW50cnkuc3RhY2tMaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBuZXdSZXMucHVzaCh7XG4gICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgcG9zaXRpb246IHByZXZcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3UmVzO1xuICAgIH0sIGluaXRpYWxWYWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9vZmZzZXQgPSAoMCwgX0RhdGFVdGlscy5nZXRQZXJjZW50VmFsdWUpKGJhckNhdGVnb3J5R2FwLCBiYW5kU2l6ZSwgMCwgdHJ1ZSk7XG4gICAgaWYgKGJhbmRTaXplIC0gMiAqIF9vZmZzZXQgLSAobGVuIC0gMSkgKiByZWFsQmFyR2FwIDw9IDApIHtcbiAgICAgIHJlYWxCYXJHYXAgPSAwO1xuICAgIH1cbiAgICB2YXIgb3JpZ2luYWxTaXplID0gKGJhbmRTaXplIC0gMiAqIF9vZmZzZXQgLSAobGVuIC0gMSkgKiByZWFsQmFyR2FwKSAvIGxlbjtcbiAgICBpZiAob3JpZ2luYWxTaXplID4gMSkge1xuICAgICAgb3JpZ2luYWxTaXplID4+PSAwO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IG1heEJhclNpemUgPT09ICttYXhCYXJTaXplID8gTWF0aC5taW4ob3JpZ2luYWxTaXplLCBtYXhCYXJTaXplKSA6IG9yaWdpbmFsU2l6ZTtcbiAgICByZXN1bHQgPSBzaXplTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgZW50cnksIGkpIHtcbiAgICAgIHZhciBuZXdSZXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlcyksIFt7XG4gICAgICAgIGl0ZW06IGVudHJ5Lml0ZW0sXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0ICsgKG9yaWdpbmFsU2l6ZSArIHJlYWxCYXJHYXApICogaSArIChvcmlnaW5hbFNpemUgLSBzaXplKSAvIDIsXG4gICAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgICBpZiAoZW50cnkuc3RhY2tMaXN0ICYmIGVudHJ5LnN0YWNrTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgZW50cnkuc3RhY2tMaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBuZXdSZXMucHVzaCh7XG4gICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgcG9zaXRpb246IG5ld1Jlc1tuZXdSZXMubGVuZ3RoIC0gMV0ucG9zaXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3UmVzO1xuICAgIH0sIGluaXRpYWxWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgYXBwZW5kT2Zmc2V0T2ZMZWdlbmQgPSBleHBvcnRzLmFwcGVuZE9mZnNldE9mTGVnZW5kID0gZnVuY3Rpb24gYXBwZW5kT2Zmc2V0T2ZMZWdlbmQob2Zmc2V0LCBfdW51c2VkLCBwcm9wcywgbGVnZW5kQm94KSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgIHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgbWFyZ2luID0gcHJvcHMubWFyZ2luO1xuICB2YXIgbGVnZW5kV2lkdGggPSB3aWR0aCAtIChtYXJnaW4ubGVmdCB8fCAwKSAtIChtYXJnaW4ucmlnaHQgfHwgMCk7XG4gIHZhciBsZWdlbmRQcm9wcyA9ICgwLCBfZ2V0TGVnZW5kUHJvcHMuZ2V0TGVnZW5kUHJvcHMpKHtcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbGVnZW5kV2lkdGg6IGxlZ2VuZFdpZHRoXG4gIH0pO1xuICBpZiAobGVnZW5kUHJvcHMpIHtcbiAgICB2YXIgX3JlZjQgPSBsZWdlbmRCb3ggfHwge30sXG4gICAgICBib3hXaWR0aCA9IF9yZWY0LndpZHRoLFxuICAgICAgYm94SGVpZ2h0ID0gX3JlZjQuaGVpZ2h0O1xuICAgIHZhciBhbGlnbiA9IGxlZ2VuZFByb3BzLmFsaWduLFxuICAgICAgdmVydGljYWxBbGlnbiA9IGxlZ2VuZFByb3BzLnZlcnRpY2FsQWxpZ24sXG4gICAgICBsYXlvdXQgPSBsZWdlbmRQcm9wcy5sYXlvdXQ7XG4gICAgaWYgKChsYXlvdXQgPT09ICd2ZXJ0aWNhbCcgfHwgbGF5b3V0ID09PSAnaG9yaXpvbnRhbCcgJiYgdmVydGljYWxBbGlnbiA9PT0gJ21pZGRsZScpICYmIGFsaWduICE9PSAnY2VudGVyJyAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikob2Zmc2V0W2FsaWduXSkpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9mZnNldCksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGFsaWduLCBvZmZzZXRbYWxpZ25dICsgKGJveFdpZHRoIHx8IDApKSk7XG4gICAgfVxuICAgIGlmICgobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcgfHwgbGF5b3V0ID09PSAndmVydGljYWwnICYmIGFsaWduID09PSAnY2VudGVyJykgJiYgdmVydGljYWxBbGlnbiAhPT0gJ21pZGRsZScgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKG9mZnNldFt2ZXJ0aWNhbEFsaWduXSkpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9mZnNldCksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIHZlcnRpY2FsQWxpZ24sIG9mZnNldFt2ZXJ0aWNhbEFsaWduXSArIChib3hIZWlnaHQgfHwgMCkpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn07XG52YXIgaXNFcnJvckJhclJlbGV2YW50Rm9yQXhpcyA9IGZ1bmN0aW9uIGlzRXJyb3JCYXJSZWxldmFudEZvckF4aXMobGF5b3V0LCBheGlzVHlwZSwgZGlyZWN0aW9uKSB7XG4gIGlmICgoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoYXhpc1R5cGUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgcmV0dXJuIGF4aXNUeXBlID09PSAneUF4aXMnO1xuICB9XG4gIGlmIChsYXlvdXQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICByZXR1cm4gYXhpc1R5cGUgPT09ICd4QXhpcyc7XG4gIH1cbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ3gnKSB7XG4gICAgcmV0dXJuIGF4aXNUeXBlID09PSAneEF4aXMnO1xuICB9XG4gIGlmIChkaXJlY3Rpb24gPT09ICd5Jykge1xuICAgIHJldHVybiBheGlzVHlwZSA9PT0gJ3lBeGlzJztcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgZ2V0RG9tYWluT2ZFcnJvckJhcnMgPSBleHBvcnRzLmdldERvbWFpbk9mRXJyb3JCYXJzID0gZnVuY3Rpb24gZ2V0RG9tYWluT2ZFcnJvckJhcnMoZGF0YSwgaXRlbSwgZGF0YUtleSwgbGF5b3V0LCBheGlzVHlwZSkge1xuICB2YXIgY2hpbGRyZW4gPSBpdGVtLnByb3BzLmNoaWxkcmVuO1xuICB2YXIgZXJyb3JCYXJzID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRBbGxCeVR5cGUpKGNoaWxkcmVuLCBfRXJyb3JCYXIuRXJyb3JCYXIpLmZpbHRlcihmdW5jdGlvbiAoZXJyb3JCYXJDaGlsZCkge1xuICAgIHJldHVybiBpc0Vycm9yQmFyUmVsZXZhbnRGb3JBeGlzKGxheW91dCwgYXhpc1R5cGUsIGVycm9yQmFyQ2hpbGQucHJvcHMuZGlyZWN0aW9uKTtcbiAgfSk7XG4gIGlmIChlcnJvckJhcnMgJiYgZXJyb3JCYXJzLmxlbmd0aCkge1xuICAgIHZhciBrZXlzID0gZXJyb3JCYXJzLm1hcChmdW5jdGlvbiAoZXJyb3JCYXJDaGlsZCkge1xuICAgICAgcmV0dXJuIGVycm9yQmFyQ2hpbGQucHJvcHMuZGF0YUtleTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZW50cnkpIHtcbiAgICAgIHZhciBlbnRyeVZhbHVlID0gZ2V0VmFsdWVCeURhdGFLZXkoZW50cnksIGRhdGFLZXkpO1xuICAgICAgaWYgKCgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShlbnRyeVZhbHVlKSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHZhciBtYWluVmFsdWUgPSBBcnJheS5pc0FycmF5KGVudHJ5VmFsdWUpID8gWygwLCBfbWluW1wiZGVmYXVsdFwiXSkoZW50cnlWYWx1ZSksICgwLCBfbWF4W1wiZGVmYXVsdFwiXSkoZW50cnlWYWx1ZSldIDogW2VudHJ5VmFsdWUsIGVudHJ5VmFsdWVdO1xuICAgICAgdmFyIGVycm9yRG9tYWluID0ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZFcnJvckFyciwgaykge1xuICAgICAgICB2YXIgZXJyb3JWYWx1ZSA9IGdldFZhbHVlQnlEYXRhS2V5KGVudHJ5LCBrLCAwKTtcbiAgICAgICAgdmFyIGxvd2VyVmFsdWUgPSBtYWluVmFsdWVbMF0gLSBNYXRoLmFicyhBcnJheS5pc0FycmF5KGVycm9yVmFsdWUpID8gZXJyb3JWYWx1ZVswXSA6IGVycm9yVmFsdWUpO1xuICAgICAgICB2YXIgdXBwZXJWYWx1ZSA9IG1haW5WYWx1ZVsxXSArIE1hdGguYWJzKEFycmF5LmlzQXJyYXkoZXJyb3JWYWx1ZSkgPyBlcnJvclZhbHVlWzFdIDogZXJyb3JWYWx1ZSk7XG4gICAgICAgIHJldHVybiBbTWF0aC5taW4obG93ZXJWYWx1ZSwgcHJldkVycm9yQXJyWzBdKSwgTWF0aC5tYXgodXBwZXJWYWx1ZSwgcHJldkVycm9yQXJyWzFdKV07XG4gICAgICB9LCBbSW5maW5pdHksIC1JbmZpbml0eV0pO1xuICAgICAgcmV0dXJuIFtNYXRoLm1pbihlcnJvckRvbWFpblswXSwgcmVzdWx0WzBdKSwgTWF0aC5tYXgoZXJyb3JEb21haW5bMV0sIHJlc3VsdFsxXSldO1xuICAgIH0sIFtJbmZpbml0eSwgLUluZmluaXR5XSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIHBhcnNlRXJyb3JCYXJzT2ZBeGlzID0gZXhwb3J0cy5wYXJzZUVycm9yQmFyc09mQXhpcyA9IGZ1bmN0aW9uIHBhcnNlRXJyb3JCYXJzT2ZBeGlzKGRhdGEsIGl0ZW1zLCBkYXRhS2V5LCBheGlzVHlwZSwgbGF5b3V0KSB7XG4gIHZhciBkb21haW5zID0gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGdldERvbWFpbk9mRXJyb3JCYXJzKGRhdGEsIGl0ZW0sIGRhdGFLZXksIGxheW91dCwgYXhpc1R5cGUpO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuICEoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoZW50cnkpO1xuICB9KTtcbiAgaWYgKGRvbWFpbnMgJiYgZG9tYWlucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZG9tYWlucy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZW50cnkpIHtcbiAgICAgIHJldHVybiBbTWF0aC5taW4ocmVzdWx0WzBdLCBlbnRyeVswXSksIE1hdGgubWF4KHJlc3VsdFsxXSwgZW50cnlbMV0pXTtcbiAgICB9LCBbSW5maW5pdHksIC1JbmZpbml0eV0pO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgZG9tYWluIG9mIGRhdGEgYnkgdGhlIGNvbmZpZ3VyYXRpb24gb2YgaXRlbSBlbGVtZW50XG4gKiBAcGFyYW0gIHtBcnJheX0gICBkYXRhICAgICAgVGhlIGRhdGEgZGlzcGxheWVkIGluIHRoZSBjaGFydFxuICogQHBhcmFtICB7QXJyYXl9ICAgaXRlbXMgICAgIFRoZSBpbnN0YW5jZXMgb2YgaXRlbVxuICogQHBhcmFtICB7U3RyaW5nfSAgdHlwZSAgICAgIFRoZSB0eXBlIG9mIGF4aXMsIG51bWJlciAtIE51bWJlciBBeGlzLCBjYXRlZ29yeSAtIENhdGVnb3J5IEF4aXNcbiAqIEBwYXJhbSAge0xheW91dFR5cGV9IGxheW91dCBUaGUgdHlwZSBvZiBsYXlvdXRcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGZpbHRlck5pbCBXaGV0aGVyIG9yIG5vdCBmaWx0ZXIgbmlsIHZhbHVlc1xuICogQHJldHVybiB7QXJyYXl9ICAgICAgICBEb21haW5cbiAqL1xudmFyIGdldERvbWFpbk9mSXRlbXNXaXRoU2FtZUF4aXMgPSBleHBvcnRzLmdldERvbWFpbk9mSXRlbXNXaXRoU2FtZUF4aXMgPSBmdW5jdGlvbiBnZXREb21haW5PZkl0ZW1zV2l0aFNhbWVBeGlzKGRhdGEsIGl0ZW1zLCB0eXBlLCBsYXlvdXQsIGZpbHRlck5pbCkge1xuICB2YXIgZG9tYWlucyA9IGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBkYXRhS2V5ID0gaXRlbS5wcm9wcy5kYXRhS2V5O1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBkYXRhS2V5KSB7XG4gICAgICByZXR1cm4gZ2V0RG9tYWluT2ZFcnJvckJhcnMoZGF0YSwgaXRlbSwgZGF0YUtleSwgbGF5b3V0KSB8fCBnZXREb21haW5PZkRhdGFCeUtleShkYXRhLCBkYXRhS2V5LCB0eXBlLCBmaWx0ZXJOaWwpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RG9tYWluT2ZEYXRhQnlLZXkoZGF0YSwgZGF0YUtleSwgdHlwZSwgZmlsdGVyTmlsKTtcbiAgfSk7XG4gIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgZG9tYWluIG9mIG51bWJlciBheGlzXG4gICAgcmV0dXJuIGRvbWFpbnMucmVkdWNlKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaWYgKHR5cGUgPT09IG51bWJlcikgbWVhbnMgdGhhdCB0aGUgZG9tYWluIGlzIG51bWVyaWNhbCB0eXBlXG4gICAgLy8gLSBidXQgdGhpcyBsaW5rIGlzIG1pc3NpbmcgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxuICAgIGZ1bmN0aW9uIChyZXN1bHQsIGVudHJ5KSB7XG4gICAgICByZXR1cm4gW01hdGgubWluKHJlc3VsdFswXSwgZW50cnlbMF0pLCBNYXRoLm1heChyZXN1bHRbMV0sIGVudHJ5WzFdKV07XG4gICAgfSwgW0luZmluaXR5LCAtSW5maW5pdHldKTtcbiAgfVxuICB2YXIgdGFnID0ge307XG4gIC8vIEdldCB0aGUgdW5pb24gc2V0IG9mIGNhdGVnb3J5IGF4aXNcbiAgcmV0dXJuIGRvbWFpbnMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGVudHJ5KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVudHJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIERhdGUgY2Fubm90IGluZGV4IGFuIG9iamVjdFxuICAgICAgaWYgKCF0YWdbZW50cnlbaV1dKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgRGF0ZSBjYW5ub3QgaW5kZXggYW4gb2JqZWN0XG4gICAgICAgIHRhZ1tlbnRyeVtpXV0gPSB0cnVlO1xuXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgRGF0ZSBjYW5ub3QgaW5kZXggYW4gb2JqZWN0XG4gICAgICAgIHJlc3VsdC5wdXNoKGVudHJ5W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgW10pO1xufTtcbnZhciBpc0NhdGVnb3JpY2FsQXhpcyA9IGV4cG9ydHMuaXNDYXRlZ29yaWNhbEF4aXMgPSBmdW5jdGlvbiBpc0NhdGVnb3JpY2FsQXhpcyhsYXlvdXQsIGF4aXNUeXBlKSB7XG4gIHJldHVybiBsYXlvdXQgPT09ICdob3Jpem9udGFsJyAmJiBheGlzVHlwZSA9PT0gJ3hBeGlzJyB8fCBsYXlvdXQgPT09ICd2ZXJ0aWNhbCcgJiYgYXhpc1R5cGUgPT09ICd5QXhpcycgfHwgbGF5b3V0ID09PSAnY2VudHJpYycgJiYgYXhpc1R5cGUgPT09ICdhbmdsZUF4aXMnIHx8IGxheW91dCA9PT0gJ3JhZGlhbCcgJiYgYXhpc1R5cGUgPT09ICdyYWRpdXNBeGlzJztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBDb29yZGluYXRlcyBvZiBncmlkXG4gKiBAcGFyYW0gIHtBcnJheX0gdGlja3MgICAgICAgICAgIFRoZSB0aWNrcyBpbiBheGlzXG4gKiBAcGFyYW0ge051bWJlcn0gbWluVmFsdWUgICAgICAgIFRoZSBtaW5pbXVuIHZhbHVlIG9mIGF4aXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhWYWx1ZSAgICAgICAgVGhlIG1heGltdW4gdmFsdWUgb2YgYXhpc1xuICogQHBhcmFtIHtib29sZWFufSBzeW5jV2l0aFRpY2tzICBTeW5jaHJvbml6ZSBncmlkIGxpbmVzIHdpdGggdGlja3Mgb3Igbm90XG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgICAgIENvb3JkaW5hdGVzXG4gKi9cbnZhciBnZXRDb29yZGluYXRlc09mR3JpZCA9IGV4cG9ydHMuZ2V0Q29vcmRpbmF0ZXNPZkdyaWQgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlc09mR3JpZCh0aWNrcywgbWluVmFsdWUsIG1heFZhbHVlLCBzeW5jV2l0aFRpY2tzKSB7XG4gIGlmIChzeW5jV2l0aFRpY2tzKSB7XG4gICAgcmV0dXJuIHRpY2tzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIHJldHVybiBlbnRyeS5jb29yZGluYXRlO1xuICAgIH0pO1xuICB9XG4gIHZhciBoYXNNaW4sIGhhc01heDtcbiAgdmFyIHZhbHVlcyA9IHRpY2tzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICBpZiAoZW50cnkuY29vcmRpbmF0ZSA9PT0gbWluVmFsdWUpIHtcbiAgICAgIGhhc01pbiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChlbnRyeS5jb29yZGluYXRlID09PSBtYXhWYWx1ZSkge1xuICAgICAgaGFzTWF4ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5LmNvb3JkaW5hdGU7XG4gIH0pO1xuICBpZiAoIWhhc01pbikge1xuICAgIHZhbHVlcy5wdXNoKG1pblZhbHVlKTtcbiAgfVxuICBpZiAoIWhhc01heCkge1xuICAgIHZhbHVlcy5wdXNoKG1heFZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHRpY2tzIG9mIGFuIGF4aXNcbiAqIEBwYXJhbSAge09iamVjdH0gIGF4aXMgVGhlIGNvbmZpZ3VyYXRpb24gb2YgYW4gYXhpc1xuICogQHBhcmFtIHtCb29sZWFufSBpc0dyaWQgV2hldGhlciBvciBub3QgYXJlIHRoZSB0aWNrcyBpbiBncmlkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQWxsIFJldHVybiB0aGUgdGlja3Mgb2YgYWxsIHRoZSBwb2ludHMgb3Igbm90XG4gKiBAcmV0dXJuIHtBcnJheX0gIFRpY2tzXG4gKi9cbnZhciBnZXRUaWNrc09mQXhpcyA9IGV4cG9ydHMuZ2V0VGlja3NPZkF4aXMgPSBmdW5jdGlvbiBnZXRUaWNrc09mQXhpcyhheGlzLCBpc0dyaWQsIGlzQWxsKSB7XG4gIGlmICghYXhpcykgcmV0dXJuIG51bGw7XG4gIHZhciBzY2FsZSA9IGF4aXMuc2NhbGU7XG4gIHZhciBkdXBsaWNhdGVEb21haW4gPSBheGlzLmR1cGxpY2F0ZURvbWFpbixcbiAgICB0eXBlID0gYXhpcy50eXBlLFxuICAgIHJhbmdlID0gYXhpcy5yYW5nZTtcbiAgdmFyIG9mZnNldEZvckJhbmQgPSBheGlzLnJlYWxTY2FsZVR5cGUgPT09ICdzY2FsZUJhbmQnID8gc2NhbGUuYmFuZHdpZHRoKCkgLyAyIDogMjtcbiAgdmFyIG9mZnNldCA9IChpc0dyaWQgfHwgaXNBbGwpICYmIHR5cGUgPT09ICdjYXRlZ29yeScgJiYgc2NhbGUuYmFuZHdpZHRoID8gc2NhbGUuYmFuZHdpZHRoKCkgLyBvZmZzZXRGb3JCYW5kIDogMDtcbiAgb2Zmc2V0ID0gYXhpcy5heGlzVHlwZSA9PT0gJ2FuZ2xlQXhpcycgJiYgKHJhbmdlID09PSBudWxsIHx8IHJhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByYW5nZS5sZW5ndGgpID49IDIgPyAoMCwgX0RhdGFVdGlscy5tYXRoU2lnbikocmFuZ2VbMF0gLSByYW5nZVsxXSkgKiAyICogb2Zmc2V0IDogb2Zmc2V0O1xuXG4gIC8vIFRoZSB0aWNrcyBzZXQgYnkgdXNlciBzaG91bGQgb25seSBhZmZlY3QgdGhlIHRpY2tzIGFkamFjZW50IHRvIGF4aXMgbGluZVxuICBpZiAoaXNHcmlkICYmIChheGlzLnRpY2tzIHx8IGF4aXMubmljZVRpY2tzKSkge1xuICAgIHZhciByZXN1bHQgPSAoYXhpcy50aWNrcyB8fCBheGlzLm5pY2VUaWNrcykubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgdmFyIHNjYWxlQ29udGVudCA9IGR1cGxpY2F0ZURvbWFpbiA/IGR1cGxpY2F0ZURvbWFpbi5pbmRleE9mKGVudHJ5KSA6IGVudHJ5O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gSWYgdGhlIHNjYWxlQ29udGVudCBpcyBub3QgYSBudW1iZXIsIHRoZSBjb29yZGluYXRlIHdpbGwgYmUgTmFOLlxuICAgICAgICAvLyBUaGF0IGNvdWxkIGJlIHRoZSBjYXNlIGZvciBleGFtcGxlIHdpdGggYSBQb2ludFNjYWxlIGFuZCBhIHN0cmluZyBhcyBkb21haW4uXG4gICAgICAgIGNvb3JkaW5hdGU6IHNjYWxlKHNjYWxlQ29udGVudCkgKyBvZmZzZXQsXG4gICAgICAgIHZhbHVlOiBlbnRyeSxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuICEoMCwgX2lzTmFOW1wiZGVmYXVsdFwiXSkocm93LmNvb3JkaW5hdGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gV2hlbiBheGlzIGlzIGEgY2F0ZWdvcmlhbCBheGlzLCBidXQgdGhlIHR5cGUgb2YgYXhpcyBpcyBudW1iZXIgb3IgdGhlIHNjYWxlIG9mIGF4aXMgaXMgbm90IFwiYXV0b1wiXG4gIGlmIChheGlzLmlzQ2F0ZWdvcmljYWwgJiYgYXhpcy5jYXRlZ29yaWNhbERvbWFpbikge1xuICAgIHJldHVybiBheGlzLmNhdGVnb3JpY2FsRG9tYWluLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb29yZGluYXRlOiBzY2FsZShlbnRyeSkgKyBvZmZzZXQsXG4gICAgICAgIHZhbHVlOiBlbnRyeSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBpZiAoc2NhbGUudGlja3MgJiYgIWlzQWxsKSB7XG4gICAgcmV0dXJuIHNjYWxlLnRpY2tzKGF4aXMudGlja0NvdW50KS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb29yZGluYXRlOiBzY2FsZShlbnRyeSkgKyBvZmZzZXQsXG4gICAgICAgIHZhbHVlOiBlbnRyeSxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvLyBXaGVuIGF4aXMgaGFzIGR1cGxpY2F0ZWQgdGV4dCwgc2VyaWFsIG51bWJlcnMgYXJlIHVzZWQgdG8gZ2VuZXJhdGUgc2NhbGVcbiAgcmV0dXJuIHNjYWxlLmRvbWFpbigpLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvb3JkaW5hdGU6IHNjYWxlKGVudHJ5KSArIG9mZnNldCxcbiAgICAgIHZhbHVlOiBkdXBsaWNhdGVEb21haW4gPyBkdXBsaWNhdGVEb21haW5bZW50cnldIDogZW50cnksXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBvZmZzZXQ6IG9mZnNldFxuICAgIH07XG4gIH0pO1xufTtcblxuLyoqXG4gKiBjb21iaW5lIHRoZSBoYW5kbGVyc1xuICogQHBhcmFtICB7RnVuY3Rpb259IGRlZmF1bHRIYW5kbGVyIEludGVybmFsIHByaXZhdGUgaGFuZGxlclxuICogQHBhcmFtICB7RnVuY3Rpb259IGNoaWxkSGFuZGxlciBIYW5kbGVyIGZ1bmN0aW9uIHNwZWNpZmllZCBpbiBjaGlsZCBjb21wb25lbnRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgICAgICAgICAgICAgICBUaGUgY29tYmluZWQgaGFuZGxlclxuICovXG5cbnZhciBoYW5kbGVyV2Vha01hcCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgY29tYmluZUV2ZW50SGFuZGxlcnMgPSBleHBvcnRzLmNvbWJpbmVFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24gY29tYmluZUV2ZW50SGFuZGxlcnMoZGVmYXVsdEhhbmRsZXIsIGNoaWxkSGFuZGxlcikge1xuICBpZiAodHlwZW9mIGNoaWxkSGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBkZWZhdWx0SGFuZGxlcjtcbiAgfVxuICBpZiAoIWhhbmRsZXJXZWFrTWFwLmhhcyhkZWZhdWx0SGFuZGxlcikpIHtcbiAgICBoYW5kbGVyV2Vha01hcC5zZXQoZGVmYXVsdEhhbmRsZXIsIG5ldyBXZWFrTWFwKCkpO1xuICB9XG4gIHZhciBjaGlsZFdlYWtNYXAgPSBoYW5kbGVyV2Vha01hcC5nZXQoZGVmYXVsdEhhbmRsZXIpO1xuICBpZiAoY2hpbGRXZWFrTWFwLmhhcyhjaGlsZEhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIGNoaWxkV2Vha01hcC5nZXQoY2hpbGRIYW5kbGVyKTtcbiAgfVxuICB2YXIgY29tYmluZUhhbmRsZXIgPSBmdW5jdGlvbiBjb21iaW5lSGFuZGxlcigpIHtcbiAgICBkZWZhdWx0SGFuZGxlci5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgY2hpbGRIYW5kbGVyLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfTtcbiAgY2hpbGRXZWFrTWFwLnNldChjaGlsZEhhbmRsZXIsIGNvbWJpbmVIYW5kbGVyKTtcbiAgcmV0dXJuIGNvbWJpbmVIYW5kbGVyO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgc2NhbGUgZnVuY3Rpb24gb2YgYXhpc1xuICogQHBhcmFtICB7T2JqZWN0fSAgIGF4aXMgICAgICAgICAgVGhlIG9wdGlvbiBvZiBheGlzXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgY2hhcnRUeXBlICAgICBUaGUgZGlzcGxheU5hbWUgb2YgY2hhcnRcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICBoYXNCYXIgICAgICAgIGlmIGl0IGhhcyBhIGJhclxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgIFRoZSBzY2FsZSBmdW5jdGlvbiBhbmQgcmVzb2x2ZWQgbmFtZVxuICovXG52YXIgcGFyc2VTY2FsZSA9IGV4cG9ydHMucGFyc2VTY2FsZSA9IGZ1bmN0aW9uIHBhcnNlU2NhbGUoYXhpcywgY2hhcnRUeXBlLCBoYXNCYXIpIHtcbiAgdmFyIHNjYWxlID0gYXhpcy5zY2FsZSxcbiAgICB0eXBlID0gYXhpcy50eXBlLFxuICAgIGxheW91dCA9IGF4aXMubGF5b3V0LFxuICAgIGF4aXNUeXBlID0gYXhpcy5heGlzVHlwZTtcbiAgaWYgKHNjYWxlID09PSAnYXV0bycpIHtcbiAgICBpZiAobGF5b3V0ID09PSAncmFkaWFsJyAmJiBheGlzVHlwZSA9PT0gJ3JhZGl1c0F4aXMnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZTogZDNTY2FsZXMuc2NhbGVCYW5kKCksXG4gICAgICAgIHJlYWxTY2FsZVR5cGU6ICdiYW5kJ1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGxheW91dCA9PT0gJ3JhZGlhbCcgJiYgYXhpc1R5cGUgPT09ICdhbmdsZUF4aXMnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZTogZDNTY2FsZXMuc2NhbGVMaW5lYXIoKSxcbiAgICAgICAgcmVhbFNjYWxlVHlwZTogJ2xpbmVhcidcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnY2F0ZWdvcnknICYmIGNoYXJ0VHlwZSAmJiAoY2hhcnRUeXBlLmluZGV4T2YoJ0xpbmVDaGFydCcpID49IDAgfHwgY2hhcnRUeXBlLmluZGV4T2YoJ0FyZWFDaGFydCcpID49IDAgfHwgY2hhcnRUeXBlLmluZGV4T2YoJ0NvbXBvc2VkQ2hhcnQnKSA+PSAwICYmICFoYXNCYXIpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZTogZDNTY2FsZXMuc2NhbGVQb2ludCgpLFxuICAgICAgICByZWFsU2NhbGVUeXBlOiAncG9pbnQnXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGU6IGQzU2NhbGVzLnNjYWxlQmFuZCgpLFxuICAgICAgICByZWFsU2NhbGVUeXBlOiAnYmFuZCdcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2FsZTogZDNTY2FsZXMuc2NhbGVMaW5lYXIoKSxcbiAgICAgIHJlYWxTY2FsZVR5cGU6ICdsaW5lYXInXG4gICAgfTtcbiAgfVxuICBpZiAoKDAsIF9pc1N0cmluZ1tcImRlZmF1bHRcIl0pKHNjYWxlKSkge1xuICAgIHZhciBuYW1lID0gXCJzY2FsZVwiLmNvbmNhdCgoMCwgX3VwcGVyRmlyc3RbXCJkZWZhdWx0XCJdKShzY2FsZSkpO1xuICAgIHJldHVybiB7XG4gICAgICBzY2FsZTogKGQzU2NhbGVzW25hbWVdIHx8IGQzU2NhbGVzLnNjYWxlUG9pbnQpKCksXG4gICAgICByZWFsU2NhbGVUeXBlOiBkM1NjYWxlc1tuYW1lXSA/IG5hbWUgOiAncG9pbnQnXG4gICAgfTtcbiAgfVxuICByZXR1cm4gKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkoc2NhbGUpID8ge1xuICAgIHNjYWxlOiBzY2FsZVxuICB9IDoge1xuICAgIHNjYWxlOiBkM1NjYWxlcy5zY2FsZVBvaW50KCksXG4gICAgcmVhbFNjYWxlVHlwZTogJ3BvaW50J1xuICB9O1xufTtcbnZhciBFUFMgPSAxZS00O1xudmFyIGNoZWNrRG9tYWluT2ZTY2FsZSA9IGV4cG9ydHMuY2hlY2tEb21haW5PZlNjYWxlID0gZnVuY3Rpb24gY2hlY2tEb21haW5PZlNjYWxlKHNjYWxlKSB7XG4gIHZhciBkb21haW4gPSBzY2FsZS5kb21haW4oKTtcbiAgaWYgKCFkb21haW4gfHwgZG9tYWluLmxlbmd0aCA8PSAyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBsZW4gPSBkb21haW4ubGVuZ3RoO1xuICB2YXIgcmFuZ2UgPSBzY2FsZS5yYW5nZSgpO1xuICB2YXIgbWluVmFsdWUgPSBNYXRoLm1pbihyYW5nZVswXSwgcmFuZ2VbMV0pIC0gRVBTO1xuICB2YXIgbWF4VmFsdWUgPSBNYXRoLm1heChyYW5nZVswXSwgcmFuZ2VbMV0pICsgRVBTO1xuICB2YXIgZmlyc3QgPSBzY2FsZShkb21haW5bMF0pO1xuICB2YXIgbGFzdCA9IHNjYWxlKGRvbWFpbltsZW4gLSAxXSk7XG4gIGlmIChmaXJzdCA8IG1pblZhbHVlIHx8IGZpcnN0ID4gbWF4VmFsdWUgfHwgbGFzdCA8IG1pblZhbHVlIHx8IGxhc3QgPiBtYXhWYWx1ZSkge1xuICAgIHNjYWxlLmRvbWFpbihbZG9tYWluWzBdLCBkb21haW5bbGVuIC0gMV1dKTtcbiAgfVxufTtcbnZhciBmaW5kUG9zaXRpb25PZkJhciA9IGV4cG9ydHMuZmluZFBvc2l0aW9uT2ZCYXIgPSBmdW5jdGlvbiBmaW5kUG9zaXRpb25PZkJhcihiYXJQb3NpdGlvbiwgY2hpbGQpIHtcbiAgaWYgKCFiYXJQb3NpdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBiYXJQb3NpdGlvbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChiYXJQb3NpdGlvbltpXS5pdGVtID09PSBjaGlsZCkge1xuICAgICAgcmV0dXJuIGJhclBvc2l0aW9uW2ldLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQm90aCB2YWx1ZSBhbmQgZG9tYWluIGFyZSB0dXBsZXMgb2YgdHdvIG51bWJlcnNcbiAqIC0gYnV0IHRoZSB0eXBlIHN0YXlzIGFzIGFycmF5IG9mIG51bWJlcnMgdW50aWwgd2UgaGF2ZSBiZXR0ZXIgc3VwcG9ydCBpbiByZXN0IG9mIHRoZSBhcHBcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIGlucHV0IHRoYXQgd2lsbCBiZSB0cnVuY2F0ZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGRvbWFpbiBib3VuZGFyaWVzXG4gKiBAcmV0dXJucyB7QXJyYXl9IHR1cGxlIG9mIHR3byBudW1iZXJzXG4gKi9cbnZhciB0cnVuY2F0ZUJ5RG9tYWluID0gZXhwb3J0cy50cnVuY2F0ZUJ5RG9tYWluID0gZnVuY3Rpb24gdHJ1bmNhdGVCeURvbWFpbih2YWx1ZSwgZG9tYWluKSB7XG4gIGlmICghZG9tYWluIHx8IGRvbWFpbi5sZW5ndGggIT09IDIgfHwgISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShkb21haW5bMF0pIHx8ICEoMCwgX0RhdGFVdGlscy5pc051bWJlcikoZG9tYWluWzFdKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgbWluVmFsdWUgPSBNYXRoLm1pbihkb21haW5bMF0sIGRvbWFpblsxXSk7XG4gIHZhciBtYXhWYWx1ZSA9IE1hdGgubWF4KGRvbWFpblswXSwgZG9tYWluWzFdKTtcbiAgdmFyIHJlc3VsdCA9IFt2YWx1ZVswXSwgdmFsdWVbMV1dO1xuICBpZiAoISgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh2YWx1ZVswXSkgfHwgdmFsdWVbMF0gPCBtaW5WYWx1ZSkge1xuICAgIHJlc3VsdFswXSA9IG1pblZhbHVlO1xuICB9XG4gIGlmICghKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHZhbHVlWzFdKSB8fCB2YWx1ZVsxXSA+IG1heFZhbHVlKSB7XG4gICAgcmVzdWx0WzFdID0gbWF4VmFsdWU7XG4gIH1cbiAgaWYgKHJlc3VsdFswXSA+IG1heFZhbHVlKSB7XG4gICAgcmVzdWx0WzBdID0gbWF4VmFsdWU7XG4gIH1cbiAgaWYgKHJlc3VsdFsxXSA8IG1pblZhbHVlKSB7XG4gICAgcmVzdWx0WzFdID0gbWluVmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU3RhY2tzIGFsbCBwb3NpdGl2ZSBudW1iZXJzIGFib3ZlIHplcm8gYW5kIGFsbCBuZWdhdGl2ZSBudW1iZXJzIGJlbG93IHplcm8uXG4gKlxuICogSWYgYWxsIHZhbHVlcyBpbiB0aGUgc2VyaWVzIGFyZSBwb3NpdGl2ZSB0aGVuIHRoaXMgYmVoYXZlcyB0aGUgc2FtZSBhcyAnbm9uZScgc3RhY2tlci5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzZXJpZXMgZnJvbSBkMy1zaGFwZSBTdGFja1xuICogQHJldHVybiB7QXJyYXl9IHNlcmllcyB3aXRoIGFwcGxpZWQgb2Zmc2V0XG4gKi9cbnZhciBvZmZzZXRTaWduID0gZXhwb3J0cy5vZmZzZXRTaWduID0gZnVuY3Rpb24gb2Zmc2V0U2lnbihzZXJpZXMpIHtcbiAgdmFyIG4gPSBzZXJpZXMubGVuZ3RoO1xuICBpZiAobiA8PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIGogPSAwLCBtID0gc2VyaWVzWzBdLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIHZhciBwb3NpdGl2ZSA9IDA7XG4gICAgdmFyIG5lZ2F0aXZlID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIHZhbHVlID0gKDAsIF9pc05hTltcImRlZmF1bHRcIl0pKHNlcmllc1tpXVtqXVsxXSkgPyBzZXJpZXNbaV1bal1bMF0gOiBzZXJpZXNbaV1bal1bMV07XG5cbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1kZXN0cnVjdHVyaW5nLCBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgc2VyaWVzW2ldW2pdWzBdID0gcG9zaXRpdmU7XG4gICAgICAgIHNlcmllc1tpXVtqXVsxXSA9IHBvc2l0aXZlICsgdmFsdWU7XG4gICAgICAgIHBvc2l0aXZlID0gc2VyaWVzW2ldW2pdWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWVzW2ldW2pdWzBdID0gbmVnYXRpdmU7XG4gICAgICAgIHNlcmllc1tpXVtqXVsxXSA9IG5lZ2F0aXZlICsgdmFsdWU7XG4gICAgICAgIG5lZ2F0aXZlID0gc2VyaWVzW2ldW2pdWzFdO1xuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmVmZXItZGVzdHJ1Y3R1cmluZywgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVwbGFjZXMgYWxsIG5lZ2F0aXZlIHZhbHVlcyB3aXRoIHplcm8gd2hlbiBzdGFja2luZyBkYXRhLlxuICpcbiAqIElmIGFsbCB2YWx1ZXMgaW4gdGhlIHNlcmllcyBhcmUgcG9zaXRpdmUgdGhlbiB0aGlzIGJlaGF2ZXMgdGhlIHNhbWUgYXMgJ25vbmUnIHN0YWNrZXIuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2VyaWVzIGZyb20gZDMtc2hhcGUgU3RhY2tcbiAqIEByZXR1cm4ge0FycmF5fSBzZXJpZXMgd2l0aCBhcHBsaWVkIG9mZnNldFxuICovXG52YXIgb2Zmc2V0UG9zaXRpdmUgPSBleHBvcnRzLm9mZnNldFBvc2l0aXZlID0gZnVuY3Rpb24gb2Zmc2V0UG9zaXRpdmUoc2VyaWVzKSB7XG4gIHZhciBuID0gc2VyaWVzLmxlbmd0aDtcbiAgaWYgKG4gPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBqID0gMCwgbSA9IHNlcmllc1swXS5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICB2YXIgcG9zaXRpdmUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgdmFsdWUgPSAoMCwgX2lzTmFOW1wiZGVmYXVsdFwiXSkoc2VyaWVzW2ldW2pdWzFdKSA/IHNlcmllc1tpXVtqXVswXSA6IHNlcmllc1tpXVtqXVsxXTtcblxuICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWRlc3RydWN0dXJpbmcsIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICBzZXJpZXNbaV1bal1bMF0gPSBwb3NpdGl2ZTtcbiAgICAgICAgc2VyaWVzW2ldW2pdWzFdID0gcG9zaXRpdmUgKyB2YWx1ZTtcbiAgICAgICAgcG9zaXRpdmUgPSBzZXJpZXNbaV1bal1bMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpZXNbaV1bal1bMF0gPSAwO1xuICAgICAgICBzZXJpZXNbaV1bal1bMV0gPSAwO1xuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmVmZXItZGVzdHJ1Y3R1cmluZywgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdHlwZSB0byBjb21wdXRlIG9mZnNldCBmb3Igc3RhY2tlZCBkYXRhLlxuICpcbiAqIGQzLXNoYXBlIGhhcyBzb21ldGhpbmcgZmlzaHkgZ29pbmcgb24gd2l0aCBpdHMgdHlwZXMuXG4gKiBJbiBAZGVmaW5pdGVseXR5cGVkL2QzLXNoYXBlLCB0aGlzIGZ1bmN0aW9uICh0aGUgb2Zmc2V0IGFjY2Vzc29yKSBpcyB0eXBlZCBhcyBTZXJpZXM8PiA9PiB2b2lkLlxuICogSG93ZXZlciEgV2hlbiBJIGFjdHVhbGx5IG9wZW4gdGhlIHN0b3J5Ym9vayBJIGNhbiBzZWUgdGhhdCB0aGUgb2Zmc2V0IGFjY2Vzc29yIGFjdHVhbGx5IHJlY2VpdmVzIEFycmF5PFNlcmllczw+Pi5cbiAqIFRoZSBzYW1lIEkgY2FuIHNlZSBpbiB0aGUgc291cmNlIGNvZGUgaXRzZWxmOlxuICogaHR0cHM6Ly9naXRodWIuY29tL0RlZmluaXRlbHlUeXBlZC9EZWZpbml0ZWx5VHlwZWQvZGlzY3Vzc2lvbnMvNjYwNDJcbiAqIFRoYXQgb25lIHVuZm9ydHVuYXRlbHkgaGFzIG5vIHR5cGVzIGJ1dCB3ZSBjYW4gdGVsbCBpdCBwYXNzZXMgdGhyZWUtZGltZW5zaW9uYWwgYXJyYXkuXG4gKlxuICogV2hpY2ggbGVhZHMgbWUgdG8gYmVsaWV2ZSB0aGF0IGRlZmluaXRlbHl0eXBlZCBpcyB3cm9uZyBvbiB0aGlzIG9uZS5cbiAqIFRoZXJlJ3Mgb3BlbiBkaXNjdXNzaW9uIG9uIHRoaXMgdG9waWMgd2l0aG91dCBtdWNoIGF0dGVudGlvbjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9EZWZpbml0ZWx5VHlwZWQvRGVmaW5pdGVseVR5cGVkL2Rpc2N1c3Npb25zLzY2MDQyXG4gKi9cblxudmFyIFNUQUNLX09GRlNFVF9NQVAgPSB7XG4gIHNpZ246IG9mZnNldFNpZ24sXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgZGVmaW5pdGVseXR5cGVkIHR5cGVzIGFyZSBpbmNvcnJlY3RcbiAgZXhwYW5kOiBfZDNTaGFwZS5zdGFja09mZnNldEV4cGFuZCxcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBkZWZpbml0ZWx5dHlwZWQgdHlwZXMgYXJlIGluY29ycmVjdFxuICBub25lOiBfZDNTaGFwZS5zdGFja09mZnNldE5vbmUsXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgZGVmaW5pdGVseXR5cGVkIHR5cGVzIGFyZSBpbmNvcnJlY3RcbiAgc2lsaG91ZXR0ZTogX2QzU2hhcGUuc3RhY2tPZmZzZXRTaWxob3VldHRlLFxuICAvLyBAdHMtZXhwZWN0LWVycm9yIGRlZmluaXRlbHl0eXBlZCB0eXBlcyBhcmUgaW5jb3JyZWN0XG4gIHdpZ2dsZTogX2QzU2hhcGUuc3RhY2tPZmZzZXRXaWdnbGUsXG4gIHBvc2l0aXZlOiBvZmZzZXRQb3NpdGl2ZVxufTtcbnZhciBnZXRTdGFja2VkRGF0YSA9IGV4cG9ydHMuZ2V0U3RhY2tlZERhdGEgPSBmdW5jdGlvbiBnZXRTdGFja2VkRGF0YShkYXRhLCBzdGFja0l0ZW1zLCBvZmZzZXRUeXBlKSB7XG4gIHZhciBkYXRhS2V5cyA9IHN0YWNrSXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0ucHJvcHMuZGF0YUtleTtcbiAgfSk7XG4gIHZhciBvZmZzZXRBY2Nlc3NvciA9IFNUQUNLX09GRlNFVF9NQVBbb2Zmc2V0VHlwZV07XG4gIHZhciBzdGFjayA9ICgwLCBfZDNTaGFwZS5zdGFjaykoKVxuICAvLyBAdHMtZXhwZWN0LWVycm9yIHN0YWNrLmtleXMgdHlwZSB3YW50cyBhbiBhcnJheSBvZiBzdHJpbmdzLCBidXQgd2UgcHJvdmlkZSBhcnJheSBvZiBEYXRhS2V5c1xuICAua2V5cyhkYXRhS2V5cykudmFsdWUoZnVuY3Rpb24gKGQsIGtleSkge1xuICAgIHJldHVybiArZ2V0VmFsdWVCeURhdGFLZXkoZCwga2V5LCAwKTtcbiAgfSkub3JkZXIoX2QzU2hhcGUuc3RhY2tPcmRlck5vbmUpXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgZGVmaW5pdGVseXR5cGVkIHR5cGVzIGFyZSBpbmNvcnJlY3RcbiAgLm9mZnNldChvZmZzZXRBY2Nlc3Nvcik7XG4gIHJldHVybiBzdGFjayhkYXRhKTtcbn07XG52YXIgZ2V0U3RhY2tHcm91cHNCeUF4aXNJZCA9IGV4cG9ydHMuZ2V0U3RhY2tHcm91cHNCeUF4aXNJZCA9IGZ1bmN0aW9uIGdldFN0YWNrR3JvdXBzQnlBeGlzSWQoZGF0YSwgX2l0ZW1zLCBudW1lcmljQXhpc0lkLCBjYXRlQXhpc0lkLCBvZmZzZXRUeXBlLCByZXZlcnNlU3RhY2tPcmRlcikge1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIHJldmVyc2luZyBpdGVtcyB0byBhZmZlY3QgcmVuZGVyIG9yZGVyIChmb3IgbGF5ZXJpbmcpXG4gIHZhciBpdGVtcyA9IHJldmVyc2VTdGFja09yZGVyID8gX2l0ZW1zLnJldmVyc2UoKSA6IF9pdGVtcztcbiAgdmFyIHBhcmVudFN0YWNrR3JvdXBzSW5pdGlhbFZhbHVlID0ge307XG4gIHZhciBzdGFja0dyb3VwcyA9IGl0ZW1zLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBpdGVtKSB7XG4gICAgdmFyIF9pdGVtJHR5cGUyO1xuICAgIHZhciBkZWZhdWx0ZWRQcm9wcyA9IChfaXRlbSR0eXBlMiA9IGl0ZW0udHlwZSkgIT09IG51bGwgJiYgX2l0ZW0kdHlwZTIgIT09IHZvaWQgMCAmJiBfaXRlbSR0eXBlMi5kZWZhdWx0UHJvcHMgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGl0ZW0udHlwZS5kZWZhdWx0UHJvcHMpLCBpdGVtLnByb3BzKSA6IGl0ZW0ucHJvcHM7XG4gICAgdmFyIHN0YWNrSWQgPSBkZWZhdWx0ZWRQcm9wcy5zdGFja0lkLFxuICAgICAgaGlkZSA9IGRlZmF1bHRlZFByb3BzLmhpZGU7XG4gICAgaWYgKGhpZGUpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciBheGlzSWQgPSBkZWZhdWx0ZWRQcm9wc1tudW1lcmljQXhpc0lkXTtcbiAgICB2YXIgcGFyZW50R3JvdXAgPSByZXN1bHRbYXhpc0lkXSB8fCB7XG4gICAgICBoYXNTdGFjazogZmFsc2UsXG4gICAgICBzdGFja0dyb3Vwczoge31cbiAgICB9O1xuICAgIGlmICgoMCwgX0RhdGFVdGlscy5pc051bU9yU3RyKShzdGFja0lkKSkge1xuICAgICAgdmFyIGNoaWxkR3JvdXAgPSBwYXJlbnRHcm91cC5zdGFja0dyb3Vwc1tzdGFja0lkXSB8fCB7XG4gICAgICAgIG51bWVyaWNBeGlzSWQ6IG51bWVyaWNBeGlzSWQsXG4gICAgICAgIGNhdGVBeGlzSWQ6IGNhdGVBeGlzSWQsXG4gICAgICAgIGl0ZW1zOiBbXVxuICAgICAgfTtcbiAgICAgIGNoaWxkR3JvdXAuaXRlbXMucHVzaChpdGVtKTtcbiAgICAgIHBhcmVudEdyb3VwLmhhc1N0YWNrID0gdHJ1ZTtcbiAgICAgIHBhcmVudEdyb3VwLnN0YWNrR3JvdXBzW3N0YWNrSWRdID0gY2hpbGRHcm91cDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50R3JvdXAuc3RhY2tHcm91cHNbKDAsIF9EYXRhVXRpbHMudW5pcXVlSWQpKCdfc3RhY2tJZF8nKV0gPSB7XG4gICAgICAgIG51bWVyaWNBeGlzSWQ6IG51bWVyaWNBeGlzSWQsXG4gICAgICAgIGNhdGVBeGlzSWQ6IGNhdGVBeGlzSWQsXG4gICAgICAgIGl0ZW1zOiBbaXRlbV1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGF4aXNJZCwgcGFyZW50R3JvdXApKTtcbiAgfSwgcGFyZW50U3RhY2tHcm91cHNJbml0aWFsVmFsdWUpO1xuICB2YXIgYXhpc1N0YWNrR3JvdXBzSW5pdGlhbFZhbHVlID0ge307XG4gIHJldHVybiBPYmplY3Qua2V5cyhzdGFja0dyb3VwcykucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGF4aXNJZCkge1xuICAgIHZhciBncm91cCA9IHN0YWNrR3JvdXBzW2F4aXNJZF07XG4gICAgaWYgKGdyb3VwLmhhc1N0YWNrKSB7XG4gICAgICB2YXIgc3RhY2tHcm91cHNJbml0aWFsVmFsdWUgPSB7fTtcbiAgICAgIGdyb3VwLnN0YWNrR3JvdXBzID0gT2JqZWN0LmtleXMoZ3JvdXAuc3RhY2tHcm91cHMpLnJlZHVjZShmdW5jdGlvbiAocmVzLCBzdGFja0lkKSB7XG4gICAgICAgIHZhciBnID0gZ3JvdXAuc3RhY2tHcm91cHNbc3RhY2tJZF07XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlcyksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIHN0YWNrSWQsIHtcbiAgICAgICAgICBudW1lcmljQXhpc0lkOiBudW1lcmljQXhpc0lkLFxuICAgICAgICAgIGNhdGVBeGlzSWQ6IGNhdGVBeGlzSWQsXG4gICAgICAgICAgaXRlbXM6IGcuaXRlbXMsXG4gICAgICAgICAgc3RhY2tlZERhdGE6IGdldFN0YWNrZWREYXRhKGRhdGEsIGcuaXRlbXMsIG9mZnNldFR5cGUpXG4gICAgICAgIH0pKTtcbiAgICAgIH0sIHN0YWNrR3JvdXBzSW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVzdWx0KSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgYXhpc0lkLCBncm91cCkpO1xuICB9LCBheGlzU3RhY2tHcm91cHNJbml0aWFsVmFsdWUpO1xufTtcblxuLyoqXG4gKiBDb25maWd1cmUgdGhlIHNjYWxlIGZ1bmN0aW9uIG9mIGF4aXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2FsZSBUaGUgc2NhbGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICBUaGUgY29uZmlndXJhdGlvbiBvZiBheGlzXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgbnVsbFxuICovXG52YXIgZ2V0VGlja3NPZlNjYWxlID0gZXhwb3J0cy5nZXRUaWNrc09mU2NhbGUgPSBmdW5jdGlvbiBnZXRUaWNrc09mU2NhbGUoc2NhbGUsIG9wdHMpIHtcbiAgdmFyIHJlYWxTY2FsZVR5cGUgPSBvcHRzLnJlYWxTY2FsZVR5cGUsXG4gICAgdHlwZSA9IG9wdHMudHlwZSxcbiAgICB0aWNrQ291bnQgPSBvcHRzLnRpY2tDb3VudCxcbiAgICBvcmlnaW5hbERvbWFpbiA9IG9wdHMub3JpZ2luYWxEb21haW4sXG4gICAgYWxsb3dEZWNpbWFscyA9IG9wdHMuYWxsb3dEZWNpbWFscztcbiAgdmFyIHNjYWxlVHlwZSA9IHJlYWxTY2FsZVR5cGUgfHwgb3B0cy5zY2FsZTtcbiAgaWYgKHNjYWxlVHlwZSAhPT0gJ2F1dG8nICYmIHNjYWxlVHlwZSAhPT0gJ2xpbmVhcicpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodGlja0NvdW50ICYmIHR5cGUgPT09ICdudW1iZXInICYmIG9yaWdpbmFsRG9tYWluICYmIChvcmlnaW5hbERvbWFpblswXSA9PT0gJ2F1dG8nIHx8IG9yaWdpbmFsRG9tYWluWzFdID09PSAnYXV0bycpKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB0aWNrcyBieSB0aGUgbnVtYmVyIG9mIGdyaWQgd2hlbiB0aGUgYXhpcyBpcyBhIG51bWJlciBheGlzXG4gICAgdmFyIGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpO1xuICAgIGlmICghZG9tYWluLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB0aWNrVmFsdWVzID0gKDAsIF9yZWNoYXJ0c1NjYWxlLmdldE5pY2VUaWNrVmFsdWVzKShkb21haW4sIHRpY2tDb3VudCwgYWxsb3dEZWNpbWFscyk7XG4gICAgc2NhbGUuZG9tYWluKFsoMCwgX21pbltcImRlZmF1bHRcIl0pKHRpY2tWYWx1ZXMpLCAoMCwgX21heFtcImRlZmF1bHRcIl0pKHRpY2tWYWx1ZXMpXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5pY2VUaWNrczogdGlja1ZhbHVlc1xuICAgIH07XG4gIH1cbiAgaWYgKHRpY2tDb3VudCAmJiB0eXBlID09PSAnbnVtYmVyJykge1xuICAgIHZhciBfZG9tYWluID0gc2NhbGUuZG9tYWluKCk7XG4gICAgdmFyIF90aWNrVmFsdWVzID0gKDAsIF9yZWNoYXJ0c1NjYWxlLmdldFRpY2tWYWx1ZXNGaXhlZERvbWFpbikoX2RvbWFpbiwgdGlja0NvdW50LCBhbGxvd0RlY2ltYWxzKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmljZVRpY2tzOiBfdGlja1ZhbHVlc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuZnVuY3Rpb24gZ2V0Q2F0ZUNvb3JkaW5hdGVPZkxpbmUoX3JlZjUpIHtcbiAgdmFyIGF4aXMgPSBfcmVmNS5heGlzLFxuICAgIHRpY2tzID0gX3JlZjUudGlja3MsXG4gICAgYmFuZFNpemUgPSBfcmVmNS5iYW5kU2l6ZSxcbiAgICBlbnRyeSA9IF9yZWY1LmVudHJ5LFxuICAgIGluZGV4ID0gX3JlZjUuaW5kZXgsXG4gICAgZGF0YUtleSA9IF9yZWY1LmRhdGFLZXk7XG4gIGlmIChheGlzLnR5cGUgPT09ICdjYXRlZ29yeScpIHtcbiAgICAvLyBmaW5kIGNvb3JkaW5hdGUgb2YgY2F0ZWdvcnkgYXhpcyBieSB0aGUgdmFsdWUgb2YgY2F0ZWdvcnlcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHdoeSBkb2VzIHRoaXMgdXNlIGRpcmVjdCBvYmplY3QgYWNjZXNzIGluc3RlYWQgb2YgZ2V0VmFsdWVCeURhdGFLZXk/XG4gICAgaWYgKCFheGlzLmFsbG93RHVwbGljYXRlZENhdGVnb3J5ICYmIGF4aXMuZGF0YUtleSAmJiAhKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGVudHJ5W2F4aXMuZGF0YUtleV0pKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHdoeSBkb2VzIHRoaXMgdXNlIGRpcmVjdCBvYmplY3QgYWNjZXNzIGluc3RlYWQgb2YgZ2V0VmFsdWVCeURhdGFLZXk/XG4gICAgICB2YXIgbWF0Y2hlZFRpY2sgPSAoMCwgX0RhdGFVdGlscy5maW5kRW50cnlJbkFycmF5KSh0aWNrcywgJ3ZhbHVlJywgZW50cnlbYXhpcy5kYXRhS2V5XSk7XG4gICAgICBpZiAobWF0Y2hlZFRpY2spIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZWRUaWNrLmNvb3JkaW5hdGUgKyBiYW5kU2l6ZSAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aWNrc1tpbmRleF0gPyB0aWNrc1tpbmRleF0uY29vcmRpbmF0ZSArIGJhbmRTaXplIC8gMiA6IG51bGw7XG4gIH1cbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWVCeURhdGFLZXkoZW50cnksICEoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoZGF0YUtleSkgPyBkYXRhS2V5IDogYXhpcy5kYXRhS2V5KTtcbiAgcmV0dXJuICEoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkodmFsdWUpID8gYXhpcy5zY2FsZSh2YWx1ZSkgOiBudWxsO1xufVxudmFyIGdldENhdGVDb29yZGluYXRlT2ZCYXIgPSBleHBvcnRzLmdldENhdGVDb29yZGluYXRlT2ZCYXIgPSBmdW5jdGlvbiBnZXRDYXRlQ29vcmRpbmF0ZU9mQmFyKF9yZWY2KSB7XG4gIHZhciBheGlzID0gX3JlZjYuYXhpcyxcbiAgICB0aWNrcyA9IF9yZWY2LnRpY2tzLFxuICAgIG9mZnNldCA9IF9yZWY2Lm9mZnNldCxcbiAgICBiYW5kU2l6ZSA9IF9yZWY2LmJhbmRTaXplLFxuICAgIGVudHJ5ID0gX3JlZjYuZW50cnksXG4gICAgaW5kZXggPSBfcmVmNi5pbmRleDtcbiAgaWYgKGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgIHJldHVybiB0aWNrc1tpbmRleF0gPyB0aWNrc1tpbmRleF0uY29vcmRpbmF0ZSArIG9mZnNldCA6IG51bGw7XG4gIH1cbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWVCeURhdGFLZXkoZW50cnksIGF4aXMuZGF0YUtleSwgYXhpcy5kb21haW5baW5kZXhdKTtcbiAgcmV0dXJuICEoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkodmFsdWUpID8gYXhpcy5zY2FsZSh2YWx1ZSkgLSBiYW5kU2l6ZSAvIDIgKyBvZmZzZXQgOiBudWxsO1xufTtcbnZhciBnZXRCYXNlVmFsdWVPZkJhciA9IGV4cG9ydHMuZ2V0QmFzZVZhbHVlT2ZCYXIgPSBmdW5jdGlvbiBnZXRCYXNlVmFsdWVPZkJhcihfcmVmNykge1xuICB2YXIgbnVtZXJpY0F4aXMgPSBfcmVmNy5udW1lcmljQXhpcztcbiAgdmFyIGRvbWFpbiA9IG51bWVyaWNBeGlzLnNjYWxlLmRvbWFpbigpO1xuICBpZiAobnVtZXJpY0F4aXMudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgbWluVmFsdWUgPSBNYXRoLm1pbihkb21haW5bMF0sIGRvbWFpblsxXSk7XG4gICAgdmFyIG1heFZhbHVlID0gTWF0aC5tYXgoZG9tYWluWzBdLCBkb21haW5bMV0pO1xuICAgIGlmIChtaW5WYWx1ZSA8PSAwICYmIG1heFZhbHVlID49IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAobWF4VmFsdWUgPCAwKSB7XG4gICAgICByZXR1cm4gbWF4VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBtaW5WYWx1ZTtcbiAgfVxuICByZXR1cm4gZG9tYWluWzBdO1xufTtcbnZhciBnZXRTdGFja2VkRGF0YU9mSXRlbSA9IGV4cG9ydHMuZ2V0U3RhY2tlZERhdGFPZkl0ZW0gPSBmdW5jdGlvbiBnZXRTdGFja2VkRGF0YU9mSXRlbShpdGVtLCBzdGFja0dyb3Vwcykge1xuICB2YXIgX2l0ZW0kdHlwZTM7XG4gIHZhciBkZWZhdWx0ZWRQcm9wcyA9IChfaXRlbSR0eXBlMyA9IGl0ZW0udHlwZSkgIT09IG51bGwgJiYgX2l0ZW0kdHlwZTMgIT09IHZvaWQgMCAmJiBfaXRlbSR0eXBlMy5kZWZhdWx0UHJvcHMgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGl0ZW0udHlwZS5kZWZhdWx0UHJvcHMpLCBpdGVtLnByb3BzKSA6IGl0ZW0ucHJvcHM7XG4gIHZhciBzdGFja0lkID0gZGVmYXVsdGVkUHJvcHMuc3RhY2tJZDtcbiAgaWYgKCgwLCBfRGF0YVV0aWxzLmlzTnVtT3JTdHIpKHN0YWNrSWQpKSB7XG4gICAgdmFyIGdyb3VwID0gc3RhY2tHcm91cHNbc3RhY2tJZF07XG4gICAgaWYgKGdyb3VwKSB7XG4gICAgICB2YXIgaXRlbUluZGV4ID0gZ3JvdXAuaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICAgIHJldHVybiBpdGVtSW5kZXggPj0gMCA/IGdyb3VwLnN0YWNrZWREYXRhW2l0ZW1JbmRleF0gOiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG52YXIgZ2V0RG9tYWluT2ZTaW5nbGUgPSBmdW5jdGlvbiBnZXREb21haW5PZlNpbmdsZShkYXRhKSB7XG4gIHJldHVybiBkYXRhLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBlbnRyeSkge1xuICAgIHJldHVybiBbKDAsIF9taW5bXCJkZWZhdWx0XCJdKShlbnRyeS5jb25jYXQoW3Jlc3VsdFswXV0pLmZpbHRlcihfRGF0YVV0aWxzLmlzTnVtYmVyKSksICgwLCBfbWF4W1wiZGVmYXVsdFwiXSkoZW50cnkuY29uY2F0KFtyZXN1bHRbMV1dKS5maWx0ZXIoX0RhdGFVdGlscy5pc051bWJlcikpXTtcbiAgfSwgW0luZmluaXR5LCAtSW5maW5pdHldKTtcbn07XG52YXIgZ2V0RG9tYWluT2ZTdGFja0dyb3VwcyA9IGV4cG9ydHMuZ2V0RG9tYWluT2ZTdGFja0dyb3VwcyA9IGZ1bmN0aW9uIGdldERvbWFpbk9mU3RhY2tHcm91cHMoc3RhY2tHcm91cHMsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzdGFja0dyb3VwcykucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHN0YWNrSWQpIHtcbiAgICB2YXIgZ3JvdXAgPSBzdGFja0dyb3Vwc1tzdGFja0lkXTtcbiAgICB2YXIgc3RhY2tlZERhdGEgPSBncm91cC5zdGFja2VkRGF0YTtcbiAgICB2YXIgZG9tYWluID0gc3RhY2tlZERhdGEucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGVudHJ5KSB7XG4gICAgICB2YXIgcyA9IGdldERvbWFpbk9mU2luZ2xlKGVudHJ5LnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4ICsgMSkpO1xuICAgICAgcmV0dXJuIFtNYXRoLm1pbihyZXNbMF0sIHNbMF0pLCBNYXRoLm1heChyZXNbMV0sIHNbMV0pXTtcbiAgICB9LCBbSW5maW5pdHksIC1JbmZpbml0eV0pO1xuICAgIHJldHVybiBbTWF0aC5taW4oZG9tYWluWzBdLCByZXN1bHRbMF0pLCBNYXRoLm1heChkb21haW5bMV0sIHJlc3VsdFsxXSldO1xuICB9LCBbSW5maW5pdHksIC1JbmZpbml0eV0pLm1hcChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSW5maW5pdHkgfHwgcmVzdWx0ID09PSAtSW5maW5pdHkgPyAwIDogcmVzdWx0O1xuICB9KTtcbn07XG52YXIgTUlOX1ZBTFVFX1JFRyA9IGV4cG9ydHMuTUlOX1ZBTFVFX1JFRyA9IC9eZGF0YU1pbltcXHNdKi1bXFxzXSooWzAtOV0rKFsuXXsxfVswLTldKyl7MCwxfSkkLztcbnZhciBNQVhfVkFMVUVfUkVHID0gZXhwb3J0cy5NQVhfVkFMVUVfUkVHID0gL15kYXRhTWF4W1xcc10qXFwrW1xcc10qKFswLTldKyhbLl17MX1bMC05XSspezAsMX0pJC87XG52YXIgcGFyc2VTcGVjaWZpZWREb21haW4gPSBleHBvcnRzLnBhcnNlU3BlY2lmaWVkRG9tYWluID0gZnVuY3Rpb24gcGFyc2VTcGVjaWZpZWREb21haW4oc3BlY2lmaWVkRG9tYWluLCBkYXRhRG9tYWluLCBhbGxvd0RhdGFPdmVyZmxvdykge1xuICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkoc3BlY2lmaWVkRG9tYWluKSkge1xuICAgIHJldHVybiBzcGVjaWZpZWREb21haW4oZGF0YURvbWFpbiwgYWxsb3dEYXRhT3ZlcmZsb3cpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzcGVjaWZpZWREb21haW4pKSB7XG4gICAgcmV0dXJuIGRhdGFEb21haW47XG4gIH1cbiAgdmFyIGRvbWFpbiA9IFtdO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1kZXN0cnVjdHVyaW5nICovXG4gIGlmICgoMCwgX0RhdGFVdGlscy5pc051bWJlcikoc3BlY2lmaWVkRG9tYWluWzBdKSkge1xuICAgIGRvbWFpblswXSA9IGFsbG93RGF0YU92ZXJmbG93ID8gc3BlY2lmaWVkRG9tYWluWzBdIDogTWF0aC5taW4oc3BlY2lmaWVkRG9tYWluWzBdLCBkYXRhRG9tYWluWzBdKTtcbiAgfSBlbHNlIGlmIChNSU5fVkFMVUVfUkVHLnRlc3Qoc3BlY2lmaWVkRG9tYWluWzBdKSkge1xuICAgIHZhciB2YWx1ZSA9ICtNSU5fVkFMVUVfUkVHLmV4ZWMoc3BlY2lmaWVkRG9tYWluWzBdKVsxXTtcbiAgICBkb21haW5bMF0gPSBkYXRhRG9tYWluWzBdIC0gdmFsdWU7XG4gIH0gZWxzZSBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkoc3BlY2lmaWVkRG9tYWluWzBdKSkge1xuICAgIGRvbWFpblswXSA9IHNwZWNpZmllZERvbWFpblswXShkYXRhRG9tYWluWzBdKTtcbiAgfSBlbHNlIHtcbiAgICBkb21haW5bMF0gPSBkYXRhRG9tYWluWzBdO1xuICB9XG4gIGlmICgoMCwgX0RhdGFVdGlscy5pc051bWJlcikoc3BlY2lmaWVkRG9tYWluWzFdKSkge1xuICAgIGRvbWFpblsxXSA9IGFsbG93RGF0YU92ZXJmbG93ID8gc3BlY2lmaWVkRG9tYWluWzFdIDogTWF0aC5tYXgoc3BlY2lmaWVkRG9tYWluWzFdLCBkYXRhRG9tYWluWzFdKTtcbiAgfSBlbHNlIGlmIChNQVhfVkFMVUVfUkVHLnRlc3Qoc3BlY2lmaWVkRG9tYWluWzFdKSkge1xuICAgIHZhciBfdmFsdWUgPSArTUFYX1ZBTFVFX1JFRy5leGVjKHNwZWNpZmllZERvbWFpblsxXSlbMV07XG4gICAgZG9tYWluWzFdID0gZGF0YURvbWFpblsxXSArIF92YWx1ZTtcbiAgfSBlbHNlIGlmICgoMCwgX2lzRnVuY3Rpb25bXCJkZWZhdWx0XCJdKShzcGVjaWZpZWREb21haW5bMV0pKSB7XG4gICAgZG9tYWluWzFdID0gc3BlY2lmaWVkRG9tYWluWzFdKGRhdGFEb21haW5bMV0pO1xuICB9IGVsc2Uge1xuICAgIGRvbWFpblsxXSA9IGRhdGFEb21haW5bMV07XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBwcmVmZXItZGVzdHJ1Y3R1cmluZyAqL1xuXG4gIHJldHVybiBkb21haW47XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgc2l6ZSBiZXR3ZWVuIHR3byBjYXRlZ29yeVxuICogQHBhcmFtICB7T2JqZWN0fSBheGlzICBUaGUgb3B0aW9ucyBvZiBheGlzXG4gKiBAcGFyYW0gIHtBcnJheX0gIHRpY2tzIFRoZSB0aWNrcyBvZiBheGlzXG4gKiBAcGFyYW0gIHtCb29sZWFufSBpc0JhciBpZiBpdGVtcyBpbiBheGlzIGFyZSBiYXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFNpemVcbiAqL1xudmFyIGdldEJhbmRTaXplT2ZBeGlzID0gZXhwb3J0cy5nZXRCYW5kU2l6ZU9mQXhpcyA9IGZ1bmN0aW9uIGdldEJhbmRTaXplT2ZBeGlzKGF4aXMsIHRpY2tzLCBpc0Jhcikge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIHdlIG5lZWQgdG8gcmV0aGluayBzY2FsZSB0eXBlXG4gIGlmIChheGlzICYmIGF4aXMuc2NhbGUgJiYgYXhpcy5zY2FsZS5iYW5kd2lkdGgpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHdlIG5lZWQgdG8gcmV0aGluayBzY2FsZSB0eXBlXG4gICAgdmFyIGJhbmRXaWR0aCA9IGF4aXMuc2NhbGUuYmFuZHdpZHRoKCk7XG4gICAgaWYgKCFpc0JhciB8fCBiYW5kV2lkdGggPiAwKSB7XG4gICAgICByZXR1cm4gYmFuZFdpZHRoO1xuICAgIH1cbiAgfVxuICBpZiAoYXhpcyAmJiB0aWNrcyAmJiB0aWNrcy5sZW5ndGggPj0gMikge1xuICAgIHZhciBvcmRlcmVkVGlja3MgPSAoMCwgX3NvcnRCeVtcImRlZmF1bHRcIl0pKHRpY2tzLCBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG8uY29vcmRpbmF0ZTtcbiAgICB9KTtcbiAgICB2YXIgYmFuZFNpemUgPSBJbmZpbml0eTtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gb3JkZXJlZFRpY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgY3VyID0gb3JkZXJlZFRpY2tzW2ldO1xuICAgICAgdmFyIHByZXYgPSBvcmRlcmVkVGlja3NbaSAtIDFdO1xuICAgICAgYmFuZFNpemUgPSBNYXRoLm1pbigoY3VyLmNvb3JkaW5hdGUgfHwgMCkgLSAocHJldi5jb29yZGluYXRlIHx8IDApLCBiYW5kU2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBiYW5kU2l6ZSA9PT0gSW5maW5pdHkgPyAwIDogYmFuZFNpemU7XG4gIH1cbiAgcmV0dXJuIGlzQmFyID8gdW5kZWZpbmVkIDogMDtcbn07XG4vKipcbiAqIHBhcnNlIHRoZSBkb21haW4gb2YgYSBjYXRlZ29yeSBheGlzIHdoZW4gYSBkb21haW4gaXMgc3BlY2lmaWVkXG4gKiBAcGFyYW0gICB7QXJyYXl9ICAgICAgICBzcGVjaWZpZWREb21haW4gIFRoZSBkb21haW4gc3BlY2lmaWVkIGJ5IHVzZXJzXG4gKiBAcGFyYW0gICB7QXJyYXl9ICAgICAgICBjYWxjdWxhdGVkRG9tYWluIFRoZSBkb21haW4gY2FsY3VsYXRlZCBieSBkYXRlS2V5XG4gKiBAcGFyYW0gICB7UmVhY3RFbGVtZW50fSBheGlzQ2hpbGQgICAgICAgIFRoZSBheGlzIFJlYWN0RWxlbWVudFxuICogQHJldHVybnMge0FycmF5fSAgICAgICAgZG9tYWluc1xuICovXG52YXIgcGFyc2VEb21haW5PZkNhdGVnb3J5QXhpcyA9IGV4cG9ydHMucGFyc2VEb21haW5PZkNhdGVnb3J5QXhpcyA9IGZ1bmN0aW9uIHBhcnNlRG9tYWluT2ZDYXRlZ29yeUF4aXMoc3BlY2lmaWVkRG9tYWluLCBjYWxjdWxhdGVkRG9tYWluLCBheGlzQ2hpbGQpIHtcbiAgaWYgKCFzcGVjaWZpZWREb21haW4gfHwgIXNwZWNpZmllZERvbWFpbi5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlZERvbWFpbjtcbiAgfVxuICBpZiAoKDAsIF9pc0VxdWFsW1wiZGVmYXVsdFwiXSkoc3BlY2lmaWVkRG9tYWluLCAoMCwgX2dldFtcImRlZmF1bHRcIl0pKGF4aXNDaGlsZCwgJ3R5cGUuZGVmYXVsdFByb3BzLmRvbWFpbicpKSkge1xuICAgIHJldHVybiBjYWxjdWxhdGVkRG9tYWluO1xuICB9XG4gIHJldHVybiBzcGVjaWZpZWREb21haW47XG59O1xudmFyIGdldFRvb2x0aXBJdGVtID0gZXhwb3J0cy5nZXRUb29sdGlwSXRlbSA9IGZ1bmN0aW9uIGdldFRvb2x0aXBJdGVtKGdyYXBoaWNhbEl0ZW0sIHBheWxvYWQpIHtcbiAgdmFyIGRlZmF1bHRlZFByb3BzID0gZ3JhcGhpY2FsSXRlbS50eXBlLmRlZmF1bHRQcm9wcyA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZ3JhcGhpY2FsSXRlbS50eXBlLmRlZmF1bHRQcm9wcyksIGdyYXBoaWNhbEl0ZW0ucHJvcHMpIDogZ3JhcGhpY2FsSXRlbS5wcm9wcztcbiAgdmFyIGRhdGFLZXkgPSBkZWZhdWx0ZWRQcm9wcy5kYXRhS2V5LFxuICAgIG5hbWUgPSBkZWZhdWx0ZWRQcm9wcy5uYW1lLFxuICAgIHVuaXQgPSBkZWZhdWx0ZWRQcm9wcy51bml0LFxuICAgIGZvcm1hdHRlciA9IGRlZmF1bHRlZFByb3BzLmZvcm1hdHRlcixcbiAgICB0b29sdGlwVHlwZSA9IGRlZmF1bHRlZFByb3BzLnRvb2x0aXBUeXBlLFxuICAgIGNoYXJ0VHlwZSA9IGRlZmF1bHRlZFByb3BzLmNoYXJ0VHlwZSxcbiAgICBoaWRlID0gZGVmYXVsdGVkUHJvcHMuaGlkZTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgKDAsIF9SZWFjdFV0aWxzLmZpbHRlclByb3BzKShncmFwaGljYWxJdGVtLCBmYWxzZSkpLCB7fSwge1xuICAgIGRhdGFLZXk6IGRhdGFLZXksXG4gICAgdW5pdDogdW5pdCxcbiAgICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcbiAgICBuYW1lOiBuYW1lIHx8IGRhdGFLZXksXG4gICAgY29sb3I6IGdldE1haW5Db2xvck9mR3JhcGhpY0l0ZW0oZ3JhcGhpY2FsSXRlbSksXG4gICAgdmFsdWU6IGdldFZhbHVlQnlEYXRhS2V5KHBheWxvYWQsIGRhdGFLZXkpLFxuICAgIHR5cGU6IHRvb2x0aXBUeXBlLFxuICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgaGlkZTogaGlkZVxuICB9KTtcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0Q2F0ZUNvb3JkaW5hdGVPZkJhciIsImdldEJhc2VWYWx1ZU9mQmFyIiwiZ2V0QmFyU2l6ZUxpc3QiLCJnZXRCYXJQb3NpdGlvbiIsImdldEJhbmRTaXplT2ZBeGlzIiwiZmluZFBvc2l0aW9uT2ZCYXIiLCJjb21iaW5lRXZlbnRIYW5kbGVycyIsImNoZWNrRG9tYWluT2ZTY2FsZSIsImNhbGN1bGF0ZUFjdGl2ZVRpY2tJbmRleCIsImFwcGVuZE9mZnNldE9mTGVnZW5kIiwiTUlOX1ZBTFVFX1JFRyIsIk1BWF9WQUxVRV9SRUciLCJnZXRDYXRlQ29vcmRpbmF0ZU9mTGluZSIsImdldENvb3JkaW5hdGVzT2ZHcmlkIiwiZ2V0RG9tYWluT2ZEYXRhQnlLZXkiLCJnZXREb21haW5PZlN0YWNrR3JvdXBzIiwiZ2V0RG9tYWluT2ZJdGVtc1dpdGhTYW1lQXhpcyIsImdldERvbWFpbk9mRXJyb3JCYXJzIiwiZW51bWVyYWJsZSIsImdldCIsIl9nZXRMZWdlbmRQcm9wcyIsImdldExlZ2VuZFByb3BzIiwiZ2V0VG9vbHRpcEl0ZW0iLCJnZXRUaWNrc09mU2NhbGUiLCJnZXRUaWNrc09mQXhpcyIsImdldFN0YWNrZWREYXRhT2ZJdGVtIiwiZ2V0U3RhY2tlZERhdGEiLCJnZXRTdGFja0dyb3Vwc0J5QXhpc0lkIiwiZ2V0TWFpbkNvbG9yT2ZHcmFwaGljSXRlbSIsImdldFZhbHVlQnlEYXRhS2V5IiwidHJ1bmNhdGVCeURvbWFpbiIsInBhcnNlU3BlY2lmaWVkRG9tYWluIiwicGFyc2VTY2FsZSIsInBhcnNlRXJyb3JCYXJzT2ZBeGlzIiwicGFyc2VEb21haW5PZkNhdGVnb3J5QXhpcyIsIm9mZnNldFNpZ24iLCJvZmZzZXRQb3NpdGl2ZSIsImlzQ2F0ZWdvcmljYWxBeGlzIiwiZDNTY2FsZXMiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfZDNTaGFwZSIsIl9tYXgiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX21pbiIsIl9pc05pbCIsIl9pc0Z1bmN0aW9uIiwiX2lzU3RyaW5nIiwiX2dldCIsIl9mbGF0TWFwIiwiX2lzTmFOIiwiX3VwcGVyRmlyc3QiLCJfaXNFcXVhbCIsIl9zb3J0QnkiLCJfcmVjaGFydHNTY2FsZSIsIl9FcnJvckJhciIsIl9EYXRhVXRpbHMiLCJfUmVhY3RVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX3R5cGVvZiIsImhhcyIsIm4iLCJfX3Byb3RvX18iLCJhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl90b0NvbnN1bWFibGVBcnJheSIsImFyciIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJUeXBlRXJyb3IiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsIml0ZXIiLCJpc0FycmF5IiwibGVuIiwibGVuZ3RoIiwiYXJyMiIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImtleSIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsImRhdGFLZXkiLCJkZWZhdWx0VmFsdWUiLCJpc051bU9yU3RyIiwiZGF0YSIsInR5cGUiLCJmaWx0ZXJOaWwiLCJmbGF0dGVuRGF0YSIsImVudHJ5IiwiZG9tYWluIiwiaXNOdW1iZXIiLCJwYXJzZUZsb2F0IiwiSW5maW5pdHkiLCJ2YWxpZGF0ZURhdGEiLCJtYXAiLCJEYXRlIiwiY29vcmRpbmF0ZSIsIl90aWNrcyRsZW5ndGgiLCJ0aWNrcyIsInVuZGVmaW5lZCIsInVuc29ydGVkVGlja3MiLCJheGlzIiwiaW5kZXgiLCJheGlzVHlwZSIsIk1hdGgiLCJhYnMiLCJyYW5nZSIsImJlZm9yZSIsImN1ciIsImFmdGVyIiwic2FtZURpcmVjdGlvbkNvb3JkIiwibWF0aFNpZ24iLCJkaWZmSW50ZXJ2YWwiLCJjdXJJblJhbmdlIiwibWluIiwibWF4IiwiYWZ0ZXJJblJhbmdlIiwic2FtZUludGVydmFsIiwibWluVmFsdWUiLCJtYXhWYWx1ZSIsIl9pIiwiaXRlbSIsIl9pdGVtJHR5cGUiLCJfcmVmIiwiZGlzcGxheU5hbWUiLCJkZWZhdWx0ZWRQcm9wcyIsImRlZmF1bHRQcm9wcyIsInByb3BzIiwic3Ryb2tlIiwiZmlsbCIsInJlc3VsdCIsIl9yZWYyIiwiZ2xvYmFsU2l6ZSIsImJhclNpemUiLCJ0b3RhbFNpemUiLCJfcmVmMiRzdGFja0dyb3VwcyIsInN0YWNrR3JvdXBzIiwibnVtZXJpY0F4aXNJZHMiLCJzZ3MiLCJzdGFja0lkcyIsImoiLCJzTGVuIiwiX3NncyRzdGFja0lkcyRqIiwiaXRlbXMiLCJjYXRlQXhpc0lkIiwiYmFySXRlbXMiLCJnZXREaXNwbGF5TmFtZSIsImluZGV4T2YiLCJiYXJJdGVtRGVmYXVsdFByb3BzIiwiYmFySXRlbVByb3BzIiwic2VsZlNpemUiLCJjYXRlSWQiLCJzdGFja0xpc3QiLCJnZXRQZXJjZW50VmFsdWUiLCJfcmVmMyIsImJhckdhcCIsImJhckNhdGVnb3J5R2FwIiwiYmFuZFNpemUiLCJfcmVmMyRzaXplTGlzdCIsInNpemVMaXN0IiwibWF4QmFyU2l6ZSIsInJlYWxCYXJHYXAiLCJpbml0aWFsVmFsdWUiLCJ1c2VGdWxsIiwiZnVsbEJhclNpemUiLCJzdW0iLCJyZWR1Y2UiLCJyZXMiLCJvZmZzZXQiLCJwcmV2Iiwic2l6ZSIsIm5ld1Bvc2l0aW9uIiwicG9zaXRpb24iLCJuZXdSZXMiLCJjb25jYXQiLCJfb2Zmc2V0Iiwib3JpZ2luYWxTaXplIiwiX3VudXNlZCIsImxlZ2VuZEJveCIsImNoaWxkcmVuIiwid2lkdGgiLCJtYXJnaW4iLCJsZWdlbmRXaWR0aCIsImxlZnQiLCJyaWdodCIsImxlZ2VuZFByb3BzIiwiX3JlZjQiLCJib3hXaWR0aCIsImJveEhlaWdodCIsImhlaWdodCIsImFsaWduIiwidmVydGljYWxBbGlnbiIsImxheW91dCIsImlzRXJyb3JCYXJSZWxldmFudEZvckF4aXMiLCJkaXJlY3Rpb24iLCJlcnJvckJhcnMiLCJmaW5kQWxsQnlUeXBlIiwiRXJyb3JCYXIiLCJlcnJvckJhckNoaWxkIiwiZW50cnlWYWx1ZSIsIm1haW5WYWx1ZSIsImVycm9yRG9tYWluIiwicHJldkVycm9yQXJyIiwiayIsImVycm9yVmFsdWUiLCJsb3dlclZhbHVlIiwidXBwZXJWYWx1ZSIsImRvbWFpbnMiLCJ0YWciLCJzeW5jV2l0aFRpY2tzIiwiaGFzTWluIiwiaGFzTWF4IiwidmFsdWVzIiwiaXNHcmlkIiwiaXNBbGwiLCJzY2FsZSIsImR1cGxpY2F0ZURvbWFpbiIsIm9mZnNldEZvckJhbmQiLCJyZWFsU2NhbGVUeXBlIiwiYmFuZHdpZHRoIiwibmljZVRpY2tzIiwic2NhbGVDb250ZW50Iiwicm93IiwiaXNDYXRlZ29yaWNhbCIsImNhdGVnb3JpY2FsRG9tYWluIiwidGlja0NvdW50IiwiaGFuZGxlcldlYWtNYXAiLCJkZWZhdWx0SGFuZGxlciIsImNoaWxkSGFuZGxlciIsImNoaWxkV2Vha01hcCIsImNvbWJpbmVIYW5kbGVyIiwiY2hhcnRUeXBlIiwiaGFzQmFyIiwic2NhbGVCYW5kIiwic2NhbGVMaW5lYXIiLCJzY2FsZVBvaW50IiwiRVBTIiwiZmlyc3QiLCJsYXN0IiwiYmFyUG9zaXRpb24iLCJjaGlsZCIsInNlcmllcyIsIm0iLCJwb3NpdGl2ZSIsIm5lZ2F0aXZlIiwiU1RBQ0tfT0ZGU0VUX01BUCIsInNpZ24iLCJleHBhbmQiLCJzdGFja09mZnNldEV4cGFuZCIsIm5vbmUiLCJzdGFja09mZnNldE5vbmUiLCJzaWxob3VldHRlIiwic3RhY2tPZmZzZXRTaWxob3VldHRlIiwid2lnZ2xlIiwic3RhY2tPZmZzZXRXaWdnbGUiLCJzdGFja0l0ZW1zIiwib2Zmc2V0VHlwZSIsImRhdGFLZXlzIiwib2Zmc2V0QWNjZXNzb3IiLCJzdGFjayIsImQiLCJvcmRlciIsInN0YWNrT3JkZXJOb25lIiwiX2l0ZW1zIiwibnVtZXJpY0F4aXNJZCIsInJldmVyc2VTdGFja09yZGVyIiwicmV2ZXJzZSIsInBhcmVudFN0YWNrR3JvdXBzSW5pdGlhbFZhbHVlIiwiX2l0ZW0kdHlwZTIiLCJzdGFja0lkIiwiaGlkZSIsImF4aXNJZCIsInBhcmVudEdyb3VwIiwiaGFzU3RhY2siLCJjaGlsZEdyb3VwIiwidW5pcXVlSWQiLCJheGlzU3RhY2tHcm91cHNJbml0aWFsVmFsdWUiLCJncm91cCIsInN0YWNrR3JvdXBzSW5pdGlhbFZhbHVlIiwiZyIsInN0YWNrZWREYXRhIiwib3B0cyIsIm9yaWdpbmFsRG9tYWluIiwiYWxsb3dEZWNpbWFscyIsInNjYWxlVHlwZSIsInRpY2tWYWx1ZXMiLCJnZXROaWNlVGlja1ZhbHVlcyIsIl9kb21haW4iLCJfdGlja1ZhbHVlcyIsImdldFRpY2tWYWx1ZXNGaXhlZERvbWFpbiIsIl9yZWY1IiwiYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnkiLCJtYXRjaGVkVGljayIsImZpbmRFbnRyeUluQXJyYXkiLCJfcmVmNiIsIl9yZWY3IiwibnVtZXJpY0F4aXMiLCJfaXRlbSR0eXBlMyIsIml0ZW1JbmRleCIsImdldERvbWFpbk9mU2luZ2xlIiwic3RhcnRJbmRleCIsImVuZEluZGV4IiwicyIsInNwZWNpZmllZERvbWFpbiIsImRhdGFEb21haW4iLCJhbGxvd0RhdGFPdmVyZmxvdyIsImV4ZWMiLCJfdmFsdWUiLCJpc0JhciIsImJhbmRXaWR0aCIsIm9yZGVyZWRUaWNrcyIsImNhbGN1bGF0ZWREb21haW4iLCJheGlzQ2hpbGQiLCJncmFwaGljYWxJdGVtIiwicGF5bG9hZCIsInVuaXQiLCJmb3JtYXR0ZXIiLCJ0b29sdGlwVHlwZSIsImZpbHRlclByb3BzIiwiY29sb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/ChartUtils.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/Constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/util/Constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.COLOR_PANEL = void 0;\nvar COLOR_PANEL = exports.COLOR_PANEL = [\n    \"#1890FF\",\n    \"#66B5FF\",\n    \"#41D9C7\",\n    \"#2FC25B\",\n    \"#6EDB8F\",\n    \"#9AE65C\",\n    \"#FACC14\",\n    \"#E6965C\",\n    \"#57AD71\",\n    \"#223273\",\n    \"#738AE6\",\n    \"#7564CC\",\n    \"#8543E0\",\n    \"#A877ED\",\n    \"#5C8EE6\",\n    \"#13C2C2\",\n    \"#70E0E0\",\n    \"#5CA3E6\",\n    \"#3436C7\",\n    \"#8082FF\",\n    \"#DD81E6\",\n    \"#F04864\",\n    \"#FA7D92\",\n    \"#D598D9\"\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvQ29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxtQkFBbUIsR0FBRyxLQUFLO0FBQzNCLElBQUlFLGNBQWNGLG1CQUFtQixHQUFHO0lBQUM7SUFBVztJQUFXO0lBQVc7SUFBVztJQUFXO0lBQVc7SUFBVztJQUFXO0lBQVc7SUFBVztJQUFXO0lBQVc7SUFBVztJQUFXO0lBQVc7SUFBVztJQUFXO0lBQVc7SUFBVztJQUFXO0lBQVc7SUFBVztJQUFXO0NBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvQ29uc3RhbnRzLmpzPzlkY2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNPTE9SX1BBTkVMID0gdm9pZCAwO1xudmFyIENPTE9SX1BBTkVMID0gZXhwb3J0cy5DT0xPUl9QQU5FTCA9IFsnIzE4OTBGRicsICcjNjZCNUZGJywgJyM0MUQ5QzcnLCAnIzJGQzI1QicsICcjNkVEQjhGJywgJyM5QUU2NUMnLCAnI0ZBQ0MxNCcsICcjRTY5NjVDJywgJyM1N0FENzEnLCAnIzIyMzI3MycsICcjNzM4QUU2JywgJyM3NTY0Q0MnLCAnIzg1NDNFMCcsICcjQTg3N0VEJywgJyM1QzhFRTYnLCAnIzEzQzJDMicsICcjNzBFMEUwJywgJyM1Q0EzRTYnLCAnIzM0MzZDNycsICcjODA4MkZGJywgJyNERDgxRTYnLCAnI0YwNDg2NCcsICcjRkE3RDkyJywgJyNENTk4RDknXTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDT0xPUl9QQU5FTCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/Constants.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/CssPrefixUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/recharts/lib/util/CssPrefixUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.generatePrefixStyle = void 0;\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar PREFIX_LIST = [\n    \"Webkit\",\n    \"Moz\",\n    \"O\",\n    \"ms\"\n];\nvar generatePrefixStyle = exports.generatePrefixStyle = function generatePrefixStyle(name, value) {\n    if (!name) {\n        return null;\n    }\n    var camelName = name.replace(/(\\w)/, function(v) {\n        return v.toUpperCase();\n    });\n    var result = PREFIX_LIST.reduce(function(res, entry) {\n        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, entry + camelName, value));\n    }, {});\n    result[name] = value;\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvQ3NzUHJlZml4VXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELDJCQUEyQixHQUFHLEtBQUs7QUFDbkMsU0FBU0csUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLLFFBQVFDLENBQUMsRUFBRUMsQ0FBQztJQUFJLElBQUlDLElBQUlkLE9BQU9lLElBQUksQ0FBQ0g7SUFBSSxJQUFJWixPQUFPZ0IscUJBQXFCLEVBQUU7UUFBRSxJQUFJVixJQUFJTixPQUFPZ0IscUJBQXFCLENBQUNKO1FBQUlDLEtBQU1QLENBQUFBLElBQUlBLEVBQUVXLE1BQU0sQ0FBQyxTQUFVSixDQUFDO1lBQUksT0FBT2IsT0FBT2tCLHdCQUF3QixDQUFDTixHQUFHQyxHQUFHTSxVQUFVO1FBQUUsRUFBQyxHQUFJTCxFQUFFTSxJQUFJLENBQUNDLEtBQUssQ0FBQ1AsR0FBR1I7SUFBSTtJQUFFLE9BQU9RO0FBQUc7QUFDOVAsU0FBU1EsY0FBY1YsQ0FBQztJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJVSxVQUFVQyxNQUFNLEVBQUVYLElBQUs7UUFBRSxJQUFJQyxJQUFJLFFBQVFTLFNBQVMsQ0FBQ1YsRUFBRSxHQUFHVSxTQUFTLENBQUNWLEVBQUUsR0FBRyxDQUFDO1FBQUdBLElBQUksSUFBSUYsUUFBUVgsT0FBT2MsSUFBSSxDQUFDLEdBQUdXLE9BQU8sQ0FBQyxTQUFVWixDQUFDO1lBQUlhLGdCQUFnQmQsR0FBR0MsR0FBR0MsQ0FBQyxDQUFDRCxFQUFFO1FBQUcsS0FBS2IsT0FBTzJCLHlCQUF5QixHQUFHM0IsT0FBTzRCLGdCQUFnQixDQUFDaEIsR0FBR1osT0FBTzJCLHlCQUF5QixDQUFDYixNQUFNSCxRQUFRWCxPQUFPYyxJQUFJVyxPQUFPLENBQUMsU0FBVVosQ0FBQztZQUFJYixPQUFPQyxjQUFjLENBQUNXLEdBQUdDLEdBQUdiLE9BQU9rQix3QkFBd0IsQ0FBQ0osR0FBR0Q7UUFBSztJQUFJO0lBQUUsT0FBT0Q7QUFBRztBQUN0YixTQUFTYyxnQkFBZ0JHLEdBQUcsRUFBRUMsR0FBRyxFQUFFM0IsS0FBSztJQUFJMkIsTUFBTUMsZUFBZUQ7SUFBTSxJQUFJQSxPQUFPRCxLQUFLO1FBQUU3QixPQUFPQyxjQUFjLENBQUM0QixLQUFLQyxLQUFLO1lBQUUzQixPQUFPQTtZQUFPZ0IsWUFBWTtZQUFNYSxjQUFjO1lBQU1DLFVBQVU7UUFBSztJQUFJLE9BQU87UUFBRUosR0FBRyxDQUFDQyxJQUFJLEdBQUczQjtJQUFPO0lBQUUsT0FBTzBCO0FBQUs7QUFDM08sU0FBU0UsZUFBZWpCLENBQUM7SUFBSSxJQUFJb0IsSUFBSUMsYUFBYXJCLEdBQUc7SUFBVyxPQUFPLFlBQVlULFFBQVE2QixLQUFLQSxJQUFJQSxJQUFJO0FBQUk7QUFDNUcsU0FBU0MsYUFBYXJCLENBQUMsRUFBRUQsQ0FBQztJQUFJLElBQUksWUFBWVIsUUFBUVMsTUFBTSxDQUFDQSxHQUFHLE9BQU9BO0lBQUcsSUFBSUYsSUFBSUUsQ0FBQyxDQUFDUCxPQUFPNkIsV0FBVyxDQUFDO0lBQUUsSUFBSSxLQUFLLE1BQU14QixHQUFHO1FBQUUsSUFBSXNCLElBQUl0QixFQUFFeUIsSUFBSSxDQUFDdkIsR0FBR0QsS0FBSztRQUFZLElBQUksWUFBWVIsUUFBUTZCLElBQUksT0FBT0E7UUFBRyxNQUFNLElBQUlJLFVBQVU7SUFBaUQ7SUFBRSxPQUFPLENBQUMsYUFBYXpCLElBQUkwQixTQUFTQyxNQUFLLEVBQUcxQjtBQUFJO0FBQzNULElBQUkyQixjQUFjO0lBQUM7SUFBVTtJQUFPO0lBQUs7Q0FBSztBQUM5QyxJQUFJckMsc0JBQXNCRiwyQkFBMkIsR0FBRyxTQUFTRSxvQkFBb0JzQyxJQUFJLEVBQUV2QyxLQUFLO0lBQzlGLElBQUksQ0FBQ3VDLE1BQU07UUFDVCxPQUFPO0lBQ1Q7SUFDQSxJQUFJQyxZQUFZRCxLQUFLRSxPQUFPLENBQUMsUUFBUSxTQUFVQyxDQUFDO1FBQzlDLE9BQU9BLEVBQUVDLFdBQVc7SUFDdEI7SUFDQSxJQUFJQyxTQUFTTixZQUFZTyxNQUFNLENBQUMsU0FBVUMsR0FBRyxFQUFFQyxLQUFLO1FBQ2xELE9BQU81QixjQUFjQSxjQUFjLENBQUMsR0FBRzJCLE1BQU0sQ0FBQyxHQUFHdkIsZ0JBQWdCLENBQUMsR0FBR3dCLFFBQVFQLFdBQVd4QztJQUMxRixHQUFHLENBQUM7SUFDSjRDLE1BQU0sQ0FBQ0wsS0FBSyxHQUFHdkM7SUFDZixPQUFPNEM7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9Dc3NQcmVmaXhVdGlscy5qcz8zNmNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZW5lcmF0ZVByZWZpeFN0eWxlID0gdm9pZCAwO1xuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBQUkVGSVhfTElTVCA9IFsnV2Via2l0JywgJ01veicsICdPJywgJ21zJ107XG52YXIgZ2VuZXJhdGVQcmVmaXhTdHlsZSA9IGV4cG9ydHMuZ2VuZXJhdGVQcmVmaXhTdHlsZSA9IGZ1bmN0aW9uIGdlbmVyYXRlUHJlZml4U3R5bGUobmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFuYW1lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGNhbWVsTmFtZSA9IG5hbWUucmVwbGFjZSgvKFxcdykvLCBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2LnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xuICB2YXIgcmVzdWx0ID0gUFJFRklYX0xJU1QucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGVudHJ5KSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVzKSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgZW50cnkgKyBjYW1lbE5hbWUsIHZhbHVlKSk7XG4gIH0sIHt9KTtcbiAgcmVzdWx0W25hbWVdID0gdmFsdWU7XG4gIHJldHVybiByZXN1bHQ7XG59OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdlbmVyYXRlUHJlZml4U3R5bGUiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJvd25LZXlzIiwiZSIsInIiLCJ0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwib2JqIiwia2V5IiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImkiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJQUkVGSVhfTElTVCIsIm5hbWUiLCJjYW1lbE5hbWUiLCJyZXBsYWNlIiwidiIsInRvVXBwZXJDYXNlIiwicmVzdWx0IiwicmVkdWNlIiwicmVzIiwiZW50cnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/CssPrefixUtils.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/DOMUtils.js":
/*!****************************************************!*\
  !*** ./node_modules/recharts/lib/util/DOMUtils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getStyleString = exports.getStringSize = exports.getOffset = void 0;\nvar _Global = __webpack_require__(/*! ./Global */ \"./node_modules/recharts/lib/util/Global.js\");\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nvar stringCache = {\n    widthCache: {},\n    cacheCount: 0\n};\nvar MAX_CACHE_NUM = 2000;\nvar SPAN_STYLE = {\n    position: \"absolute\",\n    top: \"-20000px\",\n    left: 0,\n    padding: 0,\n    margin: 0,\n    border: \"none\",\n    whiteSpace: \"pre\"\n};\nvar STYLE_LIST = [\n    \"minWidth\",\n    \"maxWidth\",\n    \"width\",\n    \"minHeight\",\n    \"maxHeight\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"fontSize\",\n    \"lineHeight\",\n    \"padding\",\n    \"margin\",\n    \"paddingLeft\",\n    \"paddingRight\",\n    \"paddingTop\",\n    \"paddingBottom\",\n    \"marginLeft\",\n    \"marginRight\",\n    \"marginTop\",\n    \"marginBottom\"\n];\nvar MEASUREMENT_SPAN_ID = \"recharts_measurement_span\";\nfunction autoCompleteStyle(name, value) {\n    if (STYLE_LIST.indexOf(name) >= 0 && value === +value) {\n        return \"\".concat(value, \"px\");\n    }\n    return value;\n}\nfunction camelToMiddleLine(text) {\n    var strs = text.split(\"\");\n    var formatStrs = strs.reduce(function(result, entry) {\n        if (entry === entry.toUpperCase()) {\n            return [].concat(_toConsumableArray(result), [\n                \"-\",\n                entry.toLowerCase()\n            ]);\n        }\n        return [].concat(_toConsumableArray(result), [\n            entry\n        ]);\n    }, []);\n    return formatStrs.join(\"\");\n}\nvar getStyleString = exports.getStyleString = function getStyleString(style) {\n    return Object.keys(style).reduce(function(result, s) {\n        return \"\".concat(result).concat(camelToMiddleLine(s), \":\").concat(autoCompleteStyle(s, style[s]), \";\");\n    }, \"\");\n};\nfunction removeInvalidKeys(obj) {\n    var copyObj = _objectSpread({}, obj);\n    Object.keys(copyObj).forEach(function(key) {\n        if (!copyObj[key]) {\n            delete copyObj[key];\n        }\n    });\n    return copyObj;\n}\nvar getStringSize = exports.getStringSize = function getStringSize(text) {\n    var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (text === undefined || text === null || _Global.Global.isSsr) {\n        return {\n            width: 0,\n            height: 0\n        };\n    }\n    var copyStyle = removeInvalidKeys(style);\n    var cacheKey = JSON.stringify({\n        text: text,\n        copyStyle: copyStyle\n    });\n    if (stringCache.widthCache[cacheKey]) {\n        return stringCache.widthCache[cacheKey];\n    }\n    try {\n        var measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);\n        if (!measurementSpan) {\n            measurementSpan = document.createElement(\"span\");\n            measurementSpan.setAttribute(\"id\", MEASUREMENT_SPAN_ID);\n            measurementSpan.setAttribute(\"aria-hidden\", \"true\");\n            document.body.appendChild(measurementSpan);\n        }\n        // Need to use CSS Object Model (CSSOM) to be able to comply with Content Security Policy (CSP)\n        // https://en.wikipedia.org/wiki/Content_Security_Policy\n        var measurementSpanStyle = _objectSpread(_objectSpread({}, SPAN_STYLE), copyStyle);\n        Object.assign(measurementSpan.style, measurementSpanStyle);\n        measurementSpan.textContent = \"\".concat(text);\n        var rect = measurementSpan.getBoundingClientRect();\n        var result = {\n            width: rect.width,\n            height: rect.height\n        };\n        stringCache.widthCache[cacheKey] = result;\n        if (++stringCache.cacheCount > MAX_CACHE_NUM) {\n            stringCache.cacheCount = 0;\n            stringCache.widthCache = {};\n        }\n        return result;\n    } catch (e) {\n        return {\n            width: 0,\n            height: 0\n        };\n    }\n};\nvar getOffset = exports.getOffset = function getOffset(rect) {\n    return {\n        top: rect.top + window.scrollY - document.documentElement.clientTop,\n        left: rect.left + window.scrollX - document.documentElement.clientLeft\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvRE9NVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1RLLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxzQkFBc0IsR0FBR0EscUJBQXFCLEdBQUdBLGlCQUFpQixHQUFHLEtBQUs7QUFDMUUsSUFBSUssVUFBVUMsbUJBQU9BLENBQUMsNERBQVU7QUFDaEMsU0FBU0MsUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSUMsSUFBSVosT0FBT2EsSUFBSSxDQUFDSDtJQUFJLElBQUlWLE9BQU9jLHFCQUFxQixFQUFFO1FBQUUsSUFBSW5CLElBQUlLLE9BQU9jLHFCQUFxQixDQUFDSjtRQUFJQyxLQUFNaEIsQ0FBQUEsSUFBSUEsRUFBRW9CLE1BQU0sQ0FBQyxTQUFVSixDQUFDO1lBQUksT0FBT1gsT0FBT2dCLHdCQUF3QixDQUFDTixHQUFHQyxHQUFHTSxVQUFVO1FBQUUsRUFBQyxHQUFJTCxFQUFFTSxJQUFJLENBQUNDLEtBQUssQ0FBQ1AsR0FBR2pCO0lBQUk7SUFBRSxPQUFPaUI7QUFBRztBQUM5UCxTQUFTUSxjQUFjVixDQUFDO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlVLFVBQVVDLE1BQU0sRUFBRVgsSUFBSztRQUFFLElBQUlDLElBQUksUUFBUVMsU0FBUyxDQUFDVixFQUFFLEdBQUdVLFNBQVMsQ0FBQ1YsRUFBRSxHQUFHLENBQUM7UUFBR0EsSUFBSSxJQUFJRixRQUFRVCxPQUFPWSxJQUFJLENBQUMsR0FBR1csT0FBTyxDQUFDLFNBQVVaLENBQUM7WUFBSWEsZ0JBQWdCZCxHQUFHQyxHQUFHQyxDQUFDLENBQUNELEVBQUU7UUFBRyxLQUFLWCxPQUFPeUIseUJBQXlCLEdBQUd6QixPQUFPMEIsZ0JBQWdCLENBQUNoQixHQUFHVixPQUFPeUIseUJBQXlCLENBQUNiLE1BQU1ILFFBQVFULE9BQU9ZLElBQUlXLE9BQU8sQ0FBQyxTQUFVWixDQUFDO1lBQUlYLE9BQU9DLGNBQWMsQ0FBQ1MsR0FBR0MsR0FBR1gsT0FBT2dCLHdCQUF3QixDQUFDSixHQUFHRDtRQUFLO0lBQUk7SUFBRSxPQUFPRDtBQUFHO0FBQ3RiLFNBQVNjLGdCQUFnQkcsR0FBRyxFQUFFQyxHQUFHLEVBQUV6QixLQUFLO0lBQUl5QixNQUFNQyxlQUFlRDtJQUFNLElBQUlBLE9BQU9ELEtBQUs7UUFBRTNCLE9BQU9DLGNBQWMsQ0FBQzBCLEtBQUtDLEtBQUs7WUFBRXpCLE9BQU9BO1lBQU9jLFlBQVk7WUFBTWEsY0FBYztZQUFNQyxVQUFVO1FBQUs7SUFBSSxPQUFPO1FBQUVKLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHekI7SUFBTztJQUFFLE9BQU93QjtBQUFLO0FBQzNPLFNBQVNFLGVBQWVqQixDQUFDO0lBQUksSUFBSW9CLElBQUlDLGFBQWFyQixHQUFHO0lBQVcsT0FBTyxZQUFZbEIsUUFBUXNDLEtBQUtBLElBQUlBLElBQUk7QUFBSTtBQUM1RyxTQUFTQyxhQUFhckIsQ0FBQyxFQUFFRCxDQUFDO0lBQUksSUFBSSxZQUFZakIsUUFBUWtCLE1BQU0sQ0FBQ0EsR0FBRyxPQUFPQTtJQUFHLElBQUlGLElBQUlFLENBQUMsQ0FBQ2hCLE9BQU9zQyxXQUFXLENBQUM7SUFBRSxJQUFJLEtBQUssTUFBTXhCLEdBQUc7UUFBRSxJQUFJc0IsSUFBSXRCLEVBQUV5QixJQUFJLENBQUN2QixHQUFHRCxLQUFLO1FBQVksSUFBSSxZQUFZakIsUUFBUXNDLElBQUksT0FBT0E7UUFBRyxNQUFNLElBQUlJLFVBQVU7SUFBaUQ7SUFBRSxPQUFPLENBQUMsYUFBYXpCLElBQUkwQixTQUFTQyxNQUFLLEVBQUcxQjtBQUFJO0FBQzNULFNBQVMyQixtQkFBbUJDLEdBQUc7SUFBSSxPQUFPQyxtQkFBbUJELFFBQVFFLGlCQUFpQkYsUUFBUUcsNEJBQTRCSCxRQUFRSTtBQUFzQjtBQUN4SixTQUFTQTtJQUF1QixNQUFNLElBQUlSLFVBQVU7QUFBeUk7QUFDN0wsU0FBU08sNEJBQTRCaEQsQ0FBQyxFQUFFa0QsTUFBTTtJQUFJLElBQUksQ0FBQ2xELEdBQUc7SUFBUSxJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPbUQsa0JBQWtCbkQsR0FBR2tEO0lBQVMsSUFBSUUsSUFBSS9DLE9BQU9ELFNBQVMsQ0FBQ2lELFFBQVEsQ0FBQ2IsSUFBSSxDQUFDeEMsR0FBR3NELEtBQUssQ0FBQyxHQUFHLENBQUM7SUFBSSxJQUFJRixNQUFNLFlBQVlwRCxFQUFFRyxXQUFXLEVBQUVpRCxJQUFJcEQsRUFBRUcsV0FBVyxDQUFDb0QsSUFBSTtJQUFFLElBQUlILE1BQU0sU0FBU0EsTUFBTSxPQUFPLE9BQU9JLE1BQU1DLElBQUksQ0FBQ3pEO0lBQUksSUFBSW9ELE1BQU0sZUFBZSwyQ0FBMkNNLElBQUksQ0FBQ04sSUFBSSxPQUFPRCxrQkFBa0JuRCxHQUFHa0Q7QUFBUztBQUMvWixTQUFTSCxpQkFBaUJZLElBQUk7SUFBSSxJQUFJLE9BQU8xRCxXQUFXLGVBQWUwRCxJQUFJLENBQUMxRCxPQUFPQyxRQUFRLENBQUMsSUFBSSxRQUFReUQsSUFBSSxDQUFDLGFBQWEsSUFBSSxNQUFNLE9BQU9ILE1BQU1DLElBQUksQ0FBQ0U7QUFBTztBQUM3SixTQUFTYixtQkFBbUJELEdBQUc7SUFBSSxJQUFJVyxNQUFNSSxPQUFPLENBQUNmLE1BQU0sT0FBT00sa0JBQWtCTjtBQUFNO0FBQzFGLFNBQVNNLGtCQUFrQk4sR0FBRyxFQUFFZ0IsR0FBRztJQUFJLElBQUlBLE9BQU8sUUFBUUEsTUFBTWhCLElBQUlsQixNQUFNLEVBQUVrQyxNQUFNaEIsSUFBSWxCLE1BQU07SUFBRSxJQUFLLElBQUlVLElBQUksR0FBR3lCLE9BQU8sSUFBSU4sTUFBTUssTUFBTXhCLElBQUl3QixLQUFLeEIsSUFBS3lCLElBQUksQ0FBQ3pCLEVBQUUsR0FBR1EsR0FBRyxDQUFDUixFQUFFO0lBQUUsT0FBT3lCO0FBQU07QUFDbEwsSUFBSUMsY0FBYztJQUNoQkMsWUFBWSxDQUFDO0lBQ2JDLFlBQVk7QUFDZDtBQUNBLElBQUlDLGdCQUFnQjtBQUNwQixJQUFJQyxhQUFhO0lBQ2ZDLFVBQVU7SUFDVkMsS0FBSztJQUNMQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFlBQVk7QUFDZDtBQUNBLElBQUlDLGFBQWE7SUFBQztJQUFZO0lBQVk7SUFBUztJQUFhO0lBQWE7SUFBVTtJQUFPO0lBQVE7SUFBWTtJQUFjO0lBQVc7SUFBVTtJQUFlO0lBQWdCO0lBQWM7SUFBaUI7SUFBYztJQUFlO0lBQWE7Q0FBZTtBQUM1USxJQUFJQyxzQkFBc0I7QUFDMUIsU0FBU0Msa0JBQWtCdEIsSUFBSSxFQUFFL0MsS0FBSztJQUNwQyxJQUFJbUUsV0FBV0csT0FBTyxDQUFDdkIsU0FBUyxLQUFLL0MsVUFBVSxDQUFDQSxPQUFPO1FBQ3JELE9BQU8sR0FBR3VFLE1BQU0sQ0FBQ3ZFLE9BQU87SUFDMUI7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsU0FBU3dFLGtCQUFrQkMsSUFBSTtJQUM3QixJQUFJQyxPQUFPRCxLQUFLRSxLQUFLLENBQUM7SUFDdEIsSUFBSUMsYUFBYUYsS0FBS0csTUFBTSxDQUFDLFNBQVVDLE1BQU0sRUFBRUMsS0FBSztRQUNsRCxJQUFJQSxVQUFVQSxNQUFNQyxXQUFXLElBQUk7WUFDakMsT0FBTyxFQUFFLENBQUNULE1BQU0sQ0FBQ25DLG1CQUFtQjBDLFNBQVM7Z0JBQUM7Z0JBQUtDLE1BQU1FLFdBQVc7YUFBRztRQUN6RTtRQUNBLE9BQU8sRUFBRSxDQUFDVixNQUFNLENBQUNuQyxtQkFBbUIwQyxTQUFTO1lBQUNDO1NBQU07SUFDdEQsR0FBRyxFQUFFO0lBQ0wsT0FBT0gsV0FBV00sSUFBSSxDQUFDO0FBQ3pCO0FBQ0EsSUFBSWpGLGlCQUFpQkYsc0JBQXNCLEdBQUcsU0FBU0UsZUFBZWtGLEtBQUs7SUFDekUsT0FBT3RGLE9BQU9hLElBQUksQ0FBQ3lFLE9BQU9OLE1BQU0sQ0FBQyxTQUFVQyxNQUFNLEVBQUVNLENBQUM7UUFDbEQsT0FBTyxHQUFHYixNQUFNLENBQUNPLFFBQVFQLE1BQU0sQ0FBQ0Msa0JBQWtCWSxJQUFJLEtBQUtiLE1BQU0sQ0FBQ0Ysa0JBQWtCZSxHQUFHRCxLQUFLLENBQUNDLEVBQUUsR0FBRztJQUNwRyxHQUFHO0FBQ0w7QUFDQSxTQUFTQyxrQkFBa0I3RCxHQUFHO0lBQzVCLElBQUk4RCxVQUFVckUsY0FBYyxDQUFDLEdBQUdPO0lBQ2hDM0IsT0FBT2EsSUFBSSxDQUFDNEUsU0FBU2xFLE9BQU8sQ0FBQyxTQUFVSyxHQUFHO1FBQ3hDLElBQUksQ0FBQzZELE9BQU8sQ0FBQzdELElBQUksRUFBRTtZQUNqQixPQUFPNkQsT0FBTyxDQUFDN0QsSUFBSTtRQUNyQjtJQUNGO0lBQ0EsT0FBTzZEO0FBQ1Q7QUFDQSxJQUFJcEYsZ0JBQWdCSCxxQkFBcUIsR0FBRyxTQUFTRyxjQUFjdUUsSUFBSTtJQUNyRSxJQUFJVSxRQUFRakUsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtxRSxZQUFZckUsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO0lBQ2pGLElBQUl1RCxTQUFTYyxhQUFhZCxTQUFTLFFBQVFyRSxRQUFRb0YsTUFBTSxDQUFDQyxLQUFLLEVBQUU7UUFDL0QsT0FBTztZQUNMQyxPQUFPO1lBQ1BDLFFBQVE7UUFDVjtJQUNGO0lBQ0EsSUFBSUMsWUFBWVAsa0JBQWtCRjtJQUNsQyxJQUFJVSxXQUFXQyxLQUFLQyxTQUFTLENBQUM7UUFDNUJ0QixNQUFNQTtRQUNObUIsV0FBV0E7SUFDYjtJQUNBLElBQUlyQyxZQUFZQyxVQUFVLENBQUNxQyxTQUFTLEVBQUU7UUFDcEMsT0FBT3RDLFlBQVlDLFVBQVUsQ0FBQ3FDLFNBQVM7SUFDekM7SUFDQSxJQUFJO1FBQ0YsSUFBSUcsa0JBQWtCQyxTQUFTQyxjQUFjLENBQUM5QjtRQUM5QyxJQUFJLENBQUM0QixpQkFBaUI7WUFDcEJBLGtCQUFrQkMsU0FBU0UsYUFBYSxDQUFDO1lBQ3pDSCxnQkFBZ0JJLFlBQVksQ0FBQyxNQUFNaEM7WUFDbkM0QixnQkFBZ0JJLFlBQVksQ0FBQyxlQUFlO1lBQzVDSCxTQUFTSSxJQUFJLENBQUNDLFdBQVcsQ0FBQ047UUFDNUI7UUFDQSwrRkFBK0Y7UUFDL0Ysd0RBQXdEO1FBQ3hELElBQUlPLHVCQUF1QnRGLGNBQWNBLGNBQWMsQ0FBQyxHQUFHMEMsYUFBYWlDO1FBQ3hFL0YsT0FBTzJHLE1BQU0sQ0FBQ1IsZ0JBQWdCYixLQUFLLEVBQUVvQjtRQUNyQ1AsZ0JBQWdCUyxXQUFXLEdBQUcsR0FBR2xDLE1BQU0sQ0FBQ0U7UUFDeEMsSUFBSWlDLE9BQU9WLGdCQUFnQlcscUJBQXFCO1FBQ2hELElBQUk3QixTQUFTO1lBQ1hZLE9BQU9nQixLQUFLaEIsS0FBSztZQUNqQkMsUUFBUWUsS0FBS2YsTUFBTTtRQUNyQjtRQUNBcEMsWUFBWUMsVUFBVSxDQUFDcUMsU0FBUyxHQUFHZjtRQUNuQyxJQUFJLEVBQUV2QixZQUFZRSxVQUFVLEdBQUdDLGVBQWU7WUFDNUNILFlBQVlFLFVBQVUsR0FBRztZQUN6QkYsWUFBWUMsVUFBVSxHQUFHLENBQUM7UUFDNUI7UUFDQSxPQUFPc0I7SUFDVCxFQUFFLE9BQU92RSxHQUFHO1FBQ1YsT0FBTztZQUNMbUYsT0FBTztZQUNQQyxRQUFRO1FBQ1Y7SUFDRjtBQUNGO0FBQ0EsSUFBSXhGLFlBQVlKLGlCQUFpQixHQUFHLFNBQVNJLFVBQVV1RyxJQUFJO0lBQ3pELE9BQU87UUFDTDdDLEtBQUs2QyxLQUFLN0MsR0FBRyxHQUFHK0MsT0FBT0MsT0FBTyxHQUFHWixTQUFTYSxlQUFlLENBQUNDLFNBQVM7UUFDbkVqRCxNQUFNNEMsS0FBSzVDLElBQUksR0FBRzhDLE9BQU9JLE9BQU8sR0FBR2YsU0FBU2EsZUFBZSxDQUFDRyxVQUFVO0lBQ3hFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvRE9NVXRpbHMuanM/MDJlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0U3R5bGVTdHJpbmcgPSBleHBvcnRzLmdldFN0cmluZ1NpemUgPSBleHBvcnRzLmdldE9mZnNldCA9IHZvaWQgMDtcbnZhciBfR2xvYmFsID0gcmVxdWlyZShcIi4vR2xvYmFsXCIpO1xuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG52YXIgc3RyaW5nQ2FjaGUgPSB7XG4gIHdpZHRoQ2FjaGU6IHt9LFxuICBjYWNoZUNvdW50OiAwXG59O1xudmFyIE1BWF9DQUNIRV9OVU0gPSAyMDAwO1xudmFyIFNQQU5fU1RZTEUgPSB7XG4gIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICB0b3A6ICctMjAwMDBweCcsXG4gIGxlZnQ6IDAsXG4gIHBhZGRpbmc6IDAsXG4gIG1hcmdpbjogMCxcbiAgYm9yZGVyOiAnbm9uZScsXG4gIHdoaXRlU3BhY2U6ICdwcmUnXG59O1xudmFyIFNUWUxFX0xJU1QgPSBbJ21pbldpZHRoJywgJ21heFdpZHRoJywgJ3dpZHRoJywgJ21pbkhlaWdodCcsICdtYXhIZWlnaHQnLCAnaGVpZ2h0JywgJ3RvcCcsICdsZWZ0JywgJ2ZvbnRTaXplJywgJ2xpbmVIZWlnaHQnLCAncGFkZGluZycsICdtYXJnaW4nLCAncGFkZGluZ0xlZnQnLCAncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdUb3AnLCAncGFkZGluZ0JvdHRvbScsICdtYXJnaW5MZWZ0JywgJ21hcmdpblJpZ2h0JywgJ21hcmdpblRvcCcsICdtYXJnaW5Cb3R0b20nXTtcbnZhciBNRUFTVVJFTUVOVF9TUEFOX0lEID0gJ3JlY2hhcnRzX21lYXN1cmVtZW50X3NwYW4nO1xuZnVuY3Rpb24gYXV0b0NvbXBsZXRlU3R5bGUobmFtZSwgdmFsdWUpIHtcbiAgaWYgKFNUWUxFX0xJU1QuaW5kZXhPZihuYW1lKSA+PSAwICYmIHZhbHVlID09PSArdmFsdWUpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQodmFsdWUsIFwicHhcIik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY2FtZWxUb01pZGRsZUxpbmUodGV4dCkge1xuICB2YXIgc3RycyA9IHRleHQuc3BsaXQoJycpO1xuICB2YXIgZm9ybWF0U3RycyA9IHN0cnMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5ID09PSBlbnRyeS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXN1bHQpLCBbJy0nLCBlbnRyeS50b0xvd2VyQ2FzZSgpXSk7XG4gICAgfVxuICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlc3VsdCksIFtlbnRyeV0pO1xuICB9LCBbXSk7XG4gIHJldHVybiBmb3JtYXRTdHJzLmpvaW4oJycpO1xufVxudmFyIGdldFN0eWxlU3RyaW5nID0gZXhwb3J0cy5nZXRTdHlsZVN0cmluZyA9IGZ1bmN0aW9uIGdldFN0eWxlU3RyaW5nKHN0eWxlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzdHlsZSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHMpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQocmVzdWx0KS5jb25jYXQoY2FtZWxUb01pZGRsZUxpbmUocyksIFwiOlwiKS5jb25jYXQoYXV0b0NvbXBsZXRlU3R5bGUocywgc3R5bGVbc10pLCBcIjtcIik7XG4gIH0sICcnKTtcbn07XG5mdW5jdGlvbiByZW1vdmVJbnZhbGlkS2V5cyhvYmopIHtcbiAgdmFyIGNvcHlPYmogPSBfb2JqZWN0U3ByZWFkKHt9LCBvYmopO1xuICBPYmplY3Qua2V5cyhjb3B5T2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWNvcHlPYmpba2V5XSkge1xuICAgICAgZGVsZXRlIGNvcHlPYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY29weU9iajtcbn1cbnZhciBnZXRTdHJpbmdTaXplID0gZXhwb3J0cy5nZXRTdHJpbmdTaXplID0gZnVuY3Rpb24gZ2V0U3RyaW5nU2l6ZSh0ZXh0KSB7XG4gIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGlmICh0ZXh0ID09PSB1bmRlZmluZWQgfHwgdGV4dCA9PT0gbnVsbCB8fCBfR2xvYmFsLkdsb2JhbC5pc1Nzcikge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gIH1cbiAgdmFyIGNvcHlTdHlsZSA9IHJlbW92ZUludmFsaWRLZXlzKHN0eWxlKTtcbiAgdmFyIGNhY2hlS2V5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgIHRleHQ6IHRleHQsXG4gICAgY29weVN0eWxlOiBjb3B5U3R5bGVcbiAgfSk7XG4gIGlmIChzdHJpbmdDYWNoZS53aWR0aENhY2hlW2NhY2hlS2V5XSkge1xuICAgIHJldHVybiBzdHJpbmdDYWNoZS53aWR0aENhY2hlW2NhY2hlS2V5XTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBtZWFzdXJlbWVudFNwYW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChNRUFTVVJFTUVOVF9TUEFOX0lEKTtcbiAgICBpZiAoIW1lYXN1cmVtZW50U3Bhbikge1xuICAgICAgbWVhc3VyZW1lbnRTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgbWVhc3VyZW1lbnRTcGFuLnNldEF0dHJpYnV0ZSgnaWQnLCBNRUFTVVJFTUVOVF9TUEFOX0lEKTtcbiAgICAgIG1lYXN1cmVtZW50U3Bhbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobWVhc3VyZW1lbnRTcGFuKTtcbiAgICB9XG4gICAgLy8gTmVlZCB0byB1c2UgQ1NTIE9iamVjdCBNb2RlbCAoQ1NTT00pIHRvIGJlIGFibGUgdG8gY29tcGx5IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgKENTUClcbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db250ZW50X1NlY3VyaXR5X1BvbGljeVxuICAgIHZhciBtZWFzdXJlbWVudFNwYW5TdHlsZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgU1BBTl9TVFlMRSksIGNvcHlTdHlsZSk7XG4gICAgT2JqZWN0LmFzc2lnbihtZWFzdXJlbWVudFNwYW4uc3R5bGUsIG1lYXN1cmVtZW50U3BhblN0eWxlKTtcbiAgICBtZWFzdXJlbWVudFNwYW4udGV4dENvbnRlbnQgPSBcIlwiLmNvbmNhdCh0ZXh0KTtcbiAgICB2YXIgcmVjdCA9IG1lYXN1cmVtZW50U3Bhbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gICAgfTtcbiAgICBzdHJpbmdDYWNoZS53aWR0aENhY2hlW2NhY2hlS2V5XSA9IHJlc3VsdDtcbiAgICBpZiAoKytzdHJpbmdDYWNoZS5jYWNoZUNvdW50ID4gTUFYX0NBQ0hFX05VTSkge1xuICAgICAgc3RyaW5nQ2FjaGUuY2FjaGVDb3VudCA9IDA7XG4gICAgICBzdHJpbmdDYWNoZS53aWR0aENhY2hlID0ge307XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICB9XG59O1xudmFyIGdldE9mZnNldCA9IGV4cG9ydHMuZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gZ2V0T2Zmc2V0KHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHJlY3QudG9wICsgd2luZG93LnNjcm9sbFkgLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50VG9wLFxuICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbmRvdy5zY3JvbGxYIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudExlZnRcbiAgfTtcbn07Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0U3R5bGVTdHJpbmciLCJnZXRTdHJpbmdTaXplIiwiZ2V0T2Zmc2V0IiwiX0dsb2JhbCIsInJlcXVpcmUiLCJvd25LZXlzIiwiZSIsInIiLCJ0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwib2JqIiwia2V5IiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImkiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwiaXRlciIsImlzQXJyYXkiLCJsZW4iLCJhcnIyIiwic3RyaW5nQ2FjaGUiLCJ3aWR0aENhY2hlIiwiY2FjaGVDb3VudCIsIk1BWF9DQUNIRV9OVU0iLCJTUEFOX1NUWUxFIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwicGFkZGluZyIsIm1hcmdpbiIsImJvcmRlciIsIndoaXRlU3BhY2UiLCJTVFlMRV9MSVNUIiwiTUVBU1VSRU1FTlRfU1BBTl9JRCIsImF1dG9Db21wbGV0ZVN0eWxlIiwiaW5kZXhPZiIsImNvbmNhdCIsImNhbWVsVG9NaWRkbGVMaW5lIiwidGV4dCIsInN0cnMiLCJzcGxpdCIsImZvcm1hdFN0cnMiLCJyZWR1Y2UiLCJyZXN1bHQiLCJlbnRyeSIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJqb2luIiwic3R5bGUiLCJzIiwicmVtb3ZlSW52YWxpZEtleXMiLCJjb3B5T2JqIiwidW5kZWZpbmVkIiwiR2xvYmFsIiwiaXNTc3IiLCJ3aWR0aCIsImhlaWdodCIsImNvcHlTdHlsZSIsImNhY2hlS2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1lYXN1cmVtZW50U3BhbiIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiYm9keSIsImFwcGVuZENoaWxkIiwibWVhc3VyZW1lbnRTcGFuU3R5bGUiLCJhc3NpZ24iLCJ0ZXh0Q29udGVudCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aW5kb3ciLCJzY3JvbGxZIiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50VG9wIiwic2Nyb2xsWCIsImNsaWVudExlZnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/DOMUtils.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/DataUtils.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/util/DataUtils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.findEntryInArray = findEntryInArray;\nexports.uniqueId = exports.mathSign = exports.isPercent = exports.isNumber = exports.isNumOrStr = exports.interpolateNumber = exports.hasDuplicate = exports.getPercentValue = exports.getLinearRegression = exports.getAnyElementOfObject = void 0;\nvar _isString = _interopRequireDefault(__webpack_require__(/*! lodash/isString */ \"lodash/isString\"));\nvar _isNaN = _interopRequireDefault(__webpack_require__(/*! lodash/isNaN */ \"lodash/isNaN\"));\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _isNumber = _interopRequireDefault(__webpack_require__(/*! lodash/isNumber */ \"lodash/isNumber\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nvar mathSign = exports.mathSign = function mathSign(value) {\n    if (value === 0) {\n        return 0;\n    }\n    if (value > 0) {\n        return 1;\n    }\n    return -1;\n};\nvar isPercent = exports.isPercent = function isPercent(value) {\n    return (0, _isString[\"default\"])(value) && value.indexOf(\"%\") === value.length - 1;\n};\nvar isNumber = exports.isNumber = function isNumber(value) {\n    return (0, _isNumber[\"default\"])(value) && !(0, _isNaN[\"default\"])(value);\n};\nvar isNumOrStr = exports.isNumOrStr = function isNumOrStr(value) {\n    return isNumber(value) || (0, _isString[\"default\"])(value);\n};\nvar idCounter = 0;\nvar uniqueId = exports.uniqueId = function uniqueId(prefix) {\n    var id = ++idCounter;\n    return \"\".concat(prefix || \"\").concat(id);\n};\n/**\n * Get percent value of a total value\n * @param {number|string} percent A percent\n * @param {number} totalValue     Total value\n * @param {number} defaultValue   The value returned when percent is undefined or invalid\n * @param {boolean} validate      If set to be true, the result will be validated\n * @return {number} value\n */ var getPercentValue = exports.getPercentValue = function getPercentValue(percent, totalValue) {\n    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var validate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (!isNumber(percent) && !(0, _isString[\"default\"])(percent)) {\n        return defaultValue;\n    }\n    var value;\n    if (isPercent(percent)) {\n        var index = percent.indexOf(\"%\");\n        value = totalValue * parseFloat(percent.slice(0, index)) / 100;\n    } else {\n        value = +percent;\n    }\n    if ((0, _isNaN[\"default\"])(value)) {\n        value = defaultValue;\n    }\n    if (validate && value > totalValue) {\n        value = totalValue;\n    }\n    return value;\n};\nvar getAnyElementOfObject = exports.getAnyElementOfObject = function getAnyElementOfObject(obj) {\n    if (!obj) {\n        return null;\n    }\n    var keys = Object.keys(obj);\n    if (keys && keys.length) {\n        return obj[keys[0]];\n    }\n    return null;\n};\nvar hasDuplicate = exports.hasDuplicate = function hasDuplicate(ary) {\n    if (!Array.isArray(ary)) {\n        return false;\n    }\n    var len = ary.length;\n    var cache = {};\n    for(var i = 0; i < len; i++){\n        if (!cache[ary[i]]) {\n            cache[ary[i]] = true;\n        } else {\n            return true;\n        }\n    }\n    return false;\n};\n/* @todo consider to rename this function into `getInterpolator` */ var interpolateNumber = exports.interpolateNumber = function interpolateNumber(numberA, numberB) {\n    if (isNumber(numberA) && isNumber(numberB)) {\n        return function(t) {\n            return numberA + t * (numberB - numberA);\n        };\n    }\n    return function() {\n        return numberB;\n    };\n};\nfunction findEntryInArray(ary, specifiedKey, specifiedValue) {\n    if (!ary || !ary.length) {\n        return null;\n    }\n    return ary.find(function(entry) {\n        return entry && (typeof specifiedKey === \"function\" ? specifiedKey(entry) : (0, _get[\"default\"])(entry, specifiedKey)) === specifiedValue;\n    });\n}\n/**\n * The least square linear regression\n * @param {Array} data The array of points\n * @returns {Object} The domain of x, and the parameter of linear function\n */ var getLinearRegression = exports.getLinearRegression = function getLinearRegression(data) {\n    if (!data || !data.length) {\n        return null;\n    }\n    var len = data.length;\n    var xsum = 0;\n    var ysum = 0;\n    var xysum = 0;\n    var xxsum = 0;\n    var xmin = Infinity;\n    var xmax = -Infinity;\n    var xcurrent = 0;\n    var ycurrent = 0;\n    for(var i = 0; i < len; i++){\n        xcurrent = data[i].cx || 0;\n        ycurrent = data[i].cy || 0;\n        xsum += xcurrent;\n        ysum += ycurrent;\n        xysum += xcurrent * ycurrent;\n        xxsum += xcurrent * xcurrent;\n        xmin = Math.min(xmin, xcurrent);\n        xmax = Math.max(xmax, xcurrent);\n    }\n    var a = len * xxsum !== xsum * xsum ? (len * xysum - xsum * ysum) / (len * xxsum - xsum * xsum) : 0;\n    return {\n        xmin: xmin,\n        xmax: xmax,\n        a: a,\n        b: (ysum - a * xsum) / len\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvRGF0YVV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCx3QkFBd0IsR0FBR0U7QUFDM0JGLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsaUJBQWlCLEdBQUdBLGdCQUFnQixHQUFHQSxrQkFBa0IsR0FBR0EseUJBQXlCLEdBQUdBLG9CQUFvQixHQUFHQSx1QkFBdUIsR0FBR0EsMkJBQTJCLEdBQUdBLDZCQUE2QixHQUFHLEtBQUs7QUFDbFAsSUFBSWEsWUFBWUMsdUJBQXVCQyxtQkFBT0EsQ0FBQyx3Q0FBaUI7QUFDaEUsSUFBSUMsU0FBU0YsdUJBQXVCQyxtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJRSxPQUFPSCx1QkFBdUJDLG1CQUFPQSxDQUFDLDhCQUFZO0FBQ3RELElBQUlHLFlBQVlKLHVCQUF1QkMsbUJBQU9BLENBQUMsd0NBQWlCO0FBQ2hFLFNBQVNELHVCQUF1QkssR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxJQUFJZixXQUFXSixnQkFBZ0IsR0FBRyxTQUFTSSxTQUFTSCxLQUFLO0lBQ3ZELElBQUlBLFVBQVUsR0FBRztRQUNmLE9BQU87SUFDVDtJQUNBLElBQUlBLFFBQVEsR0FBRztRQUNiLE9BQU87SUFDVDtJQUNBLE9BQU8sQ0FBQztBQUNWO0FBQ0EsSUFBSUksWUFBWUwsaUJBQWlCLEdBQUcsU0FBU0ssVUFBVUosS0FBSztJQUMxRCxPQUFPLENBQUMsR0FBR1ksU0FBUyxDQUFDLFVBQVUsRUFBRVosVUFBVUEsTUFBTW9CLE9BQU8sQ0FBQyxTQUFTcEIsTUFBTXFCLE1BQU0sR0FBRztBQUNuRjtBQUNBLElBQUloQixXQUFXTixnQkFBZ0IsR0FBRyxTQUFTTSxTQUFTTCxLQUFLO0lBQ3ZELE9BQU8sQ0FBQyxHQUFHaUIs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QU1BO1FBQ05FLE1BQU1BO1FBQ05RLEdBQUdBO1FBQ0hDLEdBQUcsQ0FBQ2QsT0FBT2EsSUFBSWQsSUFBRyxJQUFLWDtJQUN6QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi91dGlsL0RhdGFVdGlscy5qcz85Y2Y5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5maW5kRW50cnlJbkFycmF5ID0gZmluZEVudHJ5SW5BcnJheTtcbmV4cG9ydHMudW5pcXVlSWQgPSBleHBvcnRzLm1hdGhTaWduID0gZXhwb3J0cy5pc1BlcmNlbnQgPSBleHBvcnRzLmlzTnVtYmVyID0gZXhwb3J0cy5pc051bU9yU3RyID0gZXhwb3J0cy5pbnRlcnBvbGF0ZU51bWJlciA9IGV4cG9ydHMuaGFzRHVwbGljYXRlID0gZXhwb3J0cy5nZXRQZXJjZW50VmFsdWUgPSBleHBvcnRzLmdldExpbmVhclJlZ3Jlc3Npb24gPSBleHBvcnRzLmdldEFueUVsZW1lbnRPZk9iamVjdCA9IHZvaWQgMDtcbnZhciBfaXNTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNTdHJpbmdcIikpO1xudmFyIF9pc05hTiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc05hTlwiKSk7XG52YXIgX2dldCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9nZXRcIikpO1xudmFyIF9pc051bWJlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc051bWJlclwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbnZhciBtYXRoU2lnbiA9IGV4cG9ydHMubWF0aFNpZ24gPSBmdW5jdGlvbiBtYXRoU2lnbih2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAodmFsdWUgPiAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcbnZhciBpc1BlcmNlbnQgPSBleHBvcnRzLmlzUGVyY2VudCA9IGZ1bmN0aW9uIGlzUGVyY2VudCh2YWx1ZSkge1xuICByZXR1cm4gKDAsIF9pc1N0cmluZ1tcImRlZmF1bHRcIl0pKHZhbHVlKSAmJiB2YWx1ZS5pbmRleE9mKCclJykgPT09IHZhbHVlLmxlbmd0aCAtIDE7XG59O1xudmFyIGlzTnVtYmVyID0gZXhwb3J0cy5pc051bWJlciA9IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiAoMCwgX2lzTnVtYmVyW1wiZGVmYXVsdFwiXSkodmFsdWUpICYmICEoMCwgX2lzTmFOW1wiZGVmYXVsdFwiXSkodmFsdWUpO1xufTtcbnZhciBpc051bU9yU3RyID0gZXhwb3J0cy5pc051bU9yU3RyID0gZnVuY3Rpb24gaXNOdW1PclN0cih2YWx1ZSkge1xuICByZXR1cm4gaXNOdW1iZXIodmFsdWUpIHx8ICgwLCBfaXNTdHJpbmdbXCJkZWZhdWx0XCJdKSh2YWx1ZSk7XG59O1xudmFyIGlkQ291bnRlciA9IDA7XG52YXIgdW5pcXVlSWQgPSBleHBvcnRzLnVuaXF1ZUlkID0gZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICByZXR1cm4gXCJcIi5jb25jYXQocHJlZml4IHx8ICcnKS5jb25jYXQoaWQpO1xufTtcblxuLyoqXG4gKiBHZXQgcGVyY2VudCB2YWx1ZSBvZiBhIHRvdGFsIHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHBlcmNlbnQgQSBwZXJjZW50XG4gKiBAcGFyYW0ge251bWJlcn0gdG90YWxWYWx1ZSAgICAgVG90YWwgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWUgICBUaGUgdmFsdWUgcmV0dXJuZWQgd2hlbiBwZXJjZW50IGlzIHVuZGVmaW5lZCBvciBpbnZhbGlkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbGlkYXRlICAgICAgSWYgc2V0IHRvIGJlIHRydWUsIHRoZSByZXN1bHQgd2lsbCBiZSB2YWxpZGF0ZWRcbiAqIEByZXR1cm4ge251bWJlcn0gdmFsdWVcbiAqL1xudmFyIGdldFBlcmNlbnRWYWx1ZSA9IGV4cG9ydHMuZ2V0UGVyY2VudFZhbHVlID0gZnVuY3Rpb24gZ2V0UGVyY2VudFZhbHVlKHBlcmNlbnQsIHRvdGFsVmFsdWUpIHtcbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgdmFyIHZhbGlkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgaWYgKCFpc051bWJlcihwZXJjZW50KSAmJiAhKDAsIF9pc1N0cmluZ1tcImRlZmF1bHRcIl0pKHBlcmNlbnQpKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxuICB2YXIgdmFsdWU7XG4gIGlmIChpc1BlcmNlbnQocGVyY2VudCkpIHtcbiAgICB2YXIgaW5kZXggPSBwZXJjZW50LmluZGV4T2YoJyUnKTtcbiAgICB2YWx1ZSA9IHRvdGFsVmFsdWUgKiBwYXJzZUZsb2F0KHBlcmNlbnQuc2xpY2UoMCwgaW5kZXgpKSAvIDEwMDtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9ICtwZXJjZW50O1xuICB9XG4gIGlmICgoMCwgX2lzTmFOW1wiZGVmYXVsdFwiXSkodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cbiAgaWYgKHZhbGlkYXRlICYmIHZhbHVlID4gdG90YWxWYWx1ZSkge1xuICAgIHZhbHVlID0gdG90YWxWYWx1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIGdldEFueUVsZW1lbnRPZk9iamVjdCA9IGV4cG9ydHMuZ2V0QW55RWxlbWVudE9mT2JqZWN0ID0gZnVuY3Rpb24gZ2V0QW55RWxlbWVudE9mT2JqZWN0KG9iaikge1xuICBpZiAoIW9iaikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgaWYgKGtleXMgJiYga2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gb2JqW2tleXNbMF1dO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbnZhciBoYXNEdXBsaWNhdGUgPSBleHBvcnRzLmhhc0R1cGxpY2F0ZSA9IGZ1bmN0aW9uIGhhc0R1cGxpY2F0ZShhcnkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFyeSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxlbiA9IGFyeS5sZW5ndGg7XG4gIHZhciBjYWNoZSA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFjYWNoZVthcnlbaV1dKSB7XG4gICAgICBjYWNoZVthcnlbaV1dID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qIEB0b2RvIGNvbnNpZGVyIHRvIHJlbmFtZSB0aGlzIGZ1bmN0aW9uIGludG8gYGdldEludGVycG9sYXRvcmAgKi9cbnZhciBpbnRlcnBvbGF0ZU51bWJlciA9IGV4cG9ydHMuaW50ZXJwb2xhdGVOdW1iZXIgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihudW1iZXJBLCBudW1iZXJCKSB7XG4gIGlmIChpc051bWJlcihudW1iZXJBKSAmJiBpc051bWJlcihudW1iZXJCKSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIG51bWJlckEgKyB0ICogKG51bWJlckIgLSBudW1iZXJBKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bWJlckI7XG4gIH07XG59O1xuZnVuY3Rpb24gZmluZEVudHJ5SW5BcnJheShhcnksIHNwZWNpZmllZEtleSwgc3BlY2lmaWVkVmFsdWUpIHtcbiAgaWYgKCFhcnkgfHwgIWFyeS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gYXJ5LmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5ICYmICh0eXBlb2Ygc3BlY2lmaWVkS2V5ID09PSAnZnVuY3Rpb24nID8gc3BlY2lmaWVkS2V5KGVudHJ5KSA6ICgwLCBfZ2V0W1wiZGVmYXVsdFwiXSkoZW50cnksIHNwZWNpZmllZEtleSkpID09PSBzcGVjaWZpZWRWYWx1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhlIGxlYXN0IHNxdWFyZSBsaW5lYXIgcmVncmVzc2lvblxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgYXJyYXkgb2YgcG9pbnRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZG9tYWluIG9mIHgsIGFuZCB0aGUgcGFyYW1ldGVyIG9mIGxpbmVhciBmdW5jdGlvblxuICovXG52YXIgZ2V0TGluZWFyUmVncmVzc2lvbiA9IGV4cG9ydHMuZ2V0TGluZWFyUmVncmVzc2lvbiA9IGZ1bmN0aW9uIGdldExpbmVhclJlZ3Jlc3Npb24oZGF0YSkge1xuICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuICB2YXIgeHN1bSA9IDA7XG4gIHZhciB5c3VtID0gMDtcbiAgdmFyIHh5c3VtID0gMDtcbiAgdmFyIHh4c3VtID0gMDtcbiAgdmFyIHhtaW4gPSBJbmZpbml0eTtcbiAgdmFyIHhtYXggPSAtSW5maW5pdHk7XG4gIHZhciB4Y3VycmVudCA9IDA7XG4gIHZhciB5Y3VycmVudCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB4Y3VycmVudCA9IGRhdGFbaV0uY3ggfHwgMDtcbiAgICB5Y3VycmVudCA9IGRhdGFbaV0uY3kgfHwgMDtcbiAgICB4c3VtICs9IHhjdXJyZW50O1xuICAgIHlzdW0gKz0geWN1cnJlbnQ7XG4gICAgeHlzdW0gKz0geGN1cnJlbnQgKiB5Y3VycmVudDtcbiAgICB4eHN1bSArPSB4Y3VycmVudCAqIHhjdXJyZW50O1xuICAgIHhtaW4gPSBNYXRoLm1pbih4bWluLCB4Y3VycmVudCk7XG4gICAgeG1heCA9IE1hdGgubWF4KHhtYXgsIHhjdXJyZW50KTtcbiAgfVxuICB2YXIgYSA9IGxlbiAqIHh4c3VtICE9PSB4c3VtICogeHN1bSA/IChsZW4gKiB4eXN1bSAtIHhzdW0gKiB5c3VtKSAvIChsZW4gKiB4eHN1bSAtIHhzdW0gKiB4c3VtKSA6IDA7XG4gIHJldHVybiB7XG4gICAgeG1pbjogeG1pbixcbiAgICB4bWF4OiB4bWF4LFxuICAgIGE6IGEsXG4gICAgYjogKHlzdW0gLSBhICogeHN1bSkgLyBsZW5cbiAgfTtcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZmluZEVudHJ5SW5BcnJheSIsInVuaXF1ZUlkIiwibWF0aFNpZ24iLCJpc1BlcmNlbnQiLCJpc051bWJlciIsImlzTnVtT3JTdHIiLCJpbnRlcnBvbGF0ZU51bWJlciIsImhhc0R1cGxpY2F0ZSIsImdldFBlcmNlbnRWYWx1ZSIsImdldExpbmVhclJlZ3Jlc3Npb24iLCJnZXRBbnlFbGVtZW50T2ZPYmplY3QiLCJfaXNTdHJpbmciLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9pc05hTiIsIl9nZXQiLCJfaXNOdW1iZXIiLCJvYmoiLCJfX2VzTW9kdWxlIiwiaW5kZXhPZiIsImxlbmd0aCIsImlkQ291bnRlciIsInByZWZpeCIsImlkIiwiY29uY2F0IiwicGVyY2VudCIsInRvdGFsVmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJ2YWxpZGF0ZSIsImluZGV4IiwicGFyc2VGbG9hdCIsInNsaWNlIiwia2V5cyIsImFyeSIsIkFycmF5IiwiaXNBcnJheSIsImxlbiIsImNhY2hlIiwiaSIsIm51bWJlckEiLCJudW1iZXJCIiwidCIsInNwZWNpZmllZEtleSIsInNwZWNpZmllZFZhbHVlIiwiZmluZCIsImVudHJ5IiwiZGF0YSIsInhzdW0iLCJ5c3VtIiwieHlzdW0iLCJ4eHN1bSIsInhtaW4iLCJJbmZpbml0eSIsInhtYXgiLCJ4Y3VycmVudCIsInljdXJyZW50IiwiY3giLCJjeSIsIk1hdGgiLCJtaW4iLCJtYXgiLCJhIiwiYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/DataUtils.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/DetectReferenceElementsDomain.js":
/*!*************************************************************************!*\
  !*** ./node_modules/recharts/lib/util/DetectReferenceElementsDomain.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.detectReferenceElementsDomain = void 0;\nvar _ReferenceDot = __webpack_require__(/*! ../cartesian/ReferenceDot */ \"./node_modules/recharts/lib/cartesian/ReferenceDot.js\");\nvar _ReferenceLine = __webpack_require__(/*! ../cartesian/ReferenceLine */ \"./node_modules/recharts/lib/cartesian/ReferenceLine.js\");\nvar _ReferenceArea = __webpack_require__(/*! ../cartesian/ReferenceArea */ \"./node_modules/recharts/lib/cartesian/ReferenceArea.js\");\nvar _IfOverflowMatches = __webpack_require__(/*! ./IfOverflowMatches */ \"./node_modules/recharts/lib/util/IfOverflowMatches.js\");\nvar _ReactUtils = __webpack_require__(/*! ./ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nvar _DataUtils = __webpack_require__(/*! ./DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nvar detectReferenceElementsDomain = exports.detectReferenceElementsDomain = function detectReferenceElementsDomain(children, domain, axisId, axisType, specifiedTicks) {\n    var lines = (0, _ReactUtils.findAllByType)(children, _ReferenceLine.ReferenceLine);\n    var dots = (0, _ReactUtils.findAllByType)(children, _ReferenceDot.ReferenceDot);\n    var elements = [].concat(_toConsumableArray(lines), _toConsumableArray(dots));\n    var areas = (0, _ReactUtils.findAllByType)(children, _ReferenceArea.ReferenceArea);\n    var idKey = \"\".concat(axisType, \"Id\");\n    var valueKey = axisType[0];\n    var finalDomain = domain;\n    if (elements.length) {\n        finalDomain = elements.reduce(function(result, el) {\n            if (el.props[idKey] === axisId && (0, _IfOverflowMatches.ifOverflowMatches)(el.props, \"extendDomain\") && (0, _DataUtils.isNumber)(el.props[valueKey])) {\n                var value = el.props[valueKey];\n                return [\n                    Math.min(result[0], value),\n                    Math.max(result[1], value)\n                ];\n            }\n            return result;\n        }, finalDomain);\n    }\n    if (areas.length) {\n        var key1 = \"\".concat(valueKey, \"1\");\n        var key2 = \"\".concat(valueKey, \"2\");\n        finalDomain = areas.reduce(function(result, el) {\n            if (el.props[idKey] === axisId && (0, _IfOverflowMatches.ifOverflowMatches)(el.props, \"extendDomain\") && (0, _DataUtils.isNumber)(el.props[key1]) && (0, _DataUtils.isNumber)(el.props[key2])) {\n                var value1 = el.props[key1];\n                var value2 = el.props[key2];\n                return [\n                    Math.min(result[0], value1, value2),\n                    Math.max(result[1], value1, value2)\n                ];\n            }\n            return result;\n        }, finalDomain);\n    }\n    if (specifiedTicks && specifiedTicks.length) {\n        finalDomain = specifiedTicks.reduce(function(result, tick) {\n            if ((0, _DataUtils.isNumber)(tick)) {\n                return [\n                    Math.min(result[0], tick),\n                    Math.max(result[1], tick)\n                ];\n            }\n            return result;\n        }, finalDomain);\n    }\n    return finalDomain;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvRGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHFDQUFxQyxHQUFHLEtBQUs7QUFDN0MsSUFBSUcsZ0JBQWdCQyxtQkFBT0EsQ0FBQyx3RkFBMkI7QUFDdkQsSUFBSUMsaUJBQWlCRCxtQkFBT0EsQ0FBQywwRkFBNEI7QUFDekQsSUFBSUUsaUJBQWlCRixtQkFBT0EsQ0FBQywwRkFBNEI7QUFDekQsSUFBSUcscUJBQXFCSCxtQkFBT0EsQ0FBQyxrRkFBcUI7QUFDdEQsSUFBSUksY0FBY0osbUJBQU9BLENBQUMsb0VBQWM7QUFDeEMsSUFBSUssYUFBYUwsbUJBQU9BLENBQUMsa0VBQWE7QUFDdEMsU0FBU00sbUJBQW1CQyxHQUFHO0lBQUksT0FBT0MsbUJBQW1CRCxRQUFRRSxpQkFBaUJGLFFBQVFHLDRCQUE0QkgsUUFBUUk7QUFBc0I7QUFDeEosU0FBU0E7SUFBdUIsTUFBTSxJQUFJQyxVQUFVO0FBQXlJO0FBQzdMLFNBQVNGLDRCQUE0QkcsQ0FBQyxFQUFFQyxNQUFNO0lBQUksSUFBSSxDQUFDRCxHQUFHO0lBQVEsSUFBSSxPQUFPQSxNQUFNLFVBQVUsT0FBT0Usa0JBQWtCRixHQUFHQztJQUFTLElBQUlFLElBQUl0QixPQUFPdUIsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ04sR0FBR08sS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUFJLElBQUlKLE1BQU0sWUFBWUgsRUFBRVEsV0FBVyxFQUFFTCxJQUFJSCxFQUFFUSxXQUFXLENBQUNDLElBQUk7SUFBRSxJQUFJTixNQUFNLFNBQVNBLE1BQU0sT0FBTyxPQUFPTyxNQUFNQyxJQUFJLENBQUNYO0lBQUksSUFBSUcsTUFBTSxlQUFlLDJDQUEyQ1MsSUFBSSxDQUFDVCxJQUFJLE9BQU9ELGtCQUFrQkYsR0FBR0M7QUFBUztBQUMvWixTQUFTTCxpQkFBaUJpQixJQUFJO0lBQUksSUFBSSxPQUFPQyxXQUFXLGVBQWVELElBQUksQ0FBQ0MsT0FBT0MsUUFBUSxDQUFDLElBQUksUUFBUUYsSUFBSSxDQUFDLGFBQWEsSUFBSSxNQUFNLE9BQU9ILE1BQU1DLElBQUksQ0FBQ0U7QUFBTztBQUM3SixTQUFTbEIsbUJBQW1CRCxHQUFHO0lBQUksSUFBSWdCLE1BQU1NLE9BQU8sQ0FBQ3RCLE1BQU0sT0FBT1Esa0JBQWtCUjtBQUFNO0FBQzFGLFNBQVNRLGtCQUFrQlIsR0FBRyxFQUFFdUIsR0FBRztJQUFJLElBQUlBLE9BQU8sUUFBUUEsTUFBTXZCLElBQUl3QixNQUFNLEVBQUVELE1BQU12QixJQUFJd0IsTUFBTTtJQUFFLElBQUssSUFBSUMsSUFBSSxHQUFHQyxPQUFPLElBQUlWLE1BQU1PLE1BQU1FLElBQUlGLEtBQUtFLElBQUtDLElBQUksQ0FBQ0QsRUFBRSxHQUFHekIsR0FBRyxDQUFDeUIsRUFBRTtJQUFFLE9BQU9DO0FBQU07QUFDbEwsSUFBSW5DLGdDQUFnQ0YscUNBQXFDLEdBQUcsU0FBU0UsOEJBQThCb0MsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxjQUFjO0lBQ25LLElBQUlDLFFBQVEsQ0FBQyxHQUFHbkMsWUFBWW9DLGFBQWEsRUFBRU4sVUFBVWpDLGVBQWV3QyxhQUFhO0lBQ2pGLElBQUlDLE9BQU8sQ0FBQyxHQUFHdEMsWUFBWW9DLGFBQWEsRUFBRU4sVUFBVW5DLGNBQWM0QyxZQUFZO0lBQzlFLElBQUlDLFdBQVcsRUFBRSxDQUFDQyxNQUFNLENBQUN2QyxtQkFBbUJpQyxRQUFRakMsbUJBQW1Cb0M7SUFDdkUsSUFBSUksUUFBUSxDQUFDLEdBQUcxQyxZQUFZb0MsYUFBYSxFQUFFTixVQUFVaEMsZUFBZTZDLGFBQWE7SUFDakYsSUFBSUMsUUFBUSxHQUFHSCxNQUFNLENBQUNSLFVBQVU7SUFDaEMsSUFBSVksV0FBV1osUUFBUSxDQUFDLEVBQUU7SUFDMUIsSUFBSWEsY0FBY2Y7SUFDbEIsSUFBSVMsU0FBU2IsTUFBTSxFQUFFO1FBQ25CbUIsY0FBY04sU0FBU08sTUFBTSxDQUFDLFNBQVVDLE1BQU0sRUFBRUMsRUFBRTtZQUNoRCxJQUFJQSxHQUFHQyxLQUFLLENBQUNOLE1BQU0sS0FBS1osVUFBVSxDQUFDLEdBQUdqQyxtQkFBbUJvRCxpQkFBaUIsRUFBRUYsR0FBR0MsS0FBSyxFQUFFLG1CQUFtQixDQUFDLEdBQUdqRCxXQUFXbUQsUUFBUSxFQUFFSCxHQUFHQyxLQUFLLENBQUNMLFNBQVMsR0FBRztnQkFDckosSUFBSXBELFFBQVF3RCxHQUFHQyxLQUFLLENBQUNMLFNBQVM7Z0JBQzlCLE9BQU87b0JBQUNRLEtBQUtDLEdBQUcsQ0FBQ04sTUFBTSxDQUFDLEVBQUUsRUFBRXZEO29CQUFRNEQsS0FBS0UsR0FBRyxDQUFDUCxNQUFNLENBQUMsRUFBRSxFQUFFdkQ7aUJBQU87WUFDakU7WUFDQSxPQUFPdUQ7UUFDVCxHQUFHRjtJQUNMO0lBQ0EsSUFBSUosTUFBTWYsTUFBTSxFQUFFO1FBQ2hCLElBQUk2QixPQUFPLEdBQUdmLE1BQU0sQ0FBQ0ksVUFBVTtRQUMvQixJQUFJWSxPQUFPLEdBQUdoQixNQUFNLENBQUNJLFVBQVU7UUFDL0JDLGNBQWNKLE1BQU1LLE1BQU0sQ0FBQyxTQUFVQyxNQUFNLEVBQUVDLEVBQUU7WUFDN0MsSUFBSUEsR0FBR0MsS0FBSyxDQUFDTixNQUFNLEtBQUtaLFVBQVUsQ0FBQyxHQUFHakMsbUJBQW1Cb0QsaUJBQWlCLEVBQUVGLEdBQUdDLEtBQUssRUFBRSxtQkFBbUIsQ0FBQyxHQUFHakQsV0FBV21ELFFBQVEsRUFBRUgsR0FBR0MsS0FBSyxDQUFDTSxLQUFLLEtBQUssQ0FBQyxHQUFHdkQsV0FBV21ELFFBQVEsRUFBRUgsR0FBR0MsS0FBSyxDQUFDTyxLQUFLLEdBQUc7Z0JBQzdMLElBQUlDLFNBQVNULEdBQUdDLEtBQUssQ0FBQ00sS0FBSztnQkFDM0IsSUFBSUcsU0FBU1YsR0FBR0MsS0FBSyxDQUFDTyxLQUFLO2dCQUMzQixPQUFPO29CQUFDSixLQUFLQyxHQUFHLENBQUNOLE1BQU0sQ0FBQyxFQUFFLEVBQUVVLFFBQVFDO29CQUFTTixLQUFLRSxHQUFHLENBQUNQLE1BQU0sQ0FBQyxFQUFFLEVBQUVVLFFBQVFDO2lCQUFRO1lBQ25GO1lBQ0EsT0FBT1g7UUFDVCxHQUFHRjtJQUNMO0lBQ0EsSUFBSVosa0JBQWtCQSxlQUFlUCxNQUFNLEVBQUU7UUFDM0NtQixjQUFjWixlQUFlYSxNQUFNLENBQUMsU0FBVUMsTUFBTSxFQUFFWSxJQUFJO1lBQ3hELElBQUksQ0FBQyxHQUFHM0QsV0FBV21ELFFBQVEsRUFBRVEsT0FBTztnQkFDbEMsT0FBTztvQkFBQ1AsS0FBS0MsR0FBRyxDQUFDTixNQUFNLENBQUMsRUFBRSxFQUFFWTtvQkFBT1AsS0FBS0UsR0FBRyxDQUFDUCxNQUFNLENBQUMsRUFBRSxFQUFFWTtpQkFBTTtZQUMvRDtZQUNBLE9BQU9aO1FBQ1QsR0FBR0Y7SUFDTDtJQUNBLE9BQU9BO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvRGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW4uanM/NTc2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW4gPSB2b2lkIDA7XG52YXIgX1JlZmVyZW5jZURvdCA9IHJlcXVpcmUoXCIuLi9jYXJ0ZXNpYW4vUmVmZXJlbmNlRG90XCIpO1xudmFyIF9SZWZlcmVuY2VMaW5lID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9SZWZlcmVuY2VMaW5lXCIpO1xudmFyIF9SZWZlcmVuY2VBcmVhID0gcmVxdWlyZShcIi4uL2NhcnRlc2lhbi9SZWZlcmVuY2VBcmVhXCIpO1xudmFyIF9JZk92ZXJmbG93TWF0Y2hlcyA9IHJlcXVpcmUoXCIuL0lmT3ZlcmZsb3dNYXRjaGVzXCIpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4vUmVhY3RVdGlsc1wiKTtcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4vRGF0YVV0aWxzXCIpO1xuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciBkZXRlY3RSZWZlcmVuY2VFbGVtZW50c0RvbWFpbiA9IGV4cG9ydHMuZGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW4gPSBmdW5jdGlvbiBkZXRlY3RSZWZlcmVuY2VFbGVtZW50c0RvbWFpbihjaGlsZHJlbiwgZG9tYWluLCBheGlzSWQsIGF4aXNUeXBlLCBzcGVjaWZpZWRUaWNrcykge1xuICB2YXIgbGluZXMgPSAoMCwgX1JlYWN0VXRpbHMuZmluZEFsbEJ5VHlwZSkoY2hpbGRyZW4sIF9SZWZlcmVuY2VMaW5lLlJlZmVyZW5jZUxpbmUpO1xuICB2YXIgZG90cyA9ICgwLCBfUmVhY3RVdGlscy5maW5kQWxsQnlUeXBlKShjaGlsZHJlbiwgX1JlZmVyZW5jZURvdC5SZWZlcmVuY2VEb3QpO1xuICB2YXIgZWxlbWVudHMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxpbmVzKSwgX3RvQ29uc3VtYWJsZUFycmF5KGRvdHMpKTtcbiAgdmFyIGFyZWFzID0gKDAsIF9SZWFjdFV0aWxzLmZpbmRBbGxCeVR5cGUpKGNoaWxkcmVuLCBfUmVmZXJlbmNlQXJlYS5SZWZlcmVuY2VBcmVhKTtcbiAgdmFyIGlkS2V5ID0gXCJcIi5jb25jYXQoYXhpc1R5cGUsIFwiSWRcIik7XG4gIHZhciB2YWx1ZUtleSA9IGF4aXNUeXBlWzBdO1xuICB2YXIgZmluYWxEb21haW4gPSBkb21haW47XG4gIGlmIChlbGVtZW50cy5sZW5ndGgpIHtcbiAgICBmaW5hbERvbWFpbiA9IGVsZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBlbCkge1xuICAgICAgaWYgKGVsLnByb3BzW2lkS2V5XSA9PT0gYXhpc0lkICYmICgwLCBfSWZPdmVyZmxvd01hdGNoZXMuaWZPdmVyZmxvd01hdGNoZXMpKGVsLnByb3BzLCAnZXh0ZW5kRG9tYWluJykgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGVsLnByb3BzW3ZhbHVlS2V5XSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZWwucHJvcHNbdmFsdWVLZXldO1xuICAgICAgICByZXR1cm4gW01hdGgubWluKHJlc3VsdFswXSwgdmFsdWUpLCBNYXRoLm1heChyZXN1bHRbMV0sIHZhbHVlKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIGZpbmFsRG9tYWluKTtcbiAgfVxuICBpZiAoYXJlYXMubGVuZ3RoKSB7XG4gICAgdmFyIGtleTEgPSBcIlwiLmNvbmNhdCh2YWx1ZUtleSwgXCIxXCIpO1xuICAgIHZhciBrZXkyID0gXCJcIi5jb25jYXQodmFsdWVLZXksIFwiMlwiKTtcbiAgICBmaW5hbERvbWFpbiA9IGFyZWFzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBlbCkge1xuICAgICAgaWYgKGVsLnByb3BzW2lkS2V5XSA9PT0gYXhpc0lkICYmICgwLCBfSWZPdmVyZmxvd01hdGNoZXMuaWZPdmVyZmxvd01hdGNoZXMpKGVsLnByb3BzLCAnZXh0ZW5kRG9tYWluJykgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGVsLnByb3BzW2tleTFdKSAmJiAoMCwgX0RhdGFVdGlscy5pc051bWJlcikoZWwucHJvcHNba2V5Ml0pKSB7XG4gICAgICAgIHZhciB2YWx1ZTEgPSBlbC5wcm9wc1trZXkxXTtcbiAgICAgICAgdmFyIHZhbHVlMiA9IGVsLnByb3BzW2tleTJdO1xuICAgICAgICByZXR1cm4gW01hdGgubWluKHJlc3VsdFswXSwgdmFsdWUxLCB2YWx1ZTIpLCBNYXRoLm1heChyZXN1bHRbMV0sIHZhbHVlMSwgdmFsdWUyKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIGZpbmFsRG9tYWluKTtcbiAgfVxuICBpZiAoc3BlY2lmaWVkVGlja3MgJiYgc3BlY2lmaWVkVGlja3MubGVuZ3RoKSB7XG4gICAgZmluYWxEb21haW4gPSBzcGVjaWZpZWRUaWNrcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgdGljaykge1xuICAgICAgaWYgKCgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh0aWNrKSkge1xuICAgICAgICByZXR1cm4gW01hdGgubWluKHJlc3VsdFswXSwgdGljayksIE1hdGgubWF4KHJlc3VsdFsxXSwgdGljayldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBmaW5hbERvbWFpbik7XG4gIH1cbiAgcmV0dXJuIGZpbmFsRG9tYWluO1xufTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZXRlY3RSZWZlcmVuY2VFbGVtZW50c0RvbWFpbiIsIl9SZWZlcmVuY2VEb3QiLCJyZXF1aXJlIiwiX1JlZmVyZW5jZUxpbmUiLCJfUmVmZXJlbmNlQXJlYSIsIl9JZk92ZXJmbG93TWF0Y2hlcyIsIl9SZWFjdFV0aWxzIiwiX0RhdGFVdGlscyIsIl90b0NvbnN1bWFibGVBcnJheSIsImFyciIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJUeXBlRXJyb3IiLCJvIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwiaXRlciIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaXNBcnJheSIsImxlbiIsImxlbmd0aCIsImkiLCJhcnIyIiwiY2hpbGRyZW4iLCJkb21haW4iLCJheGlzSWQiLCJheGlzVHlwZSIsInNwZWNpZmllZFRpY2tzIiwibGluZXMiLCJmaW5kQWxsQnlUeXBlIiwiUmVmZXJlbmNlTGluZSIsImRvdHMiLCJSZWZlcmVuY2VEb3QiLCJlbGVtZW50cyIsImNvbmNhdCIsImFyZWFzIiwiUmVmZXJlbmNlQXJlYSIsImlkS2V5IiwidmFsdWVLZXkiLCJmaW5hbERvbWFpbiIsInJlZHVjZSIsInJlc3VsdCIsImVsIiwicHJvcHMiLCJpZk92ZXJmbG93TWF0Y2hlcyIsImlzTnVtYmVyIiwiTWF0aCIsIm1pbiIsIm1heCIsImtleTEiLCJrZXkyIiwidmFsdWUxIiwidmFsdWUyIiwidGljayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/DetectReferenceElementsDomain.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/Events.js":
/*!**************************************************!*\
  !*** ./node_modules/recharts/lib/util/Events.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.eventCenter = exports.SYNC_EVENT = void 0;\nvar _eventemitter = _interopRequireDefault(__webpack_require__(/*! eventemitter3 */ \"eventemitter3\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nvar eventCenter = exports.eventCenter = new _eventemitter[\"default\"]();\nvar SYNC_EVENT = exports.SYNC_EVENT = \"recharts.syncMouseEvents\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvRXZlbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxtQkFBbUIsR0FBR0Esa0JBQWtCLEdBQUcsS0FBSztBQUNoRCxJQUFJSSxnQkFBZ0JDLHVCQUF1QkMsbUJBQU9BLENBQUMsb0NBQWU7QUFDbEUsU0FBU0QsdUJBQXVCRSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLElBQUlMLGNBQWNGLG1CQUFtQixHQUFHLElBQUlJLGFBQWEsQ0FBQyxVQUFVO0FBQ3BFLElBQUlELGFBQWFILGtCQUFrQixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi91dGlsL0V2ZW50cy5qcz8xOGYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ldmVudENlbnRlciA9IGV4cG9ydHMuU1lOQ19FVkVOVCA9IHZvaWQgMDtcbnZhciBfZXZlbnRlbWl0dGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZXZlbnRlbWl0dGVyM1wiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbnZhciBldmVudENlbnRlciA9IGV4cG9ydHMuZXZlbnRDZW50ZXIgPSBuZXcgX2V2ZW50ZW1pdHRlcltcImRlZmF1bHRcIl0oKTtcbnZhciBTWU5DX0VWRU5UID0gZXhwb3J0cy5TWU5DX0VWRU5UID0gJ3JlY2hhcnRzLnN5bmNNb3VzZUV2ZW50cyc7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZXZlbnRDZW50ZXIiLCJTWU5DX0VWRU5UIiwiX2V2ZW50ZW1pdHRlciIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwib2JqIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/Events.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/FunnelUtils.js":
/*!*******************************************************!*\
  !*** ./node_modules/recharts/lib/util/FunnelUtils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FunnelTrapezoid = FunnelTrapezoid;\nexports.typeGuardTrapezoidProps = typeGuardTrapezoidProps;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _ActiveShapeUtils = __webpack_require__(/*! ./ActiveShapeUtils */ \"./node_modules/recharts/lib/util/ActiveShapeUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n// Trapezoid props is expecting x, y, height as numbers.\n// When props are being spread in from a user defined component in Funnel,\n// the prop types of an SVGElement have these typed as string | number.\n// This function will return the passed in props along with x, y, height as numbers.\nfunction typeGuardTrapezoidProps(option, props) {\n    var xValue = \"\".concat(props.x || option.x);\n    var x = parseInt(xValue, 10);\n    var yValue = \"\".concat(props.y || option.y);\n    var y = parseInt(yValue, 10);\n    var heightValue = \"\".concat((props === null || props === void 0 ? void 0 : props.height) || (option === null || option === void 0 ? void 0 : option.height));\n    var height = parseInt(heightValue, 10);\n    return _objectSpread(_objectSpread(_objectSpread({}, props), (0, _ActiveShapeUtils.getPropsFromShapeOption)(option)), {}, {\n        height: height,\n        x: x,\n        y: y\n    });\n}\nfunction FunnelTrapezoid(props) {\n    return /*#__PURE__*/ _react[\"default\"].createElement(_ActiveShapeUtils.Shape, _extends({\n        shapeType: \"trapezoid\",\n        propTransformer: typeGuardTrapezoidProps\n    }, props));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvRnVubmVsVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHVCQUF1QixHQUFHRTtBQUMxQkYsK0JBQStCLEdBQUdHO0FBQ2xDLElBQUlDLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDbkQsSUFBSUMsb0JBQW9CRCxtQkFBT0EsQ0FBQyxnRkFBb0I7QUFDcEQsU0FBU0QsdUJBQXVCRyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHLFNBQVNFLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSztJQUFhQSxXQUFXbEIsT0FBT21CLE1BQU0sR0FBR25CLE9BQU9tQixNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUFFLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUFFLElBQUssSUFBSUksT0FBT0QsT0FBUTtnQkFBRSxJQUFJekIsT0FBT2lCLFNBQVMsQ0FBQ1UsY0FBYyxDQUFDQyxJQUFJLENBQUNILFFBQVFDLE1BQU07b0JBQUVMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQUU7WUFBRTtR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LE1BQU0sQ0FBQyxDQUFDRixVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSUEsTUFBTVEsTUFBTSxLQUFNVCxDQUFBQSxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT1MsTUFBTTtJQUMxSixJQUFJQSxTQUFTSixTQUFTRyxhQUFhO0lBQ25DLE9BQU9yQixjQUFjQSxjQUFjQSxjQUFjLENBQUMsR0FBR2MsUUFBUSxDQUFDLEdBQUc3QyxrQkFBa0JzRCx1QkFBdUIsRUFBRVYsVUFBVSxDQUFDLEdBQUc7UUFDeEhTLFFBQVFBO1FBQ1JMLEdBQUdBO1FBQ0hHLEdBQUdBO0lBQ0w7QUFDRjtBQUNBLFNBQVN4RCxnQkFBZ0JrRCxLQUFLO0lBQzVCLE9BQU8sV0FBVyxHQUFFaEQsTUFBTSxDQUFDLFVBQVUsQ0FBQzBELGFBQWEsQ0FBQ3ZELGtCQUFrQndELEtBQUssRUFBRS9DLFNBQVM7UUFDcEZnRCxXQUFXO1FBQ1hDLGlCQUFpQjlEO0lBQ25CLEdBQUdpRDtBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi91dGlsL0Z1bm5lbFV0aWxzLmpzP2FiYmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkZ1bm5lbFRyYXBlem9pZCA9IEZ1bm5lbFRyYXBlem9pZDtcbmV4cG9ydHMudHlwZUd1YXJkVHJhcGV6b2lkUHJvcHMgPSB0eXBlR3VhcmRUcmFwZXpvaWRQcm9wcztcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX0FjdGl2ZVNoYXBlVXRpbHMgPSByZXF1aXJlKFwiLi9BY3RpdmVTaGFwZVV0aWxzXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG4vLyBUcmFwZXpvaWQgcHJvcHMgaXMgZXhwZWN0aW5nIHgsIHksIGhlaWdodCBhcyBudW1iZXJzLlxuLy8gV2hlbiBwcm9wcyBhcmUgYmVpbmcgc3ByZWFkIGluIGZyb20gYSB1c2VyIGRlZmluZWQgY29tcG9uZW50IGluIEZ1bm5lbCxcbi8vIHRoZSBwcm9wIHR5cGVzIG9mIGFuIFNWR0VsZW1lbnQgaGF2ZSB0aGVzZSB0eXBlZCBhcyBzdHJpbmcgfCBudW1iZXIuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBwYXNzZWQgaW4gcHJvcHMgYWxvbmcgd2l0aCB4LCB5LCBoZWlnaHQgYXMgbnVtYmVycy5cbmZ1bmN0aW9uIHR5cGVHdWFyZFRyYXBlem9pZFByb3BzKG9wdGlvbiwgcHJvcHMpIHtcbiAgdmFyIHhWYWx1ZSA9IFwiXCIuY29uY2F0KHByb3BzLnggfHwgb3B0aW9uLngpO1xuICB2YXIgeCA9IHBhcnNlSW50KHhWYWx1ZSwgMTApO1xuICB2YXIgeVZhbHVlID0gXCJcIi5jb25jYXQocHJvcHMueSB8fCBvcHRpb24ueSk7XG4gIHZhciB5ID0gcGFyc2VJbnQoeVZhbHVlLCAxMCk7XG4gIHZhciBoZWlnaHRWYWx1ZSA9IFwiXCIuY29uY2F0KChwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuaGVpZ2h0KSB8fCAob3B0aW9uID09PSBudWxsIHx8IG9wdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uLmhlaWdodCkpO1xuICB2YXIgaGVpZ2h0ID0gcGFyc2VJbnQoaGVpZ2h0VmFsdWUsIDEwKTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksICgwLCBfQWN0aXZlU2hhcGVVdGlscy5nZXRQcm9wc0Zyb21TaGFwZU9wdGlvbikob3B0aW9uKSksIHt9LCB7XG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pO1xufVxuZnVuY3Rpb24gRnVubmVsVHJhcGV6b2lkKHByb3BzKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9BY3RpdmVTaGFwZVV0aWxzLlNoYXBlLCBfZXh0ZW5kcyh7XG4gICAgc2hhcGVUeXBlOiBcInRyYXBlem9pZFwiLFxuICAgIHByb3BUcmFuc2Zvcm1lcjogdHlwZUd1YXJkVHJhcGV6b2lkUHJvcHNcbiAgfSwgcHJvcHMpKTtcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJGdW5uZWxUcmFwZXpvaWQiLCJ0eXBlR3VhcmRUcmFwZXpvaWRQcm9wcyIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX0FjdGl2ZVNoYXBlVXRpbHMiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5Iiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJvcHRpb24iLCJwcm9wcyIsInhWYWx1ZSIsImNvbmNhdCIsIngiLCJwYXJzZUludCIsInlWYWx1ZSIsInkiLCJoZWlnaHRWYWx1ZSIsImhlaWdodCIsImdldFByb3BzRnJvbVNoYXBlT3B0aW9uIiwiY3JlYXRlRWxlbWVudCIsIlNoYXBlIiwic2hhcGVUeXBlIiwicHJvcFRyYW5zZm9ybWVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/FunnelUtils.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/Global.js":
/*!**************************************************!*\
  !*** ./node_modules/recharts/lib/util/Global.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Global = void 0;\nvar parseIsSsrByDefault = function parseIsSsrByDefault() {\n    return !( false && 0);\n};\nvar Global = exports.Global = {\n    isSsr: parseIsSsrByDefault(),\n    get: function get(key) {\n        return Global[key];\n    },\n    set: function set(key, value) {\n        if (typeof key === \"string\") {\n            Global[key] = value;\n        } else {\n            var keys = Object.keys(key);\n            if (keys && keys.length) {\n                keys.forEach(function(k) {\n                    Global[k] = key[k];\n                });\n            }\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvR2xvYmFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxjQUFjLEdBQUcsS0FBSztBQUN0QixJQUFJRyxzQkFBc0IsU0FBU0E7SUFDakMsT0FBTyxDQUFFLE9BQWlGLElBQUlDLENBQWlCO0FBQ2pIO0FBQ0EsSUFBSUYsU0FBU0YsY0FBYyxHQUFHO0lBQzVCUSxPQUFPTDtJQUNQTSxLQUFLLFNBQVNBLElBQUlDLEdBQUc7UUFDbkIsT0FBT1IsTUFBTSxDQUFDUSxJQUFJO0lBQ3BCO0lBQ0FDLEtBQUssU0FBU0EsSUFBSUQsR0FBRyxFQUFFVCxLQUFLO1FBQzFCLElBQUksT0FBT1MsUUFBUSxVQUFVO1lBQzNCUixNQUFNLENBQUNRLElBQUksR0FBR1Q7UUFDaEIsT0FBTztZQUNMLElBQUlXLE9BQU9kLE9BQU9jLElBQUksQ0FBQ0Y7WUFDdkIsSUFBSUUsUUFBUUEsS0FBS0MsTUFBTSxFQUFFO2dCQUN2QkQsS0FBS0UsT0FBTyxDQUFDLFNBQVVDLENBQUM7b0JBQ3RCYixNQUFNLENBQUNhLEVBQUUsR0FBR0wsR0FBRyxDQUFDSyxFQUFFO2dCQUNwQjtZQUNGO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi91dGlsL0dsb2JhbC5qcz80ODllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5HbG9iYWwgPSB2b2lkIDA7XG52YXIgcGFyc2VJc1NzckJ5RGVmYXVsdCA9IGZ1bmN0aW9uIHBhcnNlSXNTc3JCeURlZmF1bHQoKSB7XG4gIHJldHVybiAhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAmJiB3aW5kb3cuc2V0VGltZW91dCk7XG59O1xudmFyIEdsb2JhbCA9IGV4cG9ydHMuR2xvYmFsID0ge1xuICBpc1NzcjogcGFyc2VJc1NzckJ5RGVmYXVsdCgpLFxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICByZXR1cm4gR2xvYmFsW2tleV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIEdsb2JhbFtrZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoa2V5KTtcbiAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoKSB7XG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgIEdsb2JhbFtrXSA9IGtleVtrXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkdsb2JhbCIsInBhcnNlSXNTc3JCeURlZmF1bHQiLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzZXRUaW1lb3V0IiwiaXNTc3IiLCJnZXQiLCJrZXkiLCJzZXQiLCJrZXlzIiwibGVuZ3RoIiwiZm9yRWFjaCIsImsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/Global.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/IfOverflowMatches.js":
/*!*************************************************************!*\
  !*** ./node_modules/recharts/lib/util/IfOverflowMatches.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ifOverflowMatches = void 0;\nvar ifOverflowMatches = exports.ifOverflowMatches = function ifOverflowMatches(props, value) {\n    var alwaysShow = props.alwaysShow;\n    var ifOverflow = props.ifOverflow;\n    if (alwaysShow) {\n        ifOverflow = \"extendDomain\";\n    }\n    return ifOverflow === value;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvSWZPdmVyZmxvd01hdGNoZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHlCQUF5QixHQUFHLEtBQUs7QUFDakMsSUFBSUUsb0JBQW9CRix5QkFBeUIsR0FBRyxTQUFTRSxrQkFBa0JDLEtBQUssRUFBRUYsS0FBSztJQUN6RixJQUFJRyxhQUFhRCxNQUFNQyxVQUFVO0lBQ2pDLElBQUlDLGFBQWFGLE1BQU1FLFVBQVU7SUFDakMsSUFBSUQsWUFBWTtRQUNkQyxhQUFhO0lBQ2Y7SUFDQSxPQUFPQSxlQUFlSjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9JZk92ZXJmbG93TWF0Y2hlcy5qcz85MDVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pZk92ZXJmbG93TWF0Y2hlcyA9IHZvaWQgMDtcbnZhciBpZk92ZXJmbG93TWF0Y2hlcyA9IGV4cG9ydHMuaWZPdmVyZmxvd01hdGNoZXMgPSBmdW5jdGlvbiBpZk92ZXJmbG93TWF0Y2hlcyhwcm9wcywgdmFsdWUpIHtcbiAgdmFyIGFsd2F5c1Nob3cgPSBwcm9wcy5hbHdheXNTaG93O1xuICB2YXIgaWZPdmVyZmxvdyA9IHByb3BzLmlmT3ZlcmZsb3c7XG4gIGlmIChhbHdheXNTaG93KSB7XG4gICAgaWZPdmVyZmxvdyA9ICdleHRlbmREb21haW4nO1xuICB9XG4gIHJldHVybiBpZk92ZXJmbG93ID09PSB2YWx1ZTtcbn07Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaWZPdmVyZmxvd01hdGNoZXMiLCJwcm9wcyIsImFsd2F5c1Nob3ciLCJpZk92ZXJmbG93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/IfOverflowMatches.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/LogUtils.js":
/*!****************************************************!*\
  !*** ./node_modules/recharts/lib/util/LogUtils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.warn = void 0;\n/* eslint no-console: 0 */ var isDev = \"development\" !== \"production\";\nvar warn = exports.warn = function warn(condition, format) {\n    for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n        args[_key - 2] = arguments[_key];\n    }\n    if (isDev && typeof console !== \"undefined\" && console.warn) {\n        if (format === undefined) {\n            console.warn(\"LogUtils requires an error message argument\");\n        }\n        if (!condition) {\n            if (format === undefined) {\n                console.warn(\"Minified exception occurred; use the non-minified dev environment \" + \"for the full error message and additional helpful warnings.\");\n            } else {\n                var argIndex = 0;\n                console.warn(format.replace(/%s/g, function() {\n                    return args[argIndex++];\n                }));\n            }\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvTG9nVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELFlBQVksR0FBRyxLQUFLO0FBQ3BCLHdCQUF3QixHQUN4QixJQUFJRyxRQUFRQyxrQkFBeUI7QUFDckMsSUFBSUYsT0FBT0YsWUFBWSxHQUFHLFNBQVNFLEtBQUtHLFNBQVMsRUFBRUMsTUFBTTtJQUN2RCxJQUFLLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQVE7UUFDMUdGLElBQUksQ0FBQ0UsT0FBTyxFQUFFLEdBQUdKLFNBQVMsQ0FBQ0ksS0FBSztJQUNsQztJQUNBLElBQUlULFNBQVMsT0FBT1UsWUFBWSxlQUFlQSxRQUFRWCxJQUFJLEVBQUU7UUFDM0QsSUFBSUksV0FBV1EsV0FBVztZQUN4QkQsUUFBUVgsSUFBSSxDQUFDO1FBQ2Y7UUFDQSxJQUFJLENBQUNHLFdBQVc7WUFDZCxJQUFJQyxXQUFXUSxXQUFXO2dCQUN4QkQsUUFBUVgsSUFBSSxDQUFDLHVFQUF1RTtZQUN0RixPQUFPO2dCQUNMLElBQUlhLFdBQVc7Z0JBQ2ZGLFFBQVFYLElBQUksQ0FBQ0ksT0FBT1UsT0FBTyxDQUFDLE9BQU87b0JBQ2pDLE9BQU9OLElBQUksQ0FBQ0ssV0FBVztnQkFDekI7WUFDRjtRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9Mb2dVdGlscy5qcz8wN2I2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy53YXJuID0gdm9pZCAwO1xuLyogZXNsaW50IG5vLWNvbnNvbGU6IDAgKi9cbnZhciBpc0RldiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XG52YXIgd2FybiA9IGV4cG9ydHMud2FybiA9IGZ1bmN0aW9uIHdhcm4oY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGlmIChpc0RldiAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0xvZ1V0aWxzIHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICAgIGNvbnNvbGUud2Fybihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIndhcm4iLCJpc0RldiIsInByb2Nlc3MiLCJjb25kaXRpb24iLCJmb3JtYXQiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImNvbnNvbGUiLCJ1bmRlZmluZWQiLCJhcmdJbmRleCIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/LogUtils.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/PolarUtils.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/util/PolarUtils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.radianToDegree = exports.polarToCartesian = exports.inRangeOfSector = exports.getTickClassName = exports.getMaxRadius = exports.getAngleOfPoint = exports.formatAxisMap = exports.formatAngleOfSector = exports.distanceBetweenPoints = exports.degreeToRadian = exports.RADIAN = void 0;\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _react = __webpack_require__(/*! react */ \"react\");\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _DataUtils = __webpack_require__(/*! ./DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ChartUtils = __webpack_require__(/*! ./ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nvar RADIAN = exports.RADIAN = Math.PI / 180;\nvar degreeToRadian = exports.degreeToRadian = function degreeToRadian(angle) {\n    return angle * Math.PI / 180;\n};\nvar radianToDegree = exports.radianToDegree = function radianToDegree(angleInRadian) {\n    return angleInRadian * 180 / Math.PI;\n};\nvar polarToCartesian = exports.polarToCartesian = function polarToCartesian(cx, cy, radius, angle) {\n    return {\n        x: cx + Math.cos(-RADIAN * angle) * radius,\n        y: cy + Math.sin(-RADIAN * angle) * radius\n    };\n};\nvar getMaxRadius = exports.getMaxRadius = function getMaxRadius(width, height) {\n    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n    };\n    return Math.min(Math.abs(width - (offset.left || 0) - (offset.right || 0)), Math.abs(height - (offset.top || 0) - (offset.bottom || 0))) / 2;\n};\n/**\n * Calculate the scale function, position, width, height of axes\n * @param  {Object} props     Latest props\n * @param  {Object} axisMap   The configuration of axes\n * @param  {Object} offset    The offset of main part in the svg element\n * @param  {Object} axisType  The type of axes, radius-axis or angle-axis\n * @param  {String} chartName The name of chart\n * @return {Object} Configuration\n */ var formatAxisMap = exports.formatAxisMap = function formatAxisMap(props, axisMap, offset, axisType, chartName) {\n    var width = props.width, height = props.height;\n    var startAngle = props.startAngle, endAngle = props.endAngle;\n    var cx = (0, _DataUtils.getPercentValue)(props.cx, width, width / 2);\n    var cy = (0, _DataUtils.getPercentValue)(props.cy, height, height / 2);\n    var maxRadius = getMaxRadius(width, height, offset);\n    var innerRadius = (0, _DataUtils.getPercentValue)(props.innerRadius, maxRadius, 0);\n    var outerRadius = (0, _DataUtils.getPercentValue)(props.outerRadius, maxRadius, maxRadius * 0.8);\n    var ids = Object.keys(axisMap);\n    return ids.reduce(function(result, id) {\n        var axis = axisMap[id];\n        var domain = axis.domain, reversed = axis.reversed;\n        var range;\n        if ((0, _isNil[\"default\"])(axis.range)) {\n            if (axisType === \"angleAxis\") {\n                range = [\n                    startAngle,\n                    endAngle\n                ];\n            } else if (axisType === \"radiusAxis\") {\n                range = [\n                    innerRadius,\n                    outerRadius\n                ];\n            }\n            if (reversed) {\n                range = [\n                    range[1],\n                    range[0]\n                ];\n            }\n        } else {\n            range = axis.range;\n            var _range = range;\n            var _range2 = _slicedToArray(_range, 2);\n            startAngle = _range2[0];\n            endAngle = _range2[1];\n        }\n        var _parseScale = (0, _ChartUtils.parseScale)(axis, chartName), realScaleType = _parseScale.realScaleType, scale = _parseScale.scale;\n        scale.domain(domain).range(range);\n        (0, _ChartUtils.checkDomainOfScale)(scale);\n        var ticks = (0, _ChartUtils.getTicksOfScale)(scale, _objectSpread(_objectSpread({}, axis), {}, {\n            realScaleType: realScaleType\n        }));\n        var finalAxis = _objectSpread(_objectSpread(_objectSpread({}, axis), ticks), {}, {\n            range: range,\n            radius: outerRadius,\n            realScaleType: realScaleType,\n            scale: scale,\n            cx: cx,\n            cy: cy,\n            innerRadius: innerRadius,\n            outerRadius: outerRadius,\n            startAngle: startAngle,\n            endAngle: endAngle\n        });\n        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, id, finalAxis));\n    }, {});\n};\nvar distanceBetweenPoints = exports.distanceBetweenPoints = function distanceBetweenPoints(point, anotherPoint) {\n    var x1 = point.x, y1 = point.y;\n    var x2 = anotherPoint.x, y2 = anotherPoint.y;\n    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n};\nvar getAngleOfPoint = exports.getAngleOfPoint = function getAngleOfPoint(_ref, _ref2) {\n    var x = _ref.x, y = _ref.y;\n    var cx = _ref2.cx, cy = _ref2.cy;\n    var radius = distanceBetweenPoints({\n        x: x,\n        y: y\n    }, {\n        x: cx,\n        y: cy\n    });\n    if (radius <= 0) {\n        return {\n            radius: radius\n        };\n    }\n    var cos = (x - cx) / radius;\n    var angleInRadian = Math.acos(cos);\n    if (y > cy) {\n        angleInRadian = 2 * Math.PI - angleInRadian;\n    }\n    return {\n        radius: radius,\n        angle: radianToDegree(angleInRadian),\n        angleInRadian: angleInRadian\n    };\n};\nvar formatAngleOfSector = exports.formatAngleOfSector = function formatAngleOfSector(_ref3) {\n    var startAngle = _ref3.startAngle, endAngle = _ref3.endAngle;\n    var startCnt = Math.floor(startAngle / 360);\n    var endCnt = Math.floor(endAngle / 360);\n    var min = Math.min(startCnt, endCnt);\n    return {\n        startAngle: startAngle - min * 360,\n        endAngle: endAngle - min * 360\n    };\n};\nvar reverseFormatAngleOfSetor = function reverseFormatAngleOfSetor(angle, _ref4) {\n    var startAngle = _ref4.startAngle, endAngle = _ref4.endAngle;\n    var startCnt = Math.floor(startAngle / 360);\n    var endCnt = Math.floor(endAngle / 360);\n    var min = Math.min(startCnt, endCnt);\n    return angle + min * 360;\n};\nvar inRangeOfSector = exports.inRangeOfSector = function inRangeOfSector(_ref5, sector) {\n    var x = _ref5.x, y = _ref5.y;\n    var _getAngleOfPoint = getAngleOfPoint({\n        x: x,\n        y: y\n    }, sector), radius = _getAngleOfPoint.radius, angle = _getAngleOfPoint.angle;\n    var innerRadius = sector.innerRadius, outerRadius = sector.outerRadius;\n    if (radius < innerRadius || radius > outerRadius) {\n        return false;\n    }\n    if (radius === 0) {\n        return true;\n    }\n    var _formatAngleOfSector = formatAngleOfSector(sector), startAngle = _formatAngleOfSector.startAngle, endAngle = _formatAngleOfSector.endAngle;\n    var formatAngle = angle;\n    var inRange;\n    if (startAngle <= endAngle) {\n        while(formatAngle > endAngle){\n            formatAngle -= 360;\n        }\n        while(formatAngle < startAngle){\n            formatAngle += 360;\n        }\n        inRange = formatAngle >= startAngle && formatAngle <= endAngle;\n    } else {\n        while(formatAngle > startAngle){\n            formatAngle -= 360;\n        }\n        while(formatAngle < endAngle){\n            formatAngle += 360;\n        }\n        inRange = formatAngle >= endAngle && formatAngle <= startAngle;\n    }\n    if (inRange) {\n        return _objectSpread(_objectSpread({}, sector), {}, {\n            radius: radius,\n            angle: reverseFormatAngleOfSetor(formatAngle, sector)\n        });\n    }\n    return null;\n};\nvar getTickClassName = exports.getTickClassName = function getTickClassName(tick) {\n    return !/*#__PURE__*/ (0, _react.isValidElement)(tick) && !(0, _isFunction[\"default\"])(tick) && typeof tick !== \"boolean\" ? tick.className : \"\";\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvUG9sYXJVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VEssOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHNCQUFzQixHQUFHQSx3QkFBd0IsR0FBR0EsdUJBQXVCLEdBQUdBLHdCQUF3QixHQUFHQSxvQkFBb0IsR0FBR0EsdUJBQXVCLEdBQUdBLHFCQUFxQixHQUFHQSwyQkFBMkIsR0FBR0EsNkJBQTZCLEdBQUdBLHNCQUFzQixHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUMvUixJQUFJYSxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLGtDQUFjO0FBQzFELElBQUlDLFNBQVNELG1CQUFPQSxDQUFDLG9CQUFPO0FBQzVCLElBQUlFLGNBQWNILHVCQUF1QkMsbUJBQU9BLENBQUMsNENBQW1CO0FBQ3BFLElBQUlHLGFBQWFILG1CQUFPQSxDQUFDLGtFQUFhO0FBQ3RDLElBQUlJLGNBQWNKLG1CQUFPQSxDQUFDLG9FQUFjO0FBQ3hDLFNBQVNELHVCQUF1Qk0sR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSxRQUFRQyxDQUFDLEVBQUVDLENBQUM7SUFBSSxJQUFJQyxJQUFJM0IsT0FBTzRCLElBQUksQ0FBQ0g7SUFBSSxJQUFJekIsT0FBTzZCLHFCQUFx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Y2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvUG9sYXJVdGlscy5qcz80YWQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yYWRpYW5Ub0RlZ3JlZSA9IGV4cG9ydHMucG9sYXJUb0NhcnRlc2lhbiA9IGV4cG9ydHMuaW5SYW5nZU9mU2VjdG9yID0gZXhwb3J0cy5nZXRUaWNrQ2xhc3NOYW1lID0gZXhwb3J0cy5nZXRNYXhSYWRpdXMgPSBleHBvcnRzLmdldEFuZ2xlT2ZQb2ludCA9IGV4cG9ydHMuZm9ybWF0QXhpc01hcCA9IGV4cG9ydHMuZm9ybWF0QW5nbGVPZlNlY3RvciA9IGV4cG9ydHMuZGlzdGFuY2VCZXR3ZWVuUG9pbnRzID0gZXhwb3J0cy5kZWdyZWVUb1JhZGlhbiA9IGV4cG9ydHMuUkFESUFOID0gdm9pZCAwO1xudmFyIF9pc05pbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc05pbFwiKSk7XG52YXIgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIF9pc0Z1bmN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xudmFyIF9EYXRhVXRpbHMgPSByZXF1aXJlKFwiLi9EYXRhVXRpbHNcIik7XG52YXIgX0NoYXJ0VXRpbHMgPSByZXF1aXJlKFwiLi9DaGFydFV0aWxzXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG52YXIgUkFESUFOID0gZXhwb3J0cy5SQURJQU4gPSBNYXRoLlBJIC8gMTgwO1xudmFyIGRlZ3JlZVRvUmFkaWFuID0gZXhwb3J0cy5kZWdyZWVUb1JhZGlhbiA9IGZ1bmN0aW9uIGRlZ3JlZVRvUmFkaWFuKGFuZ2xlKSB7XG4gIHJldHVybiBhbmdsZSAqIE1hdGguUEkgLyAxODA7XG59O1xudmFyIHJhZGlhblRvRGVncmVlID0gZXhwb3J0cy5yYWRpYW5Ub0RlZ3JlZSA9IGZ1bmN0aW9uIHJhZGlhblRvRGVncmVlKGFuZ2xlSW5SYWRpYW4pIHtcbiAgcmV0dXJuIGFuZ2xlSW5SYWRpYW4gKiAxODAgLyBNYXRoLlBJO1xufTtcbnZhciBwb2xhclRvQ2FydGVzaWFuID0gZXhwb3J0cy5wb2xhclRvQ2FydGVzaWFuID0gZnVuY3Rpb24gcG9sYXJUb0NhcnRlc2lhbihjeCwgY3ksIHJhZGl1cywgYW5nbGUpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBjeCArIE1hdGguY29zKC1SQURJQU4gKiBhbmdsZSkgKiByYWRpdXMsXG4gICAgeTogY3kgKyBNYXRoLnNpbigtUkFESUFOICogYW5nbGUpICogcmFkaXVzXG4gIH07XG59O1xudmFyIGdldE1heFJhZGl1cyA9IGV4cG9ydHMuZ2V0TWF4UmFkaXVzID0gZnVuY3Rpb24gZ2V0TWF4UmFkaXVzKHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5hYnMod2lkdGggLSAob2Zmc2V0LmxlZnQgfHwgMCkgLSAob2Zmc2V0LnJpZ2h0IHx8IDApKSwgTWF0aC5hYnMoaGVpZ2h0IC0gKG9mZnNldC50b3AgfHwgMCkgLSAob2Zmc2V0LmJvdHRvbSB8fCAwKSkpIC8gMjtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzY2FsZSBmdW5jdGlvbiwgcG9zaXRpb24sIHdpZHRoLCBoZWlnaHQgb2YgYXhlc1xuICogQHBhcmFtICB7T2JqZWN0fSBwcm9wcyAgICAgTGF0ZXN0IHByb3BzXG4gKiBAcGFyYW0gIHtPYmplY3R9IGF4aXNNYXAgICBUaGUgY29uZmlndXJhdGlvbiBvZiBheGVzXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9mZnNldCAgICBUaGUgb2Zmc2V0IG9mIG1haW4gcGFydCBpbiB0aGUgc3ZnIGVsZW1lbnRcbiAqIEBwYXJhbSAge09iamVjdH0gYXhpc1R5cGUgIFRoZSB0eXBlIG9mIGF4ZXMsIHJhZGl1cy1heGlzIG9yIGFuZ2xlLWF4aXNcbiAqIEBwYXJhbSAge1N0cmluZ30gY2hhcnROYW1lIFRoZSBuYW1lIG9mIGNoYXJ0XG4gKiBAcmV0dXJuIHtPYmplY3R9IENvbmZpZ3VyYXRpb25cbiAqL1xudmFyIGZvcm1hdEF4aXNNYXAgPSBleHBvcnRzLmZvcm1hdEF4aXNNYXAgPSBmdW5jdGlvbiBmb3JtYXRBeGlzTWFwKHByb3BzLCBheGlzTWFwLCBvZmZzZXQsIGF4aXNUeXBlLCBjaGFydE5hbWUpIHtcbiAgdmFyIHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0O1xuICB2YXIgc3RhcnRBbmdsZSA9IHByb3BzLnN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGUgPSBwcm9wcy5lbmRBbmdsZTtcbiAgdmFyIGN4ID0gKDAsIF9EYXRhVXRpbHMuZ2V0UGVyY2VudFZhbHVlKShwcm9wcy5jeCwgd2lkdGgsIHdpZHRoIC8gMik7XG4gIHZhciBjeSA9ICgwLCBfRGF0YVV0aWxzLmdldFBlcmNlbnRWYWx1ZSkocHJvcHMuY3ksIGhlaWdodCwgaGVpZ2h0IC8gMik7XG4gIHZhciBtYXhSYWRpdXMgPSBnZXRNYXhSYWRpdXMod2lkdGgsIGhlaWdodCwgb2Zmc2V0KTtcbiAgdmFyIGlubmVyUmFkaXVzID0gKDAsIF9EYXRhVXRpbHMuZ2V0UGVyY2VudFZhbHVlKShwcm9wcy5pbm5lclJhZGl1cywgbWF4UmFkaXVzLCAwKTtcbiAgdmFyIG91dGVyUmFkaXVzID0gKDAsIF9EYXRhVXRpbHMuZ2V0UGVyY2VudFZhbHVlKShwcm9wcy5vdXRlclJhZGl1cywgbWF4UmFkaXVzLCBtYXhSYWRpdXMgKiAwLjgpO1xuICB2YXIgaWRzID0gT2JqZWN0LmtleXMoYXhpc01hcCk7XG4gIHJldHVybiBpZHMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGlkKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTWFwW2lkXTtcbiAgICB2YXIgZG9tYWluID0gYXhpcy5kb21haW4sXG4gICAgICByZXZlcnNlZCA9IGF4aXMucmV2ZXJzZWQ7XG4gICAgdmFyIHJhbmdlO1xuICAgIGlmICgoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkoYXhpcy5yYW5nZSkpIHtcbiAgICAgIGlmIChheGlzVHlwZSA9PT0gJ2FuZ2xlQXhpcycpIHtcbiAgICAgICAgcmFuZ2UgPSBbc3RhcnRBbmdsZSwgZW5kQW5nbGVdO1xuICAgICAgfSBlbHNlIGlmIChheGlzVHlwZSA9PT0gJ3JhZGl1c0F4aXMnKSB7XG4gICAgICAgIHJhbmdlID0gW2lubmVyUmFkaXVzLCBvdXRlclJhZGl1c107XG4gICAgICB9XG4gICAgICBpZiAocmV2ZXJzZWQpIHtcbiAgICAgICAgcmFuZ2UgPSBbcmFuZ2VbMV0sIHJhbmdlWzBdXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UgPSBheGlzLnJhbmdlO1xuICAgICAgdmFyIF9yYW5nZSA9IHJhbmdlO1xuICAgICAgdmFyIF9yYW5nZTIgPSBfc2xpY2VkVG9BcnJheShfcmFuZ2UsIDIpO1xuICAgICAgc3RhcnRBbmdsZSA9IF9yYW5nZTJbMF07XG4gICAgICBlbmRBbmdsZSA9IF9yYW5nZTJbMV07XG4gICAgfVxuICAgIHZhciBfcGFyc2VTY2FsZSA9ICgwLCBfQ2hhcnRVdGlscy5wYXJzZVNjYWxlKShheGlzLCBjaGFydE5hbWUpLFxuICAgICAgcmVhbFNjYWxlVHlwZSA9IF9wYXJzZVNjYWxlLnJlYWxTY2FsZVR5cGUsXG4gICAgICBzY2FsZSA9IF9wYXJzZVNjYWxlLnNjYWxlO1xuICAgIHNjYWxlLmRvbWFpbihkb21haW4pLnJhbmdlKHJhbmdlKTtcbiAgICAoMCwgX0NoYXJ0VXRpbHMuY2hlY2tEb21haW5PZlNjYWxlKShzY2FsZSk7XG4gICAgdmFyIHRpY2tzID0gKDAsIF9DaGFydFV0aWxzLmdldFRpY2tzT2ZTY2FsZSkoc2NhbGUsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYXhpcyksIHt9LCB7XG4gICAgICByZWFsU2NhbGVUeXBlOiByZWFsU2NhbGVUeXBlXG4gICAgfSkpO1xuICAgIHZhciBmaW5hbEF4aXMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYXhpcyksIHRpY2tzKSwge30sIHtcbiAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgIHJhZGl1czogb3V0ZXJSYWRpdXMsXG4gICAgICByZWFsU2NhbGVUeXBlOiByZWFsU2NhbGVUeXBlLFxuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgY3g6IGN4LFxuICAgICAgY3k6IGN5LFxuICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxuICAgIH0pO1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGlkLCBmaW5hbEF4aXMpKTtcbiAgfSwge30pO1xufTtcbnZhciBkaXN0YW5jZUJldHdlZW5Qb2ludHMgPSBleHBvcnRzLmRpc3RhbmNlQmV0d2VlblBvaW50cyA9IGZ1bmN0aW9uIGRpc3RhbmNlQmV0d2VlblBvaW50cyhwb2ludCwgYW5vdGhlclBvaW50KSB7XG4gIHZhciB4MSA9IHBvaW50LngsXG4gICAgeTEgPSBwb2ludC55O1xuICB2YXIgeDIgPSBhbm90aGVyUG9pbnQueCxcbiAgICB5MiA9IGFub3RoZXJQb2ludC55O1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDIsIDIpICsgTWF0aC5wb3coeTEgLSB5MiwgMikpO1xufTtcbnZhciBnZXRBbmdsZU9mUG9pbnQgPSBleHBvcnRzLmdldEFuZ2xlT2ZQb2ludCA9IGZ1bmN0aW9uIGdldEFuZ2xlT2ZQb2ludChfcmVmLCBfcmVmMikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICB5ID0gX3JlZi55O1xuICB2YXIgY3ggPSBfcmVmMi5jeCxcbiAgICBjeSA9IF9yZWYyLmN5O1xuICB2YXIgcmFkaXVzID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSwge1xuICAgIHg6IGN4LFxuICAgIHk6IGN5XG4gIH0pO1xuICBpZiAocmFkaXVzIDw9IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmFkaXVzOiByYWRpdXNcbiAgICB9O1xuICB9XG4gIHZhciBjb3MgPSAoeCAtIGN4KSAvIHJhZGl1cztcbiAgdmFyIGFuZ2xlSW5SYWRpYW4gPSBNYXRoLmFjb3MoY29zKTtcbiAgaWYgKHkgPiBjeSkge1xuICAgIGFuZ2xlSW5SYWRpYW4gPSAyICogTWF0aC5QSSAtIGFuZ2xlSW5SYWRpYW47XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBhbmdsZTogcmFkaWFuVG9EZWdyZWUoYW5nbGVJblJhZGlhbiksXG4gICAgYW5nbGVJblJhZGlhbjogYW5nbGVJblJhZGlhblxuICB9O1xufTtcbnZhciBmb3JtYXRBbmdsZU9mU2VjdG9yID0gZXhwb3J0cy5mb3JtYXRBbmdsZU9mU2VjdG9yID0gZnVuY3Rpb24gZm9ybWF0QW5nbGVPZlNlY3RvcihfcmVmMykge1xuICB2YXIgc3RhcnRBbmdsZSA9IF9yZWYzLnN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGUgPSBfcmVmMy5lbmRBbmdsZTtcbiAgdmFyIHN0YXJ0Q250ID0gTWF0aC5mbG9vcihzdGFydEFuZ2xlIC8gMzYwKTtcbiAgdmFyIGVuZENudCA9IE1hdGguZmxvb3IoZW5kQW5nbGUgLyAzNjApO1xuICB2YXIgbWluID0gTWF0aC5taW4oc3RhcnRDbnQsIGVuZENudCk7XG4gIHJldHVybiB7XG4gICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSAtIG1pbiAqIDM2MCxcbiAgICBlbmRBbmdsZTogZW5kQW5nbGUgLSBtaW4gKiAzNjBcbiAgfTtcbn07XG52YXIgcmV2ZXJzZUZvcm1hdEFuZ2xlT2ZTZXRvciA9IGZ1bmN0aW9uIHJldmVyc2VGb3JtYXRBbmdsZU9mU2V0b3IoYW5nbGUsIF9yZWY0KSB7XG4gIHZhciBzdGFydEFuZ2xlID0gX3JlZjQuc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZSA9IF9yZWY0LmVuZEFuZ2xlO1xuICB2YXIgc3RhcnRDbnQgPSBNYXRoLmZsb29yKHN0YXJ0QW5nbGUgLyAzNjApO1xuICB2YXIgZW5kQ250ID0gTWF0aC5mbG9vcihlbmRBbmdsZSAvIDM2MCk7XG4gIHZhciBtaW4gPSBNYXRoLm1pbihzdGFydENudCwgZW5kQ250KTtcbiAgcmV0dXJuIGFuZ2xlICsgbWluICogMzYwO1xufTtcbnZhciBpblJhbmdlT2ZTZWN0b3IgPSBleHBvcnRzLmluUmFuZ2VPZlNlY3RvciA9IGZ1bmN0aW9uIGluUmFuZ2VPZlNlY3RvcihfcmVmNSwgc2VjdG9yKSB7XG4gIHZhciB4ID0gX3JlZjUueCxcbiAgICB5ID0gX3JlZjUueTtcbiAgdmFyIF9nZXRBbmdsZU9mUG9pbnQgPSBnZXRBbmdsZU9mUG9pbnQoe1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9LCBzZWN0b3IpLFxuICAgIHJhZGl1cyA9IF9nZXRBbmdsZU9mUG9pbnQucmFkaXVzLFxuICAgIGFuZ2xlID0gX2dldEFuZ2xlT2ZQb2ludC5hbmdsZTtcbiAgdmFyIGlubmVyUmFkaXVzID0gc2VjdG9yLmlubmVyUmFkaXVzLFxuICAgIG91dGVyUmFkaXVzID0gc2VjdG9yLm91dGVyUmFkaXVzO1xuICBpZiAocmFkaXVzIDwgaW5uZXJSYWRpdXMgfHwgcmFkaXVzID4gb3V0ZXJSYWRpdXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHJhZGl1cyA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBfZm9ybWF0QW5nbGVPZlNlY3RvciA9IGZvcm1hdEFuZ2xlT2ZTZWN0b3Ioc2VjdG9yKSxcbiAgICBzdGFydEFuZ2xlID0gX2Zvcm1hdEFuZ2xlT2ZTZWN0b3Iuc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZSA9IF9mb3JtYXRBbmdsZU9mU2VjdG9yLmVuZEFuZ2xlO1xuICB2YXIgZm9ybWF0QW5nbGUgPSBhbmdsZTtcbiAgdmFyIGluUmFuZ2U7XG4gIGlmIChzdGFydEFuZ2xlIDw9IGVuZEFuZ2xlKSB7XG4gICAgd2hpbGUgKGZvcm1hdEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgIGZvcm1hdEFuZ2xlIC09IDM2MDtcbiAgICB9XG4gICAgd2hpbGUgKGZvcm1hdEFuZ2xlIDwgc3RhcnRBbmdsZSkge1xuICAgICAgZm9ybWF0QW5nbGUgKz0gMzYwO1xuICAgIH1cbiAgICBpblJhbmdlID0gZm9ybWF0QW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBmb3JtYXRBbmdsZSA8PSBlbmRBbmdsZTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoZm9ybWF0QW5nbGUgPiBzdGFydEFuZ2xlKSB7XG4gICAgICBmb3JtYXRBbmdsZSAtPSAzNjA7XG4gICAgfVxuICAgIHdoaWxlIChmb3JtYXRBbmdsZSA8IGVuZEFuZ2xlKSB7XG4gICAgICBmb3JtYXRBbmdsZSArPSAzNjA7XG4gICAgfVxuICAgIGluUmFuZ2UgPSBmb3JtYXRBbmdsZSA+PSBlbmRBbmdsZSAmJiBmb3JtYXRBbmdsZSA8PSBzdGFydEFuZ2xlO1xuICB9XG4gIGlmIChpblJhbmdlKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc2VjdG9yKSwge30sIHtcbiAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgYW5nbGU6IHJldmVyc2VGb3JtYXRBbmdsZU9mU2V0b3IoZm9ybWF0QW5nbGUsIHNlY3RvcilcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG52YXIgZ2V0VGlja0NsYXNzTmFtZSA9IGV4cG9ydHMuZ2V0VGlja0NsYXNzTmFtZSA9IGZ1bmN0aW9uIGdldFRpY2tDbGFzc05hbWUodGljaykge1xuICByZXR1cm4gISAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5pc1ZhbGlkRWxlbWVudCkodGljaykgJiYgISgwLCBfaXNGdW5jdGlvbltcImRlZmF1bHRcIl0pKHRpY2spICYmIHR5cGVvZiB0aWNrICE9PSAnYm9vbGVhbicgPyB0aWNrLmNsYXNzTmFtZSA6ICcnO1xufTsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyYWRpYW5Ub0RlZ3JlZSIsInBvbGFyVG9DYXJ0ZXNpYW4iLCJpblJhbmdlT2ZTZWN0b3IiLCJnZXRUaWNrQ2xhc3NOYW1lIiwiZ2V0TWF4UmFkaXVzIiwiZ2V0QW5nbGVPZlBvaW50IiwiZm9ybWF0QXhpc01hcCIsImZvcm1hdEFuZ2xlT2ZTZWN0b3IiLCJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCJkZWdyZWVUb1JhZGlhbiIsIlJBRElBTiIsIl9pc05pbCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiX2lzRnVuY3Rpb24iLCJfRGF0YVV0aWxzIiwiX0NoYXJ0VXRpbHMiLCJvYmoiLCJfX2VzTW9kdWxlIiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImtleSIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJpIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibGVuIiwiYXJyMiIsImwiLCJ1IiwiYSIsImYiLCJuZXh0IiwiZG9uZSIsImlzQXJyYXkiLCJNYXRoIiwiUEkiLCJhbmdsZSIsImFuZ2xlSW5SYWRpYW4iLCJjeCIsImN5IiwicmFkaXVzIiwieCIsImNvcyIsInkiLCJzaW4iLCJ3aWR0aCIsImhlaWdodCIsIm9mZnNldCIsInVuZGVmaW5lZCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsIm1pbiIsImFicyIsInByb3BzIiwiYXhpc01hcCIsImF4aXNUeXBlIiwiY2hhcnROYW1lIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiZ2V0UGVyY2VudFZhbHVlIiwibWF4UmFkaXVzIiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsImlkcyIsInJlZHVjZSIsInJlc3VsdCIsImlkIiwiYXhpcyIsImRvbWFpbiIsInJldmVyc2VkIiwicmFuZ2UiLCJfcmFuZ2UiLCJfcmFuZ2UyIiwiX3BhcnNlU2NhbGUiLCJwYXJzZVNjYWxlIiwicmVhbFNjYWxlVHlwZSIsInNjYWxlIiwiY2hlY2tEb21haW5PZlNjYWxlIiwidGlja3MiLCJnZXRUaWNrc09mU2NhbGUiLCJmaW5hbEF4aXMiLCJwb2ludCIsImFub3RoZXJQb2ludCIsIngxIiwieTEiLCJ4MiIsInkyIiwic3FydCIsInBvdyIsIl9yZWYiLCJfcmVmMiIsImFjb3MiLCJfcmVmMyIsInN0YXJ0Q250IiwiZmxvb3IiLCJlbmRDbnQiLCJyZXZlcnNlRm9ybWF0QW5nbGVPZlNldG9yIiwiX3JlZjQiLCJfcmVmNSIsInNlY3RvciIsIl9nZXRBbmdsZU9mUG9pbnQiLCJfZm9ybWF0QW5nbGVPZlNlY3RvciIsImZvcm1hdEFuZ2xlIiwiaW5SYW5nZSIsInRpY2siLCJpc1ZhbGlkRWxlbWVudCIsImNsYXNzTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/PolarUtils.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/RadialBarUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/recharts/lib/util/RadialBarUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RadialBarSector = RadialBarSector;\nexports.parseCornerRadius = parseCornerRadius;\nexports.typeGuardSectorProps = typeGuardSectorProps;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _ActiveShapeUtils = __webpack_require__(/*! ./ActiveShapeUtils */ \"./node_modules/recharts/lib/util/ActiveShapeUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction parseCornerRadius(cornerRadius) {\n    if (typeof cornerRadius === \"string\") {\n        return parseInt(cornerRadius, 10);\n    }\n    return cornerRadius;\n}\n// Sector props is expecting cx, cy as numbers.\n// When props are being spread in from a user defined component in RadialBar,\n// the prop types of an SVGElement have these typed as string | number.\n// This function will return the passed in props along with cx, cy as numbers.\nfunction typeGuardSectorProps(option, props) {\n    var cxValue = \"\".concat(props.cx || option.cx);\n    var cx = Number(cxValue);\n    var cyValue = \"\".concat(props.cy || option.cy);\n    var cy = Number(cyValue);\n    return _objectSpread(_objectSpread(_objectSpread({}, props), option), {}, {\n        cx: cx,\n        cy: cy\n    });\n}\nfunction RadialBarSector(props) {\n    return /*#__PURE__*/ _react[\"default\"].createElement(_ActiveShapeUtils.Shape, _extends({\n        shapeType: \"sector\",\n        propTransformer: typeGuardSectorProps\n    }, props));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvUmFkaWFsQmFyVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHVCQUF1QixHQUFHRTtBQUMxQkYseUJBQXlCLEdBQUdHO0FBQzVCSCw0QkFBNEIsR0FBR0k7QUFDL0IsSUFBSUMsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxvQkFBb0JELG1CQUFPQSxDQUFDLGdGQUFvQjtBQUNwRCxTQUFTRCx1QkFBdUJHLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0UsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLO0lBQWFBLFdBQVduQixPQUFPb0IsTUFBTSxHQUFHcEIsT0FBT29CLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQUUsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQUUsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUFFLElBQUkxQixPQUFPa0IsU0FBUyxDQUFDVSxjQUFjLENBQUNDLElBQUksQ0FBQ0gsUUFBUUMsTUFBTTtvQkFBRUwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0s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QUFPSztJQUNoQixJQUFJRyxVQUFVLEdBQUdGLE1BQU0sQ0FBQ0YsTUFBTUssRUFBRSxJQUFJTixPQUFPTSxFQUFFO0lBQzdDLElBQUlBLEtBQUtULE9BQU9RO0lBQ2hCLE9BQU9wQixjQUFjQSxjQUFjQSxjQUFjLENBQUMsR0FBR2dCLFFBQVFELFNBQVMsQ0FBQyxHQUFHO1FBQ3hFSSxJQUFJQTtRQUNKRSxJQUFJQTtJQUNOO0FBQ0Y7QUFDQSxTQUFTMUQsZ0JBQWdCcUQsS0FBSztJQUM1QixPQUFPLFdBQVcsR0FBRWxELE1BQU0sQ0FBQyxVQUFVLENBQUN3RCxhQUFhLENBQUNyRCxrQkFBa0JzRCxLQUFLLEVBQUU3QyxTQUFTO1FBQ3BGOEMsV0FBVztRQUNYQyxpQkFBaUI1RDtJQUNuQixHQUFHbUQ7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9SYWRpYWxCYXJVdGlscy5qcz82OTMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5SYWRpYWxCYXJTZWN0b3IgPSBSYWRpYWxCYXJTZWN0b3I7XG5leHBvcnRzLnBhcnNlQ29ybmVyUmFkaXVzID0gcGFyc2VDb3JuZXJSYWRpdXM7XG5leHBvcnRzLnR5cGVHdWFyZFNlY3RvclByb3BzID0gdHlwZUd1YXJkU2VjdG9yUHJvcHM7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9BY3RpdmVTaGFwZVV0aWxzID0gcmVxdWlyZShcIi4vQWN0aXZlU2hhcGVVdGlsc1wiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gcGFyc2VDb3JuZXJSYWRpdXMoY29ybmVyUmFkaXVzKSB7XG4gIGlmICh0eXBlb2YgY29ybmVyUmFkaXVzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZUludChjb3JuZXJSYWRpdXMsIDEwKTtcbiAgfVxuICByZXR1cm4gY29ybmVyUmFkaXVzO1xufVxuXG4vLyBTZWN0b3IgcHJvcHMgaXMgZXhwZWN0aW5nIGN4LCBjeSBhcyBudW1iZXJzLlxuLy8gV2hlbiBwcm9wcyBhcmUgYmVpbmcgc3ByZWFkIGluIGZyb20gYSB1c2VyIGRlZmluZWQgY29tcG9uZW50IGluIFJhZGlhbEJhcixcbi8vIHRoZSBwcm9wIHR5cGVzIG9mIGFuIFNWR0VsZW1lbnQgaGF2ZSB0aGVzZSB0eXBlZCBhcyBzdHJpbmcgfCBudW1iZXIuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBwYXNzZWQgaW4gcHJvcHMgYWxvbmcgd2l0aCBjeCwgY3kgYXMgbnVtYmVycy5cbmZ1bmN0aW9uIHR5cGVHdWFyZFNlY3RvclByb3BzKG9wdGlvbiwgcHJvcHMpIHtcbiAgdmFyIGN4VmFsdWUgPSBcIlwiLmNvbmNhdChwcm9wcy5jeCB8fCBvcHRpb24uY3gpO1xuICB2YXIgY3ggPSBOdW1iZXIoY3hWYWx1ZSk7XG4gIHZhciBjeVZhbHVlID0gXCJcIi5jb25jYXQocHJvcHMuY3kgfHwgb3B0aW9uLmN5KTtcbiAgdmFyIGN5ID0gTnVtYmVyKGN5VmFsdWUpO1xuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwgb3B0aW9uKSwge30sIHtcbiAgICBjeDogY3gsXG4gICAgY3k6IGN5XG4gIH0pO1xufVxuZnVuY3Rpb24gUmFkaWFsQmFyU2VjdG9yKHByb3BzKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9BY3RpdmVTaGFwZVV0aWxzLlNoYXBlLCBfZXh0ZW5kcyh7XG4gICAgc2hhcGVUeXBlOiBcInNlY3RvclwiLFxuICAgIHByb3BUcmFuc2Zvcm1lcjogdHlwZUd1YXJkU2VjdG9yUHJvcHNcbiAgfSwgcHJvcHMpKTtcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSYWRpYWxCYXJTZWN0b3IiLCJwYXJzZUNvcm5lclJhZGl1cyIsInR5cGVHdWFyZFNlY3RvclByb3BzIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfQWN0aXZlU2hhcGVVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJvd25LZXlzIiwiZSIsInIiLCJ0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsImNvcm5lclJhZGl1cyIsInBhcnNlSW50Iiwib3B0aW9uIiwicHJvcHMiLCJjeFZhbHVlIiwiY29uY2F0IiwiY3giLCJjeVZhbHVlIiwiY3kiLCJjcmVhdGVFbGVtZW50IiwiU2hhcGUiLCJzaGFwZVR5cGUiLCJwcm9wVHJhbnNmb3JtZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/RadialBarUtils.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/ReactUtils.js":
/*!******************************************************!*\
  !*** ./node_modules/recharts/lib/util/ReactUtils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.filterSvgElements = exports.filterProps = exports.TOOLTIP_TYPES = exports.SCALE_TYPES = exports.LEGEND_TYPES = void 0;\nexports.findAllByType = findAllByType;\nexports.findChildByType = findChildByType;\nexports.withoutType = exports.validateWidthHeight = exports.toArray = exports.renderByOrder = exports.parseChildIndex = exports.isValidSpreadableProp = exports.isSingleChildEqual = exports.isChildrenEqual = exports.hasClipDot = exports.getReactEventByType = exports.getDisplayName = void 0;\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"lodash/get\"));\nvar _isNil = _interopRequireDefault(__webpack_require__(/*! lodash/isNil */ \"lodash/isNil\"));\nvar _isString = _interopRequireDefault(__webpack_require__(/*! lodash/isString */ \"lodash/isString\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nvar _isObject = _interopRequireDefault(__webpack_require__(/*! lodash/isObject */ \"lodash/isObject\"));\nvar _react = __webpack_require__(/*! react */ \"react\");\nvar _reactIs = __webpack_require__(/*! react-is */ \"react-is\");\nvar _DataUtils = __webpack_require__(/*! ./DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nvar _ShallowEqual = __webpack_require__(/*! ./ShallowEqual */ \"./node_modules/recharts/lib/util/ShallowEqual.js\");\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/recharts/lib/util/types.js\");\nvar _excluded = [\n    \"children\"\n], _excluded2 = [\n    \"children\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nvar REACT_BROWSER_EVENT_MAP = {\n    click: \"onClick\",\n    mousedown: \"onMouseDown\",\n    mouseup: \"onMouseUp\",\n    mouseover: \"onMouseOver\",\n    mousemove: \"onMouseMove\",\n    mouseout: \"onMouseOut\",\n    mouseenter: \"onMouseEnter\",\n    mouseleave: \"onMouseLeave\",\n    touchcancel: \"onTouchCancel\",\n    touchend: \"onTouchEnd\",\n    touchmove: \"onTouchMove\",\n    touchstart: \"onTouchStart\",\n    contextmenu: \"onContextMenu\",\n    dblclick: \"onDoubleClick\"\n};\nvar SCALE_TYPES = exports.SCALE_TYPES = [\n    \"auto\",\n    \"linear\",\n    \"pow\",\n    \"sqrt\",\n    \"log\",\n    \"identity\",\n    \"time\",\n    \"band\",\n    \"point\",\n    \"ordinal\",\n    \"quantile\",\n    \"quantize\",\n    \"utc\",\n    \"sequential\",\n    \"threshold\"\n];\nvar LEGEND_TYPES = exports.LEGEND_TYPES = [\n    \"plainline\",\n    \"line\",\n    \"square\",\n    \"rect\",\n    \"circle\",\n    \"cross\",\n    \"diamond\",\n    \"star\",\n    \"triangle\",\n    \"wye\",\n    \"none\"\n];\nvar TOOLTIP_TYPES = exports.TOOLTIP_TYPES = [\n    \"none\"\n];\n/**\n * Get the display name of a component\n * @param  {Object} Comp Specified Component\n * @return {String}      Display name of Component\n */ var getDisplayName = exports.getDisplayName = function getDisplayName(Comp) {\n    if (typeof Comp === \"string\") {\n        return Comp;\n    }\n    if (!Comp) {\n        return \"\";\n    }\n    return Comp.displayName || Comp.name || \"Component\";\n};\n// `toArray` gets called multiple times during the render\n// so we can memoize last invocation (since reference to `children` is the same)\nvar lastChildren = null;\nvar lastResult = null;\nvar toArray = exports.toArray = function toArray(children) {\n    if (children === lastChildren && Array.isArray(lastResult)) {\n        return lastResult;\n    }\n    var result = [];\n    _react.Children.forEach(children, function(child) {\n        if ((0, _isNil[\"default\"])(child)) return;\n        if ((0, _reactIs.isFragment)(child)) {\n            result = result.concat(toArray(child.props.children));\n        } else {\n            // @ts-expect-error this could still be Iterable<ReactNode> and TS does not like that\n            result.push(child);\n        }\n    });\n    lastResult = result;\n    lastChildren = children;\n    return result;\n};\n/*\n * Find and return all matched children by type.\n * `type` must be a React.ComponentType\n */ function findAllByType(children, type) {\n    var result = [];\n    var types = [];\n    if (Array.isArray(type)) {\n        types = type.map(function(t) {\n            return getDisplayName(t);\n        });\n    } else {\n        types = [\n            getDisplayName(type)\n        ];\n    }\n    toArray(children).forEach(function(child) {\n        var childType = (0, _get[\"default\"])(child, \"type.displayName\") || (0, _get[\"default\"])(child, \"type.name\");\n        if (types.indexOf(childType) !== -1) {\n            result.push(child);\n        }\n    });\n    return result;\n}\n/*\n * Return the first matched child by type, return null otherwise.\n * `type` must be a React.ComponentType\n */ function findChildByType(children, type) {\n    var result = findAllByType(children, type);\n    return result && result[0];\n}\n/*\n * Create a new array of children excluding the ones matched the type\n */ var withoutType = exports.withoutType = function withoutType(children, type) {\n    var newChildren = [];\n    var types;\n    if (Array.isArray(type)) {\n        types = type.map(function(t) {\n            return getDisplayName(t);\n        });\n    } else {\n        types = [\n            getDisplayName(type)\n        ];\n    }\n    toArray(children).forEach(function(child) {\n        var displayName = (0, _get[\"default\"])(child, \"type.displayName\");\n        if (displayName && types.indexOf(displayName) !== -1) {\n            return;\n        }\n        newChildren.push(child);\n    });\n    return newChildren;\n};\n/**\n * validate the width and height props of a chart element\n * @param  {Object} el A chart element\n * @return {Boolean}   true If the props width and height are number, and greater than 0\n */ var validateWidthHeight = exports.validateWidthHeight = function validateWidthHeight(el) {\n    if (!el || !el.props) {\n        return false;\n    }\n    var _el$props = el.props, width = _el$props.width, height = _el$props.height;\n    if (!(0, _DataUtils.isNumber)(width) || width <= 0 || !(0, _DataUtils.isNumber)(height) || height <= 0) {\n        return false;\n    }\n    return true;\n};\nvar SVG_TAGS = [\n    \"a\",\n    \"altGlyph\",\n    \"altGlyphDef\",\n    \"altGlyphItem\",\n    \"animate\",\n    \"animateColor\",\n    \"animateMotion\",\n    \"animateTransform\",\n    \"circle\",\n    \"clipPath\",\n    \"color-profile\",\n    \"cursor\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"feBlend\",\n    \"feColormatrix\",\n    \"feComponentTransfer\",\n    \"feComposite\",\n    \"feConvolveMatrix\",\n    \"feDiffuseLighting\",\n    \"feDisplacementMap\",\n    \"feDistantLight\",\n    \"feFlood\",\n    \"feFuncA\",\n    \"feFuncB\",\n    \"feFuncG\",\n    \"feFuncR\",\n    \"feGaussianBlur\",\n    \"feImage\",\n    \"feMerge\",\n    \"feMergeNode\",\n    \"feMorphology\",\n    \"feOffset\",\n    \"fePointLight\",\n    \"feSpecularLighting\",\n    \"feSpotLight\",\n    \"feTile\",\n    \"feTurbulence\",\n    \"filter\",\n    \"font\",\n    \"font-face\",\n    \"font-face-format\",\n    \"font-face-name\",\n    \"font-face-url\",\n    \"foreignObject\",\n    \"g\",\n    \"glyph\",\n    \"glyphRef\",\n    \"hkern\",\n    \"image\",\n    \"line\",\n    \"lineGradient\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"missing-glyph\",\n    \"mpath\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialGradient\",\n    \"rect\",\n    \"script\",\n    \"set\",\n    \"stop\",\n    \"style\",\n    \"svg\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"textPath\",\n    \"title\",\n    \"tref\",\n    \"tspan\",\n    \"use\",\n    \"view\",\n    \"vkern\"\n];\nvar isSvgElement = function isSvgElement(child) {\n    return child && child.type && (0, _isString[\"default\"])(child.type) && SVG_TAGS.indexOf(child.type) >= 0;\n};\nvar hasClipDot = exports.hasClipDot = function hasClipDot(dot) {\n    return dot && _typeof(dot) === \"object\" && \"clipDot\" in dot;\n};\n/**\n * Checks if the property is valid to spread onto an SVG element or onto a specific component\n * @param {unknown} property property value currently being compared\n * @param {string} key property key currently being compared\n * @param {boolean} includeEvents if events are included in spreadable props\n * @param {boolean} svgElementType checks against map of SVG element types to attributes\n * @returns {boolean} is prop valid\n */ var isValidSpreadableProp = exports.isValidSpreadableProp = function isValidSpreadableProp(property, key, includeEvents, svgElementType) {\n    var _FilteredElementKeyMa;\n    /**\n   * If the svg element type is explicitly included, check against the filtered element key map\n   * to determine if there are attributes that should only exist on that element type.\n   * @todo Add an internal cjs version of https://github.com/wooorm/svg-element-attributes for full coverage.\n   */ var matchingElementTypeKeys = (_FilteredElementKeyMa = _types.FilteredElementKeyMap === null || _types.FilteredElementKeyMap === void 0 ? void 0 : _types.FilteredElementKeyMap[svgElementType]) !== null && _FilteredElementKeyMa !== void 0 ? _FilteredElementKeyMa : [];\n    return !(0, _isFunction[\"default\"])(property) && (svgElementType && matchingElementTypeKeys.includes(key) || _types.SVGElementPropKeys.includes(key)) || includeEvents && _types.EventKeys.includes(key);\n};\n/**\n * Filter all the svg elements of children\n * @param  {Array} children The children of a react element\n * @return {Array}          All the svg elements\n */ var filterSvgElements = exports.filterSvgElements = function filterSvgElements(children) {\n    var svgElements = [];\n    toArray(children).forEach(function(entry) {\n        if (isSvgElement(entry)) {\n            svgElements.push(entry);\n        }\n    });\n    return svgElements;\n};\nvar filterProps = exports.filterProps = function filterProps(props, includeEvents, svgElementType) {\n    if (!props || typeof props === \"function\" || typeof props === \"boolean\") {\n        return null;\n    }\n    var inputProps = props;\n    if (/*#__PURE__*/ (0, _react.isValidElement)(props)) {\n        inputProps = props.props;\n    }\n    if (!(0, _isObject[\"default\"])(inputProps)) {\n        return null;\n    }\n    var out = {};\n    /**\n   * Props are blindly spread onto SVG elements. This loop filters out properties that we don't want to spread.\n   * Items filtered out are as follows:\n   *   - functions in properties that are SVG attributes (functions are included when includeEvents is true)\n   *   - props that are SVG attributes but don't matched the passed svgElementType\n   *   - any prop that is not in SVGElementPropKeys (or in EventKeys if includeEvents is true)\n   */ Object.keys(inputProps).forEach(function(key) {\n        var _inputProps;\n        if (isValidSpreadableProp((_inputProps = inputProps) === null || _inputProps === void 0 ? void 0 : _inputProps[key], key, includeEvents, svgElementType)) {\n            out[key] = inputProps[key];\n        }\n    });\n    return out;\n};\n/**\n * Wether props of children changed\n * @param  {Object} nextChildren The latest children\n * @param  {Object} prevChildren The prev children\n * @return {Boolean}             equal or not\n */ var isChildrenEqual = exports.isChildrenEqual = function isChildrenEqual(nextChildren, prevChildren) {\n    if (nextChildren === prevChildren) {\n        return true;\n    }\n    var count = _react.Children.count(nextChildren);\n    if (count !== _react.Children.count(prevChildren)) {\n        return false;\n    }\n    if (count === 0) {\n        return true;\n    }\n    if (count === 1) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return isSingleChildEqual(Array.isArray(nextChildren) ? nextChildren[0] : nextChildren, Array.isArray(prevChildren) ? prevChildren[0] : prevChildren);\n    }\n    for(var i = 0; i < count; i++){\n        var nextChild = nextChildren[i];\n        var prevChild = prevChildren[i];\n        if (Array.isArray(nextChild) || Array.isArray(prevChild)) {\n            if (!isChildrenEqual(nextChild, prevChild)) {\n                return false;\n            }\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        } else if (!isSingleChildEqual(nextChild, prevChild)) {\n            return false;\n        }\n    }\n    return true;\n};\nvar isSingleChildEqual = exports.isSingleChildEqual = function isSingleChildEqual(nextChild, prevChild) {\n    if ((0, _isNil[\"default\"])(nextChild) && (0, _isNil[\"default\"])(prevChild)) {\n        return true;\n    }\n    if (!(0, _isNil[\"default\"])(nextChild) && !(0, _isNil[\"default\"])(prevChild)) {\n        var _ref = nextChild.props || {}, nextChildren = _ref.children, nextProps = _objectWithoutProperties(_ref, _excluded);\n        var _ref2 = prevChild.props || {}, prevChildren = _ref2.children, prevProps = _objectWithoutProperties(_ref2, _excluded2);\n        if (nextChildren && prevChildren) {\n            return (0, _ShallowEqual.shallowEqual)(nextProps, prevProps) && isChildrenEqual(nextChildren, prevChildren);\n        }\n        if (!nextChildren && !prevChildren) {\n            return (0, _ShallowEqual.shallowEqual)(nextProps, prevProps);\n        }\n        return false;\n    }\n    return false;\n};\nvar renderByOrder = exports.renderByOrder = function renderByOrder(children, renderMap) {\n    var elements = [];\n    var record = {};\n    toArray(children).forEach(function(child, index) {\n        if (isSvgElement(child)) {\n            elements.push(child);\n        } else if (child) {\n            var displayName = getDisplayName(child.type);\n            var _ref3 = renderMap[displayName] || {}, handler = _ref3.handler, once = _ref3.once;\n            if (handler && (!once || !record[displayName])) {\n                var results = handler(child, displayName, index);\n                elements.push(results);\n                record[displayName] = true;\n            }\n        }\n    });\n    return elements;\n};\nvar getReactEventByType = exports.getReactEventByType = function getReactEventByType(e) {\n    var type = e && e.type;\n    if (type && REACT_BROWSER_EVENT_MAP[type]) {\n        return REACT_BROWSER_EVENT_MAP[type];\n    }\n    return null;\n};\nvar parseChildIndex = exports.parseChildIndex = function parseChildIndex(child, children) {\n    return toArray(children).indexOf(child);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvUmVhY3RVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQseUJBQXlCLEdBQUdBLG1CQUFtQixHQUFHQSxxQkFBcUIsR0FBR0EsbUJBQW1CLEdBQUdBLG9CQUFvQixHQUFHLEtBQUs7QUFDNUhBLHFCQUFxQixHQUFHTztBQUN4QlAsdUJBQXVCLEdBQUdRO0FBQzFCUixtQkFBbUIsR0FBR0EsMkJBQTJCLEdBQUdBLGVBQWUsR0FBR0EscUJBQXFCLEdBQUdBLHVCQUF1QixHQUFHQSw2QkFBNkIsR0FBR0EsMEJBQTBCLEdBQUdBLHVCQUF1QixHQUFHQSxrQkFBa0IsR0FBR0EsMkJBQTJCLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDaFMsSUFBSW9CLE9BQU9DLHVCQUF1QkMsbUJBQU9BLENBQUMsOEJBQVk7QUFDdEQsSUFBSUMsU0FBU0YsdUJBQXVCQyxtQkFBT0EsQ0FBQyxrQ0FBYztBQUMxRCxJQUFJRSxZQUFZSCx1QkFBdUJDLG1CQUFPQSxDQUFDLHdDQUFpQjtBQUNoRSxJQUFJRyxjQUFjSix1QkFBdUJDLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUNwRSxJQUFJSSxZQUFZTCx1QkFBdUJDLG1CQUFPQSxDQUFDLHdDQUFpQjtBQUNoRSxJQUFJSyxTQUFTTCxtQkFBT0EsQ0FBQyxvQkFBTztBQUM1QixJQUFJTSxXQUFXTixtQkFBT0EsQ0FBQywwQkFBVTtBQUNqQyxJQUFJTyxhQUFhUCxtQkFBT0EsQ0FBQyxrRUFBYTtBQUN0QyxJQUFJUSxnQkFBZ0JSLG1CQUFPQSxDQUFDLHdFQUFnQjtBQUM1QyxJQUFJUyxTQUFTVCxtQkFBT0EsQ0FBQywwREFBUztBQUM5QixJQUFJVSxZQUFZO0lBQUM7Q0FBVyxFQUMxQkMsYUFBYTtJQUFDO0NBQVc7QUFDM0IsU0FBU1osdUJBQXVCYSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFB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QixJQUFJVixjQUFjckQsZUFBZStELE1BQU1LLElBQUk7WUFDM0MsSUFBSTRDLFFBQVFKLFNBQVMsQ0FBQ3ZELFlBQVksSUFBSSxDQUFDLEdBQ3JDNEQsVUFBVUQsTUFBTUMsT0FBTyxFQUN2QkMsT0FBT0YsTUFBTUUsSUFBSTtZQUNuQixJQUFJRCxXQUFZLEVBQUNDLFFBQVEsQ0FBQ0osTUFBTSxDQUFDekQsWUFBWSxHQUFHO2dCQUM5QyxJQUFJOEQsVUFBVUYsUUFBUWxELE9BQU9WLGFBQWEwRDtnQkFDMUNGLFNBQVMxQyxJQUFJLENBQUNnRDtnQkFDZEwsTUFBTSxDQUFDekQsWUFBWSxHQUFHO1lBQ3hCO1FBQ0Y7SUFDRjtJQUNBLE9BQU93RDtBQUNUO0FBQ0EsSUFBSTlHLHNCQUFzQmxCLDJCQUEyQixHQUFHLFNBQVNrQixvQkFBb0JxSCxDQUFDO0lBQ3BGLElBQUloRCxPQUFPZ0QsS0FBS0EsRUFBRWhELElBQUk7SUFDdEIsSUFBSUEsUUFBUS9CLHVCQUF1QixDQUFDK0IsS0FBSyxFQUFFO1FBQ3pDLE9BQU8vQix1QkFBdUIsQ0FBQytCLEtBQUs7SUFDdEM7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxJQUFJMUUsa0JBQWtCYix1QkFBdUIsR0FBRyxTQUFTYSxnQkFBZ0JxRSxLQUFLLEVBQUVOLFFBQVE7SUFDdEYsT0FBT2pFLFFBQVFpRSxVQUFVOUIsT0FBTyxDQUFDb0M7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvUmVhY3RVdGlscy5qcz8yYTNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5maWx0ZXJTdmdFbGVtZW50cyA9IGV4cG9ydHMuZmlsdGVyUHJvcHMgPSBleHBvcnRzLlRPT0xUSVBfVFlQRVMgPSBleHBvcnRzLlNDQUxFX1RZUEVTID0gZXhwb3J0cy5MRUdFTkRfVFlQRVMgPSB2b2lkIDA7XG5leHBvcnRzLmZpbmRBbGxCeVR5cGUgPSBmaW5kQWxsQnlUeXBlO1xuZXhwb3J0cy5maW5kQ2hpbGRCeVR5cGUgPSBmaW5kQ2hpbGRCeVR5cGU7XG5leHBvcnRzLndpdGhvdXRUeXBlID0gZXhwb3J0cy52YWxpZGF0ZVdpZHRoSGVpZ2h0ID0gZXhwb3J0cy50b0FycmF5ID0gZXhwb3J0cy5yZW5kZXJCeU9yZGVyID0gZXhwb3J0cy5wYXJzZUNoaWxkSW5kZXggPSBleHBvcnRzLmlzVmFsaWRTcHJlYWRhYmxlUHJvcCA9IGV4cG9ydHMuaXNTaW5nbGVDaGlsZEVxdWFsID0gZXhwb3J0cy5pc0NoaWxkcmVuRXF1YWwgPSBleHBvcnRzLmhhc0NsaXBEb3QgPSBleHBvcnRzLmdldFJlYWN0RXZlbnRCeVR5cGUgPSBleHBvcnRzLmdldERpc3BsYXlOYW1lID0gdm9pZCAwO1xudmFyIF9nZXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZ2V0XCIpKTtcbnZhciBfaXNOaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNOaWxcIikpO1xudmFyIF9pc1N0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc1N0cmluZ1wiKSk7XG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XG52YXIgX2lzT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzT2JqZWN0XCIpKTtcbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgX3JlYWN0SXMgPSByZXF1aXJlKFwicmVhY3QtaXNcIik7XG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuL0RhdGFVdGlsc1wiKTtcbnZhciBfU2hhbGxvd0VxdWFsID0gcmVxdWlyZShcIi4vU2hhbGxvd0VxdWFsXCIpO1xudmFyIF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xudmFyIF9leGNsdWRlZCA9IFtcImNoaWxkcmVuXCJdLFxuICBfZXhjbHVkZWQyID0gW1wiY2hpbGRyZW5cIl07XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG52YXIgUkVBQ1RfQlJPV1NFUl9FVkVOVF9NQVAgPSB7XG4gIGNsaWNrOiAnb25DbGljaycsXG4gIG1vdXNlZG93bjogJ29uTW91c2VEb3duJyxcbiAgbW91c2V1cDogJ29uTW91c2VVcCcsXG4gIG1vdXNlb3ZlcjogJ29uTW91c2VPdmVyJyxcbiAgbW91c2Vtb3ZlOiAnb25Nb3VzZU1vdmUnLFxuICBtb3VzZW91dDogJ29uTW91c2VPdXQnLFxuICBtb3VzZWVudGVyOiAnb25Nb3VzZUVudGVyJyxcbiAgbW91c2VsZWF2ZTogJ29uTW91c2VMZWF2ZScsXG4gIHRvdWNoY2FuY2VsOiAnb25Ub3VjaENhbmNlbCcsXG4gIHRvdWNoZW5kOiAnb25Ub3VjaEVuZCcsXG4gIHRvdWNobW92ZTogJ29uVG91Y2hNb3ZlJyxcbiAgdG91Y2hzdGFydDogJ29uVG91Y2hTdGFydCcsXG4gIGNvbnRleHRtZW51OiAnb25Db250ZXh0TWVudScsXG4gIGRibGNsaWNrOiAnb25Eb3VibGVDbGljaydcbn07XG52YXIgU0NBTEVfVFlQRVMgPSBleHBvcnRzLlNDQUxFX1RZUEVTID0gWydhdXRvJywgJ2xpbmVhcicsICdwb3cnLCAnc3FydCcsICdsb2cnLCAnaWRlbnRpdHknLCAndGltZScsICdiYW5kJywgJ3BvaW50JywgJ29yZGluYWwnLCAncXVhbnRpbGUnLCAncXVhbnRpemUnLCAndXRjJywgJ3NlcXVlbnRpYWwnLCAndGhyZXNob2xkJ107XG52YXIgTEVHRU5EX1RZUEVTID0gZXhwb3J0cy5MRUdFTkRfVFlQRVMgPSBbJ3BsYWlubGluZScsICdsaW5lJywgJ3NxdWFyZScsICdyZWN0JywgJ2NpcmNsZScsICdjcm9zcycsICdkaWFtb25kJywgJ3N0YXInLCAndHJpYW5nbGUnLCAnd3llJywgJ25vbmUnXTtcbnZhciBUT09MVElQX1RZUEVTID0gZXhwb3J0cy5UT09MVElQX1RZUEVTID0gWydub25lJ107XG5cbi8qKlxuICogR2V0IHRoZSBkaXNwbGF5IG5hbWUgb2YgYSBjb21wb25lbnRcbiAqIEBwYXJhbSAge09iamVjdH0gQ29tcCBTcGVjaWZpZWQgQ29tcG9uZW50XG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgRGlzcGxheSBuYW1lIG9mIENvbXBvbmVudFxuICovXG52YXIgZ2V0RGlzcGxheU5hbWUgPSBleHBvcnRzLmdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoQ29tcCkge1xuICBpZiAodHlwZW9mIENvbXAgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIENvbXA7XG4gIH1cbiAgaWYgKCFDb21wKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBDb21wLmRpc3BsYXlOYW1lIHx8IENvbXAubmFtZSB8fCAnQ29tcG9uZW50Jztcbn07XG5cbi8vIGB0b0FycmF5YCBnZXRzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgdGhlIHJlbmRlclxuLy8gc28gd2UgY2FuIG1lbW9pemUgbGFzdCBpbnZvY2F0aW9uIChzaW5jZSByZWZlcmVuY2UgdG8gYGNoaWxkcmVuYCBpcyB0aGUgc2FtZSlcbnZhciBsYXN0Q2hpbGRyZW4gPSBudWxsO1xudmFyIGxhc3RSZXN1bHQgPSBudWxsO1xudmFyIHRvQXJyYXkgPSBleHBvcnRzLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbiA9PT0gbGFzdENoaWxkcmVuICYmIEFycmF5LmlzQXJyYXkobGFzdFJlc3VsdCkpIHtcbiAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIF9yZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKGNoaWxkKSkgcmV0dXJuO1xuICAgIGlmICgoMCwgX3JlYWN0SXMuaXNGcmFnbWVudCkoY2hpbGQpKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRvQXJyYXkoY2hpbGQucHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGNvdWxkIHN0aWxsIGJlIEl0ZXJhYmxlPFJlYWN0Tm9kZT4gYW5kIFRTIGRvZXMgbm90IGxpa2UgdGhhdFxuICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfSk7XG4gIGxhc3RSZXN1bHQgPSByZXN1bHQ7XG4gIGxhc3RDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLypcbiAqIEZpbmQgYW5kIHJldHVybiBhbGwgbWF0Y2hlZCBjaGlsZHJlbiBieSB0eXBlLlxuICogYHR5cGVgIG11c3QgYmUgYSBSZWFjdC5Db21wb25lbnRUeXBlXG4gKi9cbmZ1bmN0aW9uIGZpbmRBbGxCeVR5cGUoY2hpbGRyZW4sIHR5cGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgdHlwZXMgPSBbXTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICB0eXBlcyA9IHR5cGUubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gZ2V0RGlzcGxheU5hbWUodCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZXMgPSBbZ2V0RGlzcGxheU5hbWUodHlwZSldO1xuICB9XG4gIHRvQXJyYXkoY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdmFyIGNoaWxkVHlwZSA9ICgwLCBfZ2V0W1wiZGVmYXVsdFwiXSkoY2hpbGQsICd0eXBlLmRpc3BsYXlOYW1lJykgfHwgKDAsIF9nZXRbXCJkZWZhdWx0XCJdKShjaGlsZCwgJ3R5cGUubmFtZScpO1xuICAgIGlmICh0eXBlcy5pbmRleE9mKGNoaWxkVHlwZSkgIT09IC0xKSB7XG4gICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLypcbiAqIFJldHVybiB0aGUgZmlyc3QgbWF0Y2hlZCBjaGlsZCBieSB0eXBlLCByZXR1cm4gbnVsbCBvdGhlcndpc2UuXG4gKiBgdHlwZWAgbXVzdCBiZSBhIFJlYWN0LkNvbXBvbmVudFR5cGVcbiAqL1xuZnVuY3Rpb24gZmluZENoaWxkQnlUeXBlKGNoaWxkcmVuLCB0eXBlKSB7XG4gIHZhciByZXN1bHQgPSBmaW5kQWxsQnlUeXBlKGNoaWxkcmVuLCB0eXBlKTtcbiAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHRbMF07XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBuZXcgYXJyYXkgb2YgY2hpbGRyZW4gZXhjbHVkaW5nIHRoZSBvbmVzIG1hdGNoZWQgdGhlIHR5cGVcbiAqL1xudmFyIHdpdGhvdXRUeXBlID0gZXhwb3J0cy53aXRob3V0VHlwZSA9IGZ1bmN0aW9uIHdpdGhvdXRUeXBlKGNoaWxkcmVuLCB0eXBlKSB7XG4gIHZhciBuZXdDaGlsZHJlbiA9IFtdO1xuICB2YXIgdHlwZXM7XG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgdHlwZXMgPSB0eXBlLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIGdldERpc3BsYXlOYW1lKHQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHR5cGVzID0gW2dldERpc3BsYXlOYW1lKHR5cGUpXTtcbiAgfVxuICB0b0FycmF5KGNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9ICgwLCBfZ2V0W1wiZGVmYXVsdFwiXSkoY2hpbGQsICd0eXBlLmRpc3BsYXlOYW1lJyk7XG4gICAgaWYgKGRpc3BsYXlOYW1lICYmIHR5cGVzLmluZGV4T2YoZGlzcGxheU5hbWUpICE9PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBuZXdDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgfSk7XG4gIHJldHVybiBuZXdDaGlsZHJlbjtcbn07XG5cbi8qKlxuICogdmFsaWRhdGUgdGhlIHdpZHRoIGFuZCBoZWlnaHQgcHJvcHMgb2YgYSBjaGFydCBlbGVtZW50XG4gKiBAcGFyYW0gIHtPYmplY3R9IGVsIEEgY2hhcnQgZWxlbWVudFxuICogQHJldHVybiB7Qm9vbGVhbn0gICB0cnVlIElmIHRoZSBwcm9wcyB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBudW1iZXIsIGFuZCBncmVhdGVyIHRoYW4gMFxuICovXG52YXIgdmFsaWRhdGVXaWR0aEhlaWdodCA9IGV4cG9ydHMudmFsaWRhdGVXaWR0aEhlaWdodCA9IGZ1bmN0aW9uIHZhbGlkYXRlV2lkdGhIZWlnaHQoZWwpIHtcbiAgaWYgKCFlbCB8fCAhZWwucHJvcHMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIF9lbCRwcm9wcyA9IGVsLnByb3BzLFxuICAgIHdpZHRoID0gX2VsJHByb3BzLndpZHRoLFxuICAgIGhlaWdodCA9IF9lbCRwcm9wcy5oZWlnaHQ7XG4gIGlmICghKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHdpZHRoKSB8fCB3aWR0aCA8PSAwIHx8ICEoMCwgX0RhdGFVdGlscy5pc051bWJlcikoaGVpZ2h0KSB8fCBoZWlnaHQgPD0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgU1ZHX1RBR1MgPSBbJ2EnLCAnYWx0R2x5cGgnLCAnYWx0R2x5cGhEZWYnLCAnYWx0R2x5cGhJdGVtJywgJ2FuaW1hdGUnLCAnYW5pbWF0ZUNvbG9yJywgJ2FuaW1hdGVNb3Rpb24nLCAnYW5pbWF0ZVRyYW5zZm9ybScsICdjaXJjbGUnLCAnY2xpcFBhdGgnLCAnY29sb3ItcHJvZmlsZScsICdjdXJzb3InLCAnZGVmcycsICdkZXNjJywgJ2VsbGlwc2UnLCAnZmVCbGVuZCcsICdmZUNvbG9ybWF0cml4JywgJ2ZlQ29tcG9uZW50VHJhbnNmZXInLCAnZmVDb21wb3NpdGUnLCAnZmVDb252b2x2ZU1hdHJpeCcsICdmZURpZmZ1c2VMaWdodGluZycsICdmZURpc3BsYWNlbWVudE1hcCcsICdmZURpc3RhbnRMaWdodCcsICdmZUZsb29kJywgJ2ZlRnVuY0EnLCAnZmVGdW5jQicsICdmZUZ1bmNHJywgJ2ZlRnVuY1InLCAnZmVHYXVzc2lhbkJsdXInLCAnZmVJbWFnZScsICdmZU1lcmdlJywgJ2ZlTWVyZ2VOb2RlJywgJ2ZlTW9ycGhvbG9neScsICdmZU9mZnNldCcsICdmZVBvaW50TGlnaHQnLCAnZmVTcGVjdWxhckxpZ2h0aW5nJywgJ2ZlU3BvdExpZ2h0JywgJ2ZlVGlsZScsICdmZVR1cmJ1bGVuY2UnLCAnZmlsdGVyJywgJ2ZvbnQnLCAnZm9udC1mYWNlJywgJ2ZvbnQtZmFjZS1mb3JtYXQnLCAnZm9udC1mYWNlLW5hbWUnLCAnZm9udC1mYWNlLXVybCcsICdmb3JlaWduT2JqZWN0JywgJ2cnLCAnZ2x5cGgnLCAnZ2x5cGhSZWYnLCAnaGtlcm4nLCAnaW1hZ2UnLCAnbGluZScsICdsaW5lR3JhZGllbnQnLCAnbWFya2VyJywgJ21hc2snLCAnbWV0YWRhdGEnLCAnbWlzc2luZy1nbHlwaCcsICdtcGF0aCcsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JywgJ3NjcmlwdCcsICdzZXQnLCAnc3RvcCcsICdzdHlsZScsICdzdmcnLCAnc3dpdGNoJywgJ3N5bWJvbCcsICd0ZXh0JywgJ3RleHRQYXRoJywgJ3RpdGxlJywgJ3RyZWYnLCAndHNwYW4nLCAndXNlJywgJ3ZpZXcnLCAndmtlcm4nXTtcbnZhciBpc1N2Z0VsZW1lbnQgPSBmdW5jdGlvbiBpc1N2Z0VsZW1lbnQoY2hpbGQpIHtcbiAgcmV0dXJuIGNoaWxkICYmIGNoaWxkLnR5cGUgJiYgKDAsIF9pc1N0cmluZ1tcImRlZmF1bHRcIl0pKGNoaWxkLnR5cGUpICYmIFNWR19UQUdTLmluZGV4T2YoY2hpbGQudHlwZSkgPj0gMDtcbn07XG52YXIgaGFzQ2xpcERvdCA9IGV4cG9ydHMuaGFzQ2xpcERvdCA9IGZ1bmN0aW9uIGhhc0NsaXBEb3QoZG90KSB7XG4gIHJldHVybiBkb3QgJiYgX3R5cGVvZihkb3QpID09PSAnb2JqZWN0JyAmJiAnY2xpcERvdCcgaW4gZG90O1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3BlcnR5IGlzIHZhbGlkIHRvIHNwcmVhZCBvbnRvIGFuIFNWRyBlbGVtZW50IG9yIG9udG8gYSBzcGVjaWZpYyBjb21wb25lbnRcbiAqIEBwYXJhbSB7dW5rbm93bn0gcHJvcGVydHkgcHJvcGVydHkgdmFsdWUgY3VycmVudGx5IGJlaW5nIGNvbXBhcmVkXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHByb3BlcnR5IGtleSBjdXJyZW50bHkgYmVpbmcgY29tcGFyZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUV2ZW50cyBpZiBldmVudHMgYXJlIGluY2x1ZGVkIGluIHNwcmVhZGFibGUgcHJvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3ZnRWxlbWVudFR5cGUgY2hlY2tzIGFnYWluc3QgbWFwIG9mIFNWRyBlbGVtZW50IHR5cGVzIHRvIGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHtib29sZWFufSBpcyBwcm9wIHZhbGlkXG4gKi9cbnZhciBpc1ZhbGlkU3ByZWFkYWJsZVByb3AgPSBleHBvcnRzLmlzVmFsaWRTcHJlYWRhYmxlUHJvcCA9IGZ1bmN0aW9uIGlzVmFsaWRTcHJlYWRhYmxlUHJvcChwcm9wZXJ0eSwga2V5LCBpbmNsdWRlRXZlbnRzLCBzdmdFbGVtZW50VHlwZSkge1xuICB2YXIgX0ZpbHRlcmVkRWxlbWVudEtleU1hO1xuICAvKipcbiAgICogSWYgdGhlIHN2ZyBlbGVtZW50IHR5cGUgaXMgZXhwbGljaXRseSBpbmNsdWRlZCwgY2hlY2sgYWdhaW5zdCB0aGUgZmlsdGVyZWQgZWxlbWVudCBrZXkgbWFwXG4gICAqIHRvIGRldGVybWluZSBpZiB0aGVyZSBhcmUgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBvbmx5IGV4aXN0IG9uIHRoYXQgZWxlbWVudCB0eXBlLlxuICAgKiBAdG9kbyBBZGQgYW4gaW50ZXJuYWwgY2pzIHZlcnNpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL3dvb29ybS9zdmctZWxlbWVudC1hdHRyaWJ1dGVzIGZvciBmdWxsIGNvdmVyYWdlLlxuICAgKi9cbiAgdmFyIG1hdGNoaW5nRWxlbWVudFR5cGVLZXlzID0gKF9GaWx0ZXJlZEVsZW1lbnRLZXlNYSA9IF90eXBlcy5GaWx0ZXJlZEVsZW1lbnRLZXlNYXAgPT09IG51bGwgfHwgX3R5cGVzLkZpbHRlcmVkRWxlbWVudEtleU1hcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3R5cGVzLkZpbHRlcmVkRWxlbWVudEtleU1hcFtzdmdFbGVtZW50VHlwZV0pICE9PSBudWxsICYmIF9GaWx0ZXJlZEVsZW1lbnRLZXlNYSAhPT0gdm9pZCAwID8gX0ZpbHRlcmVkRWxlbWVudEtleU1hIDogW107XG4gIHJldHVybiAhKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkocHJvcGVydHkpICYmIChzdmdFbGVtZW50VHlwZSAmJiBtYXRjaGluZ0VsZW1lbnRUeXBlS2V5cy5pbmNsdWRlcyhrZXkpIHx8IF90eXBlcy5TVkdFbGVtZW50UHJvcEtleXMuaW5jbHVkZXMoa2V5KSkgfHwgaW5jbHVkZUV2ZW50cyAmJiBfdHlwZXMuRXZlbnRLZXlzLmluY2x1ZGVzKGtleSk7XG59O1xuXG4vKipcbiAqIEZpbHRlciBhbGwgdGhlIHN2ZyBlbGVtZW50cyBvZiBjaGlsZHJlblxuICogQHBhcmFtICB7QXJyYXl9IGNoaWxkcmVuIFRoZSBjaGlsZHJlbiBvZiBhIHJlYWN0IGVsZW1lbnRcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICBBbGwgdGhlIHN2ZyBlbGVtZW50c1xuICovXG52YXIgZmlsdGVyU3ZnRWxlbWVudHMgPSBleHBvcnRzLmZpbHRlclN2Z0VsZW1lbnRzID0gZnVuY3Rpb24gZmlsdGVyU3ZnRWxlbWVudHMoY2hpbGRyZW4pIHtcbiAgdmFyIHN2Z0VsZW1lbnRzID0gW107XG4gIHRvQXJyYXkoY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgaWYgKGlzU3ZnRWxlbWVudChlbnRyeSkpIHtcbiAgICAgIHN2Z0VsZW1lbnRzLnB1c2goZW50cnkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzdmdFbGVtZW50cztcbn07XG52YXIgZmlsdGVyUHJvcHMgPSBleHBvcnRzLmZpbHRlclByb3BzID0gZnVuY3Rpb24gZmlsdGVyUHJvcHMocHJvcHMsIGluY2x1ZGVFdmVudHMsIHN2Z0VsZW1lbnRUeXBlKSB7XG4gIGlmICghcHJvcHMgfHwgdHlwZW9mIHByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBwcm9wcyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGlucHV0UHJvcHMgPSBwcm9wcztcbiAgaWYgKCAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5pc1ZhbGlkRWxlbWVudCkocHJvcHMpKSB7XG4gICAgaW5wdXRQcm9wcyA9IHByb3BzLnByb3BzO1xuICB9XG4gIGlmICghKDAsIF9pc09iamVjdFtcImRlZmF1bHRcIl0pKGlucHV0UHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG91dCA9IHt9O1xuXG4gIC8qKlxuICAgKiBQcm9wcyBhcmUgYmxpbmRseSBzcHJlYWQgb250byBTVkcgZWxlbWVudHMuIFRoaXMgbG9vcCBmaWx0ZXJzIG91dCBwcm9wZXJ0aWVzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byBzcHJlYWQuXG4gICAqIEl0ZW1zIGZpbHRlcmVkIG91dCBhcmUgYXMgZm9sbG93czpcbiAgICogICAtIGZ1bmN0aW9ucyBpbiBwcm9wZXJ0aWVzIHRoYXQgYXJlIFNWRyBhdHRyaWJ1dGVzIChmdW5jdGlvbnMgYXJlIGluY2x1ZGVkIHdoZW4gaW5jbHVkZUV2ZW50cyBpcyB0cnVlKVxuICAgKiAgIC0gcHJvcHMgdGhhdCBhcmUgU1ZHIGF0dHJpYnV0ZXMgYnV0IGRvbid0IG1hdGNoZWQgdGhlIHBhc3NlZCBzdmdFbGVtZW50VHlwZVxuICAgKiAgIC0gYW55IHByb3AgdGhhdCBpcyBub3QgaW4gU1ZHRWxlbWVudFByb3BLZXlzIChvciBpbiBFdmVudEtleXMgaWYgaW5jbHVkZUV2ZW50cyBpcyB0cnVlKVxuICAgKi9cbiAgT2JqZWN0LmtleXMoaW5wdXRQcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIF9pbnB1dFByb3BzO1xuICAgIGlmIChpc1ZhbGlkU3ByZWFkYWJsZVByb3AoKF9pbnB1dFByb3BzID0gaW5wdXRQcm9wcykgPT09IG51bGwgfHwgX2lucHV0UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pbnB1dFByb3BzW2tleV0sIGtleSwgaW5jbHVkZUV2ZW50cywgc3ZnRWxlbWVudFR5cGUpKSB7XG4gICAgICBvdXRba2V5XSA9IGlucHV0UHJvcHNba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBXZXRoZXIgcHJvcHMgb2YgY2hpbGRyZW4gY2hhbmdlZFxuICogQHBhcmFtICB7T2JqZWN0fSBuZXh0Q2hpbGRyZW4gVGhlIGxhdGVzdCBjaGlsZHJlblxuICogQHBhcmFtICB7T2JqZWN0fSBwcmV2Q2hpbGRyZW4gVGhlIHByZXYgY2hpbGRyZW5cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgIGVxdWFsIG9yIG5vdFxuICovXG52YXIgaXNDaGlsZHJlbkVxdWFsID0gZXhwb3J0cy5pc0NoaWxkcmVuRXF1YWwgPSBmdW5jdGlvbiBpc0NoaWxkcmVuRXF1YWwobmV4dENoaWxkcmVuLCBwcmV2Q2hpbGRyZW4pIHtcbiAgaWYgKG5leHRDaGlsZHJlbiA9PT0gcHJldkNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGNvdW50ID0gX3JlYWN0LkNoaWxkcmVuLmNvdW50KG5leHRDaGlsZHJlbik7XG4gIGlmIChjb3VudCAhPT0gX3JlYWN0LkNoaWxkcmVuLmNvdW50KHByZXZDaGlsZHJlbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgIHJldHVybiBpc1NpbmdsZUNoaWxkRXF1YWwoQXJyYXkuaXNBcnJheShuZXh0Q2hpbGRyZW4pID8gbmV4dENoaWxkcmVuWzBdIDogbmV4dENoaWxkcmVuLCBBcnJheS5pc0FycmF5KHByZXZDaGlsZHJlbikgPyBwcmV2Q2hpbGRyZW5bMF0gOiBwcmV2Q2hpbGRyZW4pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIHZhciBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGRyZW5baV07XG4gICAgdmFyIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbltpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0Q2hpbGQpIHx8IEFycmF5LmlzQXJyYXkocHJldkNoaWxkKSkge1xuICAgICAgaWYgKCFpc0NoaWxkcmVuRXF1YWwobmV4dENoaWxkLCBwcmV2Q2hpbGQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICB9IGVsc2UgaWYgKCFpc1NpbmdsZUNoaWxkRXF1YWwobmV4dENoaWxkLCBwcmV2Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBpc1NpbmdsZUNoaWxkRXF1YWwgPSBleHBvcnRzLmlzU2luZ2xlQ2hpbGRFcXVhbCA9IGZ1bmN0aW9uIGlzU2luZ2xlQ2hpbGRFcXVhbChuZXh0Q2hpbGQsIHByZXZDaGlsZCkge1xuICBpZiAoKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKG5leHRDaGlsZCkgJiYgKDAsIF9pc05pbFtcImRlZmF1bHRcIl0pKHByZXZDaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoISgwLCBfaXNOaWxbXCJkZWZhdWx0XCJdKShuZXh0Q2hpbGQpICYmICEoMCwgX2lzTmlsW1wiZGVmYXVsdFwiXSkocHJldkNoaWxkKSkge1xuICAgIHZhciBfcmVmID0gbmV4dENoaWxkLnByb3BzIHx8IHt9LFxuICAgICAgbmV4dENoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIG5leHRQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuICAgIHZhciBfcmVmMiA9IHByZXZDaGlsZC5wcm9wcyB8fCB7fSxcbiAgICAgIHByZXZDaGlsZHJlbiA9IF9yZWYyLmNoaWxkcmVuLFxuICAgICAgcHJldlByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBfZXhjbHVkZWQyKTtcbiAgICBpZiAobmV4dENoaWxkcmVuICYmIHByZXZDaGlsZHJlbikge1xuICAgICAgcmV0dXJuICgwLCBfU2hhbGxvd0VxdWFsLnNoYWxsb3dFcXVhbCkobmV4dFByb3BzLCBwcmV2UHJvcHMpICYmIGlzQ2hpbGRyZW5FcXVhbChuZXh0Q2hpbGRyZW4sIHByZXZDaGlsZHJlbik7XG4gICAgfVxuICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiAoMCwgX1NoYWxsb3dFcXVhbC5zaGFsbG93RXF1YWwpKG5leHRQcm9wcywgcHJldlByb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgcmVuZGVyQnlPcmRlciA9IGV4cG9ydHMucmVuZGVyQnlPcmRlciA9IGZ1bmN0aW9uIHJlbmRlckJ5T3JkZXIoY2hpbGRyZW4sIHJlbmRlck1hcCkge1xuICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgdmFyIHJlY29yZCA9IHt9O1xuICB0b0FycmF5KGNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICBpZiAoaXNTdmdFbGVtZW50KGNoaWxkKSkge1xuICAgICAgZWxlbWVudHMucHVzaChjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChjaGlsZCkge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWUoY2hpbGQudHlwZSk7XG4gICAgICB2YXIgX3JlZjMgPSByZW5kZXJNYXBbZGlzcGxheU5hbWVdIHx8IHt9LFxuICAgICAgICBoYW5kbGVyID0gX3JlZjMuaGFuZGxlcixcbiAgICAgICAgb25jZSA9IF9yZWYzLm9uY2U7XG4gICAgICBpZiAoaGFuZGxlciAmJiAoIW9uY2UgfHwgIXJlY29yZFtkaXNwbGF5TmFtZV0pKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gaGFuZGxlcihjaGlsZCwgZGlzcGxheU5hbWUsIGluZGV4KTtcbiAgICAgICAgZWxlbWVudHMucHVzaChyZXN1bHRzKTtcbiAgICAgICAgcmVjb3JkW2Rpc3BsYXlOYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVsZW1lbnRzO1xufTtcbnZhciBnZXRSZWFjdEV2ZW50QnlUeXBlID0gZXhwb3J0cy5nZXRSZWFjdEV2ZW50QnlUeXBlID0gZnVuY3Rpb24gZ2V0UmVhY3RFdmVudEJ5VHlwZShlKSB7XG4gIHZhciB0eXBlID0gZSAmJiBlLnR5cGU7XG4gIGlmICh0eXBlICYmIFJFQUNUX0JST1dTRVJfRVZFTlRfTUFQW3R5cGVdKSB7XG4gICAgcmV0dXJuIFJFQUNUX0JST1dTRVJfRVZFTlRfTUFQW3R5cGVdO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbnZhciBwYXJzZUNoaWxkSW5kZXggPSBleHBvcnRzLnBhcnNlQ2hpbGRJbmRleCA9IGZ1bmN0aW9uIHBhcnNlQ2hpbGRJbmRleChjaGlsZCwgY2hpbGRyZW4pIHtcbiAgcmV0dXJuIHRvQXJyYXkoY2hpbGRyZW4pLmluZGV4T2YoY2hpbGQpO1xufTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJmaWx0ZXJTdmdFbGVtZW50cyIsImZpbHRlclByb3BzIiwiVE9PTFRJUF9UWVBFUyIsIlNDQUxFX1RZUEVTIiwiTEVHRU5EX1RZUEVTIiwiZmluZEFsbEJ5VHlwZSIsImZpbmRDaGlsZEJ5VHlwZSIsIndpdGhvdXRUeXBlIiwidmFsaWRhdGVXaWR0aEhlaWdodCIsInRvQXJyYXkiLCJyZW5kZXJCeU9yZGVyIiwicGFyc2VDaGlsZEluZGV4IiwiaXNWYWxpZFNwcmVhZGFibGVQcm9wIiwiaXNTaW5nbGVDaGlsZEVxdWFsIiwiaXNDaGlsZHJlbkVxdWFsIiwiaGFzQ2xpcERvdCIsImdldFJlYWN0RXZlbnRCeVR5cGUiLCJnZXREaXNwbGF5TmFtZSIsIl9nZXQiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9pc05pbCIsIl9pc1N0cmluZyIsIl9pc0Z1bmN0aW9uIiwiX2lzT2JqZWN0IiwiX3JlYWN0IiwiX3JlYWN0SXMiLCJfRGF0YVV0aWxzIiwiX1NoYWxsb3dFcXVhbCIsIl90eXBlcyIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwic291cmNlIiwiZXhjbHVkZWQiLCJ0YXJnZXQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImtleSIsImkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwibGVuZ3RoIiwiaW5kZXhPZiIsInByb3RvdHlwZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiY2FsbCIsImhhc093blByb3BlcnR5IiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwiUkVBQ1RfQlJPV1NFUl9FVkVOVF9NQVAiLCJjbGljayIsIm1vdXNlZG93biIsIm1vdXNldXAiLCJtb3VzZW92ZXIiLCJtb3VzZW1vdmUiLCJtb3VzZW91dCIsIm1vdXNlZW50ZXIiLCJtb3VzZWxlYXZlIiwidG91Y2hjYW5jZWwiLCJ0b3VjaGVuZCIsInRvdWNobW92ZSIsInRvdWNoc3RhcnQiLCJjb250ZXh0bWVudSIsImRibGNsaWNrIiwiQ29tcCIsImRpc3BsYXlOYW1lIiwibmFtZSIsImxhc3RDaGlsZHJlbiIsImxhc3RSZXN1bHQiLCJjaGlsZHJlbiIsIkFycmF5IiwiaXNBcnJheSIsInJlc3VsdCIsIkNoaWxkcmVuIiwiZm9yRWFjaCIsImNoaWxkIiwiaXNGcmFnbWVudCIsImNvbmNhdCIsInByb3BzIiwicHVzaCIsInR5cGUiLCJ0eXBlcyIsIm1hcCIsInQiLCJjaGlsZFR5cGUiLCJuZXdDaGlsZHJlbiIsImVsIiwiX2VsJHByb3BzIiwid2lkdGgiLCJoZWlnaHQiLCJpc051bWJlciIsIlNWR19UQUdTIiwiaXNTdmdFbGVtZW50IiwiZG90IiwicHJvcGVydHkiLCJpbmNsdWRlRXZlbnRzIiwic3ZnRWxlbWVudFR5cGUiLCJfRmlsdGVyZWRFbGVtZW50S2V5TWEiLCJtYXRjaGluZ0VsZW1lbnRUeXBlS2V5cyIsIkZpbHRlcmVkRWxlbWVudEtleU1hcCIsImluY2x1ZGVzIiwiU1ZHRWxlbWVudFByb3BLZXlzIiwiRXZlbnRLZXlzIiwic3ZnRWxlbWVudHMiLCJlbnRyeSIsImlucHV0UHJvcHMiLCJpc1ZhbGlkRWxlbWVudCIsIm91dCIsImtleXMiLCJfaW5wdXRQcm9wcyIsIm5leHRDaGlsZHJlbiIsInByZXZDaGlsZHJlbiIsImNvdW50IiwibmV4dENoaWxkIiwicHJldkNoaWxkIiwiX3JlZiIsIm5leHRQcm9wcyIsIl9yZWYyIiwicHJldlByb3BzIiwic2hhbGxvd0VxdWFsIiwicmVuZGVyTWFwIiwiZWxlbWVudHMiLCJyZWNvcmQiLCJpbmRleCIsIl9yZWYzIiwiaGFuZGxlciIsIm9uY2UiLCJyZXN1bHRzIiwiZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/ReactUtils.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/ReduceCSSCalc.js":
/*!*********************************************************!*\
  !*** ./node_modules/recharts/lib/util/ReduceCSSCalc.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.reduceCSSCalc = reduceCSSCalc;\nexports.safeEvaluateExpression = safeEvaluateExpression;\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar MULTIPLY_OR_DIVIDE_REGEX = /(-?\\d+(?:\\.\\d+)?[a-zA-Z%]*)([*/])(-?\\d+(?:\\.\\d+)?[a-zA-Z%]*)/;\nvar ADD_OR_SUBTRACT_REGEX = /(-?\\d+(?:\\.\\d+)?[a-zA-Z%]*)([+-])(-?\\d+(?:\\.\\d+)?[a-zA-Z%]*)/;\nvar CSS_LENGTH_UNIT_REGEX = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/;\nvar NUM_SPLIT_REGEX = /(-?\\d+(?:\\.\\d+)?)([a-zA-Z%]+)?/;\nvar CONVERSION_RATES = {\n    cm: 96 / 2.54,\n    mm: 96 / 25.4,\n    pt: 96 / 72,\n    pc: 96 / 6,\n    \"in\": 96,\n    Q: 96 / (2.54 * 40),\n    px: 1\n};\nvar FIXED_CSS_LENGTH_UNITS = Object.keys(CONVERSION_RATES);\nvar STR_NAN = \"NaN\";\nfunction convertToPx(value, unit) {\n    return value * CONVERSION_RATES[unit];\n}\nvar DecimalCSS = /*#__PURE__*/ function() {\n    function DecimalCSS(num, unit) {\n        _classCallCheck(this, DecimalCSS);\n        this.num = num;\n        this.unit = unit;\n        this.num = num;\n        this.unit = unit;\n        if (Number.isNaN(num)) {\n            this.unit = \"\";\n        }\n        if (unit !== \"\" && !CSS_LENGTH_UNIT_REGEX.test(unit)) {\n            this.num = NaN;\n            this.unit = \"\";\n        }\n        if (FIXED_CSS_LENGTH_UNITS.includes(unit)) {\n            this.num = convertToPx(num, unit);\n            this.unit = \"px\";\n        }\n    }\n    return _createClass(DecimalCSS, [\n        {\n            key: \"add\",\n            value: function add(other) {\n                if (this.unit !== other.unit) {\n                    return new DecimalCSS(NaN, \"\");\n                }\n                return new DecimalCSS(this.num + other.num, this.unit);\n            }\n        },\n        {\n            key: \"subtract\",\n            value: function subtract(other) {\n                if (this.unit !== other.unit) {\n                    return new DecimalCSS(NaN, \"\");\n                }\n                return new DecimalCSS(this.num - other.num, this.unit);\n            }\n        },\n        {\n            key: \"multiply\",\n            value: function multiply(other) {\n                if (this.unit !== \"\" && other.unit !== \"\" && this.unit !== other.unit) {\n                    return new DecimalCSS(NaN, \"\");\n                }\n                return new DecimalCSS(this.num * other.num, this.unit || other.unit);\n            }\n        },\n        {\n            key: \"divide\",\n            value: function divide(other) {\n                if (this.unit !== \"\" && other.unit !== \"\" && this.unit !== other.unit) {\n                    return new DecimalCSS(NaN, \"\");\n                }\n                return new DecimalCSS(this.num / other.num, this.unit || other.unit);\n            }\n        },\n        {\n            key: \"toString\",\n            value: function toString() {\n                return \"\".concat(this.num).concat(this.unit);\n            }\n        },\n        {\n            key: \"isNaN\",\n            value: function isNaN() {\n                return Number.isNaN(this.num);\n            }\n        }\n    ], [\n        {\n            key: \"parse\",\n            value: function parse(str) {\n                var _NUM_SPLIT_REGEX$exec;\n                var _ref = (_NUM_SPLIT_REGEX$exec = NUM_SPLIT_REGEX.exec(str)) !== null && _NUM_SPLIT_REGEX$exec !== void 0 ? _NUM_SPLIT_REGEX$exec : [], _ref2 = _slicedToArray(_ref, 3), numStr = _ref2[1], unit = _ref2[2];\n                return new DecimalCSS(parseFloat(numStr), unit !== null && unit !== void 0 ? unit : \"\");\n            }\n        }\n    ]);\n}();\nfunction calculateArithmetic(expr) {\n    if (expr.includes(STR_NAN)) {\n        return STR_NAN;\n    }\n    var newExpr = expr;\n    while(newExpr.includes(\"*\") || newExpr.includes(\"/\")){\n        var _MULTIPLY_OR_DIVIDE_R;\n        var _ref3 = (_MULTIPLY_OR_DIVIDE_R = MULTIPLY_OR_DIVIDE_REGEX.exec(newExpr)) !== null && _MULTIPLY_OR_DIVIDE_R !== void 0 ? _MULTIPLY_OR_DIVIDE_R : [], _ref4 = _slicedToArray(_ref3, 4), leftOperand = _ref4[1], operator = _ref4[2], rightOperand = _ref4[3];\n        var lTs = DecimalCSS.parse(leftOperand !== null && leftOperand !== void 0 ? leftOperand : \"\");\n        var rTs = DecimalCSS.parse(rightOperand !== null && rightOperand !== void 0 ? rightOperand : \"\");\n        var result = operator === \"*\" ? lTs.multiply(rTs) : lTs.divide(rTs);\n        if (result.isNaN()) {\n            return STR_NAN;\n        }\n        newExpr = newExpr.replace(MULTIPLY_OR_DIVIDE_REGEX, result.toString());\n    }\n    while(newExpr.includes(\"+\") || /.-\\d+(?:\\.\\d+)?/.test(newExpr)){\n        var _ADD_OR_SUBTRACT_REGE;\n        var _ref5 = (_ADD_OR_SUBTRACT_REGE = ADD_OR_SUBTRACT_REGEX.exec(newExpr)) !== null && _ADD_OR_SUBTRACT_REGE !== void 0 ? _ADD_OR_SUBTRACT_REGE : [], _ref6 = _slicedToArray(_ref5, 4), _leftOperand = _ref6[1], _operator = _ref6[2], _rightOperand = _ref6[3];\n        var _lTs = DecimalCSS.parse(_leftOperand !== null && _leftOperand !== void 0 ? _leftOperand : \"\");\n        var _rTs = DecimalCSS.parse(_rightOperand !== null && _rightOperand !== void 0 ? _rightOperand : \"\");\n        var _result = _operator === \"+\" ? _lTs.add(_rTs) : _lTs.subtract(_rTs);\n        if (_result.isNaN()) {\n            return STR_NAN;\n        }\n        newExpr = newExpr.replace(ADD_OR_SUBTRACT_REGEX, _result.toString());\n    }\n    return newExpr;\n}\nvar PARENTHESES_REGEX = /\\(([^()]*)\\)/;\nfunction calculateParentheses(expr) {\n    var newExpr = expr;\n    while(newExpr.includes(\"(\")){\n        var _PARENTHESES_REGEX$ex = PARENTHESES_REGEX.exec(newExpr), _PARENTHESES_REGEX$ex2 = _slicedToArray(_PARENTHESES_REGEX$ex, 2), parentheticalExpression = _PARENTHESES_REGEX$ex2[1];\n        newExpr = newExpr.replace(PARENTHESES_REGEX, calculateArithmetic(parentheticalExpression));\n    }\n    return newExpr;\n}\nfunction evaluateExpression(expression) {\n    var newExpr = expression.replace(/\\s+/g, \"\");\n    newExpr = calculateParentheses(newExpr);\n    newExpr = calculateArithmetic(newExpr);\n    return newExpr;\n}\nfunction safeEvaluateExpression(expression) {\n    try {\n        return evaluateExpression(expression);\n    } catch (e) {\n        /* istanbul ignore next */ return STR_NAN;\n    }\n}\nfunction reduceCSSCalc(expression) {\n    var result = safeEvaluateExpression(expression.slice(5, -1));\n    if (result === STR_NAN) {\n        // notify the user\n        return \"\";\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvUmVkdWNlQ1NTQ2FsYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQscUJBQXFCLEdBQUdFO0FBQ3hCRiw4QkFBOEIsR0FBR0c7QUFDakMsU0FBU0MsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLLGVBQWVDLEdBQUcsRUFBRUMsQ0FBQztJQUFJLE9BQU9DLGdCQUFnQkYsUUFBUUcsc0JBQXNCSCxLQUFLQyxNQUFNRyw0QkFBNEJKLEtBQUtDLE1BQU1JO0FBQW9CO0FBQzdKLFNBQVNBO0lBQXFCLE1BQU0sSUFBSUMsVUFBVTtBQUE4STtBQUNoTSxTQUFTRiw0QkFBNEJWLENBQUMsRUFBRWEsTUFBTTtJQUFJLElBQUksQ0FBQ2IsR0FBRztJQUFRLElBQUksT0FBT0EsTUFBTSxVQUFVLE9BQU9jLGtCQUFrQmQsR0FBR2E7SUFBUyxJQUFJRSxJQUFJdEIsT0FBT1csU0FBUyxDQUFDWSxRQUFRLENBQUNDLElBQUksQ0FBQ2pCLEdBQUdrQixLQUFLLENBQUMsR0FBRyxDQUFDO0lBQUksSUFBSUgsTUFBTSxZQUFZZixFQUFFRyxXQUFXLEVBQUVZLElBQUlmLEVBQUVHLFdBQVcsQ0FBQ2dCLElBQUk7SUFBRSxJQUFJSixNQUFNLFNBQVNBLE1BQU0sT0FBTyxPQUFPSyxNQUFNQyxJQUFJLENBQUNyQjtJQUFJLElBQUllLE1BQU0sZUFBZSwyQ0FBMkNP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dUJ5SCxVQUFVO0lBQ3hDLElBQUk7UUFDRixPQUFPRCxtQkFBbUJDO0lBQzVCLEVBQUUsT0FBTzFGLEdBQUc7UUFDVix3QkFBd0IsR0FDeEIsT0FBT3dDO0lBQ1Q7QUFDRjtBQUNBLFNBQVN4RSxjQUFjMEgsVUFBVTtJQUMvQixJQUFJakIsU0FBU3hHLHVCQUF1QnlILFdBQVdyRyxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQ3pELElBQUlvRixXQUFXakMsU0FBUztRQUN0QixrQkFBa0I7UUFDbEIsT0FBTztJQUNUO0lBQ0EsT0FBT2lDO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvUmVkdWNlQ1NTQ2FsYy5qcz8xOTM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZWR1Y2VDU1NDYWxjID0gcmVkdWNlQ1NTQ2FsYztcbmV4cG9ydHMuc2FmZUV2YWx1YXRlRXhwcmVzc2lvbiA9IHNhZmVFdmFsdWF0ZUV4cHJlc3Npb247XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgTVVMVElQTFlfT1JfRElWSURFX1JFR0VYID0gLygtP1xcZCsoPzpcXC5cXGQrKT9bYS16QS1aJV0qKShbKi9dKSgtP1xcZCsoPzpcXC5cXGQrKT9bYS16QS1aJV0qKS87XG52YXIgQUREX09SX1NVQlRSQUNUX1JFR0VYID0gLygtP1xcZCsoPzpcXC5cXGQrKT9bYS16QS1aJV0qKShbKy1dKSgtP1xcZCsoPzpcXC5cXGQrKT9bYS16QS1aJV0qKS87XG52YXIgQ1NTX0xFTkdUSF9VTklUX1JFR0VYID0gL15weHxjbXx2aHx2d3xlbXxyZW18JXxtbXxpbnxwdHxwY3xleHxjaHx2bWlufHZtYXh8USQvO1xudmFyIE5VTV9TUExJVF9SRUdFWCA9IC8oLT9cXGQrKD86XFwuXFxkKyk/KShbYS16QS1aJV0rKT8vO1xudmFyIENPTlZFUlNJT05fUkFURVMgPSB7XG4gIGNtOiA5NiAvIDIuNTQsXG4gIG1tOiA5NiAvIDI1LjQsXG4gIHB0OiA5NiAvIDcyLFxuICBwYzogOTYgLyA2LFxuICBcImluXCI6IDk2LFxuICBROiA5NiAvICgyLjU0ICogNDApLFxuICBweDogMVxufTtcbnZhciBGSVhFRF9DU1NfTEVOR1RIX1VOSVRTID0gT2JqZWN0LmtleXMoQ09OVkVSU0lPTl9SQVRFUyk7XG52YXIgU1RSX05BTiA9ICdOYU4nO1xuZnVuY3Rpb24gY29udmVydFRvUHgodmFsdWUsIHVuaXQpIHtcbiAgcmV0dXJuIHZhbHVlICogQ09OVkVSU0lPTl9SQVRFU1t1bml0XTtcbn1cbnZhciBEZWNpbWFsQ1NTID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGVjaW1hbENTUyhudW0sIHVuaXQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVjaW1hbENTUyk7XG4gICAgdGhpcy5udW0gPSBudW07XG4gICAgdGhpcy51bml0ID0gdW5pdDtcbiAgICB0aGlzLm51bSA9IG51bTtcbiAgICB0aGlzLnVuaXQgPSB1bml0O1xuICAgIGlmIChOdW1iZXIuaXNOYU4obnVtKSkge1xuICAgICAgdGhpcy51bml0ID0gJyc7XG4gICAgfVxuICAgIGlmICh1bml0ICE9PSAnJyAmJiAhQ1NTX0xFTkdUSF9VTklUX1JFR0VYLnRlc3QodW5pdCkpIHtcbiAgICAgIHRoaXMubnVtID0gTmFOO1xuICAgICAgdGhpcy51bml0ID0gJyc7XG4gICAgfVxuICAgIGlmIChGSVhFRF9DU1NfTEVOR1RIX1VOSVRTLmluY2x1ZGVzKHVuaXQpKSB7XG4gICAgICB0aGlzLm51bSA9IGNvbnZlcnRUb1B4KG51bSwgdW5pdCk7XG4gICAgICB0aGlzLnVuaXQgPSAncHgnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKERlY2ltYWxDU1MsIFt7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQob3RoZXIpIHtcbiAgICAgIGlmICh0aGlzLnVuaXQgIT09IG90aGVyLnVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsQ1NTKE5hTiwgJycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsQ1NTKHRoaXMubnVtICsgb3RoZXIubnVtLCB0aGlzLnVuaXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJ0cmFjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgaWYgKHRoaXMudW5pdCAhPT0gb3RoZXIudW5pdCkge1xuICAgICAgICByZXR1cm4gbmV3IERlY2ltYWxDU1MoTmFOLCAnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERlY2ltYWxDU1ModGhpcy5udW0gLSBvdGhlci5udW0sIHRoaXMudW5pdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm11bHRpcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGx5KG90aGVyKSB7XG4gICAgICBpZiAodGhpcy51bml0ICE9PSAnJyAmJiBvdGhlci51bml0ICE9PSAnJyAmJiB0aGlzLnVuaXQgIT09IG90aGVyLnVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsQ1NTKE5hTiwgJycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsQ1NTKHRoaXMubnVtICogb3RoZXIubnVtLCB0aGlzLnVuaXQgfHwgb3RoZXIudW5pdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpdmlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXZpZGUob3RoZXIpIHtcbiAgICAgIGlmICh0aGlzLnVuaXQgIT09ICcnICYmIG90aGVyLnVuaXQgIT09ICcnICYmIHRoaXMudW5pdCAhPT0gb3RoZXIudW5pdCkge1xuICAgICAgICByZXR1cm4gbmV3IERlY2ltYWxDU1MoTmFOLCAnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERlY2ltYWxDU1ModGhpcy5udW0gLyBvdGhlci5udW0sIHRoaXMudW5pdCB8fCBvdGhlci51bml0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5udW0pLmNvbmNhdCh0aGlzLnVuaXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc05hTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc05hTigpIHtcbiAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4odGhpcy5udW0pO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgICAgdmFyIF9OVU1fU1BMSVRfUkVHRVgkZXhlYztcbiAgICAgIHZhciBfcmVmID0gKF9OVU1fU1BMSVRfUkVHRVgkZXhlYyA9IE5VTV9TUExJVF9SRUdFWC5leGVjKHN0cikpICE9PSBudWxsICYmIF9OVU1fU1BMSVRfUkVHRVgkZXhlYyAhPT0gdm9pZCAwID8gX05VTV9TUExJVF9SRUdFWCRleGVjIDogW10sXG4gICAgICAgIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMyksXG4gICAgICAgIG51bVN0ciA9IF9yZWYyWzFdLFxuICAgICAgICB1bml0ID0gX3JlZjJbMl07XG4gICAgICByZXR1cm4gbmV3IERlY2ltYWxDU1MocGFyc2VGbG9hdChudW1TdHIpLCB1bml0ICE9PSBudWxsICYmIHVuaXQgIT09IHZvaWQgMCA/IHVuaXQgOiAnJyk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5mdW5jdGlvbiBjYWxjdWxhdGVBcml0aG1ldGljKGV4cHIpIHtcbiAgaWYgKGV4cHIuaW5jbHVkZXMoU1RSX05BTikpIHtcbiAgICByZXR1cm4gU1RSX05BTjtcbiAgfVxuICB2YXIgbmV3RXhwciA9IGV4cHI7XG4gIHdoaWxlIChuZXdFeHByLmluY2x1ZGVzKCcqJykgfHwgbmV3RXhwci5pbmNsdWRlcygnLycpKSB7XG4gICAgdmFyIF9NVUxUSVBMWV9PUl9ESVZJREVfUjtcbiAgICB2YXIgX3JlZjMgPSAoX01VTFRJUExZX09SX0RJVklERV9SID0gTVVMVElQTFlfT1JfRElWSURFX1JFR0VYLmV4ZWMobmV3RXhwcikpICE9PSBudWxsICYmIF9NVUxUSVBMWV9PUl9ESVZJREVfUiAhPT0gdm9pZCAwID8gX01VTFRJUExZX09SX0RJVklERV9SIDogW10sXG4gICAgICBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCA0KSxcbiAgICAgIGxlZnRPcGVyYW5kID0gX3JlZjRbMV0sXG4gICAgICBvcGVyYXRvciA9IF9yZWY0WzJdLFxuICAgICAgcmlnaHRPcGVyYW5kID0gX3JlZjRbM107XG4gICAgdmFyIGxUcyA9IERlY2ltYWxDU1MucGFyc2UobGVmdE9wZXJhbmQgIT09IG51bGwgJiYgbGVmdE9wZXJhbmQgIT09IHZvaWQgMCA/IGxlZnRPcGVyYW5kIDogJycpO1xuICAgIHZhciByVHMgPSBEZWNpbWFsQ1NTLnBhcnNlKHJpZ2h0T3BlcmFuZCAhPT0gbnVsbCAmJiByaWdodE9wZXJhbmQgIT09IHZvaWQgMCA/IHJpZ2h0T3BlcmFuZCA6ICcnKTtcbiAgICB2YXIgcmVzdWx0ID0gb3BlcmF0b3IgPT09ICcqJyA/IGxUcy5tdWx0aXBseShyVHMpIDogbFRzLmRpdmlkZShyVHMpO1xuICAgIGlmIChyZXN1bHQuaXNOYU4oKSkge1xuICAgICAgcmV0dXJuIFNUUl9OQU47XG4gICAgfVxuICAgIG5ld0V4cHIgPSBuZXdFeHByLnJlcGxhY2UoTVVMVElQTFlfT1JfRElWSURFX1JFR0VYLCByZXN1bHQudG9TdHJpbmcoKSk7XG4gIH1cbiAgd2hpbGUgKG5ld0V4cHIuaW5jbHVkZXMoJysnKSB8fCAvLi1cXGQrKD86XFwuXFxkKyk/Ly50ZXN0KG5ld0V4cHIpKSB7XG4gICAgdmFyIF9BRERfT1JfU1VCVFJBQ1RfUkVHRTtcbiAgICB2YXIgX3JlZjUgPSAoX0FERF9PUl9TVUJUUkFDVF9SRUdFID0gQUREX09SX1NVQlRSQUNUX1JFR0VYLmV4ZWMobmV3RXhwcikpICE9PSBudWxsICYmIF9BRERfT1JfU1VCVFJBQ1RfUkVHRSAhPT0gdm9pZCAwID8gX0FERF9PUl9TVUJUUkFDVF9SRUdFIDogW10sXG4gICAgICBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCA0KSxcbiAgICAgIF9sZWZ0T3BlcmFuZCA9IF9yZWY2WzFdLFxuICAgICAgX29wZXJhdG9yID0gX3JlZjZbMl0sXG4gICAgICBfcmlnaHRPcGVyYW5kID0gX3JlZjZbM107XG4gICAgdmFyIF9sVHMgPSBEZWNpbWFsQ1NTLnBhcnNlKF9sZWZ0T3BlcmFuZCAhPT0gbnVsbCAmJiBfbGVmdE9wZXJhbmQgIT09IHZvaWQgMCA/IF9sZWZ0T3BlcmFuZCA6ICcnKTtcbiAgICB2YXIgX3JUcyA9IERlY2ltYWxDU1MucGFyc2UoX3JpZ2h0T3BlcmFuZCAhPT0gbnVsbCAmJiBfcmlnaHRPcGVyYW5kICE9PSB2b2lkIDAgPyBfcmlnaHRPcGVyYW5kIDogJycpO1xuICAgIHZhciBfcmVzdWx0ID0gX29wZXJhdG9yID09PSAnKycgPyBfbFRzLmFkZChfclRzKSA6IF9sVHMuc3VidHJhY3QoX3JUcyk7XG4gICAgaWYgKF9yZXN1bHQuaXNOYU4oKSkge1xuICAgICAgcmV0dXJuIFNUUl9OQU47XG4gICAgfVxuICAgIG5ld0V4cHIgPSBuZXdFeHByLnJlcGxhY2UoQUREX09SX1NVQlRSQUNUX1JFR0VYLCBfcmVzdWx0LnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBuZXdFeHByO1xufVxudmFyIFBBUkVOVEhFU0VTX1JFR0VYID0gL1xcKChbXigpXSopXFwpLztcbmZ1bmN0aW9uIGNhbGN1bGF0ZVBhcmVudGhlc2VzKGV4cHIpIHtcbiAgdmFyIG5ld0V4cHIgPSBleHByO1xuICB3aGlsZSAobmV3RXhwci5pbmNsdWRlcygnKCcpKSB7XG4gICAgdmFyIF9QQVJFTlRIRVNFU19SRUdFWCRleCA9IFBBUkVOVEhFU0VTX1JFR0VYLmV4ZWMobmV3RXhwciksXG4gICAgICBfUEFSRU5USEVTRVNfUkVHRVgkZXgyID0gX3NsaWNlZFRvQXJyYXkoX1BBUkVOVEhFU0VTX1JFR0VYJGV4LCAyKSxcbiAgICAgIHBhcmVudGhldGljYWxFeHByZXNzaW9uID0gX1BBUkVOVEhFU0VTX1JFR0VYJGV4MlsxXTtcbiAgICBuZXdFeHByID0gbmV3RXhwci5yZXBsYWNlKFBBUkVOVEhFU0VTX1JFR0VYLCBjYWxjdWxhdGVBcml0aG1ldGljKHBhcmVudGhldGljYWxFeHByZXNzaW9uKSk7XG4gIH1cbiAgcmV0dXJuIG5ld0V4cHI7XG59XG5mdW5jdGlvbiBldmFsdWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICB2YXIgbmV3RXhwciA9IGV4cHJlc3Npb24ucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gIG5ld0V4cHIgPSBjYWxjdWxhdGVQYXJlbnRoZXNlcyhuZXdFeHByKTtcbiAgbmV3RXhwciA9IGNhbGN1bGF0ZUFyaXRobWV0aWMobmV3RXhwcik7XG4gIHJldHVybiBuZXdFeHByO1xufVxuZnVuY3Rpb24gc2FmZUV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIFNUUl9OQU47XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZHVjZUNTU0NhbGMoZXhwcmVzc2lvbikge1xuICB2YXIgcmVzdWx0ID0gc2FmZUV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uLnNsaWNlKDUsIC0xKSk7XG4gIGlmIChyZXN1bHQgPT09IFNUUl9OQU4pIHtcbiAgICAvLyBub3RpZnkgdGhlIHVzZXJcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZWR1Y2VDU1NDYWxjIiwic2FmZUV2YWx1YXRlRXhwcmVzc2lvbiIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiaSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibGVuIiwibGVuZ3RoIiwiYXJyMiIsInIiLCJsIiwidCIsImUiLCJ1IiwiYSIsImYiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJpc0FycmF5IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIk1VTFRJUExZX09SX0RJVklERV9SRUdFWCIsIkFERF9PUl9TVUJUUkFDVF9SRUdFWCIsIkNTU19MRU5HVEhfVU5JVF9SRUdFWCIsIk5VTV9TUExJVF9SRUdFWCIsIkNPTlZFUlNJT05fUkFURVMiLCJjbSIsIm1tIiwicHQiLCJwYyIsIlEiLCJweCIsIkZJWEVEX0NTU19MRU5HVEhfVU5JVFMiLCJrZXlzIiwiU1RSX05BTiIsImNvbnZlcnRUb1B4IiwidW5pdCIsIkRlY2ltYWxDU1MiLCJudW0iLCJpc05hTiIsIk5hTiIsImluY2x1ZGVzIiwiYWRkIiwib3RoZXIiLCJzdWJ0cmFjdCIsIm11bHRpcGx5IiwiZGl2aWRlIiwiY29uY2F0IiwicGFyc2UiLCJzdHIiLCJfTlVNX1NQTElUX1JFR0VYJGV4ZWMiLCJfcmVmIiwiZXhlYyIsIl9yZWYyIiwibnVtU3RyIiwicGFyc2VGbG9hdCIsImNhbGN1bGF0ZUFyaXRobWV0aWMiLCJleHByIiwibmV3RXhwciIsIl9NVUxUSVBMWV9PUl9ESVZJREVfUiIsIl9yZWYzIiwiX3JlZjQiLCJsZWZ0T3BlcmFuZCIsIm9wZXJhdG9yIiwicmlnaHRPcGVyYW5kIiwibFRzIiwiclRzIiwicmVzdWx0IiwicmVwbGFjZSIsIl9BRERfT1JfU1VCVFJBQ1RfUkVHRSIsIl9yZWY1IiwiX3JlZjYiLCJfbGVmdE9wZXJhbmQiLCJfb3BlcmF0b3IiLCJfcmlnaHRPcGVyYW5kIiwiX2xUcyIsIl9yVHMiLCJfcmVzdWx0IiwiUEFSRU5USEVTRVNfUkVHRVgiLCJjYWxjdWxhdGVQYXJlbnRoZXNlcyIsIl9QQVJFTlRIRVNFU19SRUdFWCRleCIsIl9QQVJFTlRIRVNFU19SRUdFWCRleDIiLCJwYXJlbnRoZXRpY2FsRXhwcmVzc2lvbiIsImV2YWx1YXRlRXhwcmVzc2lvbiIsImV4cHJlc3Npb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/ReduceCSSCalc.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/ScatterUtils.js":
/*!********************************************************!*\
  !*** ./node_modules/recharts/lib/util/ScatterUtils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ScatterSymbol = ScatterSymbol;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _Symbols = __webpack_require__(/*! ../shape/Symbols */ \"./node_modules/recharts/lib/shape/Symbols.js\");\nvar _ActiveShapeUtils = __webpack_require__(/*! ./ActiveShapeUtils */ \"./node_modules/recharts/lib/util/ActiveShapeUtils.js\");\nvar _excluded = [\n    \"option\",\n    \"isActive\"\n];\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction ScatterSymbol(_ref) {\n    var option = _ref.option, isActive = _ref.isActive, props = _objectWithoutProperties(_ref, _excluded);\n    if (typeof option === \"string\") {\n        return /*#__PURE__*/ _react[\"default\"].createElement(_ActiveShapeUtils.Shape, _extends({\n            option: /*#__PURE__*/ _react[\"default\"].createElement(_Symbols.Symbols, _extends({\n                type: option\n            }, props)),\n            isActive: isActive,\n            shapeType: \"symbols\"\n        }, props));\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(_ActiveShapeUtils.Shape, _extends({\n        option: option,\n        isActive: isActive,\n        shapeType: \"symbols\"\n    }, props));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvU2NhdHRlclV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxxQkFBcUIsR0FBR0U7QUFDeEIsSUFBSUMsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNuRCxJQUFJQyxXQUFXRCxtQkFBT0EsQ0FBQyxzRUFBa0I7QUFDekMsSUFBSUUsb0JBQW9CRixtQkFBT0EsQ0FBQyxnRkFBb0I7QUFDcEQsSUFBSUcsWUFBWTtJQUFDO0lBQVU7Q0FBVztBQUN0QyxTQUFTSix1QkFBdUJLLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEcsU0FBU0U7SUFBYUEsV0FBV2IsT0FBT2MsTUFBTSxHQUFHZCxPQUFPYyxNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUFFLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUFFLElBQUssSUFBSUksT0FBT0QsT0FBUTtnQkFBRSxJQUFJcEIsT0FBT3NCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFFBQVFDLE1BQU07b0JBQUVMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQUU7WUFBRTtRQUFFO1FBQUUsT0FBT0w7SUFBUTtJQUFHLE9BQU9ILFNBQVNZLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQVk7QUFDbFYsU0FBU1EseUJBQXlCTixNQUFNLEVBQUVPLFFBQVE7SUFBSSxJQUFJUCxVQUFVLE1BQU0sT0FBTyxDQUFDO0lBQUcsSUFBSUosU0FBU1ksOEJBQThCUixRQUFRTztJQUFXLElBQUlOLEtBQUtKO0lBQUcsSUFBSWpCLE9BQU82QixxQkFBcUIsRUFBRTtRQUFFLElBQUlDLG1CQUFtQjlCLE9BQU82QixxQkFBcUIsQ0FBQ1Q7UUFBUyxJQUFLSCxJQUFJLEdBQUdBLElBQUlhLGlCQUFpQlgsTUFBTSxFQUFFRixJQUFLO1lBQUVJLE1BQU1TLGdCQUFnQixDQUFDYixFQUFFO1lBQUUsSUFBSVUsU0FBU0ksT0FBTyxDQUFDVixRQUFRLEdBQUc7WUFBVSxJQUFJLENBQUNyQixPQUFPc0IsU0FBUyxDQUFDVSxvQkFBb0IsQ0FBQ1IsSUFBSSxDQUFDSixRQUFRQyxNQUFNO1lBQVVMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7UUFBRTtJQUFFO0lBQUUsT0FBT0w7QUFBUTtBQUMzZSxTQUFTWSw4QkFBOEJSLE1BQU0sRUFBRU8sUUFBUTtJQUFJLElBQUlQLFVBQVUsTUFBTSxPQUFPLENBQUM7SUFBRyxJQUFJSixTQUFTLENBQUM7SUFBRyxJQUFLLElBQUlLLE9BQU9ELE9BQVE7UUFBRSxJQUFJcEIsT0FBT3NCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFFBQVFDLE1BQU07WUFBRSxJQUFJTSxTQUFTSSxPQUFPLENBQUNWLFFBQVEsR0FBRztZQUFVTCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO1FBQUU7SUFBRTtJQUFFLE9BQU9MO0FBQVE7QUFDdFIsU0FBU1osY0FBYzZCLElBQUk7SUFDekIsSUFBSUMsU0FBU0QsS0FBS0MsTUFBTSxFQUN0QkMsV0FBV0YsS0FBS0UsUUFBUSxFQUN4QkMsUUFBUVYseUJBQXlCTyxNQUFNdkI7SUFDekMsSUFBSSxPQUFPd0IsV0FBVyxVQUFVO1FBQzlCLE9BQU8sV0FBVyxHQUFFN0IsTUFBTSxDQUFDLFVBQVUsQ0FBQ2dDLGFBQWEsQ0FBQzVCLGtCQUFrQjZCLEtBQUssRUFBRXpCLFNBQVM7WUFDcEZxQixRQUFRLFdBQVcsR0FBRTdCLE1BQU0sQ0FBQyxVQUFVLENBQUNnQyxhQUFhLENBQUM3QixTQUFTK0IsT0FBTyxFQUFFMUIsU0FBUztnQkFDOUUyQixNQUFNTjtZQUNSLEdBQUdFO1lBQ0hELFVBQVVBO1lBQ1ZNLFdBQVc7UUFDYixHQUFHTDtJQUNMO0lBQ0EsT0FBTyxXQUFXLEdBQUUvQixNQUFNLENBQUMsVUFBVSxDQUFDZ0MsYUFBYSxDQUFDNUIsa0JBQWtCNkIsS0FBSyxFQUFFekIsU0FBUztRQUNwRnFCLFFBQVFBO1FBQ1JDLFVBQVVBO1FBQ1ZNLFdBQVc7SUFDYixHQUFHTDtBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi91dGlsL1NjYXR0ZXJVdGlscy5qcz83ZWIxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5TY2F0dGVyU3ltYm9sID0gU2NhdHRlclN5bWJvbDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX1N5bWJvbHMgPSByZXF1aXJlKFwiLi4vc2hhcGUvU3ltYm9sc1wiKTtcbnZhciBfQWN0aXZlU2hhcGVVdGlscyA9IHJlcXVpcmUoXCIuL0FjdGl2ZVNoYXBlVXRpbHNcIik7XG52YXIgX2V4Y2x1ZGVkID0gW1wib3B0aW9uXCIsIFwiaXNBY3RpdmVcIl07XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIFNjYXR0ZXJTeW1ib2woX3JlZikge1xuICB2YXIgb3B0aW9uID0gX3JlZi5vcHRpb24sXG4gICAgaXNBY3RpdmUgPSBfcmVmLmlzQWN0aXZlLFxuICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG4gIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9BY3RpdmVTaGFwZVV0aWxzLlNoYXBlLCBfZXh0ZW5kcyh7XG4gICAgICBvcHRpb246IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1N5bWJvbHMuU3ltYm9scywgX2V4dGVuZHMoe1xuICAgICAgICB0eXBlOiBvcHRpb25cbiAgICAgIH0sIHByb3BzKSksXG4gICAgICBpc0FjdGl2ZTogaXNBY3RpdmUsXG4gICAgICBzaGFwZVR5cGU6IFwic3ltYm9sc1wiXG4gICAgfSwgcHJvcHMpKTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfQWN0aXZlU2hhcGVVdGlscy5TaGFwZSwgX2V4dGVuZHMoe1xuICAgIG9wdGlvbjogb3B0aW9uLFxuICAgIGlzQWN0aXZlOiBpc0FjdGl2ZSxcbiAgICBzaGFwZVR5cGU6IFwic3ltYm9sc1wiXG4gIH0sIHByb3BzKSk7XG59Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU2NhdHRlclN5bWJvbCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX1N5bWJvbHMiLCJfQWN0aXZlU2hhcGVVdGlscyIsIl9leGNsdWRlZCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9yZWYiLCJvcHRpb24iLCJpc0FjdGl2ZSIsInByb3BzIiwiY3JlYXRlRWxlbWVudCIsIlNoYXBlIiwiU3ltYm9scyIsInR5cGUiLCJzaGFwZVR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/ScatterUtils.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/ShallowEqual.js":
/*!********************************************************!*\
  !*** ./node_modules/recharts/lib/util/ShallowEqual.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.shallowEqual = shallowEqual;\nfunction shallowEqual(a, b) {\n    /* eslint-disable no-restricted-syntax */ for(var key in a){\n        if (({}).hasOwnProperty.call(a, key) && (!({}).hasOwnProperty.call(b, key) || a[key] !== b[key])) {\n            return false;\n        }\n    }\n    for(var _key in b){\n        if (({}).hasOwnProperty.call(b, _key) && !({}).hasOwnProperty.call(a, _key)) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvU2hhbGxvd0VxdWFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxvQkFBb0IsR0FBR0U7QUFDdkIsU0FBU0EsYUFBYUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3hCLHVDQUF1QyxHQUN2QyxJQUFLLElBQUlDLE9BQU9GLEVBQUc7UUFDakIsSUFBSSxFQUFDLEdBQUVHLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixHQUFHRSxRQUFTLEVBQUMsRUFBQyxHQUFFQyxjQUFjLENBQUNDLElBQUksQ0FBQ0gsR0FBR0MsUUFBUUYsQ0FBQyxDQUFDRSxJQUFJLEtBQUtELENBQUMsQ0FBQ0MsSUFBSSxHQUFHO1lBQzVGLE9BQU87UUFDVDtJQUNGO0lBQ0EsSUFBSyxJQUFJRyxRQUFRSixFQUFHO1FBQ2xCLElBQUksRUFBQyxHQUFFRSxjQUFjLENBQUNDLElBQUksQ0FBQ0gsR0FBR0ksU0FBUyxDQUFDLEVBQUMsR0FBRUYsY0FBYyxDQUFDQyxJQUFJLENBQUNKLEdBQUdLLE9BQU87WUFDdkUsT0FBTztRQUNUO0lBQ0Y7SUFDQSxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvU2hhbGxvd0VxdWFsLmpzPzQxODMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNoYWxsb3dFcXVhbCA9IHNoYWxsb3dFcXVhbDtcbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChhLCBiKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG4gIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYSwga2V5KSAmJiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5KSB8fCBhW2tleV0gIT09IGJba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgX2tleSBpbiBiKSB7XG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYiwgX2tleSkgJiYgIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYSwgX2tleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2hhbGxvd0VxdWFsIiwiYSIsImIiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfa2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/ShallowEqual.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/TickUtils.js":
/*!*****************************************************!*\
  !*** ./node_modules/recharts/lib/util/TickUtils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getAngledTickWidth = getAngledTickWidth;\nexports.getNumberIntervalTicks = getNumberIntervalTicks;\nexports.getTickBoundaries = getTickBoundaries;\nexports.isVisible = isVisible;\nvar _CartesianUtils = __webpack_require__(/*! ./CartesianUtils */ \"./node_modules/recharts/lib/util/CartesianUtils.js\");\nvar _getEveryNthWithCondition = __webpack_require__(/*! ./getEveryNthWithCondition */ \"./node_modules/recharts/lib/util/getEveryNthWithCondition.js\");\nfunction getAngledTickWidth(contentSize, unitSize, angle) {\n    var size = {\n        width: contentSize.width + unitSize.width,\n        height: contentSize.height + unitSize.height\n    };\n    return (0, _CartesianUtils.getAngledRectangleWidth)(size, angle);\n}\nfunction getTickBoundaries(viewBox, sign, sizeKey) {\n    var isWidth = sizeKey === \"width\";\n    var x = viewBox.x, y = viewBox.y, width = viewBox.width, height = viewBox.height;\n    if (sign === 1) {\n        return {\n            start: isWidth ? x : y,\n            end: isWidth ? x + width : y + height\n        };\n    }\n    return {\n        start: isWidth ? x + width : y + height,\n        end: isWidth ? x : y\n    };\n}\nfunction isVisible(sign, tickPosition, getSize, start, end) {\n    /* Since getSize() is expensive (it reads the ticks' size from the DOM), we do this check first to avoid calculating\n   * the tick's size. */ if (sign * tickPosition < sign * start || sign * tickPosition > sign * end) {\n        return false;\n    }\n    var size = getSize();\n    return sign * (tickPosition - sign * size / 2 - start) >= 0 && sign * (tickPosition + sign * size / 2 - end) <= 0;\n}\nfunction getNumberIntervalTicks(ticks, interval) {\n    return (0, _getEveryNthWithCondition.getEveryNthWithCondition)(ticks, interval + 1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvVGlja1V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCwwQkFBMEIsR0FBR0U7QUFDN0JGLDhCQUE4QixHQUFHRztBQUNqQ0gseUJBQXlCLEdBQUdJO0FBQzVCSixpQkFBaUIsR0FBR0s7QUFDcEIsSUFBSUMsa0JBQWtCQyxtQkFBT0EsQ0FBQyw0RUFBa0I7QUFDaEQsSUFBSUMsNEJBQTRCRCxtQkFBT0EsQ0FBQyxnR0FBNEI7QUFDcEUsU0FBU0wsbUJBQW1CTyxXQUFXLEVBQUVDLFFBQVEsRUFBRUMsS0FBSztJQUN0RCxJQUFJQyxPQUFPO1FBQ1RDLE9BQU9KLFlBQVlJLEtBQUssR0FBR0gsU0FBU0csS0FBSztRQUN6Q0MsUUFBUUwsWUFBWUssTUFBTSxHQUFHSixTQUFTSSxNQUFNO0lBQzlDO0lBQ0EsT0FBTyxDQUFDLEdBQUdSLGdCQUFnQlMsdUJBQXVCLEVBQUVILE1BQU1EO0FBQzVEO0FBQ0EsU0FBU1Asa0JBQWtCWSxPQUFPLEVBQUVDLElBQUksRUFBRUMsT0FBTztJQUMvQyxJQUFJQyxVQUFVRCxZQUFZO0lBQzFCLElBQUlFLElBQUlKLFFBQVFJLENBQUMsRUFDZkMsSUFBSUwsUUFBUUssQ0FBQyxFQUNiUixRQUFRRyxRQUFRSCxLQUFLLEVBQ3JCQyxTQUFTRSxRQUFRRixNQUFNO0lBQ3pCLElBQUlHLFNBQVMsR0FBRztRQUNkLE9BQU87WUFDTEssT0FBT0gsVUFBVUMsSUFBSUM7WUFDckJFLEtBQUtKLFVBQVVDLElBQUlQLFFBQVFRLElBQUlQO1FBQ2pDO0lBQ0Y7SUFDQSxPQUFPO1FBQ0xRLE9BQU9ILFVBQVVDLElBQUlQLFFBQVFRLElBQUlQO1FBQ2pDUyxLQUFLSixVQUFVQyxJQUFJQztJQUNyQjtBQUNGO0FBQ0EsU0FBU2hCLFVBQVVZLElBQUksRUFBRU8sWUFBWSxFQUFFQyxPQUFPLEVBQUVILEtBQUssRUFBRUMsR0FBRztJQUN4RDtzQkFDb0IsR0FDcEIsSUFBSU4sT0FBT08sZUFBZVAsT0FBT0ssU0FBU0wsT0FBT08sZUFBZVAsT0FBT00sS0FBSztRQUMxRSxPQUFPO0lBQ1Q7SUFDQSxJQUFJWCxPQUFPYTtJQUNYLE9BQU9SLE9BQVFPLENBQUFBLGVBQWVQLE9BQU9MLE9BQU8sSUFBSVUsS0FBSSxLQUFNLEtBQUtMLE9BQVFPLENBQUFBLGVBQWVQLE9BQU9MLE9BQU8sSUFBSVcsR0FBRSxLQUFNO0FBQ2xIO0FBQ0EsU0FBU3BCLHVCQUF1QnVCLEtBQUssRUFBRUMsUUFBUTtJQUM3QyxPQUFPLENBQUMsR0FBR25CLDBCQUEwQm9CLHdCQUF3QixFQUFFRixPQUFPQyxXQUFXO0FBQ25GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi91dGlsL1RpY2tVdGlscy5qcz80YjU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRBbmdsZWRUaWNrV2lkdGggPSBnZXRBbmdsZWRUaWNrV2lkdGg7XG5leHBvcnRzLmdldE51bWJlckludGVydmFsVGlja3MgPSBnZXROdW1iZXJJbnRlcnZhbFRpY2tzO1xuZXhwb3J0cy5nZXRUaWNrQm91bmRhcmllcyA9IGdldFRpY2tCb3VuZGFyaWVzO1xuZXhwb3J0cy5pc1Zpc2libGUgPSBpc1Zpc2libGU7XG52YXIgX0NhcnRlc2lhblV0aWxzID0gcmVxdWlyZShcIi4vQ2FydGVzaWFuVXRpbHNcIik7XG52YXIgX2dldEV2ZXJ5TnRoV2l0aENvbmRpdGlvbiA9IHJlcXVpcmUoXCIuL2dldEV2ZXJ5TnRoV2l0aENvbmRpdGlvblwiKTtcbmZ1bmN0aW9uIGdldEFuZ2xlZFRpY2tXaWR0aChjb250ZW50U2l6ZSwgdW5pdFNpemUsIGFuZ2xlKSB7XG4gIHZhciBzaXplID0ge1xuICAgIHdpZHRoOiBjb250ZW50U2l6ZS53aWR0aCArIHVuaXRTaXplLndpZHRoLFxuICAgIGhlaWdodDogY29udGVudFNpemUuaGVpZ2h0ICsgdW5pdFNpemUuaGVpZ2h0XG4gIH07XG4gIHJldHVybiAoMCwgX0NhcnRlc2lhblV0aWxzLmdldEFuZ2xlZFJlY3RhbmdsZVdpZHRoKShzaXplLCBhbmdsZSk7XG59XG5mdW5jdGlvbiBnZXRUaWNrQm91bmRhcmllcyh2aWV3Qm94LCBzaWduLCBzaXplS2V5KSB7XG4gIHZhciBpc1dpZHRoID0gc2l6ZUtleSA9PT0gJ3dpZHRoJztcbiAgdmFyIHggPSB2aWV3Qm94LngsXG4gICAgeSA9IHZpZXdCb3gueSxcbiAgICB3aWR0aCA9IHZpZXdCb3gud2lkdGgsXG4gICAgaGVpZ2h0ID0gdmlld0JveC5oZWlnaHQ7XG4gIGlmIChzaWduID09PSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBpc1dpZHRoID8geCA6IHksXG4gICAgICBlbmQ6IGlzV2lkdGggPyB4ICsgd2lkdGggOiB5ICsgaGVpZ2h0XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBpc1dpZHRoID8geCArIHdpZHRoIDogeSArIGhlaWdodCxcbiAgICBlbmQ6IGlzV2lkdGggPyB4IDogeVxuICB9O1xufVxuZnVuY3Rpb24gaXNWaXNpYmxlKHNpZ24sIHRpY2tQb3NpdGlvbiwgZ2V0U2l6ZSwgc3RhcnQsIGVuZCkge1xuICAvKiBTaW5jZSBnZXRTaXplKCkgaXMgZXhwZW5zaXZlIChpdCByZWFkcyB0aGUgdGlja3MnIHNpemUgZnJvbSB0aGUgRE9NKSwgd2UgZG8gdGhpcyBjaGVjayBmaXJzdCB0byBhdm9pZCBjYWxjdWxhdGluZ1xuICAgKiB0aGUgdGljaydzIHNpemUuICovXG4gIGlmIChzaWduICogdGlja1Bvc2l0aW9uIDwgc2lnbiAqIHN0YXJ0IHx8IHNpZ24gKiB0aWNrUG9zaXRpb24gPiBzaWduICogZW5kKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzaXplID0gZ2V0U2l6ZSgpO1xuICByZXR1cm4gc2lnbiAqICh0aWNrUG9zaXRpb24gLSBzaWduICogc2l6ZSAvIDIgLSBzdGFydCkgPj0gMCAmJiBzaWduICogKHRpY2tQb3NpdGlvbiArIHNpZ24gKiBzaXplIC8gMiAtIGVuZCkgPD0gMDtcbn1cbmZ1bmN0aW9uIGdldE51bWJlckludGVydmFsVGlja3ModGlja3MsIGludGVydmFsKSB7XG4gIHJldHVybiAoMCwgX2dldEV2ZXJ5TnRoV2l0aENvbmRpdGlvbi5nZXRFdmVyeU50aFdpdGhDb25kaXRpb24pKHRpY2tzLCBpbnRlcnZhbCArIDEpO1xufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEFuZ2xlZFRpY2tXaWR0aCIsImdldE51bWJlckludGVydmFsVGlja3MiLCJnZXRUaWNrQm91bmRhcmllcyIsImlzVmlzaWJsZSIsIl9DYXJ0ZXNpYW5VdGlscyIsInJlcXVpcmUiLCJfZ2V0RXZlcnlOdGhXaXRoQ29uZGl0aW9uIiwiY29udGVudFNpemUiLCJ1bml0U2l6ZSIsImFuZ2xlIiwic2l6ZSIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0QW5nbGVkUmVjdGFuZ2xlV2lkdGgiLCJ2aWV3Qm94Iiwic2lnbiIsInNpemVLZXkiLCJpc1dpZHRoIiwieCIsInkiLCJzdGFydCIsImVuZCIsInRpY2tQb3NpdGlvbiIsImdldFNpemUiLCJ0aWNrcyIsImludGVydmFsIiwiZ2V0RXZlcnlOdGhXaXRoQ29uZGl0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/TickUtils.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/calculateViewBox.js":
/*!************************************************************!*\
  !*** ./node_modules/recharts/lib/util/calculateViewBox.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.calculateViewBox = void 0;\nvar _memoize = _interopRequireDefault(__webpack_require__(/*! lodash/memoize */ \"lodash/memoize\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\n/**\n * This is memoized because the viewBox is unlikely to change often\n * - but because it is computed from offset, any change to it would re-render all children.\n *\n * And because we have many readers of the viewBox, and update it only rarely,\n * then let's optimize with memoization.\n */ var calculateViewBox = exports.calculateViewBox = (0, _memoize[\"default\"])(function(offset) {\n    return {\n        x: offset.left,\n        y: offset.top,\n        width: offset.width,\n        height: offset.height\n    };\n}, function(offset) {\n    return [\n        \"l\",\n        offset.left,\n        \"t\",\n        offset.top,\n        \"w\",\n        offset.width,\n        \"h\",\n        offset.height\n    ].join(\"\");\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvY2FsY3VsYXRlVmlld0JveC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsd0JBQXdCLEdBQUcsS0FBSztBQUNoQyxJQUFJRyxXQUFXQyx1QkFBdUJDLG1CQUFPQSxDQUFDLHNDQUFnQjtBQUM5RCxTQUFTRCx1QkFBdUJFLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFDaEc7Ozs7OztDQU1DLEdBQ0QsSUFBSUosbUJBQW1CRix3QkFBd0IsR0FBRyxDQUFDLEdBQUdHLFFBQVEsQ0FBQyxVQUFVLEVBQUUsU0FBVUssTUFBTTtJQUN6RixPQUFPO1FBQ0xDLEdBQUdELE9BQU9FLElBQUk7UUFDZEMsR0FBR0gsT0FBT0ksR0FBRztRQUNiQyxPQUFPTCxPQUFPSyxLQUFLO1FBQ25CQyxRQUFRTixPQUFPTSxNQUFNO0lBQ3ZCO0FBQ0YsR0FBRyxTQUFVTixNQUFNO0lBQ2pCLE9BQU87UUFBQztRQUFLQSxPQUFPRSxJQUFJO1FBQUU7UUFBS0YsT0FBT0ksR0FBRztRQUFFO1FBQUtKLE9BQU9LLEtBQUs7UUFBRTtRQUFLTCxPQUFPTSxNQUFNO0tBQUMsQ0FBQ0MsSUFBSSxDQUFDO0FBQ3pGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi91dGlsL2NhbGN1bGF0ZVZpZXdCb3guanM/ZDI3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2FsY3VsYXRlVmlld0JveCA9IHZvaWQgMDtcbnZhciBfbWVtb2l6ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9tZW1vaXplXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuLyoqXG4gKiBUaGlzIGlzIG1lbW9pemVkIGJlY2F1c2UgdGhlIHZpZXdCb3ggaXMgdW5saWtlbHkgdG8gY2hhbmdlIG9mdGVuXG4gKiAtIGJ1dCBiZWNhdXNlIGl0IGlzIGNvbXB1dGVkIGZyb20gb2Zmc2V0LCBhbnkgY2hhbmdlIHRvIGl0IHdvdWxkIHJlLXJlbmRlciBhbGwgY2hpbGRyZW4uXG4gKlxuICogQW5kIGJlY2F1c2Ugd2UgaGF2ZSBtYW55IHJlYWRlcnMgb2YgdGhlIHZpZXdCb3gsIGFuZCB1cGRhdGUgaXQgb25seSByYXJlbHksXG4gKiB0aGVuIGxldCdzIG9wdGltaXplIHdpdGggbWVtb2l6YXRpb24uXG4gKi9cbnZhciBjYWxjdWxhdGVWaWV3Qm94ID0gZXhwb3J0cy5jYWxjdWxhdGVWaWV3Qm94ID0gKDAsIF9tZW1vaXplW1wiZGVmYXVsdFwiXSkoZnVuY3Rpb24gKG9mZnNldCkge1xuICByZXR1cm4ge1xuICAgIHg6IG9mZnNldC5sZWZ0LFxuICAgIHk6IG9mZnNldC50b3AsXG4gICAgd2lkdGg6IG9mZnNldC53aWR0aCxcbiAgICBoZWlnaHQ6IG9mZnNldC5oZWlnaHRcbiAgfTtcbn0sIGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgcmV0dXJuIFsnbCcsIG9mZnNldC5sZWZ0LCAndCcsIG9mZnNldC50b3AsICd3Jywgb2Zmc2V0LndpZHRoLCAnaCcsIG9mZnNldC5oZWlnaHRdLmpvaW4oJycpO1xufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY2FsY3VsYXRlVmlld0JveCIsIl9tZW1vaXplIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJvYmoiLCJfX2VzTW9kdWxlIiwib2Zmc2V0IiwieCIsImxlZnQiLCJ5IiwidG9wIiwid2lkdGgiLCJoZWlnaHQiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/calculateViewBox.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/cursor/getCursorPoints.js":
/*!******************************************************************!*\
  !*** ./node_modules/recharts/lib/util/cursor/getCursorPoints.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getCursorPoints = getCursorPoints;\nvar _PolarUtils = __webpack_require__(/*! ../PolarUtils */ \"./node_modules/recharts/lib/util/PolarUtils.js\");\nvar _getRadialCursorPoints = __webpack_require__(/*! ./getRadialCursorPoints */ \"./node_modules/recharts/lib/util/cursor/getRadialCursorPoints.js\");\nfunction getCursorPoints(layout, activeCoordinate, offset) {\n    var x1, y1, x2, y2;\n    if (layout === \"horizontal\") {\n        x1 = activeCoordinate.x;\n        x2 = x1;\n        y1 = offset.top;\n        y2 = offset.top + offset.height;\n    } else if (layout === \"vertical\") {\n        y1 = activeCoordinate.y;\n        y2 = y1;\n        x1 = offset.left;\n        x2 = offset.left + offset.width;\n    } else if (activeCoordinate.cx != null && activeCoordinate.cy != null) {\n        if (layout === \"centric\") {\n            var cx = activeCoordinate.cx, cy = activeCoordinate.cy, innerRadius = activeCoordinate.innerRadius, outerRadius = activeCoordinate.outerRadius, angle = activeCoordinate.angle;\n            var innerPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, innerRadius, angle);\n            var outerPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, outerRadius, angle);\n            x1 = innerPoint.x;\n            y1 = innerPoint.y;\n            x2 = outerPoint.x;\n            y2 = outerPoint.y;\n        } else {\n            return (0, _getRadialCursorPoints.getRadialCursorPoints)(activeCoordinate);\n        }\n    }\n    return [\n        {\n            x: x1,\n            y: y1\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvY3Vyc29yL2dldEN1cnNvclBvaW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsdUJBQXVCLEdBQUdFO0FBQzFCLElBQUlDLGNBQWNDLG1CQUFPQSxDQUFDLHFFQUFlO0FBQ3pDLElBQUlDLHlCQUF5QkQsbUJBQU9BLENBQUMsaUdBQXlCO0FBQzlELFNBQVNGLGdCQUFnQkksTUFBTSxFQUFFQyxnQkFBZ0IsRUFBRUMsTUFBTTtJQUN2RCxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztJQUNoQixJQUFJTixXQUFXLGNBQWM7UUFDM0JHLEtBQUtGLGlCQUFpQk0sQ0FBQztRQUN2QkYsS0FBS0Y7UUFDTEMsS0FBS0YsT0FBT00sR0FBRztRQUNmRixLQUFLSixPQUFPTSxHQUFHLEdBQUdOLE9BQU9PLE1BQU07SUFDakMsT0FBTyxJQUFJVCxXQUFXLFlBQVk7UUFDaENJLEtBQUtILGlCQUFpQlMsQ0FBQztRQUN2QkosS0FBS0Y7UUFDTEQsS0FBS0QsT0FBT1MsSUFBSTtRQUNoQk4sS0FBS0gsT0FBT1MsSUFBSSxHQUFHVCxPQUFPVSxLQUFLO0lBQ2pDLE9BQU8sSUFBSVgsaUJBQWlCWSxFQUFFLElBQUksUUFBUVosaUJBQWlCYSxFQUFFLElBQUksTUFBTTtRQUNyRSxJQUFJZCxXQUFXLFdBQVc7WUFDeEIsSUFBSWEsS0FBS1osaUJBQWlCWSxFQUFFLEVBQzFCQyxLQUFLYixpQkFBaUJhLEVBQUUsRUFDeEJDLGNBQWNkLGlCQUFpQmMsV0FBVyxFQUMxQ0MsY0FBY2YsaUJBQWlCZSxXQUFXLEVBQzFDQyxRQUFRaEIsaUJBQWlCZ0IsS0FBSztZQUNoQyxJQUFJQyxhQUFhLENBQUMsR0FBR3JCLFlBQVlzQixnQkFBZ0IsRUFBRU4sSUFBSUMsSUFBSUMsYUFBYUU7WUFDeEUsSUFBSUcsYUFBYSxDQUFDLEdBQUd2QixZQUFZc0IsZ0JBQWdCLEVBQUVOLElBQUlDLElBQUlFLGFBQWFDO1lBQ3hFZCxLQUFLZSxXQUFXWCxDQUFDO1lBQ2pCSCxLQUFLYyxXQUFXUixDQUFDO1lBQ2pCTCxLQUFLZSxXQUFXYixDQUFDO1lBQ2pCRCxLQUFLYyxXQUFXVixDQUFDO1FBQ25CLE9BQU87WUFDTCxPQUFPLENBQUMsR0FBR1gsdUJBQXVCc0IscUJBQXFCLEVBQUVwQjtRQUMzRDtJQUNGO0lBQ0EsT0FBTztRQUFDO1lBQ05NLEdBQUdKO1lBQ0hPLEdBQUdOO1FBQ0w7UUFBRztZQUNERyxHQUFHRjtZQUNISyxHQUFHSjtRQUNMO0tBQUU7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9jdXJzb3IvZ2V0Q3Vyc29yUG9pbnRzLmpzPzE4N2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldEN1cnNvclBvaW50cyA9IGdldEN1cnNvclBvaW50cztcbnZhciBfUG9sYXJVdGlscyA9IHJlcXVpcmUoXCIuLi9Qb2xhclV0aWxzXCIpO1xudmFyIF9nZXRSYWRpYWxDdXJzb3JQb2ludHMgPSByZXF1aXJlKFwiLi9nZXRSYWRpYWxDdXJzb3JQb2ludHNcIik7XG5mdW5jdGlvbiBnZXRDdXJzb3JQb2ludHMobGF5b3V0LCBhY3RpdmVDb29yZGluYXRlLCBvZmZzZXQpIHtcbiAgdmFyIHgxLCB5MSwgeDIsIHkyO1xuICBpZiAobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICB4MSA9IGFjdGl2ZUNvb3JkaW5hdGUueDtcbiAgICB4MiA9IHgxO1xuICAgIHkxID0gb2Zmc2V0LnRvcDtcbiAgICB5MiA9IG9mZnNldC50b3AgKyBvZmZzZXQuaGVpZ2h0O1xuICB9IGVsc2UgaWYgKGxheW91dCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgIHkxID0gYWN0aXZlQ29vcmRpbmF0ZS55O1xuICAgIHkyID0geTE7XG4gICAgeDEgPSBvZmZzZXQubGVmdDtcbiAgICB4MiA9IG9mZnNldC5sZWZ0ICsgb2Zmc2V0LndpZHRoO1xuICB9IGVsc2UgaWYgKGFjdGl2ZUNvb3JkaW5hdGUuY3ggIT0gbnVsbCAmJiBhY3RpdmVDb29yZGluYXRlLmN5ICE9IG51bGwpIHtcbiAgICBpZiAobGF5b3V0ID09PSAnY2VudHJpYycpIHtcbiAgICAgIHZhciBjeCA9IGFjdGl2ZUNvb3JkaW5hdGUuY3gsXG4gICAgICAgIGN5ID0gYWN0aXZlQ29vcmRpbmF0ZS5jeSxcbiAgICAgICAgaW5uZXJSYWRpdXMgPSBhY3RpdmVDb29yZGluYXRlLmlubmVyUmFkaXVzLFxuICAgICAgICBvdXRlclJhZGl1cyA9IGFjdGl2ZUNvb3JkaW5hdGUub3V0ZXJSYWRpdXMsXG4gICAgICAgIGFuZ2xlID0gYWN0aXZlQ29vcmRpbmF0ZS5hbmdsZTtcbiAgICAgIHZhciBpbm5lclBvaW50ID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgaW5uZXJSYWRpdXMsIGFuZ2xlKTtcbiAgICAgIHZhciBvdXRlclBvaW50ID0gKDAsIF9Qb2xhclV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4pKGN4LCBjeSwgb3V0ZXJSYWRpdXMsIGFuZ2xlKTtcbiAgICAgIHgxID0gaW5uZXJQb2ludC54O1xuICAgICAgeTEgPSBpbm5lclBvaW50Lnk7XG4gICAgICB4MiA9IG91dGVyUG9pbnQueDtcbiAgICAgIHkyID0gb3V0ZXJQb2ludC55O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9nZXRSYWRpYWxDdXJzb3JQb2ludHMuZ2V0UmFkaWFsQ3Vyc29yUG9pbnRzKShhY3RpdmVDb29yZGluYXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFt7XG4gICAgeDogeDEsXG4gICAgeTogeTFcbiAgfSwge1xuICAgIHg6IHgyLFxuICAgIHk6IHkyXG4gIH1dO1xufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEN1cnNvclBvaW50cyIsIl9Qb2xhclV0aWxzIiwicmVxdWlyZSIsIl9nZXRSYWRpYWxDdXJzb3JQb2ludHMiLCJsYXlvdXQiLCJhY3RpdmVDb29yZGluYXRlIiwib2Zmc2V0IiwieDEiLCJ5MSIsIngyIiwieTIiLCJ4IiwidG9wIiwiaGVpZ2h0IiwieSIsImxlZnQiLCJ3aWR0aCIsImN4IiwiY3kiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwiYW5nbGUiLCJpbm5lclBvaW50IiwicG9sYXJUb0NhcnRlc2lhbiIsIm91dGVyUG9pbnQiLCJnZXRSYWRpYWxDdXJzb3JQb2ludHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/cursor/getCursorPoints.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/cursor/getCursorRectangle.js":
/*!*********************************************************************!*\
  !*** ./node_modules/recharts/lib/util/cursor/getCursorRectangle.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getCursorRectangle = getCursorRectangle;\nfunction getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize) {\n    var halfSize = tooltipAxisBandSize / 2;\n    return {\n        stroke: \"none\",\n        fill: \"#ccc\",\n        x: layout === \"horizontal\" ? activeCoordinate.x - halfSize : offset.left + 0.5,\n        y: layout === \"horizontal\" ? offset.top + 0.5 : activeCoordinate.y - halfSize,\n        width: layout === \"horizontal\" ? tooltipAxisBandSize : offset.width - 1,\n        height: layout === \"horizontal\" ? offset.height - 1 : tooltipAxisBandSize\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvY3Vyc29yL2dldEN1cnNvclJlY3RhbmdsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsMEJBQTBCLEdBQUdFO0FBQzdCLFNBQVNBLG1CQUFtQkMsTUFBTSxFQUFFQyxnQkFBZ0IsRUFBRUMsTUFBTSxFQUFFQyxtQkFBbUI7SUFDL0UsSUFBSUMsV0FBV0Qsc0JBQXNCO0lBQ3JDLE9BQU87UUFDTEUsUUFBUTtRQUNSQyxNQUFNO1FBQ05DLEdBQUdQLFdBQVcsZUFBZUMsaUJBQWlCTSxDQUFDLEdBQUdILFdBQVdGLE9BQU9NLElBQUksR0FBRztRQUMzRUMsR0FBR1QsV0FBVyxlQUFlRSxPQUFPUSxHQUFHLEdBQUcsTUFBTVQsaUJBQWlCUSxDQUFDLEdBQUdMO1FBQ3JFTyxPQUFPWCxXQUFXLGVBQWVHLHNCQUFzQkQsT0FBT1MsS0FBSyxHQUFHO1FBQ3RFQyxRQUFRWixXQUFXLGVBQWVFLE9BQU9VLE1BQU0sR0FBRyxJQUFJVDtJQUN4RDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi91dGlsL2N1cnNvci9nZXRDdXJzb3JSZWN0YW5nbGUuanM/ZDQzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0Q3Vyc29yUmVjdGFuZ2xlID0gZ2V0Q3Vyc29yUmVjdGFuZ2xlO1xuZnVuY3Rpb24gZ2V0Q3Vyc29yUmVjdGFuZ2xlKGxheW91dCwgYWN0aXZlQ29vcmRpbmF0ZSwgb2Zmc2V0LCB0b29sdGlwQXhpc0JhbmRTaXplKSB7XG4gIHZhciBoYWxmU2l6ZSA9IHRvb2x0aXBBeGlzQmFuZFNpemUgLyAyO1xuICByZXR1cm4ge1xuICAgIHN0cm9rZTogJ25vbmUnLFxuICAgIGZpbGw6ICcjY2NjJyxcbiAgICB4OiBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IGFjdGl2ZUNvb3JkaW5hdGUueCAtIGhhbGZTaXplIDogb2Zmc2V0LmxlZnQgKyAwLjUsXG4gICAgeTogbGF5b3V0ID09PSAnaG9yaXpvbnRhbCcgPyBvZmZzZXQudG9wICsgMC41IDogYWN0aXZlQ29vcmRpbmF0ZS55IC0gaGFsZlNpemUsXG4gICAgd2lkdGg6IGxheW91dCA9PT0gJ2hvcml6b250YWwnID8gdG9vbHRpcEF4aXNCYW5kU2l6ZSA6IG9mZnNldC53aWR0aCAtIDEsXG4gICAgaGVpZ2h0OiBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IG9mZnNldC5oZWlnaHQgLSAxIDogdG9vbHRpcEF4aXNCYW5kU2l6ZVxuICB9O1xufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEN1cnNvclJlY3RhbmdsZSIsImxheW91dCIsImFjdGl2ZUNvb3JkaW5hdGUiLCJvZmZzZXQiLCJ0b29sdGlwQXhpc0JhbmRTaXplIiwiaGFsZlNpemUiLCJzdHJva2UiLCJmaWxsIiwieCIsImxlZnQiLCJ5IiwidG9wIiwid2lkdGgiLCJoZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/cursor/getCursorRectangle.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/cursor/getRadialCursorPoints.js":
/*!************************************************************************!*\
  !*** ./node_modules/recharts/lib/util/cursor/getRadialCursorPoints.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getRadialCursorPoints = getRadialCursorPoints;\nvar _PolarUtils = __webpack_require__(/*! ../PolarUtils */ \"./node_modules/recharts/lib/util/PolarUtils.js\");\n/**\n * Only applicable for radial layouts\n * @param {Object} activeCoordinate ChartCoordinate\n * @returns {Object} RadialCursorPoints\n */ function getRadialCursorPoints(activeCoordinate) {\n    var cx = activeCoordinate.cx, cy = activeCoordinate.cy, radius = activeCoordinate.radius, startAngle = activeCoordinate.startAngle, endAngle = activeCoordinate.endAngle;\n    var startPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, startAngle);\n    var endPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, endAngle);\n    return {\n        points: [\n            startPoint,\n            endPoint\n        ],\n        cx: cx,\n        cy: cy,\n        radius: radius,\n        startAngle: startAngle,\n        endAngle: endAngle\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvY3Vyc29yL2dldFJhZGlhbEN1cnNvclBvaW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsNkJBQTZCLEdBQUdFO0FBQ2hDLElBQUlDLGNBQWNDLG1CQUFPQSxDQUFDLHFFQUFlO0FBQ3pDOzs7O0NBSUMsR0FDRCxTQUFTRixzQkFBc0JHLGdCQUFnQjtJQUM3QyxJQUFJQyxLQUFLRCxpQkFBaUJDLEVBQUUsRUFDMUJDLEtBQUtGLGlCQUFpQkUsRUFBRSxFQUN4QkMsU0FBU0gsaUJBQWlCRyxNQUFNLEVBQ2hDQyxhQUFhSixpQkFBaUJJLFVBQVUsRUFDeENDLFdBQVdMLGlCQUFpQkssUUFBUTtJQUN0QyxJQUFJQyxhQUFhLENBQUMsR0FBR1IsWUFBWVMsZ0JBQWdCLEVBQUVOLElBQUlDLElBQUlDLFFBQVFDO0lBQ25FLElBQUlJLFdBQVcsQ0FBQyxHQUFHVixZQUFZUyxnQkFBZ0IsRUFBRU4sSUFBSUMsSUFBSUMsUUFBUUU7SUFDakUsT0FBTztRQUNMSSxRQUFRO1lBQUNIO1lBQVlFO1NBQVM7UUFDOUJQLElBQUlBO1FBQ0pDLElBQUlBO1FBQ0pDLFFBQVFBO1FBQ1JDLFlBQVlBO1FBQ1pDLFVBQVVBO0lBQ1o7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9jdXJzb3IvZ2V0UmFkaWFsQ3Vyc29yUG9pbnRzLmpzPzM5YWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldFJhZGlhbEN1cnNvclBvaW50cyA9IGdldFJhZGlhbEN1cnNvclBvaW50cztcbnZhciBfUG9sYXJVdGlscyA9IHJlcXVpcmUoXCIuLi9Qb2xhclV0aWxzXCIpO1xuLyoqXG4gKiBPbmx5IGFwcGxpY2FibGUgZm9yIHJhZGlhbCBsYXlvdXRzXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aXZlQ29vcmRpbmF0ZSBDaGFydENvb3JkaW5hdGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJhZGlhbEN1cnNvclBvaW50c1xuICovXG5mdW5jdGlvbiBnZXRSYWRpYWxDdXJzb3JQb2ludHMoYWN0aXZlQ29vcmRpbmF0ZSkge1xuICB2YXIgY3ggPSBhY3RpdmVDb29yZGluYXRlLmN4LFxuICAgIGN5ID0gYWN0aXZlQ29vcmRpbmF0ZS5jeSxcbiAgICByYWRpdXMgPSBhY3RpdmVDb29yZGluYXRlLnJhZGl1cyxcbiAgICBzdGFydEFuZ2xlID0gYWN0aXZlQ29vcmRpbmF0ZS5zdGFydEFuZ2xlLFxuICAgIGVuZEFuZ2xlID0gYWN0aXZlQ29vcmRpbmF0ZS5lbmRBbmdsZTtcbiAgdmFyIHN0YXJ0UG9pbnQgPSAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUpO1xuICB2YXIgZW5kUG9pbnQgPSAoMCwgX1BvbGFyVXRpbHMucG9sYXJUb0NhcnRlc2lhbikoY3gsIGN5LCByYWRpdXMsIGVuZEFuZ2xlKTtcbiAgcmV0dXJuIHtcbiAgICBwb2ludHM6IFtzdGFydFBvaW50LCBlbmRQb2ludF0sXG4gICAgY3g6IGN4LFxuICAgIGN5OiBjeSxcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxuICB9O1xufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldFJhZGlhbEN1cnNvclBvaW50cyIsIl9Qb2xhclV0aWxzIiwicmVxdWlyZSIsImFjdGl2ZUNvb3JkaW5hdGUiLCJjeCIsImN5IiwicmFkaXVzIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwic3RhcnRQb2ludCIsInBvbGFyVG9DYXJ0ZXNpYW4iLCJlbmRQb2ludCIsInBvaW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/cursor/getRadialCursorPoints.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/getEveryNthWithCondition.js":
/*!********************************************************************!*\
  !*** ./node_modules/recharts/lib/util/getEveryNthWithCondition.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getEveryNthWithCondition = getEveryNthWithCondition;\n/**\n * Given an array and a number N, return a new array which contains every nTh\n * element of the input array. For n below 1, an empty array is returned.\n * If isValid is provided, all candidates must suffice the condition, else undefined is returned.\n * @param {T[]} array An input array.\n * @param {integer} n A number\n * @param {Function} isValid A function to evaluate a candidate form the array\n * @returns {T[]} The result array of the same type as the input array.\n */ function getEveryNthWithCondition(array, n, isValid) {\n    if (n < 1) {\n        return [];\n    }\n    if (n === 1 && isValid === undefined) {\n        return array;\n    }\n    var result = [];\n    for(var i = 0; i < array.length; i += n){\n        if (isValid === undefined || isValid(array[i]) === true) {\n            result.push(array[i]);\n        } else {\n            return undefined;\n        }\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvZ2V0RXZlcnlOdGhXaXRoQ29uZGl0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxnQ0FBZ0MsR0FBR0U7QUFDbkM7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTQSx5QkFBeUJDLEtBQUssRUFBRUMsQ0FBQyxFQUFFQyxPQUFPO0lBQ2pELElBQUlELElBQUksR0FBRztRQUNULE9BQU8sRUFBRTtJQUNYO0lBQ0EsSUFBSUEsTUFBTSxLQUFLQyxZQUFZQyxXQUFXO1FBQ3BDLE9BQU9IO0lBQ1Q7SUFDQSxJQUFJSSxTQUFTLEVBQUU7SUFDZixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUwsTUFBTU0sTUFBTSxFQUFFRCxLQUFLSixFQUFHO1FBQ3hDLElBQUlDLFlBQVlDLGFBQWFELFFBQVFGLEtBQUssQ0FBQ0ssRUFBRSxNQUFNLE1BQU07WUFDdkRELE9BQU9HLElBQUksQ0FBQ1AsS0FBSyxDQUFDSyxFQUFFO1FBQ3RCLE9BQU87WUFDTCxPQUFPRjtRQUNUO0lBQ0Y7SUFDQSxPQUFPQztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi91dGlsL2dldEV2ZXJ5TnRoV2l0aENvbmRpdGlvbi5qcz80NjhmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRFdmVyeU50aFdpdGhDb25kaXRpb24gPSBnZXRFdmVyeU50aFdpdGhDb25kaXRpb247XG4vKipcbiAqIEdpdmVuIGFuIGFycmF5IGFuZCBhIG51bWJlciBOLCByZXR1cm4gYSBuZXcgYXJyYXkgd2hpY2ggY29udGFpbnMgZXZlcnkgblRoXG4gKiBlbGVtZW50IG9mIHRoZSBpbnB1dCBhcnJheS4gRm9yIG4gYmVsb3cgMSwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQuXG4gKiBJZiBpc1ZhbGlkIGlzIHByb3ZpZGVkLCBhbGwgY2FuZGlkYXRlcyBtdXN0IHN1ZmZpY2UgdGhlIGNvbmRpdGlvbiwgZWxzZSB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1RbXX0gYXJyYXkgQW4gaW5wdXQgYXJyYXkuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG4gQSBudW1iZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGlzVmFsaWQgQSBmdW5jdGlvbiB0byBldmFsdWF0ZSBhIGNhbmRpZGF0ZSBmb3JtIHRoZSBhcnJheVxuICogQHJldHVybnMge1RbXX0gVGhlIHJlc3VsdCBhcnJheSBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBpbnB1dCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlcnlOdGhXaXRoQ29uZGl0aW9uKGFycmF5LCBuLCBpc1ZhbGlkKSB7XG4gIGlmIChuIDwgMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAobiA9PT0gMSAmJiBpc1ZhbGlkID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSBuKSB7XG4gICAgaWYgKGlzVmFsaWQgPT09IHVuZGVmaW5lZCB8fCBpc1ZhbGlkKGFycmF5W2ldKSA9PT0gdHJ1ZSkge1xuICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEV2ZXJ5TnRoV2l0aENvbmRpdGlvbiIsImFycmF5IiwibiIsImlzVmFsaWQiLCJ1bmRlZmluZWQiLCJyZXN1bHQiLCJpIiwibGVuZ3RoIiwicHVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/getEveryNthWithCondition.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/getLegendProps.js":
/*!**********************************************************!*\
  !*** ./node_modules/recharts/lib/util/getLegendProps.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getLegendProps = void 0;\nvar _Legend = __webpack_require__(/*! ../component/Legend */ \"./node_modules/recharts/lib/component/Legend.js\");\nvar _ChartUtils = __webpack_require__(/*! ./ChartUtils */ \"./node_modules/recharts/lib/util/ChartUtils.js\");\nvar _ReactUtils = __webpack_require__(/*! ./ReactUtils */ \"./node_modules/recharts/lib/util/ReactUtils.js\");\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar getLegendProps = exports.getLegendProps = function getLegendProps(_ref) {\n    var children = _ref.children, formattedGraphicalItems = _ref.formattedGraphicalItems, legendWidth = _ref.legendWidth, legendContent = _ref.legendContent;\n    var legendItem = (0, _ReactUtils.findChildByType)(children, _Legend.Legend);\n    if (!legendItem) {\n        return null;\n    }\n    var legendDefaultProps = _Legend.Legend.defaultProps;\n    var legendProps = legendDefaultProps !== undefined ? _objectSpread(_objectSpread({}, legendDefaultProps), legendItem.props) : {};\n    var legendData;\n    if (legendItem.props && legendItem.props.payload) {\n        legendData = legendItem.props && legendItem.props.payload;\n    } else if (legendContent === \"children\") {\n        legendData = (formattedGraphicalItems || []).reduce(function(result, _ref2) {\n            var item = _ref2.item, props = _ref2.props;\n            var data = props.sectors || props.data || [];\n            return result.concat(data.map(function(entry) {\n                return {\n                    type: legendItem.props.iconType || item.props.legendType,\n                    value: entry.name,\n                    color: entry.fill,\n                    payload: entry\n                };\n            }));\n        }, []);\n    } else {\n        legendData = (formattedGraphicalItems || []).map(function(_ref3) {\n            var item = _ref3.item;\n            var itemDefaultProps = item.type.defaultProps;\n            var itemProps = itemDefaultProps !== undefined ? _objectSpread(_objectSpread({}, itemDefaultProps), item.props) : {};\n            var dataKey = itemProps.dataKey, name = itemProps.name, legendType = itemProps.legendType, hide = itemProps.hide;\n            return {\n                inactive: hide,\n                dataKey: dataKey,\n                type: legendProps.iconType || legendType || \"square\",\n                color: (0, _ChartUtils.getMainColorOfGraphicItem)(item),\n                value: name || dataKey,\n                // @ts-expect-error property strokeDasharray is required in Payload but optional in props\n                payload: itemProps\n            };\n        });\n    }\n    return _objectSpread(_objectSpread(_objectSpread({}, legendProps), _Legend.Legend.getWithHeight(legendItem, legendWidth)), {}, {\n        payload: legendData,\n        item: legendItem\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvZ2V0TGVnZW5kUHJvcHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHNCQUFzQixHQUFHLEtBQUs7QUFDOUIsSUFBSUcsVUFBVUMsbUJBQU9BLENBQUMsNEVBQXFCO0FBQzNDLElBQUlDLGNBQWNELG1CQUFPQSxDQUFDLG9FQUFjO0FBQ3hDLElBQUlFLGNBQWNGLG1CQUFPQSxDQUFDLG9FQUFjO0FBQ3hDLFNBQVNHLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSyxRQUFRQyxDQUFDLEVBQUVDLENBQUM7SUFBSSxJQUFJQyxJQUFJbEIsT0FBT21CLElBQUksQ0FBQ0g7SUFBSSxJQUFJaEIsT0FBT29CLHFCQUFxQixFQUFFO1FBQUUsSUFBSVYsSUFBSVYsT0FBT29CLHFCQUFxQixDQUFDSjtRQUFJQyxLQUFNUCxDQUFBQSxJQUFJQSxFQUFFVyxNQUFNLENBQUMsU0FBVUosQ0FBQztZQUFJLE9BQU9qQixPQUFPc0Isd0JBQXdCLENBQUNOLEdBQUdDLEdBQUdNLFVBQVU7UUFBRSxFQUFDLEdBQUlMLEVBQUVNLElBQUksQ0FBQ0MsS0FBSyxDQUFDUCxHQUFHUjtJQUFJO0lBQUUsT0FBT1E7QUFBRztBQUM5UCxTQUFTUSxjQUFjVixDQUFDO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlVLFVBQVVDLE1BQU0sRUFBRVgsSUFBSztRQUFF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QUFVQyxLQUFLO2dCQUMzQyxPQUFPO29CQUNMQyxNQUFNbkIsV0FBV08sS0FBSyxDQUFDYSxRQUFRLElBQUlQLEtBQUtOLEtBQUssQ0FBQ2MsVUFBVTtvQkFDeERwRSxPQUFPaUUsTUFBTUksSUFBSTtvQkFDakJDLE9BQU9MLE1BQU1NLElBQUk7b0JBQ2pCZixTQUFTUztnQkFDWDtZQUNGO1FBQ0YsR0FBRyxFQUFFO0lBQ1AsT0FBTztRQUNMVixhQUFhLENBQUNYLDJCQUEyQixFQUFFLEVBQUVvQixHQUFHLENBQUMsU0FBVVEsS0FBSztZQUM5RCxJQUFJWixPQUFPWSxNQUFNWixJQUFJO1lBQ3JCLElBQUlhLG1CQUFtQmIsS0FBS00sSUFBSSxDQUFDZixZQUFZO1lBQzdDLElBQUl1QixZQUFZRCxxQkFBcUJwQixZQUFZOUIsY0FBY0EsY0FBYyxDQUFDLEdBQUdrRCxtQkFBbUJiLEtBQUtOLEtBQUssSUFBSSxDQUFDO1lBQ25ILElBQUlxQixVQUFVRCxVQUFVQyxPQUFPLEVBQzdCTixPQUFPSyxVQUFVTCxJQUFJLEVBQ3JCRCxhQUFhTSxVQUFVTixVQUFVLEVBQ2pDUSxPQUFPRixVQUFVRSxJQUFJO1lBQ3ZCLE9BQU87Z0JBQ0xDLFVBQVVEO2dCQUNWRCxTQUFTQTtnQkFDVFQsTUFBTWQsWUFBWWUsUUFBUSxJQUFJQyxjQUFjO2dCQUM1Q0UsT0FBTyxDQUFDLEdBQUdsRSxZQUFZMEUseUJBQXlCLEVBQUVsQjtnQkFDbEQ1RCxPQUFPcUUsUUFBUU07Z0JBQ2YseUZBQXlGO2dCQUN6Rm5CLFNBQVNrQjtZQUNYO1FBQ0Y7SUFDRjtJQUNBLE9BQU9uRCxjQUFjQSxjQUFjQSxjQUFjLENBQUMsR0FBRzZCLGNBQWNsRCxRQUFRK0MsTUFBTSxDQUFDOEIsYUFBYSxDQUFDaEMsWUFBWUYsZUFBZSxDQUFDLEdBQUc7UUFDN0hXLFNBQVNEO1FBQ1RLLE1BQU1iO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC9nZXRMZWdlbmRQcm9wcy5qcz8wMmE5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRMZWdlbmRQcm9wcyA9IHZvaWQgMDtcbnZhciBfTGVnZW5kID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC9MZWdlbmRcIik7XG52YXIgX0NoYXJ0VXRpbHMgPSByZXF1aXJlKFwiLi9DaGFydFV0aWxzXCIpO1xudmFyIF9SZWFjdFV0aWxzID0gcmVxdWlyZShcIi4vUmVhY3RVdGlsc1wiKTtcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgZ2V0TGVnZW5kUHJvcHMgPSBleHBvcnRzLmdldExlZ2VuZFByb3BzID0gZnVuY3Rpb24gZ2V0TGVnZW5kUHJvcHMoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgIGZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zID0gX3JlZi5mb3JtYXR0ZWRHcmFwaGljYWxJdGVtcyxcbiAgICBsZWdlbmRXaWR0aCA9IF9yZWYubGVnZW5kV2lkdGgsXG4gICAgbGVnZW5kQ29udGVudCA9IF9yZWYubGVnZW5kQ29udGVudDtcbiAgdmFyIGxlZ2VuZEl0ZW0gPSAoMCwgX1JlYWN0VXRpbHMuZmluZENoaWxkQnlUeXBlKShjaGlsZHJlbiwgX0xlZ2VuZC5MZWdlbmQpO1xuICBpZiAoIWxlZ2VuZEl0ZW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbGVnZW5kRGVmYXVsdFByb3BzID0gX0xlZ2VuZC5MZWdlbmQuZGVmYXVsdFByb3BzO1xuICB2YXIgbGVnZW5kUHJvcHMgPSBsZWdlbmREZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbGVnZW5kRGVmYXVsdFByb3BzKSwgbGVnZW5kSXRlbS5wcm9wcykgOiB7fTtcbiAgdmFyIGxlZ2VuZERhdGE7XG4gIGlmIChsZWdlbmRJdGVtLnByb3BzICYmIGxlZ2VuZEl0ZW0ucHJvcHMucGF5bG9hZCkge1xuICAgIGxlZ2VuZERhdGEgPSBsZWdlbmRJdGVtLnByb3BzICYmIGxlZ2VuZEl0ZW0ucHJvcHMucGF5bG9hZDtcbiAgfSBlbHNlIGlmIChsZWdlbmRDb250ZW50ID09PSAnY2hpbGRyZW4nKSB7XG4gICAgbGVnZW5kRGF0YSA9IChmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcyB8fCBbXSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIF9yZWYyKSB7XG4gICAgICB2YXIgaXRlbSA9IF9yZWYyLml0ZW0sXG4gICAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG4gICAgICB2YXIgZGF0YSA9IHByb3BzLnNlY3RvcnMgfHwgcHJvcHMuZGF0YSB8fCBbXTtcbiAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KGRhdGEubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IGxlZ2VuZEl0ZW0ucHJvcHMuaWNvblR5cGUgfHwgaXRlbS5wcm9wcy5sZWdlbmRUeXBlLFxuICAgICAgICAgIHZhbHVlOiBlbnRyeS5uYW1lLFxuICAgICAgICAgIGNvbG9yOiBlbnRyeS5maWxsLFxuICAgICAgICAgIHBheWxvYWQ6IGVudHJ5XG4gICAgICAgIH07XG4gICAgICB9KSk7XG4gICAgfSwgW10pO1xuICB9IGVsc2Uge1xuICAgIGxlZ2VuZERhdGEgPSAoZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXMgfHwgW10pLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgIHZhciBpdGVtID0gX3JlZjMuaXRlbTtcbiAgICAgIHZhciBpdGVtRGVmYXVsdFByb3BzID0gaXRlbS50eXBlLmRlZmF1bHRQcm9wcztcbiAgICAgIHZhciBpdGVtUHJvcHMgPSBpdGVtRGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGl0ZW1EZWZhdWx0UHJvcHMpLCBpdGVtLnByb3BzKSA6IHt9O1xuICAgICAgdmFyIGRhdGFLZXkgPSBpdGVtUHJvcHMuZGF0YUtleSxcbiAgICAgICAgbmFtZSA9IGl0ZW1Qcm9wcy5uYW1lLFxuICAgICAgICBsZWdlbmRUeXBlID0gaXRlbVByb3BzLmxlZ2VuZFR5cGUsXG4gICAgICAgIGhpZGUgPSBpdGVtUHJvcHMuaGlkZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluYWN0aXZlOiBoaWRlLFxuICAgICAgICBkYXRhS2V5OiBkYXRhS2V5LFxuICAgICAgICB0eXBlOiBsZWdlbmRQcm9wcy5pY29uVHlwZSB8fCBsZWdlbmRUeXBlIHx8ICdzcXVhcmUnLFxuICAgICAgICBjb2xvcjogKDAsIF9DaGFydFV0aWxzLmdldE1haW5Db2xvck9mR3JhcGhpY0l0ZW0pKGl0ZW0pLFxuICAgICAgICB2YWx1ZTogbmFtZSB8fCBkYXRhS2V5LFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHByb3BlcnR5IHN0cm9rZURhc2hhcnJheSBpcyByZXF1aXJlZCBpbiBQYXlsb2FkIGJ1dCBvcHRpb25hbCBpbiBwcm9wc1xuICAgICAgICBwYXlsb2FkOiBpdGVtUHJvcHNcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBsZWdlbmRQcm9wcyksIF9MZWdlbmQuTGVnZW5kLmdldFdpdGhIZWlnaHQobGVnZW5kSXRlbSwgbGVnZW5kV2lkdGgpKSwge30sIHtcbiAgICBwYXlsb2FkOiBsZWdlbmREYXRhLFxuICAgIGl0ZW06IGxlZ2VuZEl0ZW1cbiAgfSk7XG59OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldExlZ2VuZFByb3BzIiwiX0xlZ2VuZCIsInJlcXVpcmUiLCJfQ2hhcnRVdGlscyIsIl9SZWFjdFV0aWxzIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIm9iaiIsImtleSIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJpIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiX3JlZiIsImNoaWxkcmVuIiwiZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXMiLCJsZWdlbmRXaWR0aCIsImxlZ2VuZENvbnRlbnQiLCJsZWdlbmRJdGVtIiwiZmluZENoaWxkQnlUeXBlIiwiTGVnZW5kIiwibGVnZW5kRGVmYXVsdFByb3BzIiwiZGVmYXVsdFByb3BzIiwibGVnZW5kUHJvcHMiLCJ1bmRlZmluZWQiLCJwcm9wcyIsImxlZ2VuZERhdGEiLCJwYXlsb2FkIiwicmVkdWNlIiwicmVzdWx0IiwiX3JlZjIiLCJpdGVtIiwiZGF0YSIsInNlY3RvcnMiLCJjb25jYXQiLCJtYXAiLCJlbnRyeSIsInR5cGUiLCJpY29uVHlwZSIsImxlZ2VuZFR5cGUiLCJuYW1lIiwiY29sb3IiLCJmaWxsIiwiX3JlZjMiLCJpdGVtRGVmYXVsdFByb3BzIiwiaXRlbVByb3BzIiwiZGF0YUtleSIsImhpZGUiLCJpbmFjdGl2ZSIsImdldE1haW5Db2xvck9mR3JhcGhpY0l0ZW0iLCJnZXRXaXRoSGVpZ2h0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/getLegendProps.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/isDomainSpecifiedByUser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/recharts/lib/util/isDomainSpecifiedByUser.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isDomainSpecifiedByUser = isDomainSpecifiedByUser;\nvar _DataUtils = __webpack_require__(/*! ./DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\n/**\n * Takes a domain and user props to determine whether he provided the domain via props or if we need to calculate it.\n * @param   {AxisDomain}  domain              The potential domain from props\n * @param   {Boolean}     allowDataOverflow   from props\n * @param   {String}      axisType            from props\n * @returns {Boolean}                         `true` if domain is specified by user\n */ function isDomainSpecifiedByUser(domain, allowDataOverflow, axisType) {\n    if (axisType === \"number\" && allowDataOverflow === true && Array.isArray(domain)) {\n        var domainStart = domain === null || domain === void 0 ? void 0 : domain[0];\n        var domainEnd = domain === null || domain === void 0 ? void 0 : domain[1];\n        /*\n     * The `isNumber` check is needed because the user could also provide strings like \"dataMin\" via the domain props.\n     * In such case, we have to compute the domain from the data.\n     */ if (!!domainStart && !!domainEnd && (0, _DataUtils.isNumber)(domainStart) && (0, _DataUtils.isNumber)(domainEnd)) {\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvaXNEb21haW5TcGVjaWZpZWRCeVVzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELCtCQUErQixHQUFHRTtBQUNsQyxJQUFJQyxhQUFhQyxtQkFBT0EsQ0FBQyxrRUFBYTtBQUN0Qzs7Ozs7O0NBTUMsR0FDRCxTQUFTRix3QkFBd0JHLE1BQU0sRUFBRUMsaUJBQWlCLEVBQUVDLFFBQVE7SUFDbEUsSUFBSUEsYUFBYSxZQUFZRCxzQkFBc0IsUUFBUUUsTUFBTUMsT0FBTyxDQUFDSixTQUFTO1FBQ2hGLElBQUlLLGNBQWNMLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxNQUFNLENBQUMsRUFBRTtRQUMzRSxJQUFJTSxZQUFZTixXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsTUFBTSxDQUFDLEVBQUU7UUFFekU7OztLQUdDLEdBQ0QsSUFBSSxDQUFDLENBQUNLLGVBQWUsQ0FBQyxDQUFDQyxhQUFhLENBQUMsR0FBR1IsV0FBV1MsUUFBUSxFQUFFRixnQkFBZ0IsQ0FBQyxHQUFHUCxXQUFXUyxRQUFRLEVBQUVELFlBQVk7WUFDaEgsT0FBTztRQUNUO0lBQ0Y7SUFDQSxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvaXNEb21haW5TcGVjaWZpZWRCeVVzZXIuanM/Mjc2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNEb21haW5TcGVjaWZpZWRCeVVzZXIgPSBpc0RvbWFpblNwZWNpZmllZEJ5VXNlcjtcbnZhciBfRGF0YVV0aWxzID0gcmVxdWlyZShcIi4vRGF0YVV0aWxzXCIpO1xuLyoqXG4gKiBUYWtlcyBhIGRvbWFpbiBhbmQgdXNlciBwcm9wcyB0byBkZXRlcm1pbmUgd2hldGhlciBoZSBwcm92aWRlZCB0aGUgZG9tYWluIHZpYSBwcm9wcyBvciBpZiB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSBpdC5cbiAqIEBwYXJhbSAgIHtBeGlzRG9tYWlufSAgZG9tYWluICAgICAgICAgICAgICBUaGUgcG90ZW50aWFsIGRvbWFpbiBmcm9tIHByb3BzXG4gKiBAcGFyYW0gICB7Qm9vbGVhbn0gICAgIGFsbG93RGF0YU92ZXJmbG93ICAgZnJvbSBwcm9wc1xuICogQHBhcmFtICAge1N0cmluZ30gICAgICBheGlzVHlwZSAgICAgICAgICAgIGZyb20gcHJvcHNcbiAqIEByZXR1cm5zIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICBgdHJ1ZWAgaWYgZG9tYWluIGlzIHNwZWNpZmllZCBieSB1c2VyXG4gKi9cbmZ1bmN0aW9uIGlzRG9tYWluU3BlY2lmaWVkQnlVc2VyKGRvbWFpbiwgYWxsb3dEYXRhT3ZlcmZsb3csIGF4aXNUeXBlKSB7XG4gIGlmIChheGlzVHlwZSA9PT0gJ251bWJlcicgJiYgYWxsb3dEYXRhT3ZlcmZsb3cgPT09IHRydWUgJiYgQXJyYXkuaXNBcnJheShkb21haW4pKSB7XG4gICAgdmFyIGRvbWFpblN0YXJ0ID0gZG9tYWluID09PSBudWxsIHx8IGRvbWFpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9tYWluWzBdO1xuICAgIHZhciBkb21haW5FbmQgPSBkb21haW4gPT09IG51bGwgfHwgZG9tYWluID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb21haW5bMV07XG5cbiAgICAvKlxuICAgICAqIFRoZSBgaXNOdW1iZXJgIGNoZWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSB1c2VyIGNvdWxkIGFsc28gcHJvdmlkZSBzdHJpbmdzIGxpa2UgXCJkYXRhTWluXCIgdmlhIHRoZSBkb21haW4gcHJvcHMuXG4gICAgICogSW4gc3VjaCBjYXNlLCB3ZSBoYXZlIHRvIGNvbXB1dGUgdGhlIGRvbWFpbiBmcm9tIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIGlmICghIWRvbWFpblN0YXJ0ICYmICEhZG9tYWluRW5kICYmICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShkb21haW5TdGFydCkgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGRvbWFpbkVuZCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNEb21haW5TcGVjaWZpZWRCeVVzZXIiLCJfRGF0YVV0aWxzIiwicmVxdWlyZSIsImRvbWFpbiIsImFsbG93RGF0YU92ZXJmbG93IiwiYXhpc1R5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJkb21haW5TdGFydCIsImRvbWFpbkVuZCIsImlzTnVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/isDomainSpecifiedByUser.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/payload/getUniqPayload.js":
/*!******************************************************************!*\
  !*** ./node_modules/recharts/lib/util/payload/getUniqPayload.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getUniqPayload = getUniqPayload;\nvar _uniqBy = _interopRequireDefault(__webpack_require__(/*! lodash/uniqBy */ \"lodash/uniqBy\"));\nvar _isFunction = _interopRequireDefault(__webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\n/**\n * This is configuration option that decides how to filter for unique values only:\n *\n * - `false` means \"no filter\"\n * - `true` means \"use recharts default filter\"\n * - function means \"use return of this function as the default key\"\n */ function getUniqPayload(payload, option, defaultUniqBy) {\n    if (option === true) {\n        return (0, _uniqBy[\"default\"])(payload, defaultUniqBy);\n    }\n    if ((0, _isFunction[\"default\"])(option)) {\n        return (0, _uniqBy[\"default\"])(payload, option);\n    }\n    return payload;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvcGF5bG9hZC9nZXRVbmlxUGF5bG9hZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsc0JBQXNCLEdBQUdFO0FBQ3pCLElBQUlDLFVBQVVDLHVCQUF1QkMsbUJBQU9BLENBQUMsb0NBQWU7QUFDNUQsSUFBSUMsY0FBY0YsdUJBQXVCQyxtQkFBT0EsQ0FBQyw0Q0FBbUI7QUFDcEUsU0FBU0QsdUJBQXVCRyxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBQ2hHOzs7Ozs7Q0FNQyxHQUVELFNBQVNMLGVBQWVPLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxhQUFhO0lBQ3BELElBQUlELFdBQVcsTUFBTTtRQUNuQixPQUFPLENBQUMsR0FBR1AsT0FBTyxDQUFDLFVBQVUsRUFBRU0sU0FBU0U7SUFDMUM7SUFDQSxJQUFJLENBQUMsR0FBR0wsV0FBVyxDQUFDLFVBQVUsRUFBRUksU0FBUztRQUN2QyxPQUFPLENBQUMsR0FBR1AsT0FBTyxDQUFDLFVBQVUsRUFBRU0sU0FBU0M7SUFDMUM7SUFDQSxPQUFPRDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2xpYi91dGlsL3BheWxvYWQvZ2V0VW5pcVBheWxvYWQuanM/ZGZhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0VW5pcVBheWxvYWQgPSBnZXRVbmlxUGF5bG9hZDtcbnZhciBfdW5pcUJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3VuaXFCeVwiKSk7XG52YXIgX2lzRnVuY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbi8qKlxuICogVGhpcyBpcyBjb25maWd1cmF0aW9uIG9wdGlvbiB0aGF0IGRlY2lkZXMgaG93IHRvIGZpbHRlciBmb3IgdW5pcXVlIHZhbHVlcyBvbmx5OlxuICpcbiAqIC0gYGZhbHNlYCBtZWFucyBcIm5vIGZpbHRlclwiXG4gKiAtIGB0cnVlYCBtZWFucyBcInVzZSByZWNoYXJ0cyBkZWZhdWx0IGZpbHRlclwiXG4gKiAtIGZ1bmN0aW9uIG1lYW5zIFwidXNlIHJldHVybiBvZiB0aGlzIGZ1bmN0aW9uIGFzIHRoZSBkZWZhdWx0IGtleVwiXG4gKi9cblxuZnVuY3Rpb24gZ2V0VW5pcVBheWxvYWQocGF5bG9hZCwgb3B0aW9uLCBkZWZhdWx0VW5pcUJ5KSB7XG4gIGlmIChvcHRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gKDAsIF91bmlxQnlbXCJkZWZhdWx0XCJdKShwYXlsb2FkLCBkZWZhdWx0VW5pcUJ5KTtcbiAgfVxuICBpZiAoKDAsIF9pc0Z1bmN0aW9uW1wiZGVmYXVsdFwiXSkob3B0aW9uKSkge1xuICAgIHJldHVybiAoMCwgX3VuaXFCeVtcImRlZmF1bHRcIl0pKHBheWxvYWQsIG9wdGlvbik7XG4gIH1cbiAgcmV0dXJuIHBheWxvYWQ7XG59Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0VW5pcVBheWxvYWQiLCJfdW5pcUJ5IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfaXNGdW5jdGlvbiIsIm9iaiIsIl9fZXNNb2R1bGUiLCJwYXlsb2FkIiwib3B0aW9uIiwiZGVmYXVsdFVuaXFCeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/payload/getUniqPayload.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/tooltip/translate.js":
/*!*************************************************************!*\
  !*** ./node_modules/recharts/lib/util/tooltip/translate.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getTooltipCSSClassName = getTooltipCSSClassName;\nexports.getTooltipTranslate = getTooltipTranslate;\nexports.getTooltipTranslateXY = getTooltipTranslateXY;\nexports.getTransformStyle = getTransformStyle;\nvar _clsx2 = _interopRequireDefault(__webpack_require__(/*! clsx */ \"clsx\"));\nvar _DataUtils = __webpack_require__(/*! ../DataUtils */ \"./node_modules/recharts/lib/util/DataUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar CSS_CLASS_PREFIX = \"recharts-tooltip-wrapper\";\nvar TOOLTIP_HIDDEN = {\n    visibility: \"hidden\"\n};\nfunction getTooltipCSSClassName(_ref) {\n    var coordinate = _ref.coordinate, translateX = _ref.translateX, translateY = _ref.translateY;\n    return (0, _clsx2[\"default\"])(CSS_CLASS_PREFIX, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, \"\".concat(CSS_CLASS_PREFIX, \"-right\"), (0, _DataUtils.isNumber)(translateX) && coordinate && (0, _DataUtils.isNumber)(coordinate.x) && translateX >= coordinate.x), \"\".concat(CSS_CLASS_PREFIX, \"-left\"), (0, _DataUtils.isNumber)(translateX) && coordinate && (0, _DataUtils.isNumber)(coordinate.x) && translateX < coordinate.x), \"\".concat(CSS_CLASS_PREFIX, \"-bottom\"), (0, _DataUtils.isNumber)(translateY) && coordinate && (0, _DataUtils.isNumber)(coordinate.y) && translateY >= coordinate.y), \"\".concat(CSS_CLASS_PREFIX, \"-top\"), (0, _DataUtils.isNumber)(translateY) && coordinate && (0, _DataUtils.isNumber)(coordinate.y) && translateY < coordinate.y));\n}\nfunction getTooltipTranslateXY(_ref2) {\n    var allowEscapeViewBox = _ref2.allowEscapeViewBox, coordinate = _ref2.coordinate, key = _ref2.key, offsetTopLeft = _ref2.offsetTopLeft, position = _ref2.position, reverseDirection = _ref2.reverseDirection, tooltipDimension = _ref2.tooltipDimension, viewBox = _ref2.viewBox, viewBoxDimension = _ref2.viewBoxDimension;\n    if (position && (0, _DataUtils.isNumber)(position[key])) {\n        return position[key];\n    }\n    var negative = coordinate[key] - tooltipDimension - offsetTopLeft;\n    var positive = coordinate[key] + offsetTopLeft;\n    if (allowEscapeViewBox[key]) {\n        return reverseDirection[key] ? negative : positive;\n    }\n    if (reverseDirection[key]) {\n        var _tooltipBoundary = negative;\n        var _viewBoxBoundary = viewBox[key];\n        if (_tooltipBoundary < _viewBoxBoundary) {\n            return Math.max(positive, viewBox[key]);\n        }\n        return Math.max(negative, viewBox[key]);\n    }\n    var tooltipBoundary = positive + tooltipDimension;\n    var viewBoxBoundary = viewBox[key] + viewBoxDimension;\n    if (tooltipBoundary > viewBoxBoundary) {\n        return Math.max(negative, viewBox[key]);\n    }\n    return Math.max(positive, viewBox[key]);\n}\nfunction getTransformStyle(_ref3) {\n    var translateX = _ref3.translateX, translateY = _ref3.translateY, useTranslate3d = _ref3.useTranslate3d;\n    return {\n        transform: useTranslate3d ? \"translate3d(\".concat(translateX, \"px, \").concat(translateY, \"px, 0)\") : \"translate(\".concat(translateX, \"px, \").concat(translateY, \"px)\")\n    };\n}\nfunction getTooltipTranslate(_ref4) {\n    var allowEscapeViewBox = _ref4.allowEscapeViewBox, coordinate = _ref4.coordinate, offsetTopLeft = _ref4.offsetTopLeft, position = _ref4.position, reverseDirection = _ref4.reverseDirection, tooltipBox = _ref4.tooltipBox, useTranslate3d = _ref4.useTranslate3d, viewBox = _ref4.viewBox;\n    var cssProperties, translateX, translateY;\n    if (tooltipBox.height > 0 && tooltipBox.width > 0 && coordinate) {\n        translateX = getTooltipTranslateXY({\n            allowEscapeViewBox: allowEscapeViewBox,\n            coordinate: coordinate,\n            key: \"x\",\n            offsetTopLeft: offsetTopLeft,\n            position: position,\n            reverseDirection: reverseDirection,\n            tooltipDimension: tooltipBox.width,\n            viewBox: viewBox,\n            viewBoxDimension: viewBox.width\n        });\n        translateY = getTooltipTranslateXY({\n            allowEscapeViewBox: allowEscapeViewBox,\n            coordinate: coordinate,\n            key: \"y\",\n            offsetTopLeft: offsetTopLeft,\n            position: position,\n            reverseDirection: reverseDirection,\n            tooltipDimension: tooltipBox.height,\n            viewBox: viewBox,\n            viewBoxDimension: viewBox.height\n        });\n        cssProperties = getTransformStyle({\n            translateX: translateX,\n            translateY: translateY,\n            useTranslate3d: useTranslate3d\n        });\n    } else {\n        cssProperties = TOOLTIP_HIDDEN;\n    }\n    return {\n        cssProperties: cssProperties,\n        cssClasses: getTooltipCSSClassName({\n            translateX: translateX,\n            translateY: translateY,\n            coordinate: coordinate\n        })\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvdG9vbHRpcC90cmFuc2xhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELDhCQUE4QixHQUFHRTtBQUNqQ0YsMkJBQTJCLEdBQUdHO0FBQzlCSCw2QkFBNkIsR0FBR0k7QUFDaENKLHlCQUF5QixHQUFHSztBQUM1QixJQUFJQyxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ2xELElBQUlDLGFBQWFELG1CQUFPQSxDQUFDLG1FQUFjO0FBQ3ZDLFNBQVNELHVCQUF1QkcsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0ssZ0JBQWdCUixHQUFHLEVBQUVTLEdBQUcsRUFBRWxCLEtBQUs7SUFBSWtCLE1BQU1DLGVBQWVEO0lBQU0sSUFBSUEsT0FBT1QsS0FBSztRQUFFWixPQUFPQyxjQUFjLENBQUNXLEtBQUtTLEtBQUs7WUFBRWxCLE9BQU9BO1lBQU9vQixZQUFZO1lBQU1DLGNBQWM7WUFBTUMsVUFBVTtRQUFLO0lBQUksT0FBTztRQUFFYixHQUFHLENBQUNTLElBQUksR0FBR2xCO0lBQU87SUFBRSxPQUFPUztBQUFLO0FBQzNPLFNBQVNVLGVBQWVJLENBQUM7SUFBSSxJQUFJQyxJQUFJQyxh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QUFXRSxNQUFNLEdBQUcsS0FBS0YsV0FBV0csS0FBSyxHQUFHLEtBQUs5QixZQUFZO1FBQy9EQyxhQUFhbkMsc0JBQXNCO1lBQ2pDMEMsb0JBQW9CQTtZQUNwQlIsWUFBWUE7WUFDWm5CLEtBQUs7WUFDTDRCLGVBQWVBO1lBQ2ZDLFVBQVVBO1lBQ1ZDLGtCQUFrQkE7WUFDbEJDLGtCQUFrQmUsV0FBV0csS0FBSztZQUNsQ2pCLFNBQVNBO1lBQ1RDLGtCQUFrQkQsUUFBUWlCLEtBQUs7UUFDakM7UUFDQTVCLGFBQWFwQyxzQkFBc0I7WUFDakMwQyxvQkFBb0JBO1lBQ3BCUixZQUFZQTtZQUNabkIsS0FBSztZQUNMNEIsZUFBZUE7WUFDZkMsVUFBVUE7WUFDVkMsa0JBQWtCQTtZQUNsQkMsa0JBQWtCZSxXQUFXRSxNQUFNO1lBQ25DaEIsU0FBU0E7WUFDVEMsa0JBQWtCRCxRQUFRZ0IsTUFBTTtRQUNsQztRQUNBRCxnQkFBZ0I3RCxrQkFBa0I7WUFDaENrQyxZQUFZQTtZQUNaQyxZQUFZQTtZQUNac0IsZ0JBQWdCQTtRQUNsQjtJQUNGLE9BQU87UUFDTEksZ0JBQWdCL0I7SUFDbEI7SUFDQSxPQUFPO1FBQ0wrQixlQUFlQTtRQUNmRyxZQUFZbkUsdUJBQXVCO1lBQ2pDcUMsWUFBWUE7WUFDWkMsWUFBWUE7WUFDWkYsWUFBWUE7UUFDZDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvdG9vbHRpcC90cmFuc2xhdGUuanM/ZTE5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0VG9vbHRpcENTU0NsYXNzTmFtZSA9IGdldFRvb2x0aXBDU1NDbGFzc05hbWU7XG5leHBvcnRzLmdldFRvb2x0aXBUcmFuc2xhdGUgPSBnZXRUb29sdGlwVHJhbnNsYXRlO1xuZXhwb3J0cy5nZXRUb29sdGlwVHJhbnNsYXRlWFkgPSBnZXRUb29sdGlwVHJhbnNsYXRlWFk7XG5leHBvcnRzLmdldFRyYW5zZm9ybVN0eWxlID0gZ2V0VHJhbnNmb3JtU3R5bGU7XG52YXIgX2Nsc3gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX0RhdGFVdGlscyA9IHJlcXVpcmUoXCIuLi9EYXRhVXRpbHNcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIENTU19DTEFTU19QUkVGSVggPSAncmVjaGFydHMtdG9vbHRpcC13cmFwcGVyJztcbnZhciBUT09MVElQX0hJRERFTiA9IHtcbiAgdmlzaWJpbGl0eTogJ2hpZGRlbidcbn07XG5mdW5jdGlvbiBnZXRUb29sdGlwQ1NTQ2xhc3NOYW1lKF9yZWYpIHtcbiAgdmFyIGNvb3JkaW5hdGUgPSBfcmVmLmNvb3JkaW5hdGUsXG4gICAgdHJhbnNsYXRlWCA9IF9yZWYudHJhbnNsYXRlWCxcbiAgICB0cmFuc2xhdGVZID0gX3JlZi50cmFuc2xhdGVZO1xuICByZXR1cm4gKDAsIF9jbHN4MltcImRlZmF1bHRcIl0pKENTU19DTEFTU19QUkVGSVgsIF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJcIi5jb25jYXQoQ1NTX0NMQVNTX1BSRUZJWCwgXCItcmlnaHRcIiksICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh0cmFuc2xhdGVYKSAmJiBjb29yZGluYXRlICYmICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShjb29yZGluYXRlLngpICYmIHRyYW5zbGF0ZVggPj0gY29vcmRpbmF0ZS54KSwgXCJcIi5jb25jYXQoQ1NTX0NMQVNTX1BSRUZJWCwgXCItbGVmdFwiKSwgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHRyYW5zbGF0ZVgpICYmIGNvb3JkaW5hdGUgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGNvb3JkaW5hdGUueCkgJiYgdHJhbnNsYXRlWCA8IGNvb3JkaW5hdGUueCksIFwiXCIuY29uY2F0KENTU19DTEFTU19QUkVGSVgsIFwiLWJvdHRvbVwiKSwgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHRyYW5zbGF0ZVkpICYmIGNvb3JkaW5hdGUgJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKGNvb3JkaW5hdGUueSkgJiYgdHJhbnNsYXRlWSA+PSBjb29yZGluYXRlLnkpLCBcIlwiLmNvbmNhdChDU1NfQ0xBU1NfUFJFRklYLCBcIi10b3BcIiksICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKSh0cmFuc2xhdGVZKSAmJiBjb29yZGluYXRlICYmICgwLCBfRGF0YVV0aWxzLmlzTnVtYmVyKShjb29yZGluYXRlLnkpICYmIHRyYW5zbGF0ZVkgPCBjb29yZGluYXRlLnkpKTtcbn1cbmZ1bmN0aW9uIGdldFRvb2x0aXBUcmFuc2xhdGVYWShfcmVmMikge1xuICB2YXIgYWxsb3dFc2NhcGVWaWV3Qm94ID0gX3JlZjIuYWxsb3dFc2NhcGVWaWV3Qm94LFxuICAgIGNvb3JkaW5hdGUgPSBfcmVmMi5jb29yZGluYXRlLFxuICAgIGtleSA9IF9yZWYyLmtleSxcbiAgICBvZmZzZXRUb3BMZWZ0ID0gX3JlZjIub2Zmc2V0VG9wTGVmdCxcbiAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxuICAgIHJldmVyc2VEaXJlY3Rpb24gPSBfcmVmMi5yZXZlcnNlRGlyZWN0aW9uLFxuICAgIHRvb2x0aXBEaW1lbnNpb24gPSBfcmVmMi50b29sdGlwRGltZW5zaW9uLFxuICAgIHZpZXdCb3ggPSBfcmVmMi52aWV3Qm94LFxuICAgIHZpZXdCb3hEaW1lbnNpb24gPSBfcmVmMi52aWV3Qm94RGltZW5zaW9uO1xuICBpZiAocG9zaXRpb24gJiYgKDAsIF9EYXRhVXRpbHMuaXNOdW1iZXIpKHBvc2l0aW9uW2tleV0pKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uW2tleV07XG4gIH1cbiAgdmFyIG5lZ2F0aXZlID0gY29vcmRpbmF0ZVtrZXldIC0gdG9vbHRpcERpbWVuc2lvbiAtIG9mZnNldFRvcExlZnQ7XG4gIHZhciBwb3NpdGl2ZSA9IGNvb3JkaW5hdGVba2V5XSArIG9mZnNldFRvcExlZnQ7XG4gIGlmIChhbGxvd0VzY2FwZVZpZXdCb3hba2V5XSkge1xuICAgIHJldHVybiByZXZlcnNlRGlyZWN0aW9uW2tleV0gPyBuZWdhdGl2ZSA6IHBvc2l0aXZlO1xuICB9XG4gIGlmIChyZXZlcnNlRGlyZWN0aW9uW2tleV0pIHtcbiAgICB2YXIgX3Rvb2x0aXBCb3VuZGFyeSA9IG5lZ2F0aXZlO1xuICAgIHZhciBfdmlld0JveEJvdW5kYXJ5ID0gdmlld0JveFtrZXldO1xuICAgIGlmIChfdG9vbHRpcEJvdW5kYXJ5IDwgX3ZpZXdCb3hCb3VuZGFyeSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHBvc2l0aXZlLCB2aWV3Qm94W2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgobmVnYXRpdmUsIHZpZXdCb3hba2V5XSk7XG4gIH1cbiAgdmFyIHRvb2x0aXBCb3VuZGFyeSA9IHBvc2l0aXZlICsgdG9vbHRpcERpbWVuc2lvbjtcbiAgdmFyIHZpZXdCb3hCb3VuZGFyeSA9IHZpZXdCb3hba2V5XSArIHZpZXdCb3hEaW1lbnNpb247XG4gIGlmICh0b29sdGlwQm91bmRhcnkgPiB2aWV3Qm94Qm91bmRhcnkpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobmVnYXRpdmUsIHZpZXdCb3hba2V5XSk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KHBvc2l0aXZlLCB2aWV3Qm94W2tleV0pO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtU3R5bGUoX3JlZjMpIHtcbiAgdmFyIHRyYW5zbGF0ZVggPSBfcmVmMy50cmFuc2xhdGVYLFxuICAgIHRyYW5zbGF0ZVkgPSBfcmVmMy50cmFuc2xhdGVZLFxuICAgIHVzZVRyYW5zbGF0ZTNkID0gX3JlZjMudXNlVHJhbnNsYXRlM2Q7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiB1c2VUcmFuc2xhdGUzZCA/IFwidHJhbnNsYXRlM2QoXCIuY29uY2F0KHRyYW5zbGF0ZVgsIFwicHgsIFwiKS5jb25jYXQodHJhbnNsYXRlWSwgXCJweCwgMClcIikgOiBcInRyYW5zbGF0ZShcIi5jb25jYXQodHJhbnNsYXRlWCwgXCJweCwgXCIpLmNvbmNhdCh0cmFuc2xhdGVZLCBcInB4KVwiKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VG9vbHRpcFRyYW5zbGF0ZShfcmVmNCkge1xuICB2YXIgYWxsb3dFc2NhcGVWaWV3Qm94ID0gX3JlZjQuYWxsb3dFc2NhcGVWaWV3Qm94LFxuICAgIGNvb3JkaW5hdGUgPSBfcmVmNC5jb29yZGluYXRlLFxuICAgIG9mZnNldFRvcExlZnQgPSBfcmVmNC5vZmZzZXRUb3BMZWZ0LFxuICAgIHBvc2l0aW9uID0gX3JlZjQucG9zaXRpb24sXG4gICAgcmV2ZXJzZURpcmVjdGlvbiA9IF9yZWY0LnJldmVyc2VEaXJlY3Rpb24sXG4gICAgdG9vbHRpcEJveCA9IF9yZWY0LnRvb2x0aXBCb3gsXG4gICAgdXNlVHJhbnNsYXRlM2QgPSBfcmVmNC51c2VUcmFuc2xhdGUzZCxcbiAgICB2aWV3Qm94ID0gX3JlZjQudmlld0JveDtcbiAgdmFyIGNzc1Byb3BlcnRpZXMsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVk7XG4gIGlmICh0b29sdGlwQm94LmhlaWdodCA+IDAgJiYgdG9vbHRpcEJveC53aWR0aCA+IDAgJiYgY29vcmRpbmF0ZSkge1xuICAgIHRyYW5zbGF0ZVggPSBnZXRUb29sdGlwVHJhbnNsYXRlWFkoe1xuICAgICAgYWxsb3dFc2NhcGVWaWV3Qm94OiBhbGxvd0VzY2FwZVZpZXdCb3gsXG4gICAgICBjb29yZGluYXRlOiBjb29yZGluYXRlLFxuICAgICAga2V5OiAneCcsXG4gICAgICBvZmZzZXRUb3BMZWZ0OiBvZmZzZXRUb3BMZWZ0LFxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgcmV2ZXJzZURpcmVjdGlvbjogcmV2ZXJzZURpcmVjdGlvbixcbiAgICAgIHRvb2x0aXBEaW1lbnNpb246IHRvb2x0aXBCb3gud2lkdGgsXG4gICAgICB2aWV3Qm94OiB2aWV3Qm94LFxuICAgICAgdmlld0JveERpbWVuc2lvbjogdmlld0JveC53aWR0aFxuICAgIH0pO1xuICAgIHRyYW5zbGF0ZVkgPSBnZXRUb29sdGlwVHJhbnNsYXRlWFkoe1xuICAgICAgYWxsb3dFc2NhcGVWaWV3Qm94OiBhbGxvd0VzY2FwZVZpZXdCb3gsXG4gICAgICBjb29yZGluYXRlOiBjb29yZGluYXRlLFxuICAgICAga2V5OiAneScsXG4gICAgICBvZmZzZXRUb3BMZWZ0OiBvZmZzZXRUb3BMZWZ0LFxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgcmV2ZXJzZURpcmVjdGlvbjogcmV2ZXJzZURpcmVjdGlvbixcbiAgICAgIHRvb2x0aXBEaW1lbnNpb246IHRvb2x0aXBCb3guaGVpZ2h0LFxuICAgICAgdmlld0JveDogdmlld0JveCxcbiAgICAgIHZpZXdCb3hEaW1lbnNpb246IHZpZXdCb3guaGVpZ2h0XG4gICAgfSk7XG4gICAgY3NzUHJvcGVydGllcyA9IGdldFRyYW5zZm9ybVN0eWxlKHtcbiAgICAgIHRyYW5zbGF0ZVg6IHRyYW5zbGF0ZVgsXG4gICAgICB0cmFuc2xhdGVZOiB0cmFuc2xhdGVZLFxuICAgICAgdXNlVHJhbnNsYXRlM2Q6IHVzZVRyYW5zbGF0ZTNkXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY3NzUHJvcGVydGllcyA9IFRPT0xUSVBfSElEREVOO1xuICB9XG4gIHJldHVybiB7XG4gICAgY3NzUHJvcGVydGllczogY3NzUHJvcGVydGllcyxcbiAgICBjc3NDbGFzc2VzOiBnZXRUb29sdGlwQ1NTQ2xhc3NOYW1lKHtcbiAgICAgIHRyYW5zbGF0ZVg6IHRyYW5zbGF0ZVgsXG4gICAgICB0cmFuc2xhdGVZOiB0cmFuc2xhdGVZLFxuICAgICAgY29vcmRpbmF0ZTogY29vcmRpbmF0ZVxuICAgIH0pXG4gIH07XG59Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0VG9vbHRpcENTU0NsYXNzTmFtZSIsImdldFRvb2x0aXBUcmFuc2xhdGUiLCJnZXRUb29sdGlwVHJhbnNsYXRlWFkiLCJnZXRUcmFuc2Zvcm1TdHlsZSIsIl9jbHN4MiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX0RhdGFVdGlscyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfdG9Qcm9wZXJ0eUtleSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInQiLCJpIiwiX3RvUHJpbWl0aXZlIiwiciIsImUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJDU1NfQ0xBU1NfUFJFRklYIiwiVE9PTFRJUF9ISURERU4iLCJ2aXNpYmlsaXR5IiwiX3JlZiIsImNvb3JkaW5hdGUiLCJ0cmFuc2xhdGVYIiwidHJhbnNsYXRlWSIsImNvbmNhdCIsImlzTnVtYmVyIiwieCIsInkiLCJfcmVmMiIsImFsbG93RXNjYXBlVmlld0JveCIsIm9mZnNldFRvcExlZnQiLCJwb3NpdGlvbiIsInJldmVyc2VEaXJlY3Rpb24iLCJ0b29sdGlwRGltZW5zaW9uIiwidmlld0JveCIsInZpZXdCb3hEaW1lbnNpb24iLCJuZWdhdGl2ZSIsInBvc2l0aXZlIiwiX3Rvb2x0aXBCb3VuZGFyeSIsIl92aWV3Qm94Qm91bmRhcnkiLCJNYXRoIiwibWF4IiwidG9vbHRpcEJvdW5kYXJ5Iiwidmlld0JveEJvdW5kYXJ5IiwiX3JlZjMiLCJ1c2VUcmFuc2xhdGUzZCIsInRyYW5zZm9ybSIsIl9yZWY0IiwidG9vbHRpcEJveCIsImNzc1Byb3BlcnRpZXMiLCJoZWlnaHQiLCJ3aWR0aCIsImNzc0NsYXNzZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/tooltip/translate.js\n");

/***/ }),

/***/ "./node_modules/recharts/lib/util/types.js":
/*!*************************************************!*\
  !*** ./node_modules/recharts/lib/util/types.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.adaptEventsOfChild = exports.adaptEventHandlers = exports.SVGElementPropKeys = exports.FilteredElementKeyMap = exports.EventKeys = void 0;\nvar _react = __webpack_require__(/*! react */ \"react\");\nvar _isObject = _interopRequireDefault(__webpack_require__(/*! lodash/isObject */ \"lodash/isObject\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\n/**\n * Determines how values are stacked:\n *\n * - `none` is the default, it adds values on top of each other. No smarts. Negative values will overlap.\n * - `expand` make it so that the values always add up to 1 - so the chart will look like a rectangle.\n * - `wiggle` and `silhouette` tries to keep the chart centered.\n * - `sign` stacks positive values above zero and negative values below zero. Similar to `none` but handles negatives.\n * - `positive` ignores all negative values, and then behaves like \\`none\\`.\n *\n * Also see https://d3js.org/d3-shape/stack#stack-offsets\n * (note that the `diverging` offset in d3 is named `sign` in recharts)\n */ //\n// Event Handler Types -- Copied from @types/react/index.d.ts and adapted for Props.\n//\nvar SVGContainerPropKeys = [\n    \"viewBox\",\n    \"children\"\n];\nvar SVGElementPropKeys = exports.SVGElementPropKeys = [\n    \"aria-activedescendant\",\n    \"aria-atomic\",\n    \"aria-autocomplete\",\n    \"aria-busy\",\n    \"aria-checked\",\n    \"aria-colcount\",\n    \"aria-colindex\",\n    \"aria-colspan\",\n    \"aria-controls\",\n    \"aria-current\",\n    \"aria-describedby\",\n    \"aria-details\",\n    \"aria-disabled\",\n    \"aria-errormessage\",\n    \"aria-expanded\",\n    \"aria-flowto\",\n    \"aria-haspopup\",\n    \"aria-hidden\",\n    \"aria-invalid\",\n    \"aria-keyshortcuts\",\n    \"aria-label\",\n    \"aria-labelledby\",\n    \"aria-level\",\n    \"aria-live\",\n    \"aria-modal\",\n    \"aria-multiline\",\n    \"aria-multiselectable\",\n    \"aria-orientation\",\n    \"aria-owns\",\n    \"aria-placeholder\",\n    \"aria-posinset\",\n    \"aria-pressed\",\n    \"aria-readonly\",\n    \"aria-relevant\",\n    \"aria-required\",\n    \"aria-roledescription\",\n    \"aria-rowcount\",\n    \"aria-rowindex\",\n    \"aria-rowspan\",\n    \"aria-selected\",\n    \"aria-setsize\",\n    \"aria-sort\",\n    \"aria-valuemax\",\n    \"aria-valuemin\",\n    \"aria-valuenow\",\n    \"aria-valuetext\",\n    \"className\",\n    \"color\",\n    \"height\",\n    \"id\",\n    \"lang\",\n    \"max\",\n    \"media\",\n    \"method\",\n    \"min\",\n    \"name\",\n    \"style\",\n    /*\n * removed 'type' SVGElementPropKey because we do not currently use any SVG elements\n * that can use it and it conflicts with the recharts prop 'type'\n * https://github.com/recharts/recharts/pull/3327\n * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type\n */ // 'type',\n    \"target\",\n    \"width\",\n    \"role\",\n    \"tabIndex\",\n    \"accentHeight\",\n    \"accumulate\",\n    \"additive\",\n    \"alignmentBaseline\",\n    \"allowReorder\",\n    \"alphabetic\",\n    \"amplitude\",\n    \"arabicForm\",\n    \"ascent\",\n    \"attributeName\",\n    \"attributeType\",\n    \"autoReverse\",\n    \"azimuth\",\n    \"baseFrequency\",\n    \"baselineShift\",\n    \"baseProfile\",\n    \"bbox\",\n    \"begin\",\n    \"bias\",\n    \"by\",\n    \"calcMode\",\n    \"capHeight\",\n    \"clip\",\n    \"clipPath\",\n    \"clipPathUnits\",\n    \"clipRule\",\n    \"colorInterpolation\",\n    \"colorInterpolationFilters\",\n    \"colorProfile\",\n    \"colorRendering\",\n    \"contentScriptType\",\n    \"contentStyleType\",\n    \"cursor\",\n    \"cx\",\n    \"cy\",\n    \"d\",\n    \"decelerate\",\n    \"descent\",\n    \"diffuseConstant\",\n    \"direction\",\n    \"display\",\n    \"divisor\",\n    \"dominantBaseline\",\n    \"dur\",\n    \"dx\",\n    \"dy\",\n    \"edgeMode\",\n    \"elevation\",\n    \"enableBackground\",\n    \"end\",\n    \"exponent\",\n    \"externalResourcesRequired\",\n    \"fill\",\n    \"fillOpacity\",\n    \"fillRule\",\n    \"filter\",\n    \"filterRes\",\n    \"filterUnits\",\n    \"floodColor\",\n    \"floodOpacity\",\n    \"focusable\",\n    \"fontFamily\",\n    \"fontSize\",\n    \"fontSizeAdjust\",\n    \"fontStretch\",\n    \"fontStyle\",\n    \"fontVariant\",\n    \"fontWeight\",\n    \"format\",\n    \"from\",\n    \"fx\",\n    \"fy\",\n    \"g1\",\n    \"g2\",\n    \"glyphName\",\n    \"glyphOrientationHorizontal\",\n    \"glyphOrientationVertical\",\n    \"glyphRef\",\n    \"gradientTransform\",\n    \"gradientUnits\",\n    \"hanging\",\n    \"horizAdvX\",\n    \"horizOriginX\",\n    \"href\",\n    \"ideographic\",\n    \"imageRendering\",\n    \"in2\",\n    \"in\",\n    \"intercept\",\n    \"k1\",\n    \"k2\",\n    \"k3\",\n    \"k4\",\n    \"k\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"kerning\",\n    \"keyPoints\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"lengthAdjust\",\n    \"letterSpacing\",\n    \"lightingColor\",\n    \"limitingConeAngle\",\n    \"local\",\n    \"markerEnd\",\n    \"markerHeight\",\n    \"markerMid\",\n    \"markerStart\",\n    \"markerUnits\",\n    \"markerWidth\",\n    \"mask\",\n    \"maskContentUnits\",\n    \"maskUnits\",\n    \"mathematical\",\n    \"mode\",\n    \"numOctaves\",\n    \"offset\",\n    \"opacity\",\n    \"operator\",\n    \"order\",\n    \"orient\",\n    \"orientation\",\n    \"origin\",\n    \"overflow\",\n    \"overlinePosition\",\n    \"overlineThickness\",\n    \"paintOrder\",\n    \"panose1\",\n    \"pathLength\",\n    \"patternContentUnits\",\n    \"patternTransform\",\n    \"patternUnits\",\n    \"pointerEvents\",\n    \"pointsAtX\",\n    \"pointsAtY\",\n    \"pointsAtZ\",\n    \"preserveAlpha\",\n    \"preserveAspectRatio\",\n    \"primitiveUnits\",\n    \"r\",\n    \"radius\",\n    \"refX\",\n    \"refY\",\n    \"renderingIntent\",\n    \"repeatCount\",\n    \"repeatDur\",\n    \"requiredExtensions\",\n    \"requiredFeatures\",\n    \"restart\",\n    \"result\",\n    \"rotate\",\n    \"rx\",\n    \"ry\",\n    \"seed\",\n    \"shapeRendering\",\n    \"slope\",\n    \"spacing\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"speed\",\n    \"spreadMethod\",\n    \"startOffset\",\n    \"stdDeviation\",\n    \"stemh\",\n    \"stemv\",\n    \"stitchTiles\",\n    \"stopColor\",\n    \"stopOpacity\",\n    \"strikethroughPosition\",\n    \"strikethroughThickness\",\n    \"string\",\n    \"stroke\",\n    \"strokeDasharray\",\n    \"strokeDashoffset\",\n    \"strokeLinecap\",\n    \"strokeLinejoin\",\n    \"strokeMiterlimit\",\n    \"strokeOpacity\",\n    \"strokeWidth\",\n    \"surfaceScale\",\n    \"systemLanguage\",\n    \"tableValues\",\n    \"targetX\",\n    \"targetY\",\n    \"textAnchor\",\n    \"textDecoration\",\n    \"textLength\",\n    \"textRendering\",\n    \"to\",\n    \"transform\",\n    \"u1\",\n    \"u2\",\n    \"underlinePosition\",\n    \"underlineThickness\",\n    \"unicode\",\n    \"unicodeBidi\",\n    \"unicodeRange\",\n    \"unitsPerEm\",\n    \"vAlphabetic\",\n    \"values\",\n    \"vectorEffect\",\n    \"version\",\n    \"vertAdvY\",\n    \"vertOriginX\",\n    \"vertOriginY\",\n    \"vHanging\",\n    \"vIdeographic\",\n    \"viewTarget\",\n    \"visibility\",\n    \"vMathematical\",\n    \"widths\",\n    \"wordSpacing\",\n    \"writingMode\",\n    \"x1\",\n    \"x2\",\n    \"x\",\n    \"xChannelSelector\",\n    \"xHeight\",\n    \"xlinkActuate\",\n    \"xlinkArcrole\",\n    \"xlinkHref\",\n    \"xlinkRole\",\n    \"xlinkShow\",\n    \"xlinkTitle\",\n    \"xlinkType\",\n    \"xmlBase\",\n    \"xmlLang\",\n    \"xmlns\",\n    \"xmlnsXlink\",\n    \"xmlSpace\",\n    \"y1\",\n    \"y2\",\n    \"y\",\n    \"yChannelSelector\",\n    \"z\",\n    \"zoomAndPan\",\n    \"ref\",\n    \"key\",\n    \"angle\"\n];\nvar PolyElementKeys = [\n    \"points\",\n    \"pathLength\"\n];\n/** svg element types that have specific attribute filtration requirements */ /** map of svg element types to unique svg attributes that belong to that element */ var FilteredElementKeyMap = exports.FilteredElementKeyMap = {\n    svg: SVGContainerPropKeys,\n    polygon: PolyElementKeys,\n    polyline: PolyElementKeys\n};\nvar EventKeys = exports.EventKeys = [\n    \"dangerouslySetInnerHTML\",\n    \"onCopy\",\n    \"onCopyCapture\",\n    \"onCut\",\n    \"onCutCapture\",\n    \"onPaste\",\n    \"onPasteCapture\",\n    \"onCompositionEnd\",\n    \"onCompositionEndCapture\",\n    \"onCompositionStart\",\n    \"onCompositionStartCapture\",\n    \"onCompositionUpdate\",\n    \"onCompositionUpdateCapture\",\n    \"onFocus\",\n    \"onFocusCapture\",\n    \"onBlur\",\n    \"onBlurCapture\",\n    \"onChange\",\n    \"onChangeCapture\",\n    \"onBeforeInput\",\n    \"onBeforeInputCapture\",\n    \"onInput\",\n    \"onInputCapture\",\n    \"onReset\",\n    \"onResetCapture\",\n    \"onSubmit\",\n    \"onSubmitCapture\",\n    \"onInvalid\",\n    \"onInvalidCapture\",\n    \"onLoad\",\n    \"onLoadCapture\",\n    \"onError\",\n    \"onErrorCapture\",\n    \"onKeyDown\",\n    \"onKeyDownCapture\",\n    \"onKeyPress\",\n    \"onKeyPressCapture\",\n    \"onKeyUp\",\n    \"onKeyUpCapture\",\n    \"onAbort\",\n    \"onAbortCapture\",\n    \"onCanPlay\",\n    \"onCanPlayCapture\",\n    \"onCanPlayThrough\",\n    \"onCanPlayThroughCapture\",\n    \"onDurationChange\",\n    \"onDurationChangeCapture\",\n    \"onEmptied\",\n    \"onEmptiedCapture\",\n    \"onEncrypted\",\n    \"onEncryptedCapture\",\n    \"onEnded\",\n    \"onEndedCapture\",\n    \"onLoadedData\",\n    \"onLoadedDataCapture\",\n    \"onLoadedMetadata\",\n    \"onLoadedMetadataCapture\",\n    \"onLoadStart\",\n    \"onLoadStartCapture\",\n    \"onPause\",\n    \"onPauseCapture\",\n    \"onPlay\",\n    \"onPlayCapture\",\n    \"onPlaying\",\n    \"onPlayingCapture\",\n    \"onProgress\",\n    \"onProgressCapture\",\n    \"onRateChange\",\n    \"onRateChangeCapture\",\n    \"onSeeked\",\n    \"onSeekedCapture\",\n    \"onSeeking\",\n    \"onSeekingCapture\",\n    \"onStalled\",\n    \"onStalledCapture\",\n    \"onSuspend\",\n    \"onSuspendCapture\",\n    \"onTimeUpdate\",\n    \"onTimeUpdateCapture\",\n    \"onVolumeChange\",\n    \"onVolumeChangeCapture\",\n    \"onWaiting\",\n    \"onWaitingCapture\",\n    \"onAuxClick\",\n    \"onAuxClickCapture\",\n    \"onClick\",\n    \"onClickCapture\",\n    \"onContextMenu\",\n    \"onContextMenuCapture\",\n    \"onDoubleClick\",\n    \"onDoubleClickCapture\",\n    \"onDrag\",\n    \"onDragCapture\",\n    \"onDragEnd\",\n    \"onDragEndCapture\",\n    \"onDragEnter\",\n    \"onDragEnterCapture\",\n    \"onDragExit\",\n    \"onDragExitCapture\",\n    \"onDragLeave\",\n    \"onDragLeaveCapture\",\n    \"onDragOver\",\n    \"onDragOverCapture\",\n    \"onDragStart\",\n    \"onDragStartCapture\",\n    \"onDrop\",\n    \"onDropCapture\",\n    \"onMouseDown\",\n    \"onMouseDownCapture\",\n    \"onMouseEnter\",\n    \"onMouseLeave\",\n    \"onMouseMove\",\n    \"onMouseMoveCapture\",\n    \"onMouseOut\",\n    \"onMouseOutCapture\",\n    \"onMouseOver\",\n    \"onMouseOverCapture\",\n    \"onMouseUp\",\n    \"onMouseUpCapture\",\n    \"onSelect\",\n    \"onSelectCapture\",\n    \"onTouchCancel\",\n    \"onTouchCancelCapture\",\n    \"onTouchEnd\",\n    \"onTouchEndCapture\",\n    \"onTouchMove\",\n    \"onTouchMoveCapture\",\n    \"onTouchStart\",\n    \"onTouchStartCapture\",\n    \"onPointerDown\",\n    \"onPointerDownCapture\",\n    \"onPointerMove\",\n    \"onPointerMoveCapture\",\n    \"onPointerUp\",\n    \"onPointerUpCapture\",\n    \"onPointerCancel\",\n    \"onPointerCancelCapture\",\n    \"onPointerEnter\",\n    \"onPointerEnterCapture\",\n    \"onPointerLeave\",\n    \"onPointerLeaveCapture\",\n    \"onPointerOver\",\n    \"onPointerOverCapture\",\n    \"onPointerOut\",\n    \"onPointerOutCapture\",\n    \"onGotPointerCapture\",\n    \"onGotPointerCaptureCapture\",\n    \"onLostPointerCapture\",\n    \"onLostPointerCaptureCapture\",\n    \"onScroll\",\n    \"onScrollCapture\",\n    \"onWheel\",\n    \"onWheelCapture\",\n    \"onAnimationStart\",\n    \"onAnimationStartCapture\",\n    \"onAnimationEnd\",\n    \"onAnimationEndCapture\",\n    \"onAnimationIteration\",\n    \"onAnimationIterationCapture\",\n    \"onTransitionEnd\",\n    \"onTransitionEndCapture\"\n];\n/** The type of easing function to use for animations */ /** Specifies the duration of animation, the unit of this option is ms. */ /** the offset of a chart, which define the blank space all around */ /**\n * The domain of axis.\n * This is the definition\n *\n * Numeric domain is always defined by an array of exactly two values, for the min and the max of the axis.\n * Categorical domain is defined as array of all possible values.\n *\n * Can be specified in many ways:\n * - array of numbers\n * - with special strings like 'dataMin' and 'dataMax'\n * - with special string math like 'dataMin - 100'\n * - with keyword 'auto'\n * - or a function\n * - array of functions\n * - or a combination of the above\n */ /**\n * NumberDomain is an evaluated {@link AxisDomain}.\n * Unlike {@link AxisDomain}, it has no variety - it's a tuple of two number.\n * This is after all the keywords and functions were evaluated and what is left is [min, max].\n *\n * Know that the min, max values are not guaranteed to be nice numbers - values like -Infinity or NaN are possible.\n *\n * There are also `category` axes that have different things than numbers in their domain.\n */ /** The props definition of base axis */ /** Defines how ticks are placed and whether / how tick collisions are handled.\n * 'preserveStart' keeps the left tick on collision and ensures that the first tick is always shown.\n * 'preserveEnd' keeps the right tick on collision and ensures that the last tick is always shown.\n * 'preserveStartEnd' keeps the left tick on collision and ensures that the first and last ticks are always shown.\n * 'equidistantPreserveStart' selects a number N such that every nTh tick will be shown without collision.\n */ var adaptEventHandlers = exports.adaptEventHandlers = function adaptEventHandlers(props, newHandler) {\n    if (!props || typeof props === \"function\" || typeof props === \"boolean\") {\n        return null;\n    }\n    var inputProps = props;\n    if (/*#__PURE__*/ (0, _react.isValidElement)(props)) {\n        inputProps = props.props;\n    }\n    if (!(0, _isObject[\"default\"])(inputProps)) {\n        return null;\n    }\n    var out = {};\n    Object.keys(inputProps).forEach(function(key) {\n        if (EventKeys.includes(key)) {\n            out[key] = newHandler || function(e) {\n                return inputProps[key](inputProps, e);\n            };\n        }\n    });\n    return out;\n};\nvar getEventHandlerOfChild = function getEventHandlerOfChild(originalHandler, data, index) {\n    return function(e) {\n        originalHandler(data, index, e);\n        return null;\n    };\n};\nvar adaptEventsOfChild = exports.adaptEventsOfChild = function adaptEventsOfChild(props, data, index) {\n    if (!(0, _isObject[\"default\"])(props) || _typeof(props) !== \"object\") {\n        return null;\n    }\n    var out = null;\n    Object.keys(props).forEach(function(key) {\n        var item = props[key];\n        if (EventKeys.includes(key) && typeof item === \"function\") {\n            if (!out) out = {};\n            out[key] = getEventHandlerOfChild(item, data, index);\n        }\n    });\n    return out;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvbGliL3V0aWwvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELDBCQUEwQixHQUFHQSwwQkFBMEIsR0FBR0EsMEJBQTBCLEdBQUdBLDZCQUE2QixHQUFHQSxpQkFBaUIsR0FBRyxLQUFLO0FBQ2hKLElBQUlPLFNBQVNDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQzVCLElBQUlDLFlBQVlDLHVCQUF1QkYsbUJBQU9BLENBQUMsd0NBQWlCO0FBQ2hFLFNBQVNFLHVCQUF1QkMsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUNoRyxTQUFTRSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1Q7Ozs7Ozs7Ozs7O0NBV0MsR0FFRCxFQUFFO0FBQ0Ysb0ZBQW9GO0FBQ3BGLEVBQUU7QUFFRixJQUFJSyx1QkFBdUI7SUFBQztJQUFXO0NBQVc7QUFDbEQsSUFBSWYscUJBQXFCSiwwQkFBMEIsR0FBRztJQUFDO0lBQXlCO0lBQWU7SUFBcUI7SUFBYTtJQUFnQjtJQUFpQjtJQUFpQjtJQUFnQjtJQUFpQjtJQUFnQjtJQUFvQjtJQUFnQjtJQUFpQjtJQUFxQjtJQUFpQjtJQUFlO0lBQWlCO0lBQWU7SUFBZ0I7SUFBcUI7SUFBYztJQUFtQjtJQUFjO0lBQWE7SUFBYztJQUFrQjtJQUF3QjtJQUFvQjtJQUFhO0lB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LFVBQVUwQixRQUFRLENBQUNELFFBQVEsT0FBT08sU0FBUyxZQUFZO1lBQ3pELElBQUksQ0FBQ1YsS0FBS0EsTUFBTSxDQUFDO1lBQ2pCQSxHQUFHLENBQUNHLElBQUksR0FBR0csdUJBQXVCSSxNQUFNRixNQUFNQztRQUNoRDtJQUNGO0lBQ0EsT0FBT1Q7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9saWIvdXRpbC90eXBlcy5qcz82NTU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGFwdEV2ZW50c09mQ2hpbGQgPSBleHBvcnRzLmFkYXB0RXZlbnRIYW5kbGVycyA9IGV4cG9ydHMuU1ZHRWxlbWVudFByb3BLZXlzID0gZXhwb3J0cy5GaWx0ZXJlZEVsZW1lbnRLZXlNYXAgPSBleHBvcnRzLkV2ZW50S2V5cyA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgX2lzT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzT2JqZWN0XCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuLyoqXG4gKiBEZXRlcm1pbmVzIGhvdyB2YWx1ZXMgYXJlIHN0YWNrZWQ6XG4gKlxuICogLSBgbm9uZWAgaXMgdGhlIGRlZmF1bHQsIGl0IGFkZHMgdmFsdWVzIG9uIHRvcCBvZiBlYWNoIG90aGVyLiBObyBzbWFydHMuIE5lZ2F0aXZlIHZhbHVlcyB3aWxsIG92ZXJsYXAuXG4gKiAtIGBleHBhbmRgIG1ha2UgaXQgc28gdGhhdCB0aGUgdmFsdWVzIGFsd2F5cyBhZGQgdXAgdG8gMSAtIHNvIHRoZSBjaGFydCB3aWxsIGxvb2sgbGlrZSBhIHJlY3RhbmdsZS5cbiAqIC0gYHdpZ2dsZWAgYW5kIGBzaWxob3VldHRlYCB0cmllcyB0byBrZWVwIHRoZSBjaGFydCBjZW50ZXJlZC5cbiAqIC0gYHNpZ25gIHN0YWNrcyBwb3NpdGl2ZSB2YWx1ZXMgYWJvdmUgemVybyBhbmQgbmVnYXRpdmUgdmFsdWVzIGJlbG93IHplcm8uIFNpbWlsYXIgdG8gYG5vbmVgIGJ1dCBoYW5kbGVzIG5lZ2F0aXZlcy5cbiAqIC0gYHBvc2l0aXZlYCBpZ25vcmVzIGFsbCBuZWdhdGl2ZSB2YWx1ZXMsIGFuZCB0aGVuIGJlaGF2ZXMgbGlrZSBcXGBub25lXFxgLlxuICpcbiAqIEFsc28gc2VlIGh0dHBzOi8vZDNqcy5vcmcvZDMtc2hhcGUvc3RhY2sjc3RhY2stb2Zmc2V0c1xuICogKG5vdGUgdGhhdCB0aGUgYGRpdmVyZ2luZ2Agb2Zmc2V0IGluIGQzIGlzIG5hbWVkIGBzaWduYCBpbiByZWNoYXJ0cylcbiAqL1xuXG4vL1xuLy8gRXZlbnQgSGFuZGxlciBUeXBlcyAtLSBDb3BpZWQgZnJvbSBAdHlwZXMvcmVhY3QvaW5kZXguZC50cyBhbmQgYWRhcHRlZCBmb3IgUHJvcHMuXG4vL1xuXG52YXIgU1ZHQ29udGFpbmVyUHJvcEtleXMgPSBbJ3ZpZXdCb3gnLCAnY2hpbGRyZW4nXTtcbnZhciBTVkdFbGVtZW50UHJvcEtleXMgPSBleHBvcnRzLlNWR0VsZW1lbnRQcm9wS2V5cyA9IFsnYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgJ2FyaWEtYXRvbWljJywgJ2FyaWEtYXV0b2NvbXBsZXRlJywgJ2FyaWEtYnVzeScsICdhcmlhLWNoZWNrZWQnLCAnYXJpYS1jb2xjb3VudCcsICdhcmlhLWNvbGluZGV4JywgJ2FyaWEtY29sc3BhbicsICdhcmlhLWNvbnRyb2xzJywgJ2FyaWEtY3VycmVudCcsICdhcmlhLWRlc2NyaWJlZGJ5JywgJ2FyaWEtZGV0YWlscycsICdhcmlhLWRpc2FibGVkJywgJ2FyaWEtZXJyb3JtZXNzYWdlJywgJ2FyaWEtZXhwYW5kZWQnLCAnYXJpYS1mbG93dG8nLCAnYXJpYS1oYXNwb3B1cCcsICdhcmlhLWhpZGRlbicsICdhcmlhLWludmFsaWQnLCAnYXJpYS1rZXlzaG9ydGN1dHMnLCAnYXJpYS1sYWJlbCcsICdhcmlhLWxhYmVsbGVkYnknLCAnYXJpYS1sZXZlbCcsICdhcmlhLWxpdmUnLCAnYXJpYS1tb2RhbCcsICdhcmlhLW11bHRpbGluZScsICdhcmlhLW11bHRpc2VsZWN0YWJsZScsICdhcmlhLW9yaWVudGF0aW9uJywgJ2FyaWEtb3ducycsICdhcmlhLXBsYWNlaG9sZGVyJywgJ2FyaWEtcG9zaW5zZXQnLCAnYXJpYS1wcmVzc2VkJywgJ2FyaWEtcmVhZG9ubHknLCAnYXJpYS1yZWxldmFudCcsICdhcmlhLXJlcXVpcmVkJywgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJywgJ2FyaWEtcm93Y291bnQnLCAnYXJpYS1yb3dpbmRleCcsICdhcmlhLXJvd3NwYW4nLCAnYXJpYS1zZWxlY3RlZCcsICdhcmlhLXNldHNpemUnLCAnYXJpYS1zb3J0JywgJ2FyaWEtdmFsdWVtYXgnLCAnYXJpYS12YWx1ZW1pbicsICdhcmlhLXZhbHVlbm93JywgJ2FyaWEtdmFsdWV0ZXh0JywgJ2NsYXNzTmFtZScsICdjb2xvcicsICdoZWlnaHQnLCAnaWQnLCAnbGFuZycsICdtYXgnLCAnbWVkaWEnLCAnbWV0aG9kJywgJ21pbicsICduYW1lJywgJ3N0eWxlJyxcbi8qXG4gKiByZW1vdmVkICd0eXBlJyBTVkdFbGVtZW50UHJvcEtleSBiZWNhdXNlIHdlIGRvIG5vdCBjdXJyZW50bHkgdXNlIGFueSBTVkcgZWxlbWVudHNcbiAqIHRoYXQgY2FuIHVzZSBpdCBhbmQgaXQgY29uZmxpY3RzIHdpdGggdGhlIHJlY2hhcnRzIHByb3AgJ3R5cGUnXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVjaGFydHMvcmVjaGFydHMvcHVsbC8zMzI3XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3R5cGVcbiAqL1xuLy8gJ3R5cGUnLFxuJ3RhcmdldCcsICd3aWR0aCcsICdyb2xlJywgJ3RhYkluZGV4JywgJ2FjY2VudEhlaWdodCcsICdhY2N1bXVsYXRlJywgJ2FkZGl0aXZlJywgJ2FsaWdubWVudEJhc2VsaW5lJywgJ2FsbG93UmVvcmRlcicsICdhbHBoYWJldGljJywgJ2FtcGxpdHVkZScsICdhcmFiaWNGb3JtJywgJ2FzY2VudCcsICdhdHRyaWJ1dGVOYW1lJywgJ2F0dHJpYnV0ZVR5cGUnLCAnYXV0b1JldmVyc2UnLCAnYXppbXV0aCcsICdiYXNlRnJlcXVlbmN5JywgJ2Jhc2VsaW5lU2hpZnQnLCAnYmFzZVByb2ZpbGUnLCAnYmJveCcsICdiZWdpbicsICdiaWFzJywgJ2J5JywgJ2NhbGNNb2RlJywgJ2NhcEhlaWdodCcsICdjbGlwJywgJ2NsaXBQYXRoJywgJ2NsaXBQYXRoVW5pdHMnLCAnY2xpcFJ1bGUnLCAnY29sb3JJbnRlcnBvbGF0aW9uJywgJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLCAnY29sb3JQcm9maWxlJywgJ2NvbG9yUmVuZGVyaW5nJywgJ2NvbnRlbnRTY3JpcHRUeXBlJywgJ2NvbnRlbnRTdHlsZVR5cGUnLCAnY3Vyc29yJywgJ2N4JywgJ2N5JywgJ2QnLCAnZGVjZWxlcmF0ZScsICdkZXNjZW50JywgJ2RpZmZ1c2VDb25zdGFudCcsICdkaXJlY3Rpb24nLCAnZGlzcGxheScsICdkaXZpc29yJywgJ2RvbWluYW50QmFzZWxpbmUnLCAnZHVyJywgJ2R4JywgJ2R5JywgJ2VkZ2VNb2RlJywgJ2VsZXZhdGlvbicsICdlbmFibGVCYWNrZ3JvdW5kJywgJ2VuZCcsICdleHBvbmVudCcsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2ZpbGwnLCAnZmlsbE9wYWNpdHknLCAnZmlsbFJ1bGUnLCAnZmlsdGVyJywgJ2ZpbHRlclJlcycsICdmaWx0ZXJVbml0cycsICdmbG9vZENvbG9yJywgJ2Zsb29kT3BhY2l0eScsICdmb2N1c2FibGUnLCAnZm9udEZhbWlseScsICdmb250U2l6ZScsICdmb250U2l6ZUFkanVzdCcsICdmb250U3RyZXRjaCcsICdmb250U3R5bGUnLCAnZm9udFZhcmlhbnQnLCAnZm9udFdlaWdodCcsICdmb3JtYXQnLCAnZnJvbScsICdmeCcsICdmeScsICdnMScsICdnMicsICdnbHlwaE5hbWUnLCAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLCAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJywgJ2dseXBoUmVmJywgJ2dyYWRpZW50VHJhbnNmb3JtJywgJ2dyYWRpZW50VW5pdHMnLCAnaGFuZ2luZycsICdob3JpekFkdlgnLCAnaG9yaXpPcmlnaW5YJywgJ2hyZWYnLCAnaWRlb2dyYXBoaWMnLCAnaW1hZ2VSZW5kZXJpbmcnLCAnaW4yJywgJ2luJywgJ2ludGVyY2VwdCcsICdrMScsICdrMicsICdrMycsICdrNCcsICdrJywgJ2tlcm5lbE1hdHJpeCcsICdrZXJuZWxVbml0TGVuZ3RoJywgJ2tlcm5pbmcnLCAna2V5UG9pbnRzJywgJ2tleVNwbGluZXMnLCAna2V5VGltZXMnLCAnbGVuZ3RoQWRqdXN0JywgJ2xldHRlclNwYWNpbmcnLCAnbGlnaHRpbmdDb2xvcicsICdsaW1pdGluZ0NvbmVBbmdsZScsICdsb2NhbCcsICdtYXJrZXJFbmQnLCAnbWFya2VySGVpZ2h0JywgJ21hcmtlck1pZCcsICdtYXJrZXJTdGFydCcsICdtYXJrZXJVbml0cycsICdtYXJrZXJXaWR0aCcsICdtYXNrJywgJ21hc2tDb250ZW50VW5pdHMnLCAnbWFza1VuaXRzJywgJ21hdGhlbWF0aWNhbCcsICdtb2RlJywgJ251bU9jdGF2ZXMnLCAnb2Zmc2V0JywgJ29wYWNpdHknLCAnb3BlcmF0b3InLCAnb3JkZXInLCAnb3JpZW50JywgJ29yaWVudGF0aW9uJywgJ29yaWdpbicsICdvdmVyZmxvdycsICdvdmVybGluZVBvc2l0aW9uJywgJ292ZXJsaW5lVGhpY2tuZXNzJywgJ3BhaW50T3JkZXInLCAncGFub3NlMScsICdwYXRoTGVuZ3RoJywgJ3BhdHRlcm5Db250ZW50VW5pdHMnLCAncGF0dGVyblRyYW5zZm9ybScsICdwYXR0ZXJuVW5pdHMnLCAncG9pbnRlckV2ZW50cycsICdwb2ludHNBdFgnLCAncG9pbnRzQXRZJywgJ3BvaW50c0F0WicsICdwcmVzZXJ2ZUFscGhhJywgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAncHJpbWl0aXZlVW5pdHMnLCAncicsICdyYWRpdXMnLCAncmVmWCcsICdyZWZZJywgJ3JlbmRlcmluZ0ludGVudCcsICdyZXBlYXRDb3VudCcsICdyZXBlYXREdXInLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAncmVzdGFydCcsICdyZXN1bHQnLCAncm90YXRlJywgJ3J4JywgJ3J5JywgJ3NlZWQnLCAnc2hhcGVSZW5kZXJpbmcnLCAnc2xvcGUnLCAnc3BhY2luZycsICdzcGVjdWxhckNvbnN0YW50JywgJ3NwZWN1bGFyRXhwb25lbnQnLCAnc3BlZWQnLCAnc3ByZWFkTWV0aG9kJywgJ3N0YXJ0T2Zmc2V0JywgJ3N0ZERldmlhdGlvbicsICdzdGVtaCcsICdzdGVtdicsICdzdGl0Y2hUaWxlcycsICdzdG9wQ29sb3InLCAnc3RvcE9wYWNpdHknLCAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLCAnc3RyaW5nJywgJ3N0cm9rZScsICdzdHJva2VEYXNoYXJyYXknLCAnc3Ryb2tlRGFzaG9mZnNldCcsICdzdHJva2VMaW5lY2FwJywgJ3N0cm9rZUxpbmVqb2luJywgJ3N0cm9rZU1pdGVybGltaXQnLCAnc3Ryb2tlT3BhY2l0eScsICdzdHJva2VXaWR0aCcsICdzdXJmYWNlU2NhbGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndGFibGVWYWx1ZXMnLCAndGFyZ2V0WCcsICd0YXJnZXRZJywgJ3RleHRBbmNob3InLCAndGV4dERlY29yYXRpb24nLCAndGV4dExlbmd0aCcsICd0ZXh0UmVuZGVyaW5nJywgJ3RvJywgJ3RyYW5zZm9ybScsICd1MScsICd1MicsICd1bmRlcmxpbmVQb3NpdGlvbicsICd1bmRlcmxpbmVUaGlja25lc3MnLCAndW5pY29kZScsICd1bmljb2RlQmlkaScsICd1bmljb2RlUmFuZ2UnLCAndW5pdHNQZXJFbScsICd2QWxwaGFiZXRpYycsICd2YWx1ZXMnLCAndmVjdG9yRWZmZWN0JywgJ3ZlcnNpb24nLCAndmVydEFkdlknLCAndmVydE9yaWdpblgnLCAndmVydE9yaWdpblknLCAndkhhbmdpbmcnLCAndklkZW9ncmFwaGljJywgJ3ZpZXdUYXJnZXQnLCAndmlzaWJpbGl0eScsICd2TWF0aGVtYXRpY2FsJywgJ3dpZHRocycsICd3b3JkU3BhY2luZycsICd3cml0aW5nTW9kZScsICd4MScsICd4MicsICd4JywgJ3hDaGFubmVsU2VsZWN0b3InLCAneEhlaWdodCcsICd4bGlua0FjdHVhdGUnLCAneGxpbmtBcmNyb2xlJywgJ3hsaW5rSHJlZicsICd4bGlua1JvbGUnLCAneGxpbmtTaG93JywgJ3hsaW5rVGl0bGUnLCAneGxpbmtUeXBlJywgJ3htbEJhc2UnLCAneG1sTGFuZycsICd4bWxucycsICd4bWxuc1hsaW5rJywgJ3htbFNwYWNlJywgJ3kxJywgJ3kyJywgJ3knLCAneUNoYW5uZWxTZWxlY3RvcicsICd6JywgJ3pvb21BbmRQYW4nLCAncmVmJywgJ2tleScsICdhbmdsZSddO1xudmFyIFBvbHlFbGVtZW50S2V5cyA9IFsncG9pbnRzJywgJ3BhdGhMZW5ndGgnXTtcblxuLyoqIHN2ZyBlbGVtZW50IHR5cGVzIHRoYXQgaGF2ZSBzcGVjaWZpYyBhdHRyaWJ1dGUgZmlsdHJhdGlvbiByZXF1aXJlbWVudHMgKi9cblxuLyoqIG1hcCBvZiBzdmcgZWxlbWVudCB0eXBlcyB0byB1bmlxdWUgc3ZnIGF0dHJpYnV0ZXMgdGhhdCBiZWxvbmcgdG8gdGhhdCBlbGVtZW50ICovXG52YXIgRmlsdGVyZWRFbGVtZW50S2V5TWFwID0gZXhwb3J0cy5GaWx0ZXJlZEVsZW1lbnRLZXlNYXAgPSB7XG4gIHN2ZzogU1ZHQ29udGFpbmVyUHJvcEtleXMsXG4gIHBvbHlnb246IFBvbHlFbGVtZW50S2V5cyxcbiAgcG9seWxpbmU6IFBvbHlFbGVtZW50S2V5c1xufTtcbnZhciBFdmVudEtleXMgPSBleHBvcnRzLkV2ZW50S2V5cyA9IFsnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLCAnb25Db3B5JywgJ29uQ29weUNhcHR1cmUnLCAnb25DdXQnLCAnb25DdXRDYXB0dXJlJywgJ29uUGFzdGUnLCAnb25QYXN0ZUNhcHR1cmUnLCAnb25Db21wb3NpdGlvbkVuZCcsICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZScsICdvbkNvbXBvc2l0aW9uU3RhcnQnLCAnb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZScsICdvbkNvbXBvc2l0aW9uVXBkYXRlJywgJ29uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlJywgJ29uRm9jdXMnLCAnb25Gb2N1c0NhcHR1cmUnLCAnb25CbHVyJywgJ29uQmx1ckNhcHR1cmUnLCAnb25DaGFuZ2UnLCAnb25DaGFuZ2VDYXB0dXJlJywgJ29uQmVmb3JlSW5wdXQnLCAnb25CZWZvcmVJbnB1dENhcHR1cmUnLCAnb25JbnB1dCcsICdvbklucHV0Q2FwdHVyZScsICdvblJlc2V0JywgJ29uUmVzZXRDYXB0dXJlJywgJ29uU3VibWl0JywgJ29uU3VibWl0Q2FwdHVyZScsICdvbkludmFsaWQnLCAnb25JbnZhbGlkQ2FwdHVyZScsICdvbkxvYWQnLCAnb25Mb2FkQ2FwdHVyZScsICdvbkVycm9yJywgJ29uRXJyb3JDYXB0dXJlJywgJ29uS2V5RG93bicsICdvbktleURvd25DYXB0dXJlJywgJ29uS2V5UHJlc3MnLCAnb25LZXlQcmVzc0NhcHR1cmUnLCAnb25LZXlVcCcsICdvbktleVVwQ2FwdHVyZScsICdvbkFib3J0JywgJ29uQWJvcnRDYXB0dXJlJywgJ29uQ2FuUGxheScsICdvbkNhblBsYXlDYXB0dXJlJywgJ29uQ2FuUGxheVRocm91Z2gnLCAnb25DYW5QbGF5VGhyb3VnaENhcHR1cmUnLCAnb25EdXJhdGlvbkNoYW5nZScsICdvbkR1cmF0aW9uQ2hhbmdlQ2FwdHVyZScsICdvbkVtcHRpZWQnLCAnb25FbXB0aWVkQ2FwdHVyZScsICdvbkVuY3J5cHRlZCcsICdvbkVuY3J5cHRlZENhcHR1cmUnLCAnb25FbmRlZCcsICdvbkVuZGVkQ2FwdHVyZScsICdvbkxvYWRlZERhdGEnLCAnb25Mb2FkZWREYXRhQ2FwdHVyZScsICdvbkxvYWRlZE1ldGFkYXRhJywgJ29uTG9hZGVkTWV0YWRhdGFDYXB0dXJlJywgJ29uTG9hZFN0YXJ0JywgJ29uTG9hZFN0YXJ0Q2FwdHVyZScsICdvblBhdXNlJywgJ29uUGF1c2VDYXB0dXJlJywgJ29uUGxheScsICdvblBsYXlDYXB0dXJlJywgJ29uUGxheWluZycsICdvblBsYXlpbmdDYXB0dXJlJywgJ29uUHJvZ3Jlc3MnLCAnb25Qcm9ncmVzc0NhcHR1cmUnLCAnb25SYXRlQ2hhbmdlJywgJ29uUmF0ZUNoYW5nZUNhcHR1cmUnLCAnb25TZWVrZWQnLCAnb25TZWVrZWRDYXB0dXJlJywgJ29uU2Vla2luZycsICdvblNlZWtpbmdDYXB0dXJlJywgJ29uU3RhbGxlZCcsICdvblN0YWxsZWRDYXB0dXJlJywgJ29uU3VzcGVuZCcsICdvblN1c3BlbmRDYXB0dXJlJywgJ29uVGltZVVwZGF0ZScsICdvblRpbWVVcGRhdGVDYXB0dXJlJywgJ29uVm9sdW1lQ2hhbmdlJywgJ29uVm9sdW1lQ2hhbmdlQ2FwdHVyZScsICdvbldhaXRpbmcnLCAnb25XYWl0aW5nQ2FwdHVyZScsICdvbkF1eENsaWNrJywgJ29uQXV4Q2xpY2tDYXB0dXJlJywgJ29uQ2xpY2snLCAnb25DbGlja0NhcHR1cmUnLCAnb25Db250ZXh0TWVudScsICdvbkNvbnRleHRNZW51Q2FwdHVyZScsICdvbkRvdWJsZUNsaWNrJywgJ29uRG91YmxlQ2xpY2tDYXB0dXJlJywgJ29uRHJhZycsICdvbkRyYWdDYXB0dXJlJywgJ29uRHJhZ0VuZCcsICdvbkRyYWdFbmRDYXB0dXJlJywgJ29uRHJhZ0VudGVyJywgJ29uRHJhZ0VudGVyQ2FwdHVyZScsICdvbkRyYWdFeGl0JywgJ29uRHJhZ0V4aXRDYXB0dXJlJywgJ29uRHJhZ0xlYXZlJywgJ29uRHJhZ0xlYXZlQ2FwdHVyZScsICdvbkRyYWdPdmVyJywgJ29uRHJhZ092ZXJDYXB0dXJlJywgJ29uRHJhZ1N0YXJ0JywgJ29uRHJhZ1N0YXJ0Q2FwdHVyZScsICdvbkRyb3AnLCAnb25Ecm9wQ2FwdHVyZScsICdvbk1vdXNlRG93bicsICdvbk1vdXNlRG93bkNhcHR1cmUnLCAnb25Nb3VzZUVudGVyJywgJ29uTW91c2VMZWF2ZScsICdvbk1vdXNlTW92ZScsICdvbk1vdXNlTW92ZUNhcHR1cmUnLCAnb25Nb3VzZU91dCcsICdvbk1vdXNlT3V0Q2FwdHVyZScsICdvbk1vdXNlT3ZlcicsICdvbk1vdXNlT3ZlckNhcHR1cmUnLCAnb25Nb3VzZVVwJywgJ29uTW91c2VVcENhcHR1cmUnLCAnb25TZWxlY3QnLCAnb25TZWxlY3RDYXB0dXJlJywgJ29uVG91Y2hDYW5jZWwnLCAnb25Ub3VjaENhbmNlbENhcHR1cmUnLCAnb25Ub3VjaEVuZCcsICdvblRvdWNoRW5kQ2FwdHVyZScsICdvblRvdWNoTW92ZScsICdvblRvdWNoTW92ZUNhcHR1cmUnLCAnb25Ub3VjaFN0YXJ0JywgJ29uVG91Y2hTdGFydENhcHR1cmUnLCAnb25Qb2ludGVyRG93bicsICdvblBvaW50ZXJEb3duQ2FwdHVyZScsICdvblBvaW50ZXJNb3ZlJywgJ29uUG9pbnRlck1vdmVDYXB0dXJlJywgJ29uUG9pbnRlclVwJywgJ29uUG9pbnRlclVwQ2FwdHVyZScsICdvblBvaW50ZXJDYW5jZWwnLCAnb25Qb2ludGVyQ2FuY2VsQ2FwdHVyZScsICdvblBvaW50ZXJFbnRlcicsICdvblBvaW50ZXJFbnRlckNhcHR1cmUnLCAnb25Qb2ludGVyTGVhdmUnLCAnb25Qb2ludGVyTGVhdmVDYXB0dXJlJywgJ29uUG9pbnRlck92ZXInLCAnb25Qb2ludGVyT3ZlckNhcHR1cmUnLCAnb25Qb2ludGVyT3V0JywgJ29uUG9pbnRlck91dENhcHR1cmUnLCAnb25Hb3RQb2ludGVyQ2FwdHVyZScsICdvbkdvdFBvaW50ZXJDYXB0dXJlQ2FwdHVyZScsICdvbkxvc3RQb2ludGVyQ2FwdHVyZScsICdvbkxvc3RQb2ludGVyQ2FwdHVyZUNhcHR1cmUnLCAnb25TY3JvbGwnLCAnb25TY3JvbGxDYXB0dXJlJywgJ29uV2hlZWwnLCAnb25XaGVlbENhcHR1cmUnLCAnb25BbmltYXRpb25TdGFydCcsICdvbkFuaW1hdGlvblN0YXJ0Q2FwdHVyZScsICdvbkFuaW1hdGlvbkVuZCcsICdvbkFuaW1hdGlvbkVuZENhcHR1cmUnLCAnb25BbmltYXRpb25JdGVyYXRpb24nLCAnb25BbmltYXRpb25JdGVyYXRpb25DYXB0dXJlJywgJ29uVHJhbnNpdGlvbkVuZCcsICdvblRyYW5zaXRpb25FbmRDYXB0dXJlJ107XG5cbi8qKiBUaGUgdHlwZSBvZiBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciBhbmltYXRpb25zICovXG5cbi8qKiBTcGVjaWZpZXMgdGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiwgdGhlIHVuaXQgb2YgdGhpcyBvcHRpb24gaXMgbXMuICovXG5cbi8qKiB0aGUgb2Zmc2V0IG9mIGEgY2hhcnQsIHdoaWNoIGRlZmluZSB0aGUgYmxhbmsgc3BhY2UgYWxsIGFyb3VuZCAqL1xuXG4vKipcbiAqIFRoZSBkb21haW4gb2YgYXhpcy5cbiAqIFRoaXMgaXMgdGhlIGRlZmluaXRpb25cbiAqXG4gKiBOdW1lcmljIGRvbWFpbiBpcyBhbHdheXMgZGVmaW5lZCBieSBhbiBhcnJheSBvZiBleGFjdGx5IHR3byB2YWx1ZXMsIGZvciB0aGUgbWluIGFuZCB0aGUgbWF4IG9mIHRoZSBheGlzLlxuICogQ2F0ZWdvcmljYWwgZG9tYWluIGlzIGRlZmluZWQgYXMgYXJyYXkgb2YgYWxsIHBvc3NpYmxlIHZhbHVlcy5cbiAqXG4gKiBDYW4gYmUgc3BlY2lmaWVkIGluIG1hbnkgd2F5czpcbiAqIC0gYXJyYXkgb2YgbnVtYmVyc1xuICogLSB3aXRoIHNwZWNpYWwgc3RyaW5ncyBsaWtlICdkYXRhTWluJyBhbmQgJ2RhdGFNYXgnXG4gKiAtIHdpdGggc3BlY2lhbCBzdHJpbmcgbWF0aCBsaWtlICdkYXRhTWluIC0gMTAwJ1xuICogLSB3aXRoIGtleXdvcmQgJ2F1dG8nXG4gKiAtIG9yIGEgZnVuY3Rpb25cbiAqIC0gYXJyYXkgb2YgZnVuY3Rpb25zXG4gKiAtIG9yIGEgY29tYmluYXRpb24gb2YgdGhlIGFib3ZlXG4gKi9cblxuLyoqXG4gKiBOdW1iZXJEb21haW4gaXMgYW4gZXZhbHVhdGVkIHtAbGluayBBeGlzRG9tYWlufS5cbiAqIFVubGlrZSB7QGxpbmsgQXhpc0RvbWFpbn0sIGl0IGhhcyBubyB2YXJpZXR5IC0gaXQncyBhIHR1cGxlIG9mIHR3byBudW1iZXIuXG4gKiBUaGlzIGlzIGFmdGVyIGFsbCB0aGUga2V5d29yZHMgYW5kIGZ1bmN0aW9ucyB3ZXJlIGV2YWx1YXRlZCBhbmQgd2hhdCBpcyBsZWZ0IGlzIFttaW4sIG1heF0uXG4gKlxuICogS25vdyB0aGF0IHRoZSBtaW4sIG1heCB2YWx1ZXMgYXJlIG5vdCBndWFyYW50ZWVkIHRvIGJlIG5pY2UgbnVtYmVycyAtIHZhbHVlcyBsaWtlIC1JbmZpbml0eSBvciBOYU4gYXJlIHBvc3NpYmxlLlxuICpcbiAqIFRoZXJlIGFyZSBhbHNvIGBjYXRlZ29yeWAgYXhlcyB0aGF0IGhhdmUgZGlmZmVyZW50IHRoaW5ncyB0aGFuIG51bWJlcnMgaW4gdGhlaXIgZG9tYWluLlxuICovXG5cbi8qKiBUaGUgcHJvcHMgZGVmaW5pdGlvbiBvZiBiYXNlIGF4aXMgKi9cblxuLyoqIERlZmluZXMgaG93IHRpY2tzIGFyZSBwbGFjZWQgYW5kIHdoZXRoZXIgLyBob3cgdGljayBjb2xsaXNpb25zIGFyZSBoYW5kbGVkLlxuICogJ3ByZXNlcnZlU3RhcnQnIGtlZXBzIHRoZSBsZWZ0IHRpY2sgb24gY29sbGlzaW9uIGFuZCBlbnN1cmVzIHRoYXQgdGhlIGZpcnN0IHRpY2sgaXMgYWx3YXlzIHNob3duLlxuICogJ3ByZXNlcnZlRW5kJyBrZWVwcyB0aGUgcmlnaHQgdGljayBvbiBjb2xsaXNpb24gYW5kIGVuc3VyZXMgdGhhdCB0aGUgbGFzdCB0aWNrIGlzIGFsd2F5cyBzaG93bi5cbiAqICdwcmVzZXJ2ZVN0YXJ0RW5kJyBrZWVwcyB0aGUgbGVmdCB0aWNrIG9uIGNvbGxpc2lvbiBhbmQgZW5zdXJlcyB0aGF0IHRoZSBmaXJzdCBhbmQgbGFzdCB0aWNrcyBhcmUgYWx3YXlzIHNob3duLlxuICogJ2VxdWlkaXN0YW50UHJlc2VydmVTdGFydCcgc2VsZWN0cyBhIG51bWJlciBOIHN1Y2ggdGhhdCBldmVyeSBuVGggdGljayB3aWxsIGJlIHNob3duIHdpdGhvdXQgY29sbGlzaW9uLlxuICovXG5cbnZhciBhZGFwdEV2ZW50SGFuZGxlcnMgPSBleHBvcnRzLmFkYXB0RXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uIGFkYXB0RXZlbnRIYW5kbGVycyhwcm9wcywgbmV3SGFuZGxlcikge1xuICBpZiAoIXByb3BzIHx8IHR5cGVvZiBwcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcHJvcHMgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpbnB1dFByb3BzID0gcHJvcHM7XG4gIGlmICggLyojX19QVVJFX18qLygwLCBfcmVhY3QuaXNWYWxpZEVsZW1lbnQpKHByb3BzKSkge1xuICAgIGlucHV0UHJvcHMgPSBwcm9wcy5wcm9wcztcbiAgfVxuICBpZiAoISgwLCBfaXNPYmplY3RbXCJkZWZhdWx0XCJdKShpbnB1dFByb3BzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBvdXQgPSB7fTtcbiAgT2JqZWN0LmtleXMoaW5wdXRQcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKEV2ZW50S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBvdXRba2V5XSA9IG5ld0hhbmRsZXIgfHwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0UHJvcHNba2V5XShpbnB1dFByb3BzLCBlKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dDtcbn07XG52YXIgZ2V0RXZlbnRIYW5kbGVyT2ZDaGlsZCA9IGZ1bmN0aW9uIGdldEV2ZW50SGFuZGxlck9mQ2hpbGQob3JpZ2luYWxIYW5kbGVyLCBkYXRhLCBpbmRleCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICBvcmlnaW5hbEhhbmRsZXIoZGF0YSwgaW5kZXgsIGUpO1xuICAgIHJldHVybiBudWxsO1xuICB9O1xufTtcbnZhciBhZGFwdEV2ZW50c09mQ2hpbGQgPSBleHBvcnRzLmFkYXB0RXZlbnRzT2ZDaGlsZCA9IGZ1bmN0aW9uIGFkYXB0RXZlbnRzT2ZDaGlsZChwcm9wcywgZGF0YSwgaW5kZXgpIHtcbiAgaWYgKCEoMCwgX2lzT2JqZWN0W1wiZGVmYXVsdFwiXSkocHJvcHMpIHx8IF90eXBlb2YocHJvcHMpICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBvdXQgPSBudWxsO1xuICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGl0ZW0gPSBwcm9wc1trZXldO1xuICAgIGlmIChFdmVudEtleXMuaW5jbHVkZXMoa2V5KSAmJiB0eXBlb2YgaXRlbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKCFvdXQpIG91dCA9IHt9O1xuICAgICAgb3V0W2tleV0gPSBnZXRFdmVudEhhbmRsZXJPZkNoaWxkKGl0ZW0sIGRhdGEsIGluZGV4KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0O1xufTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhZGFwdEV2ZW50c09mQ2hpbGQiLCJhZGFwdEV2ZW50SGFuZGxlcnMiLCJTVkdFbGVtZW50UHJvcEtleXMiLCJGaWx0ZXJlZEVsZW1lbnRLZXlNYXAiLCJFdmVudEtleXMiLCJfcmVhY3QiLCJyZXF1aXJlIiwiX2lzT2JqZWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJTVkdDb250YWluZXJQcm9wS2V5cyIsIlBvbHlFbGVtZW50S2V5cyIsInN2ZyIsInBvbHlnb24iLCJwb2x5bGluZSIsInByb3BzIiwibmV3SGFuZGxlciIsImlucHV0UHJvcHMiLCJpc1ZhbGlkRWxlbWVudCIsIm91dCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiaW5jbHVkZXMiLCJlIiwiZ2V0RXZlbnRIYW5kbGVyT2ZDaGlsZCIsIm9yaWdpbmFsSGFuZGxlciIsImRhdGEiLCJpbmRleCIsIml0ZW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recharts/lib/util/types.js\n");

/***/ })

};
;
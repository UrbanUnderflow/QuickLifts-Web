"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/createRound",{

/***/ "./src/api/firebase/gemini/service.ts":
/*!********************************************!*\
  !*** ./src/api/firebase/gemini/service.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GeminiService: function() { return /* binding */ GeminiService; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_async_to_generator */ \"./node_modules/@swc/helpers/esm/_async_to_generator.js\");\n/* harmony import */ var _swc_helpers_class_call_check__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ \"./node_modules/@swc/helpers/esm/_class_call_check.js\");\n/* harmony import */ var _swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_ts_generator */ \"./node_modules/@swc/helpers/esm/_ts_generator.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./src/api/firebase/config.ts\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n// services/GeminiService.ts\n\n\n\n\n\nvar GeminiService = /*#__PURE__*/ function() {\n    \"use strict\";\n    function GeminiService() {\n        (0,_swc_helpers_class_call_check__WEBPACK_IMPORTED_MODULE_2__._)(this, GeminiService);\n    }\n    var _proto = GeminiService.prototype;\n    _proto.sendPrompt = function sendPrompt(prompt) {\n        var _this = this;\n        return (0,_swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_3__._)(function() {\n            var generateRef, response, error;\n            return (0,_swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_4__._)(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        _state.trys.push([\n                            0,\n                            3,\n                            ,\n                            4\n                        ]);\n                        return [\n                            4,\n                            (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_config__WEBPACK_IMPORTED_MODULE_0__.db, \"generate\"), {\n                                prompt: prompt\n                            })\n                        ];\n                    case 1:\n                        generateRef = _state.sent();\n                        console.log(\"Generated prompt document ID:\", generateRef.id);\n                        return [\n                            4,\n                            _this.fetchOutputWithRetry(generateRef, 30, 2000)\n                        ];\n                    case 2:\n                        response = _state.sent();\n                        return [\n                            2,\n                            response\n                        ];\n                    case 3:\n                        error = _state.sent();\n                        console.error(\"Error sending prompt:\", error);\n                        throw error;\n                    case 4:\n                        return [\n                            2\n                        ];\n                }\n            });\n        })();\n    };\n    _proto.fetchOutputWithRetry = function fetchOutputWithRetry(docRef, attempts, delay) {\n        var _this = this;\n        return (0,_swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_3__._)(function() {\n            var snapshot, data;\n            return (0,_swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_4__._)(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        if (attempts === 0) {\n                            throw new Error(\"Max retry attempts reached\");\n                        }\n                        return [\n                            4,\n                            (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(docRef)\n                        ];\n                    case 1:\n                        snapshot = _state.sent();\n                        data = snapshot.data();\n                        if (data === null || data === void 0 ? void 0 : data.output) {\n                            return [\n                                2,\n                                data.output\n                            ];\n                        }\n                        return [\n                            4,\n                            new Promise(function(resolve) {\n                                return setTimeout(resolve, delay);\n                            })\n                        ];\n                    case 2:\n                        _state.sent();\n                        return [\n                            2,\n                            _this.fetchOutputWithRetry(docRef, attempts - 1, delay)\n                        ];\n                }\n            });\n        })();\n    };\n    _proto.generateRound = function generateRound(mustIncludeExercises, userPrompt, preferences, creatorExercises, allAvailableExercises, startDate, endDate) {\n        var _this = this;\n        return (0,_swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_3__._)(function() {\n            var numberOfWorkouts, mustIncludeList, creatorExerciseList, allExerciseList, prompt, response, jsonString, parsedResponse, error;\n            return (0,_swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_4__._)(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        // Calculate the number of workouts based on date range\n                        numberOfWorkouts = _this.calculateNumberOfWorkouts(startDate, endDate);\n                        // Combine all available exercises\n                        mustIncludeList = mustIncludeExercises.join(\", \");\n                        creatorExerciseList = creatorExercises.map(function(ex) {\n                            return ex.name;\n                        }).join(\", \");\n                        allExerciseList = allAvailableExercises.map(function(ex) {\n                            return ex.name;\n                        }).join(\", \");\n                        prompt = \"\\n    You are a JSON-generating fitness AI. Your response must be PURE JSON - no markdown, no HTML, no explanations.\\n    \\n    Task: Create a fitness program with these requirements:\\n\\n    USER DESCRIPTION:\\n    \".concat(userPrompt, \"\\n\\n    PROGRAM LENGTH:\\n    - Generate exactly \").concat(numberOfWorkouts, \" workout stacks\\n    - Program runs from \").concat(startDate.toLocaleDateString(), \" to \").concat(endDate.toLocaleDateString(), \"\\n\\n    EXERCISE SELECTION PRIORITIES:\\n    1. Must include these exercises: \").concat(mustIncludeList, \"\\n    2. Prefer these creator-specific exercises when possible: \").concat(creatorExerciseList, \"\\n    3. Can also include any of these exercises as needed: \").concat(allExerciseList, \"\\n\\n    PREFERENCES:\\n    \").concat(preferences.join(\"\\n\"), \"\\n\\n    SPECIFIC REQUIREMENTS:\\n    1. Generate exactly \").concat(numberOfWorkouts, \" unique workout stacks\\n    2. Each stack should have a descriptive title and purpose\\n    3. Consider workout frequency and progression over the \").concat(_this.calculateWeeks(startDate, endDate), ' week period\\n    4. Space out similar workouts appropriately\\n    5. Include progressive overload where appropriate\\n\\n    RESPONSE FORMAT REQUIREMENTS:\\n    1. Response must be valid JSON only\\n    2. No markdown backticks\\n    3. No HTML encoding\\n    4. No explanatory text\\n    5. Array values must use straight quotes only: [\"8\",\"10\"] not [\"8\",\"10\"]\\n    6. Numbers must be numeric: 45 not \"45\"\\n\\n    JSON STRUCTURE:\\n    {\\n      \"stacks\": [\\n        {\\n          \"title\": \"Upper Body Power\",\\n          \"description\": \"Focus on upper body strength\",\\n          \"exercises\": [\\n            {\\n              \"name\": \"Bench Press\",\\n              \"category\": {\\n                \"type\": \"weightTraining\",\\n                \"details\": {\\n                  \"sets\": 3,\\n                  \"reps\": [\"8\",\"10\"],\\n                  \"weight\": 0,\\n                  \"screenTime\": 45\\n                }\\n              }\\n            }\\n          ]\\n        }\\n      ]\\n    }\\n\\n    REMEMBER:\\n    - Must generate exactly ').concat(numberOfWorkouts, \" stacks\\n    - Use only exercises from the provided lists\\n    - 4-6 exercises per stack\\n    - Only return the JSON object, nothing else\\n    \");\n                        console.log(\"Generating program with\", numberOfWorkouts, \"workouts\");\n                        _state.label = 1;\n                    case 1:\n                        _state.trys.push([\n                            1,\n                            3,\n                            ,\n                            4\n                        ]);\n                        return [\n                            4,\n                            _this.sendPrompt(prompt)\n                        ];\n                    case 2:\n                        response = _state.sent();\n                        // Clean and sanitize the response\n                        jsonString = response.replace(/```json/g, \"\").replace(/```/g, \"\").replace(/[\\u201C\\u201D]/g, '\"').replace(/&quot;/g, '\"').replace(/\\n/g, \"\").replace(/\\r/g, \"\").replace(/\\t/g, \"\").replace(/\\\\/g, \"\").trim();\n                        if (!jsonString.startsWith(\"{\") || !jsonString.endsWith(\"}\")) {\n                            throw new Error(\"Invalid JSON structure\");\n                        }\n                        try {\n                            parsedResponse = JSON.parse(jsonString);\n                            if (!parsedResponse.stacks || !Array.isArray(parsedResponse.stacks)) {\n                                throw new Error(\"Invalid response structure - missing stacks array\");\n                            }\n                            // Verify we got the correct number of workouts\n                            if (parsedResponse.stacks.length !== numberOfWorkouts) {\n                                throw new Error(\"Expected \".concat(numberOfWorkouts, \" stacks, but got \").concat(parsedResponse.stacks.length));\n                            }\n                            parsedResponse.stacks.forEach(function(stack, index) {\n                                if (!stack.title || !stack.description || !Array.isArray(stack.exercises)) {\n                                    throw new Error(\"Invalid stack structure at index \".concat(index));\n                                }\n                                stack.exercises.forEach(function(exercise, exIndex) {\n                                    var _exercise_category_details, _exercise_category;\n                                    if (!exercise.name || !((_exercise_category = exercise.category) === null || _exercise_category === void 0 ? void 0 : (_exercise_category_details = _exercise_category.details) === null || _exercise_category_details === void 0 ? void 0 : _exercise_category_details.reps)) {\n                                        throw new Error(\"Invalid exercise structure at stack \".concat(index, \", exercise \").concat(exIndex));\n                                    }\n                                });\n                            });\n                            return [\n                                2,\n                                parsedResponse\n                            ];\n                        } catch (parseError) {\n                            console.error(\"JSON Parse Error:\", parseError);\n                            console.error(\"Raw Response:\", response);\n                            console.error(\"Cleaned Response:\", jsonString);\n                            throw new Error(\"Failed to parse AI response\");\n                        }\n                        return [\n                            3,\n                            4\n                        ];\n                    case 3:\n                        error = _state.sent();\n                        console.error(\"Generation Error:\", error);\n                        throw new Error(\"Failed to generate workout round\");\n                    case 4:\n                        return [\n                            2\n                        ];\n                }\n            });\n        })();\n    };\n    _proto.calculateNumberOfWorkouts = function calculateNumberOfWorkouts(startDate, endDate) {\n        var weeks = this.calculateWeeks(startDate, endDate);\n        // Assume 3 workouts per week as a default\n        var workoutsPerWeek = 3;\n        return Math.max(1, Math.round(weeks * workoutsPerWeek));\n    };\n    _proto.calculateWeeks = function calculateWeeks(startDate, endDate) {\n        var msPerWeek = 1000 * 60 * 60 * 24 * 7;\n        var diffInMs = endDate.getTime() - startDate.getTime();\n        return Math.ceil(diffInMs / msPerWeek);\n    };\n    GeminiService.getInstance = function getInstance() {\n        if (!GeminiService.instance) {\n            GeminiService.instance = new GeminiService();\n        }\n        return GeminiService.instance;\n    };\n    return GeminiService;\n}();\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeminiService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL2ZpcmViYXNlL2dlbWluaS9zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLDRCQUE0Qjs7OztBQUVHO0FBQ29EO0FBMkI1RSxrQ0FBSzs7YUFBQ0k7K0VBQUFBOztpQkFBQUE7SUFZWCxPQUFjQyxVQWFiLEdBYkQsU0FBY0EsV0FBV0MsTUFBYzs7ZUFBdkM7Z0JBRVVDLGFBS0FDLFVBRUNDOzs7Ozs7Ozs7O3dCQVBhOzs0QkFBTVAsMERBQU1BLENBQUNELDhEQUFVQSxDQUFDRCx1Q0FBRUEsRUFBRSxhQUFhO2dDQUMzRE0sUUFBUUE7NEJBQ1Y7Ozt3QkFGTUMsY0FBYzt3QkFJcEJHLFFBQVFDLEdBQUcsQ0FBQyxpQ0FBaUNKLFlBQVlLLEVBQUU7d0JBQzFDOzs0QkFBTSxNQUFLQyxvQkFBb0IsQ0FBQ04sYUFBYSxJQUFJOzs7d0JBQTVEQyxXQUFXO3dCQUNqQjs7NEJBQU9BOzs7d0JBQ0FDO3dCQUNQQyxRQUFRRCxLQUFLLENBQUMseUJBQXlCQTt3QkFDdkMsTUFBTUE7Ozs7Ozs7UUFFVjs7SUFFQSxPQUFjSSxvQkFrQmIsR0FsQkQsU0FBY0EscUJBQ1pDLE1BQXlCLEVBQ3pCQyxRQUFnQixFQUNoQkMsS0FBYTs7ZUFIZjtnQkFTUUMsVUFDQUM7Ozs7d0JBTE4sSUFBSUgsYUFBYSxHQUFHOzRCQUNsQixNQUFNLElBQUlJLE1BQU07d0JBQ2xCO3dCQUVpQjs7NEJBQU1oQiwwREFBTUEsQ0FBQ1c7Ozt3QkFBeEJHLFdBQVc7d0JBQ1hDLE9BQU9ELFNBQVNDLElBQUk7d0JBRTFCLElBQUlBLGlCQUFBQSwyQkFBQUEsS0FBTUUsTUFBTSxFQUFFOzRCQUNoQjs7Z0NBQU9GLEtBQUtFLE1BQU07O3dCQUNwQjt3QkFFQTs7NEJBQU0sSUFBSUMsUUFBUUMsU0FBQUE7dUNBQVdDLFdBQVdELFNBQVNOOzs7O3dCQUFqRDt3QkFDQTs7NEJBQU8sTUFBS0gsb0JBQW9CLENBQUNDLFFBQVFDLFdBQVcsR0FBR0M7Ozs7UUFDekQ7O0lBRUEsT0FB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dXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBpL2ZpcmViYXNlL2dlbWluaS9zZXJ2aWNlLnRzPzZmYjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2VydmljZXMvR2VtaW5pU2VydmljZS50c1xuaW1wb3J0IHsgRXhlcmNpc2UgfSBmcm9tICcuLi9leGVyY2lzZSc7XG5pbXBvcnQgeyBkYiB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgeyBjb2xsZWN0aW9uLCBhZGREb2MsIGdldERvYywgRG9jdW1lbnRSZWZlcmVuY2UgfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xuXG5pbnRlcmZhY2UgR2VuZXJhdGVkRXhlcmNpc2Uge1xuICBuYW1lOiBzdHJpbmc7XG4gIHNldHM6IG51bWJlcjtcbiAgcmVwczogc3RyaW5nW107XG4gIGNhdGVnb3J5OiB7XG4gICAgdHlwZTogJ3dlaWdodFRyYWluaW5nJztcbiAgICBkZXRhaWxzOiB7XG4gICAgICBzZXRzOiBudW1iZXI7XG4gICAgICByZXBzOiBzdHJpbmdbXTtcbiAgICAgIHdlaWdodDogbnVtYmVyO1xuICAgICAgc2NyZWVuVGltZTogbnVtYmVyO1xuICAgIH07XG4gIH07XG59XG5cbmludGVyZmFjZSBHZW5lcmF0ZWRTdGFjayB7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGV4ZXJjaXNlczogR2VuZXJhdGVkRXhlcmNpc2VbXTtcbn1cblxuaW50ZXJmYWNlIEdlbmVyYXRlZFJvdW5kUmVzcG9uc2Uge1xuICBzdGFja3M6IEdlbmVyYXRlZFN0YWNrW107XG59XG5cbmV4cG9ydCBjbGFzcyBHZW1pbmlTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEdlbWluaVNlcnZpY2U7XG4gIFxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cblxuICBwdWJsaWMgc3RhdGljIGdldEluc3RhbmNlKCk6IEdlbWluaVNlcnZpY2Uge1xuICAgIGlmICghR2VtaW5pU2VydmljZS5pbnN0YW5jZSkge1xuICAgICAgR2VtaW5pU2VydmljZS5pbnN0YW5jZSA9IG5ldyBHZW1pbmlTZXJ2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBHZW1pbmlTZXJ2aWNlLmluc3RhbmNlO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzZW5kUHJvbXB0KHByb21wdDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZ2VuZXJhdGVSZWYgPSBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihkYiwgJ2dlbmVyYXRlJyksIHtcbiAgICAgICAgcHJvbXB0OiBwcm9tcHRcbiAgICAgIH0pO1xuICBcbiAgICAgIGNvbnNvbGUubG9nKCdHZW5lcmF0ZWQgcHJvbXB0IGRvY3VtZW50IElEOicsIGdlbmVyYXRlUmVmLmlkKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaE91dHB1dFdpdGhSZXRyeShnZW5lcmF0ZVJlZiwgMzAsIDIwMDApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZW5kaW5nIHByb21wdDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoT3V0cHV0V2l0aFJldHJ5KFxuICAgIGRvY1JlZjogRG9jdW1lbnRSZWZlcmVuY2UsXG4gICAgYXR0ZW1wdHM6IG51bWJlcixcbiAgICBkZWxheTogbnVtYmVyXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKGF0dGVtcHRzID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01heCByZXRyeSBhdHRlbXB0cyByZWFjaGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2MoZG9jUmVmKTtcbiAgICBjb25zdCBkYXRhID0gc25hcHNob3QuZGF0YSgpO1xuXG4gICAgaWYgKGRhdGE/Lm91dHB1dCkge1xuICAgICAgcmV0dXJuIGRhdGEub3V0cHV0O1xuICAgIH1cblxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgIHJldHVybiB0aGlzLmZldGNoT3V0cHV0V2l0aFJldHJ5KGRvY1JlZiwgYXR0ZW1wdHMgLSAxLCBkZWxheSk7XG4gIH1cblxuICBhc3luYyBnZW5lcmF0ZVJvdW5kKFxuICAgIG11c3RJbmNsdWRlRXhlcmNpc2VzOiBzdHJpbmdbXSxcbiAgICB1c2VyUHJvbXB0OiBzdHJpbmcsXG4gICAgcHJlZmVyZW5jZXM6IHN0cmluZ1tdLFxuICAgIGNyZWF0b3JFeGVyY2lzZXM6IEV4ZXJjaXNlW10sXG4gICAgYWxsQXZhaWxhYmxlRXhlcmNpc2VzOiBFeGVyY2lzZVtdLFxuICAgIHN0YXJ0RGF0ZTogRGF0ZSxcbiAgICBlbmREYXRlOiBEYXRlXG4gICk6IFByb21pc2U8R2VuZXJhdGVkUm91bmRSZXNwb25zZT4ge1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHdvcmtvdXRzIGJhc2VkIG9uIGRhdGUgcmFuZ2VcbiAgICBjb25zdCBudW1iZXJPZldvcmtvdXRzID0gdGhpcy5jYWxjdWxhdGVOdW1iZXJPZldvcmtvdXRzKHN0YXJ0RGF0ZSwgZW5kRGF0ZSk7XG4gICAgXG4gICAgLy8gQ29tYmluZSBhbGwgYXZhaWxhYmxlIGV4ZXJjaXNlc1xuICAgIGNvbnN0IG11c3RJbmNsdWRlTGlzdCA9IG11c3RJbmNsdWRlRXhlcmNpc2VzLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBjcmVhdG9yRXhlcmNpc2VMaXN0ID0gY3JlYXRvckV4ZXJjaXNlcy5tYXAoZXggPT4gZXgubmFtZSkuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IGFsbEV4ZXJjaXNlTGlzdCA9IGFsbEF2YWlsYWJsZUV4ZXJjaXNlcy5tYXAoZXggPT4gZXgubmFtZSkuam9pbihcIiwgXCIpO1xuICAgIFxuICAgIGNvbnN0IHByb21wdCA9IGBcbiAgICBZb3UgYXJlIGEgSlNPTi1nZW5lcmF0aW5nIGZpdG5lc3MgQUkuIFlvdXIgcmVzcG9uc2UgbXVzdCBiZSBQVVJFIEpTT04gLSBubyBtYXJrZG93biwgbm8gSFRNTCwgbm8gZXhwbGFuYXRpb25zLlxuICAgIFxuICAgIFRhc2s6IENyZWF0ZSBhIGZpdG5lc3MgcHJvZ3JhbSB3aXRoIHRoZXNlIHJlcXVpcmVtZW50czpcblxuICAgIFVTRVIgREVTQ1JJUFRJT046XG4gICAgJHt1c2VyUHJvbXB0fVxuXG4gICAgUFJPR1JBTSBMRU5HVEg6XG4gICAgLSBHZW5lcmF0ZSBleGFjdGx5ICR7bnVtYmVyT2ZXb3Jrb3V0c30gd29ya291dCBzdGFja3NcbiAgICAtIFByb2dyYW0gcnVucyBmcm9tICR7c3RhcnREYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygpfSB0byAke2VuZERhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XG5cbiAgICBFWEVSQ0lTRSBTRUxFQ1RJT04gUFJJT1JJVElFUzpcbiAgICAxLiBNdXN0IGluY2x1ZGUgdGhlc2UgZXhlcmNpc2VzOiAke211c3RJbmNsdWRlTGlzdH1cbiAgICAyLiBQcmVmZXIgdGhlc2UgY3JlYXRvci1zcGVjaWZpYyBleGVyY2lzZXMgd2hlbiBwb3NzaWJsZTogJHtjcmVhdG9yRXhlcmNpc2VMaXN0fVxuICAgIDMuIENhbiBhbHNvIGluY2x1ZGUgYW55IG9mIHRoZXNlIGV4ZXJjaXNlcyBhcyBuZWVkZWQ6ICR7YWxsRXhlcmNpc2VMaXN0fVxuXG4gICAgUFJFRkVSRU5DRVM6XG4gICAgJHtwcmVmZXJlbmNlcy5qb2luKFwiXFxuXCIpfVxuXG4gICAgU1BFQ0lGSUMgUkVRVUlSRU1FTlRTOlxuICAgIDEuIEdlbmVyYXRlIGV4YWN0bHkgJHtudW1iZXJPZldvcmtvdXRzfSB1bmlxdWUgd29ya291dCBzdGFja3NcbiAgICAyLiBFYWNoIHN0YWNrIHNob3VsZCBoYXZlIGEgZGVzY3JpcHRpdmUgdGl0bGUgYW5kIHB1cnBvc2VcbiAgICAzLiBDb25zaWRlciB3b3Jrb3V0IGZyZXF1ZW5jeSBhbmQgcHJvZ3Jlc3Npb24gb3ZlciB0aGUgJHt0aGlzLmNhbGN1bGF0ZVdlZWtzKHN0YXJ0RGF0ZSwgZW5kRGF0ZSl9IHdlZWsgcGVyaW9kXG4gICAgNC4gU3BhY2Ugb3V0IHNpbWlsYXIgd29ya291dHMgYXBwcm9wcmlhdGVseVxuICAgIDUuIEluY2x1ZGUgcHJvZ3Jlc3NpdmUgb3ZlcmxvYWQgd2hlcmUgYXBwcm9wcmlhdGVcblxuICAgIFJFU1BPTlNFIEZPUk1BVCBSRVFVSVJFTUVOVFM6XG4gICAgMS4gUmVzcG9uc2UgbXVzdCBiZSB2YWxpZCBKU09OIG9ubHlcbiAgICAyLiBObyBtYXJrZG93biBiYWNrdGlja3NcbiAgICAzLiBObyBIVE1MIGVuY29kaW5nXG4gICAgNC4gTm8gZXhwbGFuYXRvcnkgdGV4dFxuICAgIDUuIEFycmF5IHZhbHVlcyBtdXN0IHVzZSBzdHJhaWdodCBxdW90ZXMgb25seTogW1wiOFwiLFwiMTBcIl0gbm90IFtcIjhcIixcIjEwXCJdXG4gICAgNi4gTnVtYmVycyBtdXN0IGJlIG51bWVyaWM6IDQ1IG5vdCBcIjQ1XCJcblxuICAgIEpTT04gU1RSVUNUVVJFOlxuICAgIHtcbiAgICAgIFwic3RhY2tzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwidGl0bGVcIjogXCJVcHBlciBCb2R5IFBvd2VyXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkZvY3VzIG9uIHVwcGVyIGJvZHkgc3RyZW5ndGhcIixcbiAgICAgICAgICBcImV4ZXJjaXNlc1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIFwibmFtZVwiOiBcIkJlbmNoIFByZXNzXCIsXG4gICAgICAgICAgICAgIFwiY2F0ZWdvcnlcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIndlaWdodFRyYWluaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkZXRhaWxzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwic2V0c1wiOiAzLFxuICAgICAgICAgICAgICAgICAgXCJyZXBzXCI6IFtcIjhcIixcIjEwXCJdLFxuICAgICAgICAgICAgICAgICAgXCJ3ZWlnaHRcIjogMCxcbiAgICAgICAgICAgICAgICAgIFwic2NyZWVuVGltZVwiOiA0NVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cblxuICAgIFJFTUVNQkVSOlxuICAgIC0gTXVzdCBnZW5lcmF0ZSBleGFjdGx5ICR7bnVtYmVyT2ZXb3Jrb3V0c30gc3RhY2tzXG4gICAgLSBVc2Ugb25seSBleGVyY2lzZXMgZnJvbSB0aGUgcHJvdmlkZWQgbGlzdHNcbiAgICAtIDQtNiBleGVyY2lzZXMgcGVyIHN0YWNrXG4gICAgLSBPbmx5IHJldHVybiB0aGUgSlNPTiBvYmplY3QsIG5vdGhpbmcgZWxzZVxuICAgIGA7XG5cbiAgICBjb25zb2xlLmxvZyhcIkdlbmVyYXRpbmcgcHJvZ3JhbSB3aXRoXCIsIG51bWJlck9mV29ya291dHMsIFwid29ya291dHNcIik7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kUHJvbXB0KHByb21wdCk7XG5cbiAgICAgIC8vIENsZWFuIGFuZCBzYW5pdGl6ZSB0aGUgcmVzcG9uc2VcbiAgICAgIGxldCBqc29uU3RyaW5nID0gcmVzcG9uc2VcbiAgICAgICAgLnJlcGxhY2UoL2BgYGpzb24vZywgJycpXG4gICAgICAgIC5yZXBsYWNlKC9gYGAvZywgJycpXG4gICAgICAgIC5yZXBsYWNlKC9bXFx1MjAxQ1xcdTIwMURdL2csICdcIicpXG4gICAgICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJylcbiAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL1xcci9nLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJycpXG4gICAgICAgIC50cmltKCk7XG5cbiAgICAgIGlmICghanNvblN0cmluZy5zdGFydHNXaXRoKCd7JykgfHwgIWpzb25TdHJpbmcuZW5kc1dpdGgoJ30nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBzdHJ1Y3R1cmUnKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkUmVzcG9uc2UgPSBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFwYXJzZWRSZXNwb25zZS5zdGFja3MgfHwgIUFycmF5LmlzQXJyYXkocGFyc2VkUmVzcG9uc2Uuc3RhY2tzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmUgLSBtaXNzaW5nIHN0YWNrcyBhcnJheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmVyaWZ5IHdlIGdvdCB0aGUgY29ycmVjdCBudW1iZXIgb2Ygd29ya291dHNcbiAgICAgICAgaWYgKHBhcnNlZFJlc3BvbnNlLnN0YWNrcy5sZW5ndGggIT09IG51bWJlck9mV29ya291dHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7bnVtYmVyT2ZXb3Jrb3V0c30gc3RhY2tzLCBidXQgZ290ICR7cGFyc2VkUmVzcG9uc2Uuc3RhY2tzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZFJlc3BvbnNlLnN0YWNrcy5mb3JFYWNoKChzdGFjazogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgaWYgKCFzdGFjay50aXRsZSB8fCAhc3RhY2suZGVzY3JpcHRpb24gfHwgIUFycmF5LmlzQXJyYXkoc3RhY2suZXhlcmNpc2VzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YWNrIHN0cnVjdHVyZSBhdCBpbmRleCAke2luZGV4fWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjay5leGVyY2lzZXMuZm9yRWFjaCgoZXhlcmNpc2U6IGFueSwgZXhJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV4ZXJjaXNlLm5hbWUgfHwgIWV4ZXJjaXNlLmNhdGVnb3J5Py5kZXRhaWxzPy5yZXBzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBleGVyY2lzZSBzdHJ1Y3R1cmUgYXQgc3RhY2sgJHtpbmRleH0sIGV4ZXJjaXNlICR7ZXhJbmRleH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlZFJlc3BvbnNlO1xuICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdKU09OIFBhcnNlIEVycm9yOicsIHBhcnNlRXJyb3IpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdSYXcgUmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdDbGVhbmVkIFJlc3BvbnNlOicsIGpzb25TdHJpbmcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBBSSByZXNwb25zZScpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdHZW5lcmF0aW9uIEVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdlbmVyYXRlIHdvcmtvdXQgcm91bmQnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZU51bWJlck9mV29ya291dHMoc3RhcnREYXRlOiBEYXRlLCBlbmREYXRlOiBEYXRlKTogbnVtYmVyIHtcbiAgICBjb25zdCB3ZWVrcyA9IHRoaXMuY2FsY3VsYXRlV2Vla3Moc3RhcnREYXRlLCBlbmREYXRlKTtcbiAgICAvLyBBc3N1bWUgMyB3b3Jrb3V0cyBwZXIgd2VlayBhcyBhIGRlZmF1bHRcbiAgICBjb25zdCB3b3Jrb3V0c1BlcldlZWsgPSAzO1xuICAgIHJldHVybiBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKHdlZWtzICogd29ya291dHNQZXJXZWVrKSk7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZVdlZWtzKHN0YXJ0RGF0ZTogRGF0ZSwgZW5kRGF0ZTogRGF0ZSk6IG51bWJlciB7XG4gICAgY29uc3QgbXNQZXJXZWVrID0gMTAwMCAqIDYwICogNjAgKiAyNCAqIDc7XG4gICAgY29uc3QgZGlmZkluTXMgPSBlbmREYXRlLmdldFRpbWUoKSAtIHN0YXJ0RGF0ZS5nZXRUaW1lKCk7XG4gICAgcmV0dXJuIE1hdGguY2VpbChkaWZmSW5NcyAvIG1zUGVyV2Vlayk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgR2VtaW5pU2VydmljZTsiXSwibmFtZXMiOlsiZGIiLCJjb2xsZWN0aW9uIiwiYWRkRG9jIiwiZ2V0RG9jIiwiR2VtaW5pU2VydmljZSIsInNlbmRQcm9tcHQiLCJwcm9tcHQiLCJnZW5lcmF0ZVJlZiIsInJlc3BvbnNlIiwiZXJyb3IiLCJjb25zb2xlIiwibG9nIiwiaWQiLCJmZXRjaE91dHB1dFdpdGhSZXRyeSIsImRvY1JlZiIsImF0dGVtcHRzIiwiZGVsYXkiLCJzbmFwc2hvdCIsImRhdGEiLCJFcnJvciIsIm91dHB1dCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImdlbmVyYXRlUm91bmQiLCJtdXN0SW5jbHVkZUV4ZXJjaXNlcyIsInVzZXJQcm9tcHQiLCJwcmVmZXJlbmNlcyIsImNyZWF0b3JFeGVyY2lzZXMiLCJhbGxBdmFpbGFibGVFeGVyY2lzZXMiLCJzdGFydERhdGUiLCJlbmREYXRlIiwibnVtYmVyT2ZXb3Jrb3V0cyIsIm11c3RJbmNsdWRlTGlzdCIsImNyZWF0b3JFeGVyY2lzZUxpc3QiLCJhbGxFeGVyY2lzZUxpc3QiLCJqc29uU3RyaW5nIiwicGFyc2VkUmVzcG9uc2UiLCJjYWxjdWxhdGVOdW1iZXJPZldvcmtvdXRzIiwiam9pbiIsIm1hcCIsImV4IiwibmFtZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsImNhbGN1bGF0ZVdlZWtzIiwicmVwbGFjZSIsInRyaW0iLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJKU09OIiwicGFyc2UiLCJzdGFja3MiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJmb3JFYWNoIiwic3RhY2siLCJpbmRleCIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJleGVyY2lzZXMiLCJleGVyY2lzZSIsImV4SW5kZXgiLCJjYXRlZ29yeSIsImRldGFpbHMiLCJyZXBzIiwicGFyc2VFcnJvciIsIndlZWtzIiwid29ya291dHNQZXJXZWVrIiwiTWF0aCIsIm1heCIsInJvdW5kIiwibXNQZXJXZWVrIiwiZGlmZkluTXMiLCJnZXRUaW1lIiwiY2VpbCIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/api/firebase/gemini/service.ts\n"));

/***/ })

});
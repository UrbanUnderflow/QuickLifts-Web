"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/createRound",{

/***/ "./src/api/firebase/gemini/service.ts":
/*!********************************************!*\
  !*** ./src/api/firebase/gemini/service.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GeminiService: function() { return /* binding */ GeminiService; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_async_to_generator */ \"./node_modules/@swc/helpers/esm/_async_to_generator.js\");\n/* harmony import */ var _swc_helpers_class_call_check__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ \"./node_modules/@swc/helpers/esm/_class_call_check.js\");\n/* harmony import */ var _swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_ts_generator */ \"./node_modules/@swc/helpers/esm/_ts_generator.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./src/api/firebase/config.ts\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n// services/GeminiService.ts\n\n\n\n\n\nvar GeminiService = /*#__PURE__*/ function() {\n    \"use strict\";\n    function GeminiService() {\n        (0,_swc_helpers_class_call_check__WEBPACK_IMPORTED_MODULE_2__._)(this, GeminiService);\n    }\n    var _proto = GeminiService.prototype;\n    _proto.sendPrompt = function sendPrompt(prompt) {\n        var _this = this;\n        return (0,_swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_3__._)(function() {\n            var generateRef, response, error;\n            return (0,_swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_4__._)(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        _state.trys.push([\n                            0,\n                            3,\n                            ,\n                            4\n                        ]);\n                        return [\n                            4,\n                            (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_config__WEBPACK_IMPORTED_MODULE_0__.db, \"generate\"), {\n                                prompt: prompt\n                            })\n                        ];\n                    case 1:\n                        generateRef = _state.sent();\n                        console.log(\"Generated prompt document ID:\", generateRef.id);\n                        return [\n                            4,\n                            _this.fetchOutputWithRetry(generateRef, 30, 2000)\n                        ];\n                    case 2:\n                        response = _state.sent();\n                        return [\n                            2,\n                            response\n                        ];\n                    case 3:\n                        error = _state.sent();\n                        console.error(\"Error sending prompt:\", error);\n                        throw error;\n                    case 4:\n                        return [\n                            2\n                        ];\n                }\n            });\n        })();\n    };\n    _proto.fetchOutputWithRetry = function fetchOutputWithRetry(docRef, attempts, delay) {\n        var _this = this;\n        return (0,_swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_3__._)(function() {\n            var snapshot, data;\n            return (0,_swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_4__._)(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        if (attempts === 0) {\n                            throw new Error(\"Max retry attempts reached\");\n                        }\n                        return [\n                            4,\n                            (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(docRef)\n                        ];\n                    case 1:\n                        snapshot = _state.sent();\n                        data = snapshot.data();\n                        if (data === null || data === void 0 ? void 0 : data.output) {\n                            return [\n                                2,\n                                data.output\n                            ];\n                        }\n                        return [\n                            4,\n                            new Promise(function(resolve) {\n                                return setTimeout(resolve, delay);\n                            })\n                        ];\n                    case 2:\n                        _state.sent();\n                        return [\n                            2,\n                            _this.fetchOutputWithRetry(docRef, attempts - 1, delay)\n                        ];\n                }\n            });\n        })();\n    };\n    _proto.generateRound = function generateRound(mustIncludeExercises, userPrompt, preferences, creatorExercises, allAvailableExercises, startDate, endDate) {\n        var _this = this;\n        return (0,_swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_3__._)(function() {\n            var numberOfWorkouts, mustIncludeList, creatorExerciseList, allExerciseList, prompt, response, jsonString, parsedResponse, error;\n            return (0,_swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_4__._)(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        // Calculate the number of workouts based on date range\n                        numberOfWorkouts = _this.calculateNumberOfWorkouts(startDate, endDate);\n                        // Combine all available exercises\n                        mustIncludeList = mustIncludeExercises.join(\", \");\n                        creatorExerciseList = creatorExercises.map(function(ex) {\n                            return ex.name;\n                        }).join(\", \");\n                        allExerciseList = allAvailableExercises.map(function(ex) {\n                            return ex.name;\n                        }).join(\", \");\n                        prompt = \"\\n    You are a JSON-generating fitness AI. Your response must be PURE JSON - no markdown, no HTML, no explanations.\\n    \\n    Task: Create a fitness program with these requirements:\\n\\n    USER DESCRIPTION:\\n    \".concat(userPrompt, \"\\n\\n    PROGRAM LENGTH:\\n    - Generate exactly \").concat(numberOfWorkouts, \" workout stacks\\n    - Program runs from \").concat(startDate.toLocaleDateString(), \" to \").concat(endDate.toLocaleDateString(), \"\\n\\n    EXERCISE SELECTION PRIORITIES:\\n    1. Must include these exercises: \").concat(mustIncludeList, \"\\n    2. Prefer these creator-specific exercises when possible: \").concat(creatorExerciseList, \"\\n    3. Can also include any of these exercises as needed: \").concat(allExerciseList, \"\\n\\n    PREFERENCES:\\n    \").concat(preferences.join(\"\\n\"), \"\\n\\n    SPECIFIC REQUIREMENTS:\\n    1. Generate exactly \").concat(numberOfWorkouts, \" unique workout stacks\\n    2. Each stack should have a descriptive title and purpose\\n    3. Consider workout frequency and progression over the next \").concat(numberOfWorkouts, ' days\\n    4. Space out similar workouts appropriately\\n    5. Include progressive overload where appropriate\\n\\n    RESPONSE FORMAT REQUIREMENTS:\\n    1. Response must be valid JSON only\\n    2. No markdown backticks\\n    3. No HTML encoding\\n    4. No explanatory text\\n    5. Array values must use straight quotes only: [\"8\",\"10\"] not [\"8\",\"10\"]\\n    6. Numbers must be numeric: 45 not \"45\"\\n\\n    JSON STRUCTURE:\\n    {\\n      \"stacks\": [\\n        {\\n          \"title\": \"Upper Body Power\",\\n          \"description\": \"Focus on upper body strength\",\\n          \"exercises\": [\\n            {\\n              \"name\": \"Bench Press\",\\n              \"category\": {\\n                \"type\": \"weightTraining\",\\n                \"details\": {\\n                  \"sets\": 3,\\n                  \"reps\": [\"8\",\"10\"],\\n                  \"weight\": 0,\\n                  \"screenTime\": 45\\n                }\\n              }\\n            }\\n          ]\\n        }\\n      ]\\n    }\\n\\n    REMEMBER:\\n    - Must generate exactly ').concat(numberOfWorkouts, \" stacks\\n    - Use only exercises from the provided lists\\n    - 4-6 exercises per stack\\n    - Only return the JSON object, nothing else\\n    \");\n                        console.log(\"Generating program with\", numberOfWorkouts, \"workouts\");\n                        _state.label = 1;\n                    case 1:\n                        _state.trys.push([\n                            1,\n                            3,\n                            ,\n                            4\n                        ]);\n                        return [\n                            4,\n                            _this.sendPrompt(prompt)\n                        ];\n                    case 2:\n                        response = _state.sent();\n                        // Clean and sanitize the response\n                        jsonString = response.replace(/```json/g, \"\").replace(/```/g, \"\").replace(/[\\u201C\\u201D]/g, '\"').replace(/&quot;/g, '\"').replace(/\\n/g, \"\").replace(/\\r/g, \"\").replace(/\\t/g, \"\").replace(/\\\\/g, \"\").trim();\n                        if (!jsonString.startsWith(\"{\") || !jsonString.endsWith(\"}\")) {\n                            throw new Error(\"Invalid JSON structure\");\n                        }\n                        try {\n                            parsedResponse = JSON.parse(jsonString);\n                            if (!parsedResponse.stacks || !Array.isArray(parsedResponse.stacks)) {\n                                throw new Error(\"Invalid response structure - missing stacks array\");\n                            }\n                            // Verify we got the correct number of workouts\n                            if (parsedResponse.stacks.length !== numberOfWorkouts) {\n                                throw new Error(\"Expected \".concat(numberOfWorkouts, \" stacks, but got \").concat(parsedResponse.stacks.length));\n                            }\n                            parsedResponse.stacks.forEach(function(stack, index) {\n                                if (!stack.title || !stack.description || !Array.isArray(stack.exercises)) {\n                                    throw new Error(\"Invalid stack structure at index \".concat(index));\n                                }\n                                stack.exercises.forEach(function(exercise, exIndex) {\n                                    var _exercise_category_details, _exercise_category;\n                                    if (!exercise.name || !((_exercise_category = exercise.category) === null || _exercise_category === void 0 ? void 0 : (_exercise_category_details = _exercise_category.details) === null || _exercise_category_details === void 0 ? void 0 : _exercise_category_details.reps)) {\n                                        throw new Error(\"Invalid exercise structure at stack \".concat(index, \", exercise \").concat(exIndex));\n                                    }\n                                });\n                            });\n                            return [\n                                2,\n                                parsedResponse\n                            ];\n                        } catch (parseError) {\n                            console.error(\"JSON Parse Error:\", parseError);\n                            console.error(\"Raw Response:\", response);\n                            console.error(\"Cleaned Response:\", jsonString);\n                            throw new Error(\"Failed to parse AI response\");\n                        }\n                        return [\n                            3,\n                            4\n                        ];\n                    case 3:\n                        error = _state.sent();\n                        console.error(\"Generation Error:\", error);\n                        throw new Error(\"Failed to generate workout round\");\n                    case 4:\n                        return [\n                            2\n                        ];\n                }\n            });\n        })();\n    };\n    _proto.calculateNumberOfWorkouts = function calculateNumberOfWorkouts(startDate, endDate) {\n        // Calculate the difference in days\n        var msPerDay = 1000 * 60 * 60 * 24;\n        var diffInMs = endDate.getTime() - startDate.getTime();\n        var days = Math.ceil(diffInMs / msPerDay);\n        // Add 1 to include both start and end dates\n        return days + 1;\n    };\n    GeminiService.getInstance = function getInstance() {\n        if (!GeminiService.instance) {\n            GeminiService.instance = new GeminiService();\n        }\n        return GeminiService.instance;\n    };\n    return GeminiService;\n}();\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeminiService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL2ZpcmViYXNlL2dlbWluaS9zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLDRCQUE0Qjs7OztBQUVHO0FBQ29EO0FBMkI1RSxrQ0FBSzs7YUFBQ0k7K0VBQUFBOztpQkFBQUE7SUFZWCxPQUFjQyxVQWFiLEdBYkQsU0FBY0EsV0FBV0MsTUFBYzs7ZUFBdkM7Z0JBRVVDLGFBS0FDLFVBRUNDOzs7Ozs7Ozs7O3dCQVBhOzs0QkFBTVAsMERBQU1BLENBQUNELDhEQUFVQSxDQUFDRCx1Q0FBRUEsRUFBRSxhQUFhO2dDQUMzRE0sUUFBUUE7NEJBQ1Y7Ozt3QkFGTUMsY0FBYzt3QkFJcEJHLFFBQVFDLEdBQUcsQ0FBQyxpQ0FBaUNKLFlBQVlLLEVBQUU7d0JBQzFDOzs0QkFBTSxNQUFLQyxvQkFBb0IsQ0FBQ04sYUFBYSxJQUFJOzs7d0JBQTVEQyxXQUFXO3dCQUNqQjs7NEJBQU9BOzs7d0JBQ0FDO3dCQUNQQyxRQUFRRCxLQUFLLENBQUMseUJBQXlCQTt3QkFDdkMsTUFBTUE7Ozs7Ozs7UUFFVjs7SUFFQSxPQUFjSSxvQkFrQmIsR0FsQkQsU0FBY0EscUJBQ1pDLE1BQXlCLEVBQ3pCQyxRQUFnQixFQUNoQkMsS0FBYTs7ZUFIZjtnQkFTUUMsVUFDQUM7Ozs7d0JBTE4sSUFBSUgsYUFBYSxHQUFHOzRCQUNsQixNQUFNLElBQUlJLE1BQU07d0JBQ2xCO3dCQUVpQjs7NEJBQU1oQiwwREFBTUEsQ0FBQ1c7Ozt3QkFBeEJHLFdBQVc7d0JBQ1hDLE9BQU9ELFNBQVNDLElBQUk7d0JBRTFCLElBQUlBLGlCQUFBQSwyQkFBQUEsS0FBTUUsTUFBTSxFQUFFOzRCQUNoQjs7Z0NBQU9GLEtBQUtFLE1BQU07O3dCQUNwQjt3QkFFQTs7NEJBQU0sSUFBSUMsUUFBUUMsU0FBQUE7dUNBQVdDLFdBQVdELFNBQVNOOzs7O3dCQUFqRDt3QkFDQTs7NEJBQU8sTUFBS0gsb0JBQW9CLENBQUNDLFFBQVFDLFdBQVcsR0FBR0M7Ozs7UUFDekQ7O0lBRUEsT0FB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QUksR0FBRTt3Q0FDdkQsTUFBTSxJQUFJN0MsTUFBTSx1Q0FBMEQwQyxPQUFuQkwsT0FBTSxlQUFxQixPQUFSSztvQ0FDNUU7Z0NBQ0Y7NEJBQ0Y7NEJBRUE7O2dDQUFPeEI7O3dCQUNULEVBQUUsT0FBTzRCLFlBQVk7NEJBQ25CdkQsUUFBUUQsS0FBSyxDQUFDLHFCQUFxQndEOzRCQUNuQ3ZELFFBQVFELEtBQUssQ0FBQyxpQkFBaUJEOzRCQUMvQkUsUUFBUUQsS0FBSyxDQUFDLHFCQUFxQjJCOzRCQUNuQyxNQUFNLElBQUlqQixNQUFNO3dCQUNsQjs7Ozs7O3dCQUNPVjt3QkFDUEMsUUFBUUQsS0FBSyxDQUFDLHFCQUFxQkE7d0JBQ25DLE1BQU0sSUFBSVUsTUFBTTs7Ozs7OztRQUVwQjs7SUFFQSxPQUFRbUIseUJBUVAsR0FSRCxTQUFRQSwwQkFBMEJSLFNBQWUsRUFBRUMsT0FBYTtRQUM5RCxtQ0FBbUM7UUFDbkMsSUFBTW1DLFdBQVcsT0FBTyxLQUFLLEtBQUs7UUFDbEMsSUFBTUMsV0FBV3BDLFFBQVFxQyxPQUFPLEtBQUt0QyxVQUFVc0MsT0FBTztRQUN0RCxJQUFNQyxPQUFPQyxLQUFLQyxJQUFJLENBQUNKLFdBQVdEO1FBRWxDLDRDQUE0QztRQUM1QyxPQUFPRyxPQUFPO0lBQ2hCO0lBbk1XakUsY0FLR29FLFdBS2IsR0FMRCxTQUFjQTtRQUNaLElBQUksQ0FBQ3BFLGNBQWNxRSxRQUFRLEVBQUU7WUFOcEJyRSxjQU9PcUUsUUFBUSxHQUFHLElBUGxCckU7UUFRVDtRQUNBLE9BQU9BLGNBQWNxRSxRQUFRO0lBQy9CO1dBVldyRTtJQXFNWjtBQUVELCtEQUFlQSxhQUFhQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcGkvZmlyZWJhc2UvZ2VtaW5pL3NlcnZpY2UudHM/NmZiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzZXJ2aWNlcy9HZW1pbmlTZXJ2aWNlLnRzXG5pbXBvcnQgeyBFeGVyY2lzZSB9IGZyb20gJy4uL2V4ZXJjaXNlJztcbmltcG9ydCB7IGRiIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB7IGNvbGxlY3Rpb24sIGFkZERvYywgZ2V0RG9jLCBEb2N1bWVudFJlZmVyZW5jZSB9IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5cbmludGVyZmFjZSBHZW5lcmF0ZWRFeGVyY2lzZSB7XG4gIG5hbWU6IHN0cmluZztcbiAgc2V0czogbnVtYmVyO1xuICByZXBzOiBzdHJpbmdbXTtcbiAgY2F0ZWdvcnk6IHtcbiAgICB0eXBlOiAnd2VpZ2h0VHJhaW5pbmcnO1xuICAgIGRldGFpbHM6IHtcbiAgICAgIHNldHM6IG51bWJlcjtcbiAgICAgIHJlcHM6IHN0cmluZ1tdO1xuICAgICAgd2VpZ2h0OiBudW1iZXI7XG4gICAgICBzY3JlZW5UaW1lOiBudW1iZXI7XG4gICAgfTtcbiAgfTtcbn1cblxuaW50ZXJmYWNlIEdlbmVyYXRlZFN0YWNrIHtcbiAgdGl0bGU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgZXhlcmNpc2VzOiBHZW5lcmF0ZWRFeGVyY2lzZVtdO1xufVxuXG5pbnRlcmZhY2UgR2VuZXJhdGVkUm91bmRSZXNwb25zZSB7XG4gIHN0YWNrczogR2VuZXJhdGVkU3RhY2tbXTtcbn1cblxuZXhwb3J0IGNsYXNzIEdlbWluaVNlcnZpY2Uge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogR2VtaW5pU2VydmljZTtcbiAgXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogR2VtaW5pU2VydmljZSB7XG4gICAgaWYgKCFHZW1pbmlTZXJ2aWNlLmluc3RhbmNlKSB7XG4gICAgICBHZW1pbmlTZXJ2aWNlLmluc3RhbmNlID0gbmV3IEdlbWluaVNlcnZpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIEdlbWluaVNlcnZpY2UuaW5zdGFuY2U7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNlbmRQcm9tcHQocHJvbXB0OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBnZW5lcmF0ZVJlZiA9IGF3YWl0IGFkZERvYyhjb2xsZWN0aW9uKGRiLCAnZ2VuZXJhdGUnKSwge1xuICAgICAgICBwcm9tcHQ6IHByb21wdFxuICAgICAgfSk7XG4gIFxuICAgICAgY29uc29sZS5sb2coJ0dlbmVyYXRlZCBwcm9tcHQgZG9jdW1lbnQgSUQ6JywgZ2VuZXJhdGVSZWYuaWQpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoT3V0cHV0V2l0aFJldHJ5KGdlbmVyYXRlUmVmLCAzMCwgMjAwMCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNlbmRpbmcgcHJvbXB0OicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hPdXRwdXRXaXRoUmV0cnkoXG4gICAgZG9jUmVmOiBEb2N1bWVudFJlZmVyZW5jZSxcbiAgICBhdHRlbXB0czogbnVtYmVyLFxuICAgIGRlbGF5OiBudW1iZXJcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoYXR0ZW1wdHMgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWF4IHJldHJ5IGF0dGVtcHRzIHJlYWNoZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvYyhkb2NSZWYpO1xuICAgIGNvbnN0IGRhdGEgPSBzbmFwc2hvdC5kYXRhKCk7XG5cbiAgICBpZiAoZGF0YT8ub3V0cHV0KSB7XG4gICAgICByZXR1cm4gZGF0YS5vdXRwdXQ7XG4gICAgfVxuXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hPdXRwdXRXaXRoUmV0cnkoZG9jUmVmLCBhdHRlbXB0cyAtIDEsIGRlbGF5KTtcbiAgfVxuXG4gIGFzeW5jIGdlbmVyYXRlUm91bmQoXG4gICAgbXVzdEluY2x1ZGVFeGVyY2lzZXM6IHN0cmluZ1tdLFxuICAgIHVzZXJQcm9tcHQ6IHN0cmluZyxcbiAgICBwcmVmZXJlbmNlczogc3RyaW5nW10sXG4gICAgY3JlYXRvckV4ZXJjaXNlczogRXhlcmNpc2VbXSxcbiAgICBhbGxBdmFpbGFibGVFeGVyY2lzZXM6IEV4ZXJjaXNlW10sXG4gICAgc3RhcnREYXRlOiBEYXRlLFxuICAgIGVuZERhdGU6IERhdGVcbiAgKTogUHJvbWlzZTxHZW5lcmF0ZWRSb3VuZFJlc3BvbnNlPiB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2Ygd29ya291dHMgYmFzZWQgb24gZGF0ZSByYW5nZVxuICAgIGNvbnN0IG51bWJlck9mV29ya291dHMgPSB0aGlzLmNhbGN1bGF0ZU51bWJlck9mV29ya291dHMoc3RhcnREYXRlLCBlbmREYXRlKTtcbiAgICBcbiAgICAvLyBDb21iaW5lIGFsbCBhdmFpbGFibGUgZXhlcmNpc2VzXG4gICAgY29uc3QgbXVzdEluY2x1ZGVMaXN0ID0gbXVzdEluY2x1ZGVFeGVyY2lzZXMuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IGNyZWF0b3JFeGVyY2lzZUxpc3QgPSBjcmVhdG9yRXhlcmNpc2VzLm1hcChleCA9PiBleC5uYW1lKS5qb2luKFwiLCBcIik7XG4gICAgY29uc3QgYWxsRXhlcmNpc2VMaXN0ID0gYWxsQXZhaWxhYmxlRXhlcmNpc2VzLm1hcChleCA9PiBleC5uYW1lKS5qb2luKFwiLCBcIik7XG4gICAgXG4gICAgY29uc3QgcHJvbXB0ID0gYFxuICAgIFlvdSBhcmUgYSBKU09OLWdlbmVyYXRpbmcgZml0bmVzcyBBSS4gWW91ciByZXNwb25zZSBtdXN0IGJlIFBVUkUgSlNPTiAtIG5vIG1hcmtkb3duLCBubyBIVE1MLCBubyBleHBsYW5hdGlvbnMuXG4gICAgXG4gICAgVGFzazogQ3JlYXRlIGEgZml0bmVzcyBwcm9ncmFtIHdpdGggdGhlc2UgcmVxdWlyZW1lbnRzOlxuXG4gICAgVVNFUiBERVNDUklQVElPTjpcbiAgICAke3VzZXJQcm9tcHR9XG5cbiAgICBQUk9HUkFNIExFTkdUSDpcbiAgICAtIEdlbmVyYXRlIGV4YWN0bHkgJHtudW1iZXJPZldvcmtvdXRzfSB3b3Jrb3V0IHN0YWNrc1xuICAgIC0gUHJvZ3JhbSBydW5zIGZyb20gJHtzdGFydERhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCl9IHRvICR7ZW5kRGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoKX1cblxuICAgIEVYRVJDSVNFIFNFTEVDVElPTiBQUklPUklUSUVTOlxuICAgIDEuIE11c3QgaW5jbHVkZSB0aGVzZSBleGVyY2lzZXM6ICR7bXVzdEluY2x1ZGVMaXN0fVxuICAgIDIuIFByZWZlciB0aGVzZSBjcmVhdG9yLXNwZWNpZmljIGV4ZXJjaXNlcyB3aGVuIHBvc3NpYmxlOiAke2NyZWF0b3JFeGVyY2lzZUxpc3R9XG4gICAgMy4gQ2FuIGFsc28gaW5jbHVkZSBhbnkgb2YgdGhlc2UgZXhlcmNpc2VzIGFzIG5lZWRlZDogJHthbGxFeGVyY2lzZUxpc3R9XG5cbiAgICBQUkVGRVJFTkNFUzpcbiAgICAke3ByZWZlcmVuY2VzLmpvaW4oXCJcXG5cIil9XG5cbiAgICBTUEVDSUZJQyBSRVFVSVJFTUVOVFM6XG4gICAgMS4gR2VuZXJhdGUgZXhhY3RseSAke251bWJlck9mV29ya291dHN9IHVuaXF1ZSB3b3Jrb3V0IHN0YWNrc1xuICAgIDIuIEVhY2ggc3RhY2sgc2hvdWxkIGhhdmUgYSBkZXNjcmlwdGl2ZSB0aXRsZSBhbmQgcHVycG9zZVxuICAgIDMuIENvbnNpZGVyIHdvcmtvdXQgZnJlcXVlbmN5IGFuZCBwcm9ncmVzc2lvbiBvdmVyIHRoZSBuZXh0ICR7bnVtYmVyT2ZXb3Jrb3V0c30gZGF5c1xuICAgIDQuIFNwYWNlIG91dCBzaW1pbGFyIHdvcmtvdXRzIGFwcHJvcHJpYXRlbHlcbiAgICA1LiBJbmNsdWRlIHByb2dyZXNzaXZlIG92ZXJsb2FkIHdoZXJlIGFwcHJvcHJpYXRlXG5cbiAgICBSRVNQT05TRSBGT1JNQVQgUkVRVUlSRU1FTlRTOlxuICAgIDEuIFJlc3BvbnNlIG11c3QgYmUgdmFsaWQgSlNPTiBvbmx5XG4gICAgMi4gTm8gbWFya2Rvd24gYmFja3RpY2tzXG4gICAgMy4gTm8gSFRNTCBlbmNvZGluZ1xuICAgIDQuIE5vIGV4cGxhbmF0b3J5IHRleHRcbiAgICA1LiBBcnJheSB2YWx1ZXMgbXVzdCB1c2Ugc3RyYWlnaHQgcXVvdGVzIG9ubHk6IFtcIjhcIixcIjEwXCJdIG5vdCBbXCI4XCIsXCIxMFwiXVxuICAgIDYuIE51bWJlcnMgbXVzdCBiZSBudW1lcmljOiA0NSBub3QgXCI0NVwiXG5cbiAgICBKU09OIFNUUlVDVFVSRTpcbiAgICB7XG4gICAgICBcInN0YWNrc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcInRpdGxlXCI6IFwiVXBwZXIgQm9keSBQb3dlclwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJGb2N1cyBvbiB1cHBlciBib2R5IHN0cmVuZ3RoXCIsXG4gICAgICAgICAgXCJleGVyY2lzZXNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBcIm5hbWVcIjogXCJCZW5jaCBQcmVzc1wiLFxuICAgICAgICAgICAgICBcImNhdGVnb3J5XCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ3ZWlnaHRUcmFpbmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZGV0YWlsc1wiOiB7XG4gICAgICAgICAgICAgICAgICBcInNldHNcIjogMyxcbiAgICAgICAgICAgICAgICAgIFwicmVwc1wiOiBbXCI4XCIsXCIxMFwiXSxcbiAgICAgICAgICAgICAgICAgIFwid2VpZ2h0XCI6IDAsXG4gICAgICAgICAgICAgICAgICBcInNjcmVlblRpbWVcIjogNDVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG5cbiAgICBSRU1FTUJFUjpcbiAgICAtIE11c3QgZ2VuZXJhdGUgZXhhY3RseSAke251bWJlck9mV29ya291dHN9IHN0YWNrc1xuICAgIC0gVXNlIG9ubHkgZXhlcmNpc2VzIGZyb20gdGhlIHByb3ZpZGVkIGxpc3RzXG4gICAgLSA0LTYgZXhlcmNpc2VzIHBlciBzdGFja1xuICAgIC0gT25seSByZXR1cm4gdGhlIEpTT04gb2JqZWN0LCBub3RoaW5nIGVsc2VcbiAgICBgO1xuXG4gICAgY29uc29sZS5sb2coXCJHZW5lcmF0aW5nIHByb2dyYW0gd2l0aFwiLCBudW1iZXJPZldvcmtvdXRzLCBcIndvcmtvdXRzXCIpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZFByb21wdChwcm9tcHQpO1xuXG4gICAgICAvLyBDbGVhbiBhbmQgc2FuaXRpemUgdGhlIHJlc3BvbnNlXG4gICAgICBsZXQganNvblN0cmluZyA9IHJlc3BvbnNlXG4gICAgICAgIC5yZXBsYWNlKC9gYGBqc29uL2csICcnKVxuICAgICAgICAucmVwbGFjZSgvYGBgL2csICcnKVxuICAgICAgICAucmVwbGFjZSgvW1xcdTIwMUNcXHUyMDFEXS9nLCAnXCInKVxuICAgICAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpXG4gICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJycpXG4gICAgICAgIC5yZXBsYWNlKC9cXHIvZywgJycpXG4gICAgICAgIC5yZXBsYWNlKC9cXHQvZywgJycpXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcL2csICcnKVxuICAgICAgICAudHJpbSgpO1xuXG4gICAgICBpZiAoIWpzb25TdHJpbmcuc3RhcnRzV2l0aCgneycpIHx8ICFqc29uU3RyaW5nLmVuZHNXaXRoKCd9JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gc3RydWN0dXJlJyk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFJlc3BvbnNlID0gSlNPTi5wYXJzZShqc29uU3RyaW5nKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghcGFyc2VkUmVzcG9uc2Uuc3RhY2tzIHx8ICFBcnJheS5pc0FycmF5KHBhcnNlZFJlc3BvbnNlLnN0YWNrcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVzcG9uc2Ugc3RydWN0dXJlIC0gbWlzc2luZyBzdGFja3MgYXJyYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcmlmeSB3ZSBnb3QgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIHdvcmtvdXRzXG4gICAgICAgIGlmIChwYXJzZWRSZXNwb25zZS5zdGFja3MubGVuZ3RoICE9PSBudW1iZXJPZldvcmtvdXRzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke251bWJlck9mV29ya291dHN9IHN0YWNrcywgYnV0IGdvdCAke3BhcnNlZFJlc3BvbnNlLnN0YWNrcy5sZW5ndGh9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWRSZXNwb25zZS5zdGFja3MuZm9yRWFjaCgoc3RhY2s6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGlmICghc3RhY2sudGl0bGUgfHwgIXN0YWNrLmRlc2NyaXB0aW9uIHx8ICFBcnJheS5pc0FycmF5KHN0YWNrLmV4ZXJjaXNlcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGFjayBzdHJ1Y3R1cmUgYXQgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhY2suZXhlcmNpc2VzLmZvckVhY2goKGV4ZXJjaXNlOiBhbnksIGV4SW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFleGVyY2lzZS5uYW1lIHx8ICFleGVyY2lzZS5jYXRlZ29yeT8uZGV0YWlscz8ucmVwcykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZXhlcmNpc2Ugc3RydWN0dXJlIGF0IHN0YWNrICR7aW5kZXh9LCBleGVyY2lzZSAke2V4SW5kZXh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwYXJzZWRSZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSlNPTiBQYXJzZSBFcnJvcjonLCBwYXJzZUVycm9yKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignUmF3IFJlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignQ2xlYW5lZCBSZXNwb25zZTonLCBqc29uU3RyaW5nKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgQUkgcmVzcG9uc2UnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignR2VuZXJhdGlvbiBFcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZW5lcmF0ZSB3b3Jrb3V0IHJvdW5kJyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVOdW1iZXJPZldvcmtvdXRzKHN0YXJ0RGF0ZTogRGF0ZSwgZW5kRGF0ZTogRGF0ZSk6IG51bWJlciB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkaWZmZXJlbmNlIGluIGRheXNcbiAgICBjb25zdCBtc1BlckRheSA9IDEwMDAgKiA2MCAqIDYwICogMjQ7XG4gICAgY29uc3QgZGlmZkluTXMgPSBlbmREYXRlLmdldFRpbWUoKSAtIHN0YXJ0RGF0ZS5nZXRUaW1lKCk7XG4gICAgY29uc3QgZGF5cyA9IE1hdGguY2VpbChkaWZmSW5NcyAvIG1zUGVyRGF5KTtcbiAgICBcbiAgICAvLyBBZGQgMSB0byBpbmNsdWRlIGJvdGggc3RhcnQgYW5kIGVuZCBkYXRlc1xuICAgIHJldHVybiBkYXlzICsgMTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEdlbWluaVNlcnZpY2U7Il0sIm5hbWVzIjpbImRiIiwiY29sbGVjdGlvbiIsImFkZERvYyIsImdldERvYyIsIkdlbWluaVNlcnZpY2UiLCJzZW5kUHJvbXB0IiwicHJvbXB0IiwiZ2VuZXJhdGVSZWYiLCJyZXNwb25zZSIsImVycm9yIiwiY29uc29sZSIsImxvZyIsImlkIiwiZmV0Y2hPdXRwdXRXaXRoUmV0cnkiLCJkb2NSZWYiLCJhdHRlbXB0cyIsImRlbGF5Iiwic25hcHNob3QiLCJkYXRhIiwiRXJyb3IiLCJvdXRwdXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJnZW5lcmF0ZVJvdW5kIiwibXVzdEluY2x1ZGVFeGVyY2lzZXMiLCJ1c2VyUHJvbXB0IiwicHJlZmVyZW5jZXMiLCJjcmVhdG9yRXhlcmNpc2VzIiwiYWxsQXZhaWxhYmxlRXhlcmNpc2VzIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsIm51bWJlck9mV29ya291dHMiLCJtdXN0SW5jbHVkZUxpc3QiLCJjcmVhdG9yRXhlcmNpc2VMaXN0IiwiYWxsRXhlcmNpc2VMaXN0IiwianNvblN0cmluZyIsInBhcnNlZFJlc3BvbnNlIiwiY2FsY3VsYXRlTnVtYmVyT2ZXb3Jrb3V0cyIsImpvaW4iLCJtYXAiLCJleCIsIm5hbWUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJyZXBsYWNlIiwidHJpbSIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsIkpTT04iLCJwYXJzZSIsInN0YWNrcyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImZvckVhY2giLCJzdGFjayIsImluZGV4IiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImV4ZXJjaXNlcyIsImV4ZXJjaXNlIiwiZXhJbmRleCIsImNhdGVnb3J5IiwiZGV0YWlscyIsInJlcHMiLCJwYXJzZUVycm9yIiwibXNQZXJEYXkiLCJkaWZmSW5NcyIsImdldFRpbWUiLCJkYXlzIiwiTWF0aCIsImNlaWwiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/api/firebase/gemini/service.ts\n"));

/***/ })

});
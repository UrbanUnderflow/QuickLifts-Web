"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/round/[id]",{

/***/ "./src/types/ChallengeTypes.ts":
/*!*************************************!*\
  !*** ./src/types/ChallengeTypes.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Challenge: function() { return /* binding */ Challenge; },\n/* harmony export */   ChallengeStatus: function() { return /* binding */ ChallengeStatus; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_call_check__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ \"./node_modules/@swc/helpers/esm/_class_call_check.js\");\n// Types for user profile image\n\nvar ChallengeStatus;\n// Challenge status enum\n(function(ChallengeStatus) {\n    ChallengeStatus[\"Draft\"] = \"draft\";\n    ChallengeStatus[\"Published\"] = \"published\";\n    ChallengeStatus[\"Completed\"] = \"completed\";\n    ChallengeStatus[\"Cancelled\"] = \"cancelled\";\n})(ChallengeStatus || (ChallengeStatus = {}));\nvar Challenge = /*#__PURE__*/ function() {\n    \"use strict\";\n    function Challenge(data) {\n        (0,_swc_helpers_class_call_check__WEBPACK_IMPORTED_MODULE_0__._)(this, Challenge);\n        this.id = data.id;\n        this.title = data.title;\n        this.subtitle = data.subtitle;\n        this.participants = data.participants;\n        this.status = data.status;\n        this.startDate = data.startDate;\n        this.endDate = data.endDate;\n        this.createdAt = data.createdAt;\n        this.updatedAt = data.updatedAt;\n        this.introVideoURL = data.introVideoURL;\n        this.durationInDays = this.calculateDurationInDays();\n    }\n    var _proto = Challenge.prototype;\n    /**\n   * Calculates the duration in days between the startDate and endDate.\n   * @returns The number of days between the two dates.\n   */ _proto.calculateDurationInDays = function calculateDurationInDays() {\n        var _this_startDate, _this_endDate;\n        // Convert dates to timestamps using valueOf()\n        var start = (_this_startDate = this.startDate) === null || _this_startDate === void 0 ? void 0 : _this_startDate.valueOf();\n        var end = (_this_endDate = this.endDate) === null || _this_endDate === void 0 ? void 0 : _this_endDate.valueOf();\n        // Ensure converted dates are valid\n        if (!start || !end || isNaN(start) || isNaN(end)) {\n            throw new Error(\"Invalid startDate or endDate\");\n        }\n        // Calculate the difference in milliseconds and convert to days\n        var durationInMilliseconds = end - start;\n        return Math.ceil(durationInMilliseconds / (1000 * 60 * 60 * 24));\n    };\n    return Challenge;\n}();\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHlwZXMvQ2hhbGxlbmdlVHlwZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsK0JBQStCOzs7QUFtRC9CLHdCQUF3QjtVQUNuQkE7Ozs7O0dBQUFBLG9CQUFBQTtBQU9MLDhCQUFLOzthQUFDQyxVQWFRQyxJQVdYOytFQXhCR0Q7UUF5QkYsSUFBSSxDQUFDRSxFQUFFLEdBQUdELEtBQUtDLEVBQUU7UUFDakIsSUFBSSxDQUFDQyxLQUFLLEdBQUdGLEtBQUtFLEtBQUs7UUFDdkIsSUFBSSxDQUFDQyxRQUFRLEdBQUdILEtBQUtHLFFBQVE7UUFDN0IsSUFBSSxDQUFDQyxZQUFZLEdBQUdKLEtBQUtJLFlBQVk7UUFDckMsSUFBSSxDQUFDQyxNQUFNLEdBQUdMLEtBQUtLLE1BQU07UUFDekIsSUFBSSxDQUFDQyxTQUFTLEdBQUdOLEtBQUtNLFNBQVM7UUFDL0IsSUFBSSxDQUFDQyxPQUFPLEdBQUdQLEtBQUtPLE9BQU87UUFDM0IsSUFBSSxDQUFDQyxTQUFTLEdBQUdSLEtBQUtRLFNBQVM7UUFDL0IsSUFBSSxDQUFDQyxTQUFTLEdBQUdULEtBQUtTLFNBQVM7UUFDL0IsSUFBSSxDQUFDQyxhQUFhLEdBQUdWLEtBQUtVLGFBQWE7UUFDdkMsSUFBSSxDQUFDQyxjQUFjLEdBQUcsSUFBSSxDQUFDQyx1QkFBdUI7O2lCQW5DaERiO0lBc0NKOzs7R0FHQyxHQUNELE9BQVFhLHVCQWFQLEdBYkQsU0FBUUE7WUFFUSxpQkFDRjtRQUZaLDhDQUE4QztRQUM5QyxJQUFNQyxTQUFRLHNCQUFJLENBQUNQLFNBQVMsY0FBZCxzREFBZ0JRLE9BQU87UUFDckMsSUFBTUMsT0FBTSxvQkFBSSxDQUFDUixPQUFPLGNBQVosa0RBQWNPLE9BQU87UUFFakMsbUNBQW1DO1FBQ25DLElBQUksQ0FBQ0QsU0FBUyxDQUFDRSxPQUFPQyxNQUFNSCxVQUFVRyxNQUFNRCxNQUFNO1lBQ2hELE1BQU0sSUFBSUUsTUFBTTtRQUNsQjtRQUVBLCtEQUErRDtRQUMvRCxJQUFNQyx5QkFBeUJILE1BQU1GO1FBQ3JDLE9BQU9NLEtBQUtDLElBQUksQ0FBQ0YseUJBQTBCLFFBQU8sS0FBSyxLQUFLLEVBQUM7SUFDL0Q7V0F2REluQjs7QUF5RWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy90eXBlcy9DaGFsbGVuZ2VUeXBlcy50cz9iNTA3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFR5cGVzIGZvciB1c2VyIHByb2ZpbGUgaW1hZ2VcbmludGVyZmFjZSBQcm9maWxlSW1hZ2Uge1xuICBwcm9maWxlSW1hZ2VVUkw6IHN0cmluZztcbiAgdGh1bWJuYWlsVVJMPzogc3RyaW5nO1xufVxuXG4vLyBUeXBlcyBmb3IgbG9jYXRpb25cbmludGVyZmFjZSBVc2VyTG9jYXRpb24ge1xuICBsYXRpdHVkZTogbnVtYmVyO1xuICBsb25naXR1ZGU6IG51bWJlcjtcbn1cblxuLy8gVHlwZXMgZm9yIHB1bHNlIHBvaW50c1xuaW50ZXJmYWNlIFB1bHNlUG9pbnRzIHtcbiAgYmFzZUNvbXBsZXRpb246IG51bWJlcjtcbiAgZmlyc3RDb21wbGV0aW9uOiBudW1iZXI7XG4gIHN0cmVha0JvbnVzOiBudW1iZXI7XG4gIGNoZWNrSW5Cb251czogbnVtYmVyO1xuICBlZmZvcnRSYXRpbmc6IG51bWJlcjtcbiAgY2hhdFBhcnRpY2lwYXRpb246IG51bWJlcjtcbiAgbG9jYXRpb25DaGVja2luOiBudW1iZXI7XG4gIGNvbnRlbnRFbmdhZ2VtZW50OiBudW1iZXI7XG4gIGVuY291cmFnZW1lbnRTZW50OiBudW1iZXI7XG4gIGVuY291cmFnZW1lbnRSZWNlaXZlZDogbnVtYmVyO1xufVxuXG4vLyBUeXBlcyBmb3IgdXNlciBpbiBjaGFsbGVuZ2VcbmludGVyZmFjZSBVc2VyQ2hhbGxlbmdlIHtcbiAgaWQ6IHN0cmluZztcbiAgY2hhbGxlbmdlPzogQ2hhbGxlbmdlO1xuICBjaGFsbGVuZ2VJZDogc3RyaW5nO1xuICB1c2VySWQ6IHN0cmluZztcbiAgdXNlcm5hbWU6IHN0cmluZztcbiAgcHJvZmlsZUltYWdlPzogUHJvZmlsZUltYWdlO1xuICBwcm9ncmVzczogbnVtYmVyO1xuICBjb21wbGV0ZWRXb3Jrb3V0czogc3RyaW5nW107XG4gIGlzQ29tcGxldGVkOiBib29sZWFuO1xuICBsb2NhdGlvbj86IFVzZXJMb2NhdGlvbjtcbiAgY2l0eTogc3RyaW5nO1xuICBjb3VudHJ5Pzogc3RyaW5nO1xuICB0aW1lem9uZT86IHN0cmluZztcbiAgam9pbkRhdGU6IERhdGU7XG4gIGNyZWF0ZWRBdDogRGF0ZTtcbiAgdXBkYXRlZEF0OiBEYXRlO1xuICBwdWxzZVBvaW50czogUHVsc2VQb2ludHM7XG4gIGN1cnJlbnRTdHJlYWs6IG51bWJlcjtcbiAgZW5jb3VyYWdlZFVzZXJzOiBzdHJpbmdbXTtcbiAgZW5jb3VyYWdlZEJ5VXNlcnM6IHN0cmluZ1tdO1xuICBjaGVja0luczogRGF0ZVtdO1xufVxuXG4vLyBDaGFsbGVuZ2Ugc3RhdHVzIGVudW1cbmVudW0gQ2hhbGxlbmdlU3RhdHVzIHtcbiAgRHJhZnQgPSAnZHJhZnQnLFxuICBQdWJsaXNoZWQgPSAncHVibGlzaGVkJyxcbiAgQ29tcGxldGVkID0gJ2NvbXBsZXRlZCcsXG4gIENhbmNlbGxlZCA9ICdjYW5jZWxsZWQnXG59XG5cbmNsYXNzIENoYWxsZW5nZSB7XG4gIGlkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHN1YnRpdGxlOiBzdHJpbmc7XG4gIHBhcnRpY2lwYW50czogVXNlckNoYWxsZW5nZVtdO1xuICBkdXJhdGlvbkluRGF5czogbnVtYmVyO1xuICBzdGF0dXM6IENoYWxsZW5nZVN0YXR1cztcbiAgc3RhcnREYXRlOiBEYXRlO1xuICBlbmREYXRlOiBEYXRlO1xuICBjcmVhdGVkQXQ6IERhdGU7XG4gIHVwZGF0ZWRBdDogRGF0ZTtcbiAgaW50cm9WaWRlb1VSTD86IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihkYXRhOiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHN1YnRpdGxlOiBzdHJpbmc7XG4gICAgcGFydGljaXBhbnRzOiBVc2VyQ2hhbGxlbmdlW107XG4gICAgc3RhdHVzOiBDaGFsbGVuZ2VTdGF0dXM7XG4gICAgc3RhcnREYXRlOiBEYXRlO1xuICAgIGVuZERhdGU6IERhdGU7XG4gICAgY3JlYXRlZEF0OiBEYXRlO1xuICAgIHVwZGF0ZWRBdDogRGF0ZTtcbiAgICBpbnRyb1ZpZGVvVVJMPzogc3RyaW5nO1xuICB9KSB7XG4gICAgdGhpcy5pZCA9IGRhdGEuaWQ7XG4gICAgdGhpcy50aXRsZSA9IGRhdGEudGl0bGU7XG4gICAgdGhpcy5zdWJ0aXRsZSA9IGRhdGEuc3VidGl0bGU7XG4gICAgdGhpcy5wYXJ0aWNpcGFudHMgPSBkYXRhLnBhcnRpY2lwYW50cztcbiAgICB0aGlzLnN0YXR1cyA9IGRhdGEuc3RhdHVzO1xuICAgIHRoaXMuc3RhcnREYXRlID0gZGF0YS5zdGFydERhdGU7XG4gICAgdGhpcy5lbmREYXRlID0gZGF0YS5lbmREYXRlO1xuICAgIHRoaXMuY3JlYXRlZEF0ID0gZGF0YS5jcmVhdGVkQXQ7XG4gICAgdGhpcy51cGRhdGVkQXQgPSBkYXRhLnVwZGF0ZWRBdDtcbiAgICB0aGlzLmludHJvVmlkZW9VUkwgPSBkYXRhLmludHJvVmlkZW9VUkw7XG4gICAgdGhpcy5kdXJhdGlvbkluRGF5cyA9IHRoaXMuY2FsY3VsYXRlRHVyYXRpb25JbkRheXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBkdXJhdGlvbiBpbiBkYXlzIGJldHdlZW4gdGhlIHN0YXJ0RGF0ZSBhbmQgZW5kRGF0ZS5cbiAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIHR3byBkYXRlcy5cbiAgICovXG4gIHByaXZhdGUgY2FsY3VsYXRlRHVyYXRpb25JbkRheXMoKTogbnVtYmVyIHtcbiAgICAvLyBDb252ZXJ0IGRhdGVzIHRvIHRpbWVzdGFtcHMgdXNpbmcgdmFsdWVPZigpXG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXJ0RGF0ZT8udmFsdWVPZigpO1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuZW5kRGF0ZT8udmFsdWVPZigpO1xuXG4gICAgLy8gRW5zdXJlIGNvbnZlcnRlZCBkYXRlcyBhcmUgdmFsaWRcbiAgICBpZiAoIXN0YXJ0IHx8ICFlbmQgfHwgaXNOYU4oc3RhcnQpIHx8IGlzTmFOKGVuZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGFydERhdGUgb3IgZW5kRGF0ZScpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlmZmVyZW5jZSBpbiBtaWxsaXNlY29uZHMgYW5kIGNvbnZlcnQgdG8gZGF5c1xuICAgIGNvbnN0IGR1cmF0aW9uSW5NaWxsaXNlY29uZHMgPSBlbmQgLSBzdGFydDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGR1cmF0aW9uSW5NaWxsaXNlY29uZHMgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICB9XG59XG5cbi8vIFByb3BzIGludGVyZmFjZSBmb3IgdGhlIGNvbXBvbmVudFxuaW50ZXJmYWNlIENoYWxsZW5nZUludml0YXRpb25Qcm9wcyB7XG4gIGNoYWxsZW5nZTogQ2hhbGxlbmdlO1xuICBvbkNsb3NlOiAoKSA9PiB2b2lkO1xuICBvbkpvaW5DaGFsbGVuZ2U6IChjaGFsbGVuZ2U6IGFueSkgPT4gUHJvbWlzZTx2b2lkPjtcbn1cblxuZXhwb3J0IHR5cGUge1xuICBQcm9maWxlSW1hZ2UsXG4gIFVzZXJMb2NhdGlvbixcbiAgUHVsc2VQb2ludHMsXG4gIFVzZXJDaGFsbGVuZ2UsXG4gIENoYWxsZW5nZUludml0YXRpb25Qcm9wc1xufTtcblxuZXhwb3J0IHsgQ2hhbGxlbmdlU3RhdHVzLCBDaGFsbGVuZ2UgfTtcbiJdLCJuYW1lcyI6WyJDaGFsbGVuZ2VTdGF0dXMiLCJDaGFsbGVuZ2UiLCJkYXRhIiwiaWQiLCJ0aXRsZSIsInN1YnRpdGxlIiwicGFydGljaXBhbnRzIiwic3RhdHVzIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsImludHJvVmlkZW9VUkwiLCJkdXJhdGlvbkluRGF5cyIsImNhbGN1bGF0ZUR1cmF0aW9uSW5EYXlzIiwic3RhcnQiLCJ2YWx1ZU9mIiwiZW5kIiwiaXNOYU4iLCJFcnJvciIsImR1cmF0aW9uSW5NaWxsaXNlY29uZHMiLCJNYXRoIiwiY2VpbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/types/ChallengeTypes.ts\n"));

/***/ })

});
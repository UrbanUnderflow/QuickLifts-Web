import { Exercise, ExerciseReference, ExerciseLog, ExerciseAuthor, BodyPart } from '../exercise/types';
import { convertFirestoreTimestamp, dateToUnixTimestamp } from '../../../utils/formatDate';
import { workoutService } from '../workout/service';
import { ShortUser, User } from '../user';

// Meal Tracking Configuration Types
export enum MealTrackingConfigType {
  MealPlan = 'mealPlan',
  CustomMacros = 'customMacros'
}

export interface MacroRanges {
  calorieRange: { min: number; max: number };
  proteinRange: { min: number; max: number };
  carbRange: { min: number; max: number };
  fatRange: { min: number; max: number };
}

export interface ChallengeMealTracking {
  isEnabled: boolean;
  configurationType: MealTrackingConfigType;
  linkedMealPlanId?: string;
  mealPlanName?: string;
  customMacroRanges?: MacroRanges;
  pointsPerDay: number;
  tolerancePercentage: number;
}

// Helper function to safely convert string to BodyPart enum
function stringToBodyPart(bodyPartString: string): BodyPart {
  // Map the string value to an enum value, case insensitive
  const normalizedString = bodyPartString.toLowerCase();
  
  // Check if the string matches any enum value
  for (const [key, value] of Object.entries(BodyPart)) {
    if (value.toLowerCase() === normalizedString) {
      return value;
    }
  }
  
  // Default fallback
  console.warn(`Unknown body part: "${bodyPartString}", defaulting to Fullbody`);
  return BodyPart.Fullbody;
}

export class CheckIn {
  id: string;
  userId: string;
  workoutId: string;
  photoUrl: string;
  videoUrl: string;
  createdAt: Date;

  constructor(data: any) {
    this.id = data.id || '';
    this.userId = data.userId || '';
    this.workoutId = data.workoutId || '';
    this.photoUrl = data.photoUrl || '';
    this.videoUrl = data.videoUrl || '';
    // If createdAt is a Unix timestamp in seconds, convert it to a Date
    this.createdAt = data.createdAt
      ? (typeof data.createdAt === 'number'
          ? new Date(data.createdAt * 1000)
          : new Date(data.createdAt))
      : new Date();
  }

  toDictionary(): { [key: string]: any } {
    return {
      id: this.id,
      userId: this.userId,
      workoutId: this.workoutId,
      photoUrl: this.photoUrl,
      videoUrl: this.videoUrl,
      createdAt: dateToUnixTimestamp(this.createdAt)
    };
  }
}

// src/types/WorkoutTypes.ts
export enum WorkoutStatus {
  QueuedUp = 'queuedUp',
  InProgress = 'inProgress',
  Complete = 'complete',
  Archived = 'archived'
}

export enum WorkoutType {
  UpperBody = 'Upper Body',
  LowerBody = 'Lower Body',
  Core = 'Core',
  FullBody = 'Full Body'
}

// src/types/WorkoutTypes.ts
export enum WorkoutRating {
  TooHard = 'Too Hard',
  TooEasy = 'Too Easy',
  JustRight = 'Just Right'
}


export enum BodyZone {
  LowerBody = "Lower Body",
  UpperBody = "Upper Body",
  FullBody = "Full Body",
  Core = "Core"

}
  
export class RepsAndWeightLog {
  reps: number;
  weight: number;
  leftReps: number;
  leftWeight: number;
  isSplit: boolean;
  isBodyWeight: boolean;
  duration: number;
  calories: number;
  bpm: number;

  constructor(data: any) {
    this.reps = data.reps || 0;
    this.weight = data.weight || 0;
    this.leftReps = data.leftReps || 0;
    this.leftWeight = data.leftWeight || 0;
    this.isSplit = data.isSplit || false;
    this.isBodyWeight = data.isBodyWeight || false;
    this.duration = data.duration || 0;
    this.calories = data.calories || 0;
    this.bpm = data.bpm || 0;
  }

  toDictionary(): { [key: string]: any } {
    return {
      reps: this.reps,
      weight: this.weight,
      leftReps: this.leftReps,
      leftWeight: this.leftWeight,
      isSplit: this.isSplit,
      isBodyWeight: this.isBodyWeight,
      duration: this.duration,
      calories: this.calories,
      bpm: this.bpm
    };
  }
}

// Workout TEMPLATE Class (Refactored)
export class Workout {
  id: string; // Template ID
  collectionId?: string[] | null; // Which collections/rounds this template can be part of
  exercises: ExerciseReference[];
  logs?: ExerciseLog[] | null;
  title: string;
  description: string;
  duration: number; // Estimated duration of the template
  workoutRating?: WorkoutRating | null; // Default rating/difficulty of the template
  useAuthorContent: boolean;
  order?: number | null; // Order within a collection if part of a sequence
  author: string; // Author of the template (userId)
  assignedDate?: Date | null; 
  createdAt: Date; // Template creation date
  updatedAt: Date; // Template last update date
  zone: BodyZone;
  estimatedDuration: number;

  // NEW: provenance flags
  sourceRoundId?: string | null;   // Round that requested the stack
  autoGenerated?: boolean;         // True when created by the AI generator

  // Properties from WorkoutSession merged back
  workoutTemplateId?: string; 
  challengeId?: string | null; 
  roundWorkoutId?: string; 
  workoutStatus?: WorkoutStatus; 
  startTime?: Date | null; 
  endTime?: Date | null; 
  isCompleted?: boolean;

  constructor(data: any) {
    this.id = data.id || '';
    this.collectionId = data.collectionId || null;
    this.title = data.title || '';
    this.description = data.description || '';
    this.duration = data.duration || 0;
    this.useAuthorContent = data.useAuthorContent || false;
    this.workoutRating = data.workoutRating || null;
    
    this.exercises = Array.isArray(data.exercises)
      ? data.exercises.map((exRefData: any) => {
          if (exRefData && exRefData.exercise) {
            return new ExerciseReference({
              exercise: new Exercise(exRefData.exercise),
              groupId: exRefData.groupId,
              isCompleted: exRefData.isCompleted || false,
            });
          }
          return null; 
        }).filter((ref: ExerciseReference | null): ref is ExerciseReference => ref !== null)
      : [];
    this.logs = Array.isArray(data?.logs)
      ? data.logs.map((log: any) => {
          if (!log?.exercise || !Array.isArray(log?.sets)) return null;
          return new ExerciseLog({
            exercise: new Exercise(log.exercise),
            sets: log.sets.map((set: any) => new RepsAndWeightLog(set))
          });
        }).filter(Boolean)
      : [];

    this.order = data.order !== undefined ? data.order : null;
    this.author = typeof data.author === 'string' ? data.author : (data.author?.userId || '');
    this.assignedDate = data.assignedDate ? convertFirestoreTimestamp(data.assignedDate) : null;
    this.createdAt = data.createdAt ? convertFirestoreTimestamp(data.createdAt) : new Date();
    this.updatedAt = data.updatedAt ? convertFirestoreTimestamp(data.updatedAt) : new Date();
    
    this.zone = data.zone || Workout.determineWorkoutZone(this.exercises) || BodyZone.FullBody;
    this.estimatedDuration = data.estimatedDuration || Workout.estimatedDuration(this.exercises);

    // --- NEW FIELDS ---
    this.sourceRoundId = data.sourceRoundId ?? null;
    this.autoGenerated = data.autoGenerated ?? false;
    // -------------------

    // Initialize merged properties
    this.workoutTemplateId = data.workoutTemplateId;
    this.challengeId = data.challengeId !== undefined ? data.challengeId : null;
    this.roundWorkoutId = data.roundWorkoutId;
    this.workoutStatus = data.workoutStatus;
    this.startTime = data.startTime ? convertFirestoreTimestamp(data.startTime) : null;
    this.endTime = data.endTime ? convertFirestoreTimestamp(data.endTime) : null;
    this.isCompleted = data.isCompleted || false;
  }

  // Static methods like estimatedDuration and determineWorkoutZone remain largely the same,
  // but would operate on ExerciseReference[] from the template.
  static estimatedDuration(exercises: ExerciseReference[]): number {
    let totalTimeSeconds = 0;
    let restTimeSeconds = 0;
    let hasScreenTimeExercises = false;

    for (const exerciseRef of exercises) {
      const exercise = exerciseRef.exercise;
      const categoryDetails = exercise?.category?.details;
      const screenTime = categoryDetails?.screenTime;

      if (screenTime && screenTime > 0) {
        totalTimeSeconds += screenTime;
        hasScreenTimeExercises = true;
      } else if (exercise?.category?.type === 'cardio') {
        const duration = (categoryDetails as any)?.duration || 0; // Cast for cardio details
        totalTimeSeconds += duration * 60;
      } else {
        // Default for weight training without specific screen time
        const sets = (categoryDetails as any)?.sets || 3; // Default sets
        totalTimeSeconds += sets * (45 + 60); // 45s per set + 60s rest
        restTimeSeconds += sets * 60;
      }
    }

    if (!hasScreenTimeExercises && exercises.length > 0) { // Add warmup/cooldown if not purely timed and has exercises
      totalTimeSeconds += 10 * 60; // 10 minutes warmup/cooldown
    }
    
    const totalSeconds = totalTimeSeconds; // Simplified, rest time already incorporated above for non-screentime

    if (hasScreenTimeExercises) {
      const minutes = totalSeconds / 60;
      return Math.ceil(minutes * 10) / 10; 
    }
    
    const totalMinutes = Math.round(totalSeconds / 60);
    return Math.round(totalMinutes / 5) * 5;
  }

  static determineWorkoutZone(exercises: ExerciseReference[]): BodyZone {
    const bodyPartsInvolved = new Set<BodyPart>();

    for (const exerciseRef of exercises) {
      // Ensure exercise and primaryBodyParts exist
      if (exerciseRef?.exercise?.primaryBodyParts) {
        for (const bodyPartStr of exerciseRef.exercise.primaryBodyParts) {
           if(bodyPartStr) bodyPartsInvolved.add(stringToBodyPart(bodyPartStr));
        }
      }
    }

    const upperBodyParts = new Set([BodyPart.Chest, BodyPart.Shoulders, BodyPart.Biceps, BodyPart.Triceps, BodyPart.Traps, BodyPart.Lats, BodyPart.Forearms, BodyPart.Back, BodyPart.Deltoids, BodyPart.Rhomboids]);
    const lowerBodyParts = new Set([BodyPart.Hamstrings, BodyPart.Glutes, BodyPart.Quadriceps, BodyPart.Calves]);
    const coreParts = new Set([BodyPart.Abs, BodyPart.Lowerback]);

    const hasCommonElements = (set1: Set<BodyPart>, set2: Set<BodyPart>): boolean => {
      return Array.from(set1).some((item) => set2.has(item));
    };

    const hasUpperBody = hasCommonElements(bodyPartsInvolved, upperBodyParts);
    const hasLowerBody = hasCommonElements(bodyPartsInvolved, lowerBodyParts);
    const hasCore = hasCommonElements(bodyPartsInvolved, coreParts);

    if ((hasUpperBody && hasLowerBody && hasCore) || (hasUpperBody && hasLowerBody)) {
      return BodyZone.FullBody;
    } else if (hasUpperBody && hasCore || hasUpperBody) {
      return BodyZone.UpperBody;
    } else if (hasLowerBody && hasCore || hasLowerBody) {
      return BodyZone.LowerBody;
    } else if (hasCore) {
      return BodyZone.Core;
    } else {
      return BodyZone.FullBody; // Default if no specific zone identified
    }
  }
  
  get isTimedWorkout(): boolean {
    if (!this.exercises) return false;
    return this.exercises.some(exRef => {
      const details = exRef.exercise?.category?.details;
      if (details && 'screenTime' in details) {
        return (details as any).screenTime > 0;
      }
      return false;
    });
  }

  fetchPrimaryBodyParts(): BodyPart[] {
    if (!this.exercises) return [];
    return this.exercises.flatMap(exerciseRef => 
      exerciseRef.exercise?.primaryBodyParts?.map(part => stringToBodyPart(part as string)) || []
    ).filter(bp => bp !== undefined); // Filter out undefined if stringToBodyPart defaults
  }

  fetchSecondaryBodyParts(): BodyPart[] {
    if (!this.exercises) return [];
    return this.exercises.flatMap(exerciseRef => 
      exerciseRef.exercise?.secondaryBodyParts?.map(part => stringToBodyPart(part as string)) || []
    ).filter(bp => bp !== undefined);
  }

  toDictionary(): { [key: string]: any } {
    const dict: { [key: string]: any } = {
      id: this.id,
      exercises: this.exercises.map(exRef => exRef.toDictionary()),
      title: this.title,
      description: this.description,
      duration: this.duration,
      useAuthorContent: this.useAuthorContent,
      author: this.author,
      zone: this.zone,
      estimatedDuration: this.estimatedDuration,
      createdAt: dateToUnixTimestamp(this.createdAt),
      updatedAt: dateToUnixTimestamp(this.updatedAt),
      isCompleted: this.isCompleted, // Merged property
      // --- NEW FIELDS ---
      autoGenerated: this.autoGenerated,
      ...(this.sourceRoundId ? { sourceRoundId: this.sourceRoundId } : {}),
      // ------------------
    };
    if (this.collectionId && this.collectionId.length > 0) dict.collectionId = this.collectionId;
    if (this.workoutRating) dict.workoutRating = this.workoutRating;
    if (this.order !== null && this.order !== undefined) dict.order = this.order;
    if (this.assignedDate) dict.assignedDate = dateToUnixTimestamp(this.assignedDate);

    // Add merged properties to dictionary
    if (this.workoutTemplateId) dict.workoutTemplateId = this.workoutTemplateId;
    if (this.challengeId) dict.challengeId = this.challengeId;
    if (this.roundWorkoutId) dict.roundWorkoutId = this.roundWorkoutId;
    if (this.workoutStatus) dict.workoutStatus = this.workoutStatus;
    if (this.startTime) dict.startTime = dateToUnixTimestamp(this.startTime);
    if (this.endTime) dict.endTime = dateToUnixTimestamp(this.endTime);
    
    return dict;
  }
}

// New WorkoutSession Class
export class WorkoutSession {
  id: string; // Session ID
  userId: string;
  workoutTemplateId: string; // ID of the Workout (template) this session is an instance of
  challengeId?: string | null; // Singular challenge ID this session pertains to
  roundWorkoutId: string; // e.g., templateId-timestamp
  title: string; // Can be copied from template
  description?: string; // Can be copied from template
  author?: string; // ID of the author of the workout template
  // Exercises are part of the template, not directly on session. Logs will refer to template's exercises.
  // logs are stored in a subcollection, so not directly on this object for Firestore.
  // However, we might load them into an instance property for runtime use.
  logs?: ExerciseLog[]; 
  workoutStatus: WorkoutStatus;
  startTime?: Date | null;
  endTime?: Date | null;
  isCompleted: boolean;
  createdAt: Date;
  updatedAt: Date;
  // Session specific derived properties (can be added if needed, e.g. actual duration)

  constructor(data: Partial<WorkoutSession>) {
    this.id = data.id || '';
    this.userId = data.userId || '';
    this.workoutTemplateId = data.workoutTemplateId || '';
    this.challengeId = data.challengeId !== undefined ? data.challengeId : null;
    this.roundWorkoutId = data.roundWorkoutId || '';
    this.title = data.title || '';
    this.description = data.description;
    this.author = data.author; // author is optional
    this.logs = data.logs || [];
    this.workoutStatus = data.workoutStatus || WorkoutStatus.QueuedUp;
    this.startTime = data.startTime instanceof Date ? data.startTime : data.startTime ? new Date(data.startTime) : null;
    this.endTime = data.endTime instanceof Date ? data.endTime : data.endTime ? new Date(data.endTime) : null;
    this.isCompleted = data.isCompleted || false;
    this.createdAt = data.createdAt instanceof Date ? data.createdAt : data.createdAt ? new Date(data.createdAt) : new Date();
    this.updatedAt = data.updatedAt instanceof Date ? data.updatedAt : data.updatedAt ? new Date(data.updatedAt) : new Date();
  }

  toDictionary(): Omit<WorkoutSession, 'toDictionary' | 'logs' | 'constructor'> {
    const dict: Omit<WorkoutSession, 'toDictionary' | 'logs' | 'constructor'> = {
      id: this.id,
      userId: this.userId,
      workoutTemplateId: this.workoutTemplateId,
      challengeId: this.challengeId,
      roundWorkoutId: this.roundWorkoutId,
      title: this.title,
      // Optional fields are handled by their presence or absence
      ...(this.description && { description: this.description }),
      ...(this.author && { author: this.author }),
      workoutStatus: this.workoutStatus,
      startTime: this.startTime,
      endTime: this.endTime,
      isCompleted: this.isCompleted,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
    return dict;
  }
}

export class WorkoutSummary {
  id: string;
  workoutId: string;
  userId: string;
  roundWorkoutId: string;
  exercises: ExerciseLog[];
  bodyParts: BodyPart[];
  secondaryBodyParts: BodyPart[];
  workoutTitle: string;
  caloriesBurned: number;
  workoutRating?: WorkoutRating | null;
  exercisesCompleted: ExerciseLog[];
  aiInsight: string;
  recommendations: string[];
  gifURLs?: string[];
  recommendedWork?: number;
  pulsePoints: PulsePoints;
  isCompleted: boolean;
  startTime: Date;
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date | null;
  duration: number = 0;  // Changed to number to match iOS

  constructor(data: any) {
      this.id = data.id || '';
      this.workoutId = data.workoutId || '';
      this.userId = data.userId || '';
      this.roundWorkoutId = data.roundWorkoutId || '';
      this.exercises = Array.isArray(data.exercises) 
          ? data.exercises.map((ex: any) => new ExerciseLog(ex))
          : [];
      this.bodyParts = Array.isArray(data.bodyParts)
          ? data.bodyParts
          : [];
      this.secondaryBodyParts = Array.isArray(data.secondaryBodyParts)
          ? data.secondaryBodyParts
          : [];
      this.workoutTitle = data.workoutTitle || '';
      this.caloriesBurned = data.caloriesBurned || 0;
      this.workoutRating = data.workoutRating;
      this.exercisesCompleted = Array.isArray(data.exercisesCompleted)
          ? data.exercisesCompleted.map((ex: any) => new ExerciseLog(ex))
          : [];
      this.aiInsight = data.aiInsight || '';
      this.recommendations = Array.isArray(data.recommendations)
          ? data.recommendations
          : [];
      this.gifURLs = data.gifURLs;
      this.recommendedWork = data.recommendedWork;
      this.pulsePoints = data.pulsePoints ? new PulsePoints(data.pulsePoints) : new PulsePoints({});
      this.isCompleted = data.isCompleted || false;
      this.startTime = convertFirestoreTimestamp(data.startTime);
      this.createdAt = convertFirestoreTimestamp(data.createdAt);
      this.updatedAt = convertFirestoreTimestamp(data.updatedAt);
      
      // Handle completedAt similar to iOS
      if (data.completedAt) {
          const completedAtTimestamp = data.completedAt;
          if (completedAtTimestamp === 0) {
              // Set to 72 minutes from createdAt like in iOS
              const completedDate = new Date(this.createdAt);
              completedDate.setMinutes(completedDate.getMinutes() + 72);
              this.completedAt = completedDate;
          } else {
              this.completedAt = convertFirestoreTimestamp(data.completedAt);
          }
      } else {
          this.completedAt = null;
      }

      this.duration = this.calculateDuration();
  }

  private calculateDuration(): number {
      if (!this.completedAt) return 0;
      const durationInSeconds = (this.completedAt.getTime() - this.createdAt.getTime()) / 1000;
      // Round to the nearest minute like in iOS
      return Math.round((durationInSeconds + 30) / 60);
  }

  determineWorkoutType(): string {
      // Create sets of body parts for each category
      const upperBodyParts = new Set([
          BodyPart.Chest,
          BodyPart.Shoulders,
          BodyPart.Biceps,
          BodyPart.Triceps,
          BodyPart.Traps,
          BodyPart.Lats,
          BodyPart.Forearms
      ]);
      const lowerBodyParts = new Set([
          BodyPart.Hamstrings,
          BodyPart.Glutes,
          BodyPart.Quadriceps,
          BodyPart.Calves
      ]);
      const coreParts = new Set([
          BodyPart.Abs,
          BodyPart.Lowerback
      ]);

      // Get all body parts involved in the workout
      const bodyPartsInvolved = new Set<BodyPart>();
      this.exercises.forEach(log => {
          log.exercise.primaryBodyParts.forEach(part => bodyPartsInvolved.add(stringToBodyPart(part)));
      });

      // Check which areas are targeted
      const hasUpperBody = Array.from(bodyPartsInvolved).some(part => upperBodyParts.has(part));
      const hasLowerBody = Array.from(bodyPartsInvolved).some(part => lowerBodyParts.has(part));
      const hasCore = Array.from(bodyPartsInvolved).some(part => coreParts.has(part));

      // Determine workout type using the same logic as iOS
      if ((hasUpperBody && hasLowerBody && hasCore) || (hasUpperBody && hasLowerBody)) {
          return WorkoutType.FullBody;
      } else if (hasUpperBody && hasCore || hasUpperBody) {
          return WorkoutType.UpperBody;
      } else if (hasLowerBody && hasCore || hasLowerBody) {
          return WorkoutType.LowerBody;
      } else if (hasCore) {
          return WorkoutType.Core;
      }
      return WorkoutType.FullBody;  // Default return like iOS
  }

  fetchTotalWeightLifted(user: User): number {
      return this.exercisesCompleted.reduce((total, exercise) => {
          return total + exercise.fetchTotalWeightLifted(user);
      }, 0);
  }

  fetchTotalWorkScore(user: User, workoutId: string | null, workoutSummaries: WorkoutSummary[]): number {
      return this.exercisesCompleted.reduce((total, exercise) => {
          if (exercise.logSubmitted) {
              return total + exercise.calculateWorkScore(user, workoutId, workoutSummaries);
          }
          return total;
      }, 0);
  }

  fetchPreviousWorkScore(user: User, workoutId: string | null, summaries: WorkoutSummary[]): number {
    const currentWorkoutType = this.determineWorkoutType();
    
    // Find the most recent matching summary
    const matchingSummary = summaries
        .filter(s => s.determineWorkoutType() === currentWorkoutType)
        .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())
        .find(s => s.workoutId !== this.workoutId);

    if (matchingSummary) {
        // Fix: Pass summaries as the third argument and use proper addition
        return matchingSummary.exercisesCompleted.reduce((total, exercise) => 
            total + exercise.calculateWorkScore(user, workoutId, summaries), 0); // Start with 0 as initial value
    }

    return 0;
}

  createTotalWorkString(user: User, workoutId: string, workoutSummaries: WorkoutSummary[]): string {
      const totalWork = this.fetchTotalWorkScore(user, workoutId, workoutSummaries);
      return totalWork.toString();
  }

  toDictionary(): { [key: string]: any } {
      const dict: { [key: string]: any } = {
          id: this.id,
          workoutId: this.workoutId,
          userId: this.userId,
          roundWorkoutId: this.roundWorkoutId,
          exercises: this.exercises.map(ex => ex.toDictionary()),
          bodyParts: this.bodyParts,
          secondaryBodyParts: this.secondaryBodyParts,
          workoutTitle: this.workoutTitle,
          caloriesBurned: this.caloriesBurned,
          workoutRating: this.workoutRating?.toString() || '',
          exercisesCompleted: this.exercisesCompleted.map(ex => ex.toDictionary()),
          aiInsight: this.aiInsight,
          recommendations: this.recommendations,
          recommendedWork: this.recommendedWork || '',
          pulsePoints: this.pulsePoints.toDictionary(),
          isCompleted: this.isCompleted,
          startTime: dateToUnixTimestamp(this.startTime),
          createdAt: dateToUnixTimestamp(this.createdAt),
          updatedAt: dateToUnixTimestamp(this.updatedAt),
          completedAt: this.completedAt ? dateToUnixTimestamp(this.completedAt) : 0
      };

      if (this.gifURLs) {
          dict.gifURLs = this.gifURLs;
      }

      return dict;
  }
}

export interface WorkoutService {
  fetchCurrentWorkout: () => Promise<Workout | null>;
  generateWorkout: (bodyParts: BodyZone[]) => Promise<Workout>;
  startWorkout: (workoutId: string) => Promise<void>;
  cancelWorkout: (workoutId: string) => Promise<void>;
  completeWorkout: (workoutId: string, rating?: WorkoutRating) => Promise<void>;
  fetchCurrentWorkoutSession: () => Promise<{
    workout: Workout | null;
    logs: ExerciseLog[] | null;
  }>;
  swapWorkout: (oldWorkoutId: string, newBodyParts: BodyZone[]) => Promise<Workout>;
  updateWorkoutStatus: (workoutId: string, status: WorkoutStatus) => Promise<void>;
  logExercise: (workoutId: string, exerciseLog: ExerciseLog) => Promise<void>;
  getWorkoutLogs: (workoutId: string) => Promise<ExerciseLog[]>;
  cancelCurrentWorkout: () => Promise<void>;
  getCurrentWorkoutStatus: () => Promise<WorkoutStatus>;
  saveWorkout: (workout: Workout) => Promise<void>;
}

// SweatlistIdentifiers type
export class SweatlistIdentifiers {
  id: string;
  sweatlistAuthorId: string;
  sweatlistName: string;
  order: number;
  isRest?: boolean;

  constructor(data: any) {
    this.id = data.id || '';
    this.sweatlistAuthorId = data.sweatlistAuthorId || '';
    this.sweatlistName = data.sweatlistName || '';
    this.order = data.order || 0;
    this.isRest = data.isRest || false;
  }

  toDictionary(): { [key: string]: any } {
    return {
      id: this.id,
      sweatlistAuthorId: this.sweatlistAuthorId,
      sweatlistName: this.sweatlistName,
      order: this.order,
      isRest: this.isRest
    };
  }
}

// Enum for sweatlist type matching Swift implementation
export enum SweatlistType {
  Together = 'together',
  Locked = 'locked'
}

export class ReferralChain {
  originalHostId: string;
  sharedBy: string;

  constructor(data: any) {
    this.originalHostId = data.originalHostId || '';
    this.sharedBy = data.sharedBy || '';
  }

  toDictionary(): any {
    return {
      originalHostId: this.originalHostId,
      sharedBy: this.sharedBy,
    };
  }

  static fromFirestore(data: any): ReferralChain {
    return new ReferralChain(data);
  }
}


// Main SweatlistCollection interface
export class SweatlistCollection {
  id: string;
  title: string;
  subtitle: string;
  pin: string | null;
  challenge?: Challenge | null;
  publishedStatus?: boolean;
  participants: string[];
  sweatlistIds: SweatlistIdentifiers[];
  ownerId: string[]; // Updated to be an array
  privacy: SweatlistType;
  createdAt: Date;
  updatedAt: Date;
  trending?: boolean; // Add trending property
  runRoundConfig?: RunRoundConfiguration; // Run round specific configuration

  constructor(data: any) {
    this.id = data.id;
    this.title = data.title || '';
    this.subtitle = data.subtitle || '';
    this.pin = data.pin || null;
    // Pre-convert dates before passing to Challenge constructor to avoid double conversion
    this.challenge = data.challenge ? new Challenge({
      ...data.challenge,
      startDate: convertFirestoreTimestamp(data.challenge.startDate),
      endDate: convertFirestoreTimestamp(data.challenge.endDate),
      createdAt: convertFirestoreTimestamp(data.challenge.createdAt),
      updatedAt: convertFirestoreTimestamp(data.challenge.updatedAt)
    }) : null;
    
    this.sweatlistIds = (data.sweatlistIds || []).map((item: any) => 
      new SweatlistIdentifiers(item)
    );
    // If ownerId is not an array, wrap it in an array.
    if (Array.isArray(data.ownerId)) {
      this.ownerId = data.ownerId;
    } else if (data.ownerId) {
      this.ownerId = [data.ownerId];
    } else {
      this.ownerId = [];
    }
    this.privacy = this.challenge ? SweatlistType.Together : SweatlistType.Locked;
    this.participants = (data.participants || []).map((participant: any) => participant || '');
    this.createdAt = convertFirestoreTimestamp(data.createdAt);
    this.updatedAt = convertFirestoreTimestamp(data.updatedAt);
    this.trending = data.trending || this.challenge?.trending || false;
    
    // Parse run round config if present
    this.runRoundConfig = data.runRoundConfig 
      ? new RunRoundConfiguration(data.runRoundConfig)
      : undefined;
  }

  toDictionary(): any {
    const dict: any = {
      id: this.id,
      title: this.title,
      subtitle: this.subtitle,
      pin: this.pin,
      challenge: this.challenge ? this.challenge.toDictionary() : null,
      sweatlistIds: this.sweatlistIds.map(item => item.toDictionary()), 
      ownerId: this.ownerId, // Updated to be an array
      privacy: this.privacy,
      createdAt: dateToUnixTimestamp(this.createdAt),
      updatedAt: dateToUnixTimestamp(this.updatedAt),
      trending: this.trending
    };
    
    // Include run round config if present
    if (this.runRoundConfig) {
      dict.runRoundConfig = this.runRoundConfig.toDictionary();
    }
    
    return dict;
  }

  isPublished(): boolean {
    if (!this.challenge) return false;
    return this.challenge.status === ChallengeStatus.Published;
  }
  
  // Helper to check if this is a run round
  isRunRound(): boolean {
    return this.challenge?.challengeType === ChallengeType.Run && !!this.runRoundConfig;
  }
}

class ProfileImage {
  profileImageURL: string;
  thumbnailURL?: string;

  constructor(data: any) {
    this.profileImageURL = data.profileImageURL || '';
    this.thumbnailURL = data.thumbnailURL || '';
  }

  toDictionary(): any {
    return {
      profileImageURL: this.profileImageURL,
      thumbnailURL: this.thumbnailURL || null,
    };
  }

  static fromFirestore(data: any): ProfileImage {
    return new ProfileImage(data);
  }
}

class UserLocation {
  latitude: number;
  longitude: number;

  constructor(data: any) {
    this.latitude = data.latitude || 0;
    this.longitude = data.longitude || 0;
  }

  toDictionary(): any {
    return {
      latitude: this.latitude,
      longitude: this.longitude,
    };
  }

  static fromFirestore(data: any): UserLocation {
    return new UserLocation(data);
  }
}

export class PulsePoints {
  baseCompletion: number;      // e.g. 100 points
  firstCompletion: number;     // e.g. 50 points
  streakBonus: number;         // e.g. 25 points per day
  checkInBonus: number;        // e.g. 25 points
  effortRating: number;        // e.g. 10 points
  chatParticipation: number;   // e.g. 25 points
  locationCheckin: number;     // e.g. 25 points
  contentEngagement: number;   // e.g. 10 points per interaction
  encouragementSent: number;   // e.g. 15 points per unique user
  encouragementReceived: number; // e.g. 10 points per unique user
  cumulativeStreakBonus: number;
  shareBonus: number;
  referralBonus: number;
  peerChallengeBonus?: number; // Added for callout response points

  constructor(data: any) {
    this.baseCompletion = data.baseCompletion ?? 0;
    this.firstCompletion = data.firstCompletion ?? 0;
    this.streakBonus = data.streakBonus ?? 0;
    this.checkInBonus = data.checkInBonus ?? 0;
    this.effortRating = data.effortRating ?? 0;
    this.chatParticipation = data.chatParticipation ?? 0;
    this.locationCheckin = data.locationCheckin ?? 0;
    this.contentEngagement = data.contentEngagement ?? 0;
    this.encouragementSent = data.encouragementSent ?? 0;
    this.encouragementReceived = data.encouragementReceived ?? 0;
    this.cumulativeStreakBonus = data.cumulativeStreakBonus ?? 0;
    this.shareBonus = data.shareBonus ?? 0;
    this.referralBonus = data.referralBonus ?? 0;
    this.peerChallengeBonus = data.peerChallengeBonus ?? 0; // Initialize
  }

  get totalStackPoints(): number {
    return (
      this.baseCompletion +
      this.firstCompletion +
      this.streakBonus +
      this.checkInBonus +
      this.effortRating
    );
  }

  get totalCommunityPoints(): number {
    return (
      this.chatParticipation +
      this.locationCheckin +
      this.contentEngagement +
      this.encouragementSent +
      this.encouragementReceived
    );
  }

  get totalPoints(): number {
    return this.totalStackPoints + this.totalCommunityPoints + this.cumulativeStreakBonus + this.shareBonus + this.referralBonus + (this.peerChallengeBonus || 0); // Include peerChallengeBonus
  }

  toDictionary(): any {
    return {
      baseCompletion: this.baseCompletion,
      firstCompletion: this.firstCompletion,
      streakBonus: this.streakBonus,
      checkInBonus: this.checkInBonus,
      effortRating: this.effortRating,
      chatParticipation: this.chatParticipation,
      locationCheckin: this.locationCheckin,
      contentEngagement: this.contentEngagement,
      encouragementSent: this.encouragementSent,
      encouragementReceived: this.encouragementReceived,
      cumulativeStreakBonus: this.cumulativeStreakBonus,
      shareBonus: this.shareBonus,
      referralBonus: this.referralBonus,
      peerChallengeBonus: this.peerChallengeBonus || 0, // Add to dictionary
      totalStackPoints: this.totalStackPoints,
      totalCommunityPoints: this.totalCommunityPoints,
      totalPoints: this.totalPoints,
    };
  }
}

export class Encouragement {
  fromUser: ShortUser;
  toUser: ShortUser;
  createdAt: Date;
 
  constructor(data: any) {
    // If data is passed as already constructed ShortUser objects
    if (data.fromUser instanceof ShortUser && data.toUser instanceof ShortUser) {
      this.fromUser = data.fromUser;
      this.toUser = data.toUser;
      this.createdAt = data.createdAt instanceof Date ? data.createdAt : new Date();
    } 
    // If data is coming from Firestore/dictionary
    else {
      const fromUserData = data.fromUser || {};
      this.fromUser = new ShortUser(fromUserData);
      
      const toUserData = data.toUser || {};
      this.toUser = new ShortUser(toUserData);
      
      this.createdAt = convertFirestoreTimestamp(data.createdAt);
    }
  }
 
  // Static method to create from separate parameters
  static create(fromUser: ShortUser, toUser: ShortUser, createdAt: Date): Encouragement {
    return new Encouragement({
      fromUser,
      toUser, 
      createdAt
    });
  }
 
  // Convert to dictionary for Firestore
  toDictionary(): { [key: string]: any } {
    return {
      fromUser: this.fromUser.toDictionary(),
      toUser: this.toUser.toDictionary(),
      createdAt: dateToUnixTimestamp(this.createdAt)
    };
  }
 }

// Types for user in challenge
class UserChallenge {
  id: string;
  challenge?: Challenge;
  challengeId: string;
  userId: string;
  fcmToken: string;          // Added
  username: string;
  profileImage?: ProfileImage;
  progress: number;
  referralChain: ReferralChain;  // Changed from referralChains to match iOS
  completedWorkouts: { id: string; workoutId: string; completedAt: Date }[];
  isCompleted: boolean;
  uid: string;               // Added
  location?: UserLocation;
  city: string;
  country?: string;
  timezone?: string;
  joinDate: Date;
  isCurrentlyActive: boolean;  // Added
  createdAt: Date;
  updatedAt: Date;
  lastActive?: Date | null;   // New property for tracking last activity
  pulsePoints: PulsePoints;
  currentStreak: number;
  longestStreak: number;      // Added
  encouragedUsers: Encouragement[];  // Changed from string[] to Encouragement[]
  encouragedByUsers: Encouragement[];  // Changed from string[] to Encouragement[]
  checkIns: CheckIn[];
  hasReceivedShareBonus: boolean;
  ignoreNotifications: string[];
  lastActiveRoundWorkoutId: string; // New property for last active round workout ID

  constructor(data: any) {
    this.id = data.id;
    // Pre-convert dates before passing to Challenge constructor to avoid double conversion
    this.challenge = data.challenge ? new Challenge({
      ...data.challenge,
      startDate: convertFirestoreTimestamp(data.challenge.startDate),
      endDate: convertFirestoreTimestamp(data.challenge.endDate),
      createdAt: convertFirestoreTimestamp(data.challenge.createdAt),
      updatedAt: convertFirestoreTimestamp(data.challenge.updatedAt)
    }) : undefined;
    this.challengeId = data.challengeId || '';
    this.userId = data.userId || '';
    this.fcmToken = data.fcmToken || '';  // Added
    this.username = data.username || '';
    this.profileImage = data.profileImage ? new ProfileImage(data.profileImage) : undefined;
    this.progress = data.progress ?? 0;
    this.referralChain = data.referralChain ? new ReferralChain(data.referralChain) : new ReferralChain({ originalHostId: '', sharedBy: '' });
    this.completedWorkouts = Array.isArray(data.completedWorkouts)
      ? data.completedWorkouts
          .map((cw: any) => ({
            id: cw.id || '',
            workoutId: cw.workoutId || '', // Ensure workoutId is a string, default to empty
            completedAt: convertFirestoreTimestamp(cw.completedAt), // Handle potential null/undefined timestamp
          }))
          .filter((cw: { id: string; workoutId: string; completedAt: Date }) => cw.workoutId !== '') // Filter out those where workoutId ended up empty
      : [];
    this.isCompleted = data.isCompleted ?? false;
    this.uid = data.uid || '';  // Added
    this.location = data.location ? new UserLocation(data.location) : undefined;
    this.city = data.city || '';
    this.country = data.country || '';
    this.timezone = data.timezone || '';
    this.joinDate = convertFirestoreTimestamp(data.joinDate);
    this.isCurrentlyActive = data.isCurrentlyActive ?? false;  // Added
    this.createdAt = convertFirestoreTimestamp(data.createdAt);
    this.updatedAt = convertFirestoreTimestamp(data.updatedAt);
    this.lastActive = data.lastActive ? convertFirestoreTimestamp(data.lastActive) : null;  // Initialize the new property
    this.pulsePoints = data.pulsePoints ? new PulsePoints(data.pulsePoints) : new PulsePoints({});
    this.currentStreak = data.currentStreak ?? 0;
    this.longestStreak = this.calculateLongestStreak();  // Added
    this.encouragedUsers = Array.isArray(data.encouragedUsers)
      ? data.encouragedUsers.map((d: any) => new Encouragement(d))
      : [];
    this.encouragedByUsers = Array.isArray(data.encouragedByUsers)
      ? data.encouragedByUsers.map((d: any) => new Encouragement(d))
      : [];
    this.checkIns = Array.isArray(data.checkIns)
      ? data.checkIns.map((d: any) => new CheckIn(d))
      : [];
    this.hasReceivedShareBonus = data.hasReceivedShareBonus ?? false;
    this.ignoreNotifications = Array.isArray(data.ignoreNotifications) ? data.ignoreNotifications : [];
    this.lastActiveRoundWorkoutId = data.lastActiveRoundWorkoutId || ''; // Initialize new property
  }

  // Add calculateLongestStreak method
  private calculateLongestStreak(): number {
    if (!this.completedWorkouts.length) return 0;

    let currentStreak = 1;
    let maxStreak = 1;
    const sortedWorkouts = [...this.completedWorkouts].sort(
      (a, b) => a.completedAt.getTime() - b.completedAt.getTime()
    );

    for (let i = 1; i < sortedWorkouts.length; i++) {
      const prevDate = new Date(sortedWorkouts[i - 1].completedAt);
      const currDate = new Date(sortedWorkouts[i].completedAt);
      
      if (this.isNextDay(prevDate, currDate)) {
        currentStreak++;
        maxStreak = Math.max(maxStreak, currentStreak);
      } else if (!this.isSameDay(prevDate, currDate)) {
        currentStreak = 1;
      }
    }

    return maxStreak;
  }

  private isNextDay(date1: Date, date2: Date): boolean {
    const nextDay = new Date(date1);
    nextDay.setDate(nextDay.getDate() + 1);
    return this.isSameDay(nextDay, date2);
  }

  private isSameDay(date1: Date, date2: Date): boolean {
    return (
      date1.getFullYear() === date2.getFullYear() &&
      date1.getMonth() === date2.getMonth() &&
      date1.getDate() === date2.getDate()
    );
  }

  toDictionary(): any {
    return {
      challenge: this.challenge ? this.challenge.toDictionary() : null,
      challengeId: this.challengeId,
      userId: this.userId,
      fcmToken: this.fcmToken,  // Added
      username: this.username,
      profileImage: this.profileImage ? this.profileImage.toDictionary() : null,
      progress: this.progress,
      referralChain: this.referralChain.toDictionary(),  // Changed from referralChains
      completedWorkouts: this.completedWorkouts.map(workout => ({
        ...workout,
        completedAt: dateToUnixTimestamp(workout.completedAt)
      })),
      isCompleted: this.isCompleted,
      uid: this.uid,  // Added
      location: this.location ? this.location.toDictionary() : null,
      city: this.city,
      country: this.country,
      timezone: this.timezone,
      joinDate: dateToUnixTimestamp(this.joinDate),
      isCurrentlyActive: this.isCurrentlyActive,  // Added
      createdAt: dateToUnixTimestamp(this.createdAt),
      updatedAt: dateToUnixTimestamp(this.updatedAt),
      lastActive: this.lastActive ? dateToUnixTimestamp(this.lastActive) : null,  // Include lastActive in serialization
      pulsePoints: this.pulsePoints.toDictionary(),
      currentStreak: this.currentStreak,
      longestStreak: this.longestStreak,  // Added
      encouragedUsers: this.encouragedUsers.map(user => user.toDictionary()),
      encouragedByUsers: this.encouragedByUsers.map(user => user.toDictionary()),
      checkIns: this.checkIns.map(checkIn => checkIn.toDictionary()),
      hasReceivedShareBonus: this.hasReceivedShareBonus,
      ignoreNotifications: this.ignoreNotifications,
      lastActiveRoundWorkoutId: this.lastActiveRoundWorkoutId // Add new property to dictionary
    };
  }
}

// Challenge status enum
enum ChallengeStatus {
  Draft = 'draft',
  Published = 'published',
  Active = 'active',
  Completed = 'completed',
  Cancelled = 'cancelled'
}

// Challenge type enum to match iOS version
export enum ChallengeType {
  Lift = 'lift',            // Weight training, strength workouts
  Run = 'run',              // Running, cardio
  Burn = 'burn',            // Fat burn, HIIT
  Stretch = 'stretch',      // Flexibility, yoga, recovery
  Hybrid = 'hybrid'         // Mixed cardio + strength
}

// Parse ChallengeType from raw string with backward compatibility
export function parseChallengeType(rawValue: string | undefined | null): ChallengeType {
  if (!rawValue) return ChallengeType.Lift;
  
  switch (rawValue) {
    // New values
    case 'lift':
      return ChallengeType.Lift;
    case 'run':
      return ChallengeType.Run;
    case 'burn':
      return ChallengeType.Burn;
    case 'stretch':
      return ChallengeType.Stretch;
    case 'hybrid':
      return ChallengeType.Hybrid;
    // Legacy values - map to appropriate new types
    case 'workout':
    case 'steps':
    case 'calories':
      return ChallengeType.Lift;
    default:
      return ChallengeType.Lift;
  }
}

// Round type enum for UI selection (determines creation flow)
export enum RoundType {
  Lift = 'lift',
  Run = 'run',
  Stretch = 'stretch',
  FatBurn = 'fatBurn'
}

export const RoundTypeInfo: Record<RoundType, {
  displayName: string;
  description: string;
  icon: string;
  color: string;
  isAvailable: boolean;
}> = {
  [RoundType.Lift]: {
    displayName: 'Lift',
    description: 'Build strength with weight training rounds',
    icon: 'dumbbell',
    color: '#22C55E', // Green
    isAvailable: true
  },
  [RoundType.Run]: {
    displayName: 'Run',
    description: 'Create run challenges for your club',
    icon: 'running',
    color: '#3B82F6', // Blue
    isAvailable: true
  },
  [RoundType.Stretch]: {
    displayName: 'Stretch',
    description: 'Mobility and flexibility focused rounds',
    icon: 'yoga',
    color: '#A855F7', // Purple
    isAvailable: true
  },
  [RoundType.FatBurn]: {
    displayName: 'Fat Burn',
    description: 'High intensity cardio rounds',
    icon: 'flame',
    color: '#F97316', // Orange
    isAvailable: false // Coming soon
  }
};

// ============================================
// RUN ROUND TYPES AND CONFIGURATION
// ============================================

// Defines the type of Run Round challenge
export enum RunRoundType {
  DistanceChallenge = 'distanceChallenge',
  VirtualRace = 'virtualRace',
  StreakChallenge = 'streakChallenge',
  IntervalProgram = 'intervalProgram',
  PaceImprovement = 'paceImprovement',
  TrainingProgram = 'trainingProgram',
  Freeform = 'freeform'
}

export const RunRoundTypeInfo: Record<RunRoundType, {
  displayName: string;
  description: string;
  icon: string;
  colors: string[];
  isAvailable: boolean;
}> = {
  [RunRoundType.DistanceChallenge]: {
    displayName: 'Distance Challenge',
    description: 'Compete for most miles',
    icon: 'map',
    colors: ['#22C55E', '#16A34A'],
    isAvailable: true
  },
  [RunRoundType.VirtualRace]: {
    displayName: 'Virtual Race',
    description: 'Race the same distance, compare times',
    icon: 'flag',
    colors: ['#3B82F6', '#2563EB'],
    isAvailable: true
  },
  [RunRoundType.StreakChallenge]: {
    displayName: 'Streak Challenge',
    description: 'Run every day, build your streak',
    icon: 'flame',
    colors: ['#F97316', '#EA580C'],
    isAvailable: true
  },
  [RunRoundType.IntervalProgram]: {
    displayName: 'Interval Program',
    description: 'Follow structured interval workouts',
    icon: 'repeat',
    colors: ['#A855F7', '#9333EA'],
    isAvailable: false
  },
  [RunRoundType.PaceImprovement]: {
    displayName: 'Pace Improvement',
    description: 'Improve your pace over time',
    icon: 'gauge',
    colors: ['#06B6D4', '#0891B2'],
    isAvailable: false
  },
  [RunRoundType.TrainingProgram]: {
    displayName: 'Training Program',
    description: 'Complete a guided training plan',
    icon: 'calendar',
    colors: ['#EAB308', '#CA8A04'],
    isAvailable: false
  },
  [RunRoundType.Freeform]: {
    displayName: 'Freeform',
    description: 'Any run counts, compete on points',
    icon: 'running',
    colors: ['#6B7280', '#4B5563'],
    isAvailable: false
  }
};

// Defines how participants are ranked in a Run Round
export enum RunLeaderboardMetric {
  TotalDistance = 'totalDistance',
  TotalTime = 'totalTime',
  FastestTime = 'fastestTime',
  AveragePace = 'averagePace',
  PaceImprovement = 'paceImprovement',
  StreakDays = 'streakDays',
  RunsCompleted = 'runsCompleted',
  PulsePoints = 'pulsePoints'
}

export const RunLeaderboardMetricInfo: Record<RunLeaderboardMetric, {
  displayName: string;
  description: string;
  icon: string;
  unitLabel: string;
  lowerIsBetter: boolean;
}> = {
  [RunLeaderboardMetric.TotalDistance]: {
    displayName: 'Total Distance',
    description: 'Most miles wins',
    icon: 'ruler',
    unitLabel: 'mi',
    lowerIsBetter: false
  },
  [RunLeaderboardMetric.TotalTime]: {
    displayName: 'Total Time',
    description: 'Most time running wins',
    icon: 'clock',
    unitLabel: 'min',
    lowerIsBetter: false
  },
  [RunLeaderboardMetric.FastestTime]: {
    displayName: 'Fastest Time',
    description: 'Fastest completion wins',
    icon: 'timer',
    unitLabel: '',
    lowerIsBetter: true
  },
  [RunLeaderboardMetric.AveragePace]: {
    displayName: 'Average Pace',
    description: 'Best average pace wins',
    icon: 'speedometer',
    unitLabel: '/mi',
    lowerIsBetter: true
  },
  [RunLeaderboardMetric.PaceImprovement]: {
    displayName: 'Pace Improvement',
    description: 'Greatest improvement wins',
    icon: 'trending-up',
    unitLabel: '%',
    lowerIsBetter: false
  },
  [RunLeaderboardMetric.StreakDays]: {
    displayName: 'Streak Days',
    description: 'Longest streak wins',
    icon: 'flame',
    unitLabel: 'days',
    lowerIsBetter: false
  },
  [RunLeaderboardMetric.RunsCompleted]: {
    displayName: 'Runs Completed',
    description: 'Most runs completed wins',
    icon: 'check-circle',
    unitLabel: 'runs',
    lowerIsBetter: false
  },
  [RunLeaderboardMetric.PulsePoints]: {
    displayName: 'Pulse Points',
    description: 'Most points wins',
    icon: 'star',
    unitLabel: 'pts',
    lowerIsBetter: false
  }
};

// Get default leaderboard metric for a run round type
export function getDefaultLeaderboardMetric(roundType: RunRoundType): RunLeaderboardMetric {
  switch (roundType) {
    case RunRoundType.DistanceChallenge:
      return RunLeaderboardMetric.TotalDistance;
    case RunRoundType.VirtualRace:
      return RunLeaderboardMetric.FastestTime;
    case RunRoundType.StreakChallenge:
      return RunLeaderboardMetric.StreakDays;
    case RunRoundType.IntervalProgram:
      return RunLeaderboardMetric.RunsCompleted;
    case RunRoundType.PaceImprovement:
      return RunLeaderboardMetric.PaceImprovement;
    case RunRoundType.TrainingProgram:
      return RunLeaderboardMetric.RunsCompleted;
    case RunRoundType.Freeform:
      return RunLeaderboardMetric.PulsePoints;
    default:
      return RunLeaderboardMetric.PulsePoints;
  }
}

// Preset distances for Virtual Race rounds
export enum RaceDistancePreset {
  OneMile = 'oneMile',
  FiveK = 'fiveK',
  TenK = 'tenK',
  HalfMarathon = 'halfMarathon',
  Marathon = 'marathon',
  Custom = 'custom'
}

export const RaceDistancePresetInfo: Record<RaceDistancePreset, {
  displayName: string;
  distanceInMiles: number | null;
}> = {
  [RaceDistancePreset.OneMile]: { displayName: '1 Mile', distanceInMiles: 1.0 },
  [RaceDistancePreset.FiveK]: { displayName: '5K', distanceInMiles: 3.1 },
  [RaceDistancePreset.TenK]: { displayName: '10K', distanceInMiles: 6.2 },
  [RaceDistancePreset.HalfMarathon]: { displayName: 'Half Marathon', distanceInMiles: 13.1 },
  [RaceDistancePreset.Marathon]: { displayName: 'Marathon', distanceInMiles: 26.2 },
  [RaceDistancePreset.Custom]: { displayName: 'Custom', distanceInMiles: null }
};

// Complete configuration for a Run Round
export class RunRoundConfiguration {
  roundType: RunRoundType;
  leaderboardMetric: RunLeaderboardMetric;
  minimumRunDistance?: number;      // Min miles to count (e.g., 0.5)
  minimumRunDuration?: number;      // Min seconds to count (e.g., 600 = 10 min)
  targetGoal?: number;              // Group or individual target (miles)
  allowTreadmill: boolean;          // Include treadmill runs?
  
  // Virtual Race specific
  raceDistancePreset?: RaceDistancePreset;
  customRaceDistance?: number;      // If preset is custom (miles)
  
  // Streak Challenge specific
  minimumRunForStreak?: number;     // Min distance to count for streak

  constructor(data: any = {}) {
    this.roundType = data.roundType || RunRoundType.Freeform;
    this.leaderboardMetric = data.leaderboardMetric || getDefaultLeaderboardMetric(this.roundType);
    this.minimumRunDistance = data.minimumRunDistance;
    this.minimumRunDuration = data.minimumRunDuration;
    this.targetGoal = data.targetGoal;
    this.allowTreadmill = data.allowTreadmill ?? true;
    this.raceDistancePreset = data.raceDistancePreset;
    this.customRaceDistance = data.customRaceDistance;
    this.minimumRunForStreak = data.minimumRunForStreak;
  }

  // Actual race distance in miles (for Virtual Race)
  get raceDistanceMiles(): number | null {
    if (this.raceDistancePreset) {
      return RaceDistancePresetInfo[this.raceDistancePreset].distanceInMiles ?? this.customRaceDistance ?? null;
    }
    return null;
  }

  toDictionary(): { [key: string]: any } {
    const dict: { [key: string]: any } = {
      roundType: this.roundType,
      leaderboardMetric: this.leaderboardMetric,
      allowTreadmill: this.allowTreadmill
    };

    if (this.minimumRunDistance !== undefined) dict.minimumRunDistance = this.minimumRunDistance;
    if (this.minimumRunDuration !== undefined) dict.minimumRunDuration = this.minimumRunDuration;
    if (this.targetGoal !== undefined) dict.targetGoal = this.targetGoal;
    if (this.raceDistancePreset) dict.raceDistancePreset = this.raceDistancePreset;
    if (this.customRaceDistance !== undefined) dict.customRaceDistance = this.customRaceDistance;
    if (this.minimumRunForStreak !== undefined) dict.minimumRunForStreak = this.minimumRunForStreak;

    return dict;
  }

  // Static factory methods for common configurations
  static distanceChallenge(options: { targetGoal?: number; allowTreadmill?: boolean } = {}): RunRoundConfiguration {
    return new RunRoundConfiguration({
      roundType: RunRoundType.DistanceChallenge,
      leaderboardMetric: RunLeaderboardMetric.TotalDistance,
      minimumRunDistance: 0.5,
      targetGoal: options.targetGoal,
      allowTreadmill: options.allowTreadmill ?? true
    });
  }

  static streakChallenge(options: { minimumRunForStreak?: number; allowTreadmill?: boolean } = {}): RunRoundConfiguration {
    const minDistance = options.minimumRunForStreak ?? 1.0;
    return new RunRoundConfiguration({
      roundType: RunRoundType.StreakChallenge,
      leaderboardMetric: RunLeaderboardMetric.StreakDays,
      minimumRunDistance: minDistance,
      minimumRunForStreak: minDistance,
      allowTreadmill: options.allowTreadmill ?? true
    });
  }

  static virtualRace(options: { 
    raceDistancePreset: RaceDistancePreset; 
    customRaceDistance?: number;
    allowTreadmill?: boolean 
  }): RunRoundConfiguration {
    return new RunRoundConfiguration({
      roundType: RunRoundType.VirtualRace,
      leaderboardMetric: RunLeaderboardMetric.FastestTime,
      raceDistancePreset: options.raceDistancePreset,
      customRaceDistance: options.customRaceDistance,
      allowTreadmill: options.allowTreadmill ?? false // GPS required for accuracy
    });
  }

  static freeform(options: { allowTreadmill?: boolean } = {}): RunRoundConfiguration {
    return new RunRoundConfiguration({
      roundType: RunRoundType.Freeform,
      leaderboardMetric: RunLeaderboardMetric.PulsePoints,
      allowTreadmill: options.allowTreadmill ?? true
    });
  }
}

// Run Round Scoring Constants
export const RunRoundScoringConstants = {
  // Base completion points
  baseCompletion: 100,
  firstCompletionBonus: 50,
  firstRunOfDayBonus: 25,
  
  // Performance points
  distanceBonusPerMile: 10,
  goalAchievedBonus: 75,
  streakBonusPerDay: 25,
  pacePersonalRecordBonus: 50,
  
  // Engagement points
  checkInBonus: 25,
  shareBonus: 25,
  effortRatingBonus: 10,
  invitationBonus: 25
};
export interface IntroVideo {
  id: string;
  userId: string;
  videoUrl: string;
  toDictionary(): any;
}

export class IntroVideo implements IntroVideo {
  id: string;
  userId: string;
  videoUrl: string;

  constructor(data: { id: string; userId: string; videoUrl: string; }) {
    this.id = data.id;
    this.userId = data.userId;
    this.videoUrl = data.videoUrl;
  }

  toDictionary(): any {
    return {
      id: this.id,
      userId: this.userId,
      videoUrl: this.videoUrl
    };
  }
}

class Challenge {
  id: string;
  title: string;
  subtitle: string;
  participants: UserChallenge[];
  status: ChallengeStatus;
  introVideos: IntroVideo[];
  privacy: SweatlistType;
  pin?: string;
  startDate: Date;
  ownerId: string[];
  endDate: Date;
  createdAt: Date;
  updatedAt: Date;
  
  // Cohort-related properties
  originalId: string;
  joinWindowEnds: Date;
  minParticipants: number;
  maxParticipants: number;
  allowLateJoins: boolean;
  cohortAuthor: string[];
  pricingInfo: PricingInfo;
  
  // Prize Money Configuration
  prizeMoney: PrizeMoney;
  
  // Challenge Type and Step-specific properties
  challengeType: ChallengeType;
  dailyStepGoal: number;
  totalStepGoal: number;
  allowedMissedDays: number;
  
  // Meal Tracking properties
  mealTracking?: ChallengeMealTracking;
  
  // Computed property
  durationInDays: number;
  isChallengeEnded: boolean;
  
  // Trending property
  trending?: boolean;

  constructor(data: {
    id: string;
    title: string;
    subtitle: string;
    participants?: UserChallenge[];
    status?: ChallengeStatus;
    introVideos?: IntroVideo[];
    privacy?: SweatlistType;
    pin?: string;
    startDate: Date;
    ownerId: string[];
    endDate: Date;
    createdAt: Date;
    updatedAt: Date;
    originalId?: string;
    joinWindowEnds?: Date;
    minParticipants?: number;
    maxParticipants?: number;
    allowLateJoins?: boolean;
    cohortAuthor?: string[];
    pricingInfo?: PricingInfo;
    prizeMoney?: PrizeMoneyData; // Add prize money to constructor interface
    challengeType?: ChallengeType;
    dailyStepGoal?: number;
    totalStepGoal?: number;
    allowedMissedDays?: number;
    mealTracking?: any; // Use any for now to handle raw Firestore data
    trending?: boolean;
  }) {
    this.id = data.id;
    this.title = data.title;
    this.subtitle = data.subtitle;
    this.participants = Array.isArray(data.participants) ? data.participants : [];    
    this.status = data.status || ChallengeStatus.Draft;
    this.introVideos = Array.isArray(data.introVideos) 
      ? data.introVideos.map(videoData => new IntroVideo(videoData)) 
      : [];
    this.privacy = data.privacy || SweatlistType.Together;
    this.pin = data.pin;
    // Handle dates - they might already be converted or need conversion
    console.log(' [Challenge Constructor] Processing dates for challenge:', data.title, {
      startDate: data.startDate,
      startDateType: typeof data.startDate,
      endDate: data.endDate,
      endDateType: typeof data.endDate,
      startDateIsDate: data.startDate instanceof Date,
      endDateIsDate: data.endDate instanceof Date
    });
    
    this.startDate = data.startDate instanceof Date ? data.startDate : convertFirestoreTimestamp(data.startDate);
    this.ownerId = data.ownerId;
    this.endDate = data.endDate instanceof Date ? data.endDate : convertFirestoreTimestamp(data.endDate);
    this.createdAt = data.createdAt instanceof Date ? data.createdAt : convertFirestoreTimestamp(data.createdAt);
    this.updatedAt = data.updatedAt instanceof Date ? data.updatedAt : convertFirestoreTimestamp(data.updatedAt);
    
    console.log(' [Challenge Constructor] After conversion:', {
      startDate: this.startDate,
      endDate: this.endDate,
      startDateValid: this.startDate instanceof Date && !isNaN(this.startDate.getTime()),
      endDateValid: this.endDate instanceof Date && !isNaN(this.endDate.getTime())
    });
    
    this.originalId = data.originalId || data.id;
    this.joinWindowEnds = data.joinWindowEnds || new Date(this.startDate.getTime() + (48 * 3600 * 1000));
    this.minParticipants = data.minParticipants || 1;
    this.maxParticipants = data.maxParticipants || 100;
    this.allowLateJoins = data.allowLateJoins !== undefined ? data.allowLateJoins : true;
    this.cohortAuthor = data.cohortAuthor || [];
    this.pricingInfo = new PricingInfo(data.pricingInfo);
    
    // Initialize new challenge type and step-related properties
    // Handle backward compatibility: old values (workout, steps, calories) map to new values
    this.challengeType = parseChallengeType(data.challengeType);
    this.dailyStepGoal = data.dailyStepGoal || 10000; // Default daily step goal
    this.totalStepGoal = data.totalStepGoal || 0; // Default total step goal
    this.allowedMissedDays = data.allowedMissedDays || 0; // Default allowed missed days
    this.trending = data.trending || false; // Default trending to false

    // Initialize meal tracking properties
    if (data.mealTracking) {
      console.log('Challenge constructor - Processing meal tracking data:', data.mealTracking);
      // Build meal tracking object, only including defined fields to avoid Firestore undefined errors
      const mealTracking: ChallengeMealTracking = {
        isEnabled: data.mealTracking.isEnabled || false,
        configurationType: data.mealTracking.configurationType === 'mealPlan' 
          ? MealTrackingConfigType.MealPlan 
          : MealTrackingConfigType.CustomMacros,
        pointsPerDay: data.mealTracking.pointsPerDay || 100,
        tolerancePercentage: data.mealTracking.tolerancePercentage || 0.10
      };
      
      // Only add optional fields if they have values
      if (data.mealTracking.linkedMealPlanId) {
        mealTracking.linkedMealPlanId = data.mealTracking.linkedMealPlanId;
      }
      if (data.mealTracking.mealPlanName) {
        mealTracking.mealPlanName = data.mealTracking.mealPlanName;
      }
      if (data.mealTracking.customMacroRanges) {
        mealTracking.customMacroRanges = data.mealTracking.customMacroRanges;
      }
      
      this.mealTracking = mealTracking;
    } else {
      // Set default meal tracking when none provided
      this.mealTracking = {
        isEnabled: false,
        configurationType: MealTrackingConfigType.CustomMacros,
        pointsPerDay: 100,
        tolerancePercentage: 0.10
      };
    }

    // Initialize prize money
    if (data.prizeMoney) {
      this.prizeMoney = new PrizeMoney(data.prizeMoney);
    } else {
      this.prizeMoney = new PrizeMoney(); // Default empty prize money
    }

    // Calculate duration and end status after initializing dates
    this.durationInDays = this.calculateDurationInDays();
    this.isChallengeEnded = new Date() > this.endDate;
    
    if (this.isChallengeEnded) {
      this.status = ChallengeStatus.Completed;
    }
  }

  toDictionary(): any {
    return {
      id: this.id,
      title: this.title,
      subtitle: this.subtitle,
      participants: this.participants.map(participant => ({
        id: participant.id,
        challengeId: participant.challengeId,
        userId: participant.userId,
        username: participant.username,
        profileImage: participant.profileImage,
        progress: participant.progress,
        completedWorkouts: participant.completedWorkouts,
        isCompleted: participant.isCompleted,
        location: participant.location,
        city: participant.city,
        country: participant.country,
        timezone: participant.timezone,
        joinDate: participant.joinDate,
        createdAt: participant.createdAt,
        updatedAt: participant.updatedAt,
        pulsePoints: participant.pulsePoints,
        currentStreak: participant.currentStreak,
        encouragedUsers: participant.encouragedUsers,
        encouragedByUsers: participant.encouragedByUsers,
        checkIns: participant.checkIns
      })),
      status: this.status,
      pin: this.pin ?? null,
      startDate: dateToUnixTimestamp(this.startDate),
      endDate: dateToUnixTimestamp(this.endDate),
      createdAt: dateToUnixTimestamp(this.createdAt),
      updatedAt: dateToUnixTimestamp(this.updatedAt),
      durationInDays: this.durationInDays,
      introVideos: this.introVideos.map(video => video.toDictionary()),
      pricingInfo: this.pricingInfo.toDictionary(),
      cohortAuthor: this.cohortAuthor,
      isChallengeEnded: this.isChallengeEnded,
      // Add new challenge type and step-related properties
      challengeType: this.challengeType,
      dailyStepGoal: this.dailyStepGoal,
      totalStepGoal: this.totalStepGoal,
      allowedMissedDays: this.allowedMissedDays,
      trending: this.trending,
      // Add meal tracking data (only include defined fields to avoid Firestore undefined errors)
      mealTracking: this.mealTracking ? (() => {
        const mealTrackingDict: any = {
          isEnabled: this.mealTracking.isEnabled,
          configurationType: this.mealTracking.configurationType,
          pointsPerDay: this.mealTracking.pointsPerDay,
          tolerancePercentage: this.mealTracking.tolerancePercentage
        };
        
        // Only include optional fields if they have values
        if (this.mealTracking.linkedMealPlanId) {
          mealTrackingDict.linkedMealPlanId = this.mealTracking.linkedMealPlanId;
        }
        if (this.mealTracking.mealPlanName) {
          mealTrackingDict.mealPlanName = this.mealTracking.mealPlanName;
        }
        if (this.mealTracking.customMacroRanges) {
          mealTrackingDict.customMacroRanges = this.mealTracking.customMacroRanges;
        }
        
        return mealTrackingDict;
      })() : undefined,
      prizeMoney: this.prizeMoney.toDictionary(),
    };
  }

  /**
   * Calculates the duration in days between the startDate and endDate.
   * @returns The number of days between the two dates.
   */
  private calculateDurationInDays(): number {
    console.log(' [calculateDurationInDays] Calculating duration for:', {
      startDate: this.startDate,
      endDate: this.endDate,
      startDateType: typeof this.startDate,
      endDateType: typeof this.endDate
    });
    
    const start = this.startDate?.valueOf();
    const end = this.endDate?.valueOf();

    console.log(' [calculateDurationInDays] Date values:', {
      start,
      end,
      startIsNaN: isNaN(start || 0),
      endIsNaN: isNaN(end || 0)
    });

    if (!start || !end || isNaN(start) || isNaN(end)) {
      console.error(' [calculateDurationInDays] Invalid dates detected, returning default duration of 30 days');
      return 30; // Return default duration instead of throwing
    }

    const durationInMilliseconds = end - start;
    const duration = Math.ceil(durationInMilliseconds / (1000 * 60 * 60 * 24));
    
    console.log(' [calculateDurationInDays] Calculated duration:', duration, 'days');
    return duration;
  }

  static toFirestoreObject(obj: any): any {
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }

    if (obj instanceof Date) {
      return obj;
    }

    if (Array.isArray(obj)) {
      return obj.map(item => this.toFirestoreObject(item));
    }

    if (obj instanceof Challenge) {
      return {
        id: obj.id,
        title: obj.title,
        subtitle: obj.subtitle,
        participants: obj.participants,
        status: obj.status,
        startDate: obj.startDate,
        endDate: obj.endDate,
        createdAt: obj.createdAt,
        updatedAt: obj.updatedAt,
        introVideos: obj.introVideos.map(video => ({
          id: video.id,
          userId: video.userId,
          videoUrl: video.videoUrl
        })),
        pricingInfo: obj.pricingInfo.toDictionary(),
        cohortAuthor: obj.cohortAuthor,
        durationInDays: obj.durationInDays,
        isChallengeEnded: obj.isChallengeEnded,
        prizeMoney: obj.prizeMoney.toDictionary(),
      };
    }

    const plainObject: { [key: string]: any } = {};
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        plainObject[key] = this.toFirestoreObject(obj[key]);
      }
    }
    return plainObject;
  }
}


// Props interface for the component
interface ChallengeInvitationProps {
  challenge: Challenge;
  onClose: () => void;
  onJoinChallenge: (challenge: any) => Promise<void>;
  ttclid?: string;
}

export type {
  ProfileImage,
  UserLocation,
  ChallengeInvitationProps
};

export { ChallengeStatus, Challenge, UserChallenge };

// MARK: - Prize Money Configuration

export enum PrizeDistributionType {
  WINNER_TAKES_ALL = "winner_takes_all",
  TOP_THREE_EQUAL = "top_three_equal", 
  TOP_THREE_WEIGHTED = "top_three_weighted",
  CUSTOM = "custom"
}

export interface PrizeMoneyData {
  isEnabled?: boolean;
  totalAmount?: number; // Amount in cents
  currency?: string;
  winnerCount?: number;
  distributionType?: PrizeDistributionType;
  customDistribution?: number[]; // Percentages for custom distribution
}

export class PrizeMoney {
  isEnabled: boolean;
  totalAmount: number; // Amount in cents
  currency: string;
  winnerCount: number;
  distributionType: PrizeDistributionType;
  customDistribution: number[]; // Percentages for custom distribution

  constructor(data: PrizeMoneyData = {}) {
    this.isEnabled = data.isEnabled ?? false;
    this.totalAmount = data.totalAmount ?? 0;
    this.currency = data.currency ?? "USD";
    this.winnerCount = data.winnerCount ?? 1;
    this.distributionType = data.distributionType ?? PrizeDistributionType.WINNER_TAKES_ALL;
    this.customDistribution = data.customDistribution ?? [];
  }

  // Helper property for dollar conversion
  get totalAmountInDollars(): number {
    return this.totalAmount / 100.0;
  }

  toDictionary(): any {
    return {
      isEnabled: this.isEnabled,
      totalAmount: this.totalAmount,
      currency: this.currency,
      winnerCount: this.winnerCount,
      distributionType: this.distributionType,
      customDistribution: this.customDistribution
    };
  }

  static fromDictionary(dict: any): PrizeMoney {
    return new PrizeMoney(dict || {});
  }

  // Calculate prize distribution for winners
  calculatePrizeDistribution(): number[] {
    if (!this.isEnabled || this.totalAmount <= 0) return [];

    switch (this.distributionType) {
      case PrizeDistributionType.WINNER_TAKES_ALL:
        return [this.totalAmount];
      
      case PrizeDistributionType.TOP_THREE_EQUAL:
        const amountPerWinner = Math.floor(this.totalAmount / 3);
        return [amountPerWinner, amountPerWinner, amountPerWinner];
      
      case PrizeDistributionType.TOP_THREE_WEIGHTED:
        const first = Math.floor(this.totalAmount * 0.5);  // 50%
        const second = Math.floor(this.totalAmount * 0.3); // 30%
        const third = this.totalAmount - first - second;   // 20%
        return [first, second, third];
      
      case PrizeDistributionType.CUSTOM:
        if (this.customDistribution.length !== this.winnerCount ||
            this.customDistribution.reduce((sum, pct) => sum + pct, 0) !== 100) {
          // If custom distribution is invalid, fallback to equal distribution
          const equalAmount = Math.floor(this.totalAmount / this.winnerCount);
          return Array(this.winnerCount).fill(equalAmount);
        }
        return this.customDistribution.map(pct => 
          Math.floor(this.totalAmount * pct / 100.0)
        );
      
      default:
        return [this.totalAmount];
    }
  }

  getDistributionTypeDisplayName(): string {
    switch (this.distributionType) {
      case PrizeDistributionType.WINNER_TAKES_ALL:
        return "Winner Takes All";
      case PrizeDistributionType.TOP_THREE_EQUAL:
        return "Top 3 - Equal Split";
      case PrizeDistributionType.TOP_THREE_WEIGHTED:
        return "Top 3 - Weighted (50/30/20)";
      case PrizeDistributionType.CUSTOM:
        return "Custom Distribution";
      default:
        return "Winner Takes All";
    }
  }
}

export class PricingInfo {
  isEnabled: boolean;
  amount: number;
  currency: string;

  constructor(data: any = {}) {
    this.isEnabled = data.isEnabled ?? false;
    this.amount = data.amount ?? 0.0;
    this.currency = data.currency ?? "USD";
  }

  toDictionary(): any {
    return {
      isEnabled: this.isEnabled,
      amount: this.amount,
      currency: this.currency
    };
  }

  static fromDictionary(dict: any): PricingInfo {
    return new PricingInfo(dict || {});
  }
}

// NEW TYPES -------------------------------------------------------------
// These interfaces mirror the Swift structs `ExerciseWeeklyStats` and `WeeklyWorkoutData`
// used on iOS for the round wrapup analytics. They will be consumed by the
// web `RoundWrapup` page to render weekoverweek charts and detailed
// exercise statistics.

/**
 * Aggregate stats for a single exercise (per week)
 */
export interface ExerciseWeeklyStats {
  /** Unique identifier */
  id: string;
  /** Plain name of the exercise */
  exerciseName: string;
  /** Primary muscle group name (human readable  e.g. "Chest") */
  muscleGroup: string;
  /** Total weight lifted for this exercise in the given week */
  totalWeight: number;
  /** Total repetitions performed for this exercise in the given week */
  totalReps: number;
  /** Convenience  totalWeight / totalReps (NaNsafe) */
  averageLoadPerRep: number;
}

/**
 * Consolidated workout statistics for a single calendar week
 * (Sunday  Saturday) within a challenge/round.
 */
export interface WeeklyWorkoutData {
  /**  ISO string representing week start (00:00:00 of Sunday) */
  weekStartDate: Date;
  /**  ISO string representing week end (23:59:59 of Saturday) */
  weekEndDate: Date;
  /** Number of sets performed */
  totalSets: number;
  /** Number of reps performed */
  totalReps: number;
  /** Aggregate volume =  (weight * reps) */
  totalVolume: number;
  /** Aggregate weight (same as totalVolume for now) */
  totalWeight: number;
  /** Counts of how many times each exercise appears */
  exerciseCounts: Record<string, number>;
  /** Volume distribution by muscle group  reps */
  muscleGroupSets: Record<string, number>;
  /** Volume distribution by muscle group  weight */
  muscleGroupWeight: Record<string, number>;
  /** Detailed perexercise stats */
  exerciseStats: ExerciseWeeklyStats[];

  /**
   * Convenience label  example "Jan 17". Left for consumer to compute if needed
   * but included here for parity with iOS.
   */
  weekLabel?: string;
}
// ----------------------------------------------------------------------

// =====================================================================
// CONTENT CATEGORY TYPES (Run, Fat Burn, Stretch)
// Matching iOS implementations for cross-platform consistency
// =====================================================================

// MARK: - Calorie Data Source
export enum CalorieDataSource {
  Algorithm = 'algorithm',
  AppleWatch = 'appleWatch',
  Manual = 'manual'
}

// MARK: - Run Types
export enum RunType {
  FreeRun = 'Free Run',
  Distance = 'Distance Goal',
  Time = 'Time Goal',
  Intervals = 'Intervals'
}

export enum RunLocation {
  Outdoor = 'Outdoor',
  Treadmill = 'Treadmill'
}

export enum TreadmillMode {
  Run = 'Run',
  Walk = 'Walk'
}

export enum DistancePreset {
  OneMile = '1 Mile',
  ThreeMiles = '3 Miles',
  FiveK = '5K',
  TenK = '10K',
  HalfMarathon = 'Half Marathon',
  Custom = 'Custom'
}

export enum TimePreset {
  FifteenMin = '15 min',
  TwentyMin = '20 min',
  ThirtyMin = '30 min',
  FortyFiveMin = '45 min',
  SixtyMin = '60 min',
  Custom = 'Custom'
}

// Distance preset to miles mapping
export const DistancePresetMiles: Record<DistancePreset, number | null> = {
  [DistancePreset.OneMile]: 1.0,
  [DistancePreset.ThreeMiles]: 3.0,
  [DistancePreset.FiveK]: 3.1,
  [DistancePreset.TenK]: 6.2,
  [DistancePreset.HalfMarathon]: 13.1,
  [DistancePreset.Custom]: null
};

// Time preset to seconds mapping
export const TimePresetSeconds: Record<TimePreset, number | null> = {
  [TimePreset.FifteenMin]: 15 * 60,
  [TimePreset.TwentyMin]: 20 * 60,
  [TimePreset.ThirtyMin]: 30 * 60,
  [TimePreset.FortyFiveMin]: 45 * 60,
  [TimePreset.SixtyMin]: 60 * 60,
  [TimePreset.Custom]: null
};

// MARK: - Interval Configuration
export interface IntervalConfiguration {
  runDurationSeconds: number;
  walkDurationSeconds: number;
  numberOfRounds: number;
}

export const IntervalConfigurationPresets = {
  beginner: { runDurationSeconds: 60, walkDurationSeconds: 60, numberOfRounds: 6 },
  intermediate: { runDurationSeconds: 120, walkDurationSeconds: 30, numberOfRounds: 8 },
  advanced: { runDurationSeconds: 180, walkDurationSeconds: 30, numberOfRounds: 10 }
};

// MARK: - Run Configuration
export interface RunConfiguration {
  runType: RunType;
  location: RunLocation;
  treadmillMode?: TreadmillMode;
  distancePreset?: DistancePreset;
  customDistanceMiles?: number;
  timePreset?: TimePreset;
  customDurationSeconds?: number;
  intervalConfig?: IntervalConfiguration;
}

// MARK: - Route Coordinate
export interface RouteCoordinate {
  latitude: number;
  longitude: number;
  timestamp: Date;
  altitude?: number;
}

// MARK: - Run Summary
export class RunSummary {
  id: string;
  userId: string;
  runType: RunType;
  location: RunLocation;
  title: string;
  distance: number; // miles
  duration: number; // seconds
  averagePace: number; // minutes per mile
  caloriesBurned: number;
  calorieSource?: CalorieDataSource;
  routeCoordinates?: RouteCoordinate[];
  treadmillPhotoURL?: string;
  targetDistance?: number;
  targetDuration?: number;
  intervalConfig?: IntervalConfiguration;
  completedIntervals?: number;
  startTime: Date;
  completedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
  pulsePoints: PulsePoints;
  workoutRating?: WorkoutRating;
  aiInsight: string;
  recommendations: string[];
  isCompleted: boolean;
  roundId?: string;
  roundDayIndex?: number;
  roundPulsePoints?: number;

  constructor(data: any) {
    this.id = data.id || '';
    this.userId = data.userId || '';
    this.runType = data.runType || RunType.FreeRun;
    this.location = data.location || RunLocation.Outdoor;
    this.title = data.title || 'Run';
    this.distance = data.distance || 0;
    this.duration = data.duration || 0;
    this.averagePace = data.averagePace || 0;
    this.caloriesBurned = data.caloriesBurned || 0;
    this.calorieSource = data.calorieSource;
    this.routeCoordinates = data.routeCoordinates;
    this.treadmillPhotoURL = data.treadmillPhotoURL;
    this.targetDistance = data.targetDistance;
    this.targetDuration = data.targetDuration;
    this.intervalConfig = data.intervalConfig;
    this.completedIntervals = data.completedIntervals;
    this.startTime = convertFirestoreTimestamp(data.startTime);
    this.completedAt = data.completedAt ? convertFirestoreTimestamp(data.completedAt) : undefined;
    this.createdAt = convertFirestoreTimestamp(data.createdAt);
    this.updatedAt = convertFirestoreTimestamp(data.updatedAt);
    this.pulsePoints = data.pulsePoints ? new PulsePoints(data.pulsePoints) : new PulsePoints({});
    this.workoutRating = data.workoutRating;
    this.aiInsight = data.aiInsight || '';
    this.recommendations = data.recommendations || [];
    this.isCompleted = data.isCompleted || false;
    this.roundId = data.roundId;
    this.roundDayIndex = data.roundDayIndex;
    this.roundPulsePoints = data.roundPulsePoints;
  }

  // Computed properties
  get goalAchieved(): boolean {
    switch (this.runType) {
      case RunType.FreeRun:
        return true;
      case RunType.Distance:
        return this.targetDistance ? this.distance >= this.targetDistance : false;
      case RunType.Time:
        return this.targetDuration ? this.duration >= this.targetDuration : false;
      case RunType.Intervals:
        return this.intervalConfig && this.completedIntervals 
          ? this.completedIntervals >= this.intervalConfig.numberOfRounds 
          : false;
      default:
        return false;
    }
  }

  get formattedPace(): string {
    const minutes = Math.floor(this.averagePace);
    const seconds = Math.round((this.averagePace - minutes) * 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')} /mi`;
  }

  get formattedDuration(): string {
    const hours = Math.floor(this.duration / 3600);
    const minutes = Math.floor((this.duration % 3600) / 60);
    const seconds = this.duration % 60;
    
    if (hours > 0) {
      return seconds > 0 
        ? `${hours}h ${minutes}m ${seconds}s`
        : `${hours}h ${minutes}m`;
    }
    return `${minutes}m ${seconds.toString().padStart(2, '0')}s`;
  }

  get formattedDistance(): string {
    return `${this.distance.toFixed(1)} mi`;
  }

  toDictionary(): Record<string, any> {
    const dict: Record<string, any> = {
      id: this.id,
      userId: this.userId,
      runType: this.runType,
      location: this.location,
      title: this.title,
      distance: this.distance,
      duration: this.duration,
      averagePace: this.averagePace,
      caloriesBurned: this.caloriesBurned,
      startTime: dateToUnixTimestamp(this.startTime),
      createdAt: dateToUnixTimestamp(this.createdAt),
      updatedAt: dateToUnixTimestamp(this.updatedAt),
      aiInsight: this.aiInsight,
      recommendations: this.recommendations,
      isCompleted: this.isCompleted,
      pulsePoints: this.pulsePoints.toDictionary()
    };

    if (this.calorieSource) dict.calorieSource = this.calorieSource;
    if (this.routeCoordinates) dict.routeCoordinates = this.routeCoordinates;
    if (this.treadmillPhotoURL) dict.treadmillPhotoURL = this.treadmillPhotoURL;
    if (this.targetDistance) dict.targetDistance = this.targetDistance;
    if (this.targetDuration) dict.targetDuration = this.targetDuration;
    if (this.intervalConfig) dict.intervalConfig = this.intervalConfig;
    if (this.completedIntervals) dict.completedIntervals = this.completedIntervals;
    if (this.completedAt) dict.completedAt = dateToUnixTimestamp(this.completedAt);
    if (this.workoutRating) dict.workoutRating = this.workoutRating;
    if (this.roundId) dict.roundId = this.roundId;
    if (this.roundDayIndex) dict.roundDayIndex = this.roundDayIndex;
    if (this.roundPulsePoints) dict.roundPulsePoints = this.roundPulsePoints;

    return dict;
  }
}

// MARK: - Fat Burn Types
export enum FatBurnEquipment {
  Stairmaster = 'Stairmaster',
  Elliptical = 'Elliptical',
  Treadmill = 'Treadmill',
  StationaryBike = 'Stationary Bike'
}

export enum FatBurnGoalType {
  FreeSession = 'Free Session',
  TimeGoal = 'Time Goal',
  DistanceGoal = 'Distance Goal',
  FloorsGoal = 'Floors Goal'
}

export enum FatBurnTimePreset {
  TenMin = '10 min',
  FifteenMin = '15 min',
  TwentyMin = '20 min',
  ThirtyMin = '30 min',
  FortyFiveMin = '45 min',
  SixtyMin = '60 min',
  Custom = 'Custom'
}

export enum FatBurnDistancePreset {
  OneMile = '1 Mile',
  TwoMiles = '2 Miles',
  ThreeMiles = '3 Miles',
  FiveMiles = '5 Miles',
  Custom = 'Custom'
}

export enum FatBurnFloorsPreset {
  TenFloors = '10 Floors',
  TwentyFloors = '20 Floors',
  ThirtyFloors = '30 Floors',
  FiftyFloors = '50 Floors',
  HundredFloors = '100 Floors',
  Custom = 'Custom'
}

// Fat Burn Time Preset to seconds mapping
export const FatBurnTimePresetSeconds: Record<FatBurnTimePreset, number | null> = {
  [FatBurnTimePreset.TenMin]: 10 * 60,
  [FatBurnTimePreset.FifteenMin]: 15 * 60,
  [FatBurnTimePreset.TwentyMin]: 20 * 60,
  [FatBurnTimePreset.ThirtyMin]: 30 * 60,
  [FatBurnTimePreset.FortyFiveMin]: 45 * 60,
  [FatBurnTimePreset.SixtyMin]: 60 * 60,
  [FatBurnTimePreset.Custom]: null
};

// Fat Burn Distance Preset to miles mapping
export const FatBurnDistancePresetMiles: Record<FatBurnDistancePreset, number | null> = {
  [FatBurnDistancePreset.OneMile]: 1.0,
  [FatBurnDistancePreset.TwoMiles]: 2.0,
  [FatBurnDistancePreset.ThreeMiles]: 3.0,
  [FatBurnDistancePreset.FiveMiles]: 5.0,
  [FatBurnDistancePreset.Custom]: null
};

// Fat Burn Floors Preset to count mapping
export const FatBurnFloorsPresetCount: Record<FatBurnFloorsPreset, number | null> = {
  [FatBurnFloorsPreset.TenFloors]: 10,
  [FatBurnFloorsPreset.TwentyFloors]: 20,
  [FatBurnFloorsPreset.ThirtyFloors]: 30,
  [FatBurnFloorsPreset.FiftyFloors]: 50,
  [FatBurnFloorsPreset.HundredFloors]: 100,
  [FatBurnFloorsPreset.Custom]: null
};

// Equipment info with icons and colors
export const FatBurnEquipmentInfo: Record<FatBurnEquipment, { icon: string; description: string; color: string }> = {
  [FatBurnEquipment.Stairmaster]: { 
    icon: 'stairs', 
    description: 'Powerful lower body cardio',
    color: '#EF4444' // Red
  },
  [FatBurnEquipment.Elliptical]: { 
    icon: 'accessibility', 
    description: 'Low-impact full body cardio',
    color: '#F97316' // Orange
  },
  [FatBurnEquipment.Treadmill]: { 
    icon: 'directions_run', 
    description: 'Indoor running or walking',
    color: '#F59E0B' // Amber
  },
  [FatBurnEquipment.StationaryBike]: { 
    icon: 'pedal_bike', 
    description: 'Seated cardio cycling',
    color: '#FBBF24' // Yellow
  }
};

// MARK: - Fat Burn Configuration
export interface FatBurnConfiguration {
  equipment: FatBurnEquipment;
  treadmillMode?: TreadmillMode;
  goalType: FatBurnGoalType;
  timePreset?: FatBurnTimePreset;
  customDurationSeconds?: number;
  distancePreset?: FatBurnDistancePreset;
  customDistanceMiles?: number;
  floorsPreset?: FatBurnFloorsPreset;
  customFloors?: number;
}

// MARK: - Fat Burn Summary
export class FatBurnSummary {
  id: string;
  userId: string;
  equipment: FatBurnEquipment;
  goalType: FatBurnGoalType;
  title: string;
  machineLevel?: number;
  duration: number; // seconds
  caloriesBurned: number;
  calorieSource?: CalorieDataSource;
  distance?: number; // miles
  averagePace?: number; // minutes per mile
  averageSpeed?: number; // mph
  floorsClimbed?: number;
  totalSteps?: number;
  stepsPerMinute?: number;
  totalStrides?: number;
  machinePhotoURL?: string;
  targetDuration?: number;
  targetDistance?: number;
  targetFloors?: number;
  startTime: Date;
  completedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
  pulsePoints: PulsePoints;
  workoutRating?: WorkoutRating;
  aiInsight: string;
  recommendations: string[];
  isCompleted: boolean;
  syncedToHealthKit: boolean;

  constructor(data: any) {
    this.id = data.id || '';
    this.userId = data.userId || '';
    this.equipment = data.equipment || FatBurnEquipment.Stairmaster;
    this.goalType = data.goalType || FatBurnGoalType.FreeSession;
    this.title = data.title || 'Fat Burn Session';
    this.machineLevel = data.machineLevel;
    this.duration = data.duration || 0;
    this.caloriesBurned = data.caloriesBurned || 0;
    this.calorieSource = data.calorieSource;
    this.distance = data.distance;
    this.averagePace = data.averagePace;
    this.averageSpeed = data.averageSpeed;
    this.floorsClimbed = data.floorsClimbed;
    this.totalSteps = data.totalSteps;
    this.stepsPerMinute = data.stepsPerMinute;
    this.totalStrides = data.totalStrides;
    this.machinePhotoURL = data.machinePhotoURL;
    this.targetDuration = data.targetDuration;
    this.targetDistance = data.targetDistance;
    this.targetFloors = data.targetFloors;
    this.startTime = convertFirestoreTimestamp(data.startTime);
    this.completedAt = data.completedAt ? convertFirestoreTimestamp(data.completedAt) : undefined;
    this.createdAt = convertFirestoreTimestamp(data.createdAt);
    this.updatedAt = convertFirestoreTimestamp(data.updatedAt);
    this.pulsePoints = data.pulsePoints ? new PulsePoints(data.pulsePoints) : new PulsePoints({});
    this.workoutRating = data.workoutRating;
    this.aiInsight = data.aiInsight || '';
    this.recommendations = data.recommendations || [];
    this.isCompleted = data.isCompleted || false;
    this.syncedToHealthKit = data.syncedToHealthKit || false;
  }

  // Computed properties
  get goalAchieved(): boolean {
    switch (this.goalType) {
      case FatBurnGoalType.FreeSession:
        return true;
      case FatBurnGoalType.TimeGoal:
        return this.targetDuration ? this.duration >= this.targetDuration : false;
      case FatBurnGoalType.DistanceGoal:
        return this.targetDistance && this.distance ? this.distance >= this.targetDistance : false;
      case FatBurnGoalType.FloorsGoal:
        return this.targetFloors && this.floorsClimbed ? this.floorsClimbed >= this.targetFloors : false;
      default:
        return false;
    }
  }

  get formattedDuration(): string {
    const hours = Math.floor(this.duration / 3600);
    const minutes = Math.floor((this.duration % 3600) / 60);
    const seconds = this.duration % 60;
    
    if (hours > 0) {
      return seconds > 0 
        ? `${hours}h ${minutes}m ${seconds}s`
        : `${hours}h ${minutes}m`;
    }
    return `${minutes}m ${seconds.toString().padStart(2, '0')}s`;
  }

  get formattedDistance(): string | undefined {
    return this.distance ? `${this.distance.toFixed(1)} mi` : undefined;
  }

  get formattedPace(): string | undefined {
    if (!this.averagePace) return undefined;
    const minutes = Math.floor(this.averagePace);
    const seconds = Math.round((this.averagePace - minutes) * 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')} /mi`;
  }

  get formattedSpeed(): string | undefined {
    return this.averageSpeed ? `${this.averageSpeed.toFixed(1)} mph` : undefined;
  }

  get formattedFloors(): string | undefined {
    return this.floorsClimbed ? `${this.floorsClimbed} floors` : undefined;
  }

  toDictionary(): Record<string, any> {
    const dict: Record<string, any> = {
      id: this.id,
      userId: this.userId,
      equipment: this.equipment,
      goalType: this.goalType,
      title: this.title,
      duration: this.duration,
      caloriesBurned: this.caloriesBurned,
      startTime: dateToUnixTimestamp(this.startTime),
      createdAt: dateToUnixTimestamp(this.createdAt),
      updatedAt: dateToUnixTimestamp(this.updatedAt),
      aiInsight: this.aiInsight,
      recommendations: this.recommendations,
      isCompleted: this.isCompleted,
      syncedToHealthKit: this.syncedToHealthKit,
      pulsePoints: this.pulsePoints.toDictionary()
    };

    if (this.machineLevel !== undefined) dict.machineLevel = this.machineLevel;
    if (this.calorieSource) dict.calorieSource = this.calorieSource;
    if (this.distance !== undefined) dict.distance = this.distance;
    if (this.averagePace !== undefined) dict.averagePace = this.averagePace;
    if (this.averageSpeed !== undefined) dict.averageSpeed = this.averageSpeed;
    if (this.floorsClimbed !== undefined) dict.floorsClimbed = this.floorsClimbed;
    if (this.totalSteps !== undefined) dict.totalSteps = this.totalSteps;
    if (this.stepsPerMinute !== undefined) dict.stepsPerMinute = this.stepsPerMinute;
    if (this.totalStrides !== undefined) dict.totalStrides = this.totalStrides;
    if (this.machinePhotoURL) dict.machinePhotoURL = this.machinePhotoURL;
    if (this.targetDuration !== undefined) dict.targetDuration = this.targetDuration;
    if (this.targetDistance !== undefined) dict.targetDistance = this.targetDistance;
    if (this.targetFloors !== undefined) dict.targetFloors = this.targetFloors;
    if (this.completedAt) dict.completedAt = dateToUnixTimestamp(this.completedAt);
    if (this.workoutRating) dict.workoutRating = this.workoutRating;

    return dict;
  }
}

// MARK: - Stretch Types
export enum StretchBodyArea {
  Neck = 'Neck',
  Shoulders = 'Shoulders',
  Arms = 'Arms',
  Chest = 'Chest',
  UpperBack = 'Upper Back',
  LowerBack = 'Lower Back',
  Hips = 'Hips',
  Legs = 'Legs',
  FullBody = 'Full Body'
}

export enum StretchDurationPreset {
  FiveMin = 5,
  TenMin = 10,
  FifteenMin = 15,
  TwentyMin = 20,
  ThirtyMin = 30
}

// Stretch body area info with icons
export const StretchBodyAreaInfo: Record<StretchBodyArea, { icon: string; bodyParts: string[] }> = {
  [StretchBodyArea.Neck]: { icon: 'accessibility', bodyParts: ['neck'] },
  [StretchBodyArea.Shoulders]: { icon: 'fitness_center', bodyParts: ['shoulders', 'deltoids'] },
  [StretchBodyArea.Arms]: { icon: 'front_hand', bodyParts: ['biceps', 'triceps', 'forearms'] },
  [StretchBodyArea.Chest]: { icon: 'accessibility', bodyParts: ['chest'] },
  [StretchBodyArea.UpperBack]: { icon: 'accessibility', bodyParts: ['traps', 'lats', 'rhomboids'] },
  [StretchBodyArea.LowerBack]: { icon: 'accessibility', bodyParts: ['lowerback'] },
  [StretchBodyArea.Hips]: { icon: 'accessibility', bodyParts: ['glutes', 'hip flexors'] },
  [StretchBodyArea.Legs]: { icon: 'directions_walk', bodyParts: ['quadriceps', 'hamstrings', 'calves'] },
  [StretchBodyArea.FullBody]: { icon: 'self_improvement', bodyParts: ['fullbody'] }
};

// MARK: - Stretch Summary
export class StretchSummary {
  id: string;
  userId: string;
  title: string;
  routineId?: string;
  bodyAreas: string[];
  stretchCount: number;
  duration: number; // seconds
  caloriesBurned: number;
  startTime: Date;
  completedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
  pulsePoints: PulsePoints;
  workoutRating?: WorkoutRating;
  isCompleted: boolean;

  constructor(data: any) {
    this.id = data.id || '';
    this.userId = data.userId || '';
    this.title = data.title || 'Stretch Session';
    this.routineId = data.routineId;
    this.bodyAreas = data.bodyAreas || [];
    this.stretchCount = data.stretchCount || 0;
    this.duration = data.duration || 0;
    this.caloriesBurned = data.caloriesBurned || 0;
    this.startTime = convertFirestoreTimestamp(data.startTime);
    this.completedAt = data.completedAt ? convertFirestoreTimestamp(data.completedAt) : undefined;
    this.createdAt = convertFirestoreTimestamp(data.createdAt);
    this.updatedAt = convertFirestoreTimestamp(data.updatedAt);
    this.pulsePoints = data.pulsePoints ? new PulsePoints(data.pulsePoints) : new PulsePoints({});
    this.workoutRating = data.workoutRating;
    this.isCompleted = data.isCompleted || false;
  }

  // Computed properties
  get formattedDuration(): string {
    const hours = Math.floor(this.duration / 3600);
    const minutes = Math.floor((this.duration % 3600) / 60);
    const seconds = this.duration % 60;
    
    if (hours > 0) {
      return seconds > 0 
        ? `${hours}h ${minutes}m ${seconds}s`
        : `${hours}h ${minutes}m`;
    }
    return `${minutes}m ${seconds.toString().padStart(2, '0')}s`;
  }

  get formattedBodyAreas(): string {
    return this.bodyAreas.join(', ');
  }

  toDictionary(): Record<string, any> {
    const dict: Record<string, any> = {
      id: this.id,
      userId: this.userId,
      title: this.title,
      bodyAreas: this.bodyAreas,
      stretchCount: this.stretchCount,
      duration: this.duration,
      caloriesBurned: this.caloriesBurned,
      startTime: dateToUnixTimestamp(this.startTime),
      createdAt: dateToUnixTimestamp(this.createdAt),
      updatedAt: dateToUnixTimestamp(this.updatedAt),
      pulsePoints: this.pulsePoints.toDictionary(),
      isCompleted: this.isCompleted
    };

    if (this.routineId) dict.routineId = this.routineId;
    if (this.completedAt) dict.completedAt = dateToUnixTimestamp(this.completedAt);
    if (this.workoutRating) dict.workoutRating = this.workoutRating;

    return dict;
  }
}

// MARK: - Content Category Type (for routing)
export enum ContentCategoryType {
  Lift = 'lift',
  Run = 'run',
  Stretch = 'stretch',
  FatBurn = 'fatBurn'
}

// Content category display info
export const ContentCategoryInfo: Record<ContentCategoryType, {
  displayName: string;
  description: string;
  icon: string;
  color: string;
  isAvailable: boolean;
}> = {
  [ContentCategoryType.Lift]: {
    displayName: 'Lift',
    description: 'Weights, Machines & Bodyweight',
    icon: 'fitness_center',
    color: '#E0FE10', // Primary Green
    isAvailable: true
  },
  [ContentCategoryType.Run]: {
    displayName: 'Run',
    description: 'Outdoor & Treadmill Runs',
    icon: 'directions_run',
    color: '#3B82F6', // Primary Blue
    isAvailable: true
  },
  [ContentCategoryType.Stretch]: {
    displayName: 'Stretch',
    description: 'Mobility & Flexibility',
    icon: 'self_improvement',
    color: '#A855F7', // Primary Purple
    isAvailable: true
  },
  [ContentCategoryType.FatBurn]: {
    displayName: 'Fat Burn',
    description: 'Treadmill, Stair Climber & more',
    icon: 'local_fire_department',
    color: '#F97316', // Orange
    isAvailable: true // Set to true - we're implementing it
  }
};
// ----------------------------------------------------------------------
